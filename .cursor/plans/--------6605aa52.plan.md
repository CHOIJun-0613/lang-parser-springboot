<!-- 6605aa52-a26a-4b05-8497-abb00e4bb383 a800b841-4fe3-46fe-96ca-0a0fc03fbc3c -->
# CLI 데코레이터 패턴 적용

## 목표

모든 CLI 명령어의 공통 초기화/정리 로직을 데코레이터로 중앙화하여 코드 중복 제거 및 유지보수성 향상

## 현재 문제점

1. **중복 코드**: 각 명령어마다 `start()`/`end()` 호출 반복
2. **일관성 부족**: 일부 명령어는 `start()`/`end()` 사용, 일부는 미사용
3. **유지보수 어려움**: 공통 로직 변경 시 여러 곳 수정 필요

### 현재 start()/end()를 사용하는 명령어 (3개)

- `sequence` (라인 1543)
- `crud_matrix` (라인 1751)  
- `analyze` (라인 2645)

### start()/end()를 사용하지 않는 명령어 (11개)

- `query`, `list_classes`, `list_methods`, `db_analysis`, `table_summary`
- `db_call_chain`, `crud_analysis`, `db_call_diagram`, `crud_visualization`
- `table_impact`, `db_statistics`

## 수정 계획

### 1. 데코레이터 함수 생성

**위치:** `start()` 함수 바로 아래 (라인 60 근처)

```python
def with_command_lifecycle(command_name):
    """
    CLI 명령어의 공통 초기화/정리를 처리하는 데코레이터
    
    Args:
        command_name: 명령어 이름 (로깅 및 통계용)
    
    Returns:
        데코레이터 함수
    """
    def decorator(func):
        from functools import wraps
        
        @wraps(func)
        def wrapper(*args, **kwargs):
            # 1. 공통 초기화 (start)
            context = start(command_name)
            
            result = {
                'success': False,
                'message': '',
                'stats': {},
                'error': None
            }
            
            try:
                # 2. 원본 함수 실행
                func_result = func(*args, **kwargs)
                
                # 함수 결과가 dict이고 result 구조를 따르는 경우 병합
                if isinstance(func_result, dict):
                    result.update(func_result)
                else:
                    # 결과가 None이거나 다른 타입인 경우 성공으로 처리
                    result['success'] = True
                    result['message'] = f'{command_name} completed'
                
                return func_result
                
            except Exception as e:
                result['success'] = False
                result['error'] = str(e)
                raise
                
            finally:
                # 3. 공통 정리 (end)
                end(context, result)
        
        return wrapper
    return decorator
```

### 2. 기존 start()/end() 사용 명령어 수정

#### 2.1 `sequence` 명령어 (라인 1539-1637)

**수정 전:**

```python
@cli.command()
def sequence(...):
    # 1. start() 호출
    context = start('sequence')
    
    result = {...}
    
    try:
        # ... 로직 ...
        result['success'] = True
        # ...
    finally:
        end(context, result)
    
    return result
```

**수정 후:**

```python
@cli.command()
@with_command_lifecycle('sequence')
def sequence(...):
    result = {
        'success': False,
        'message': '',
        'stats': {},
        'error': None,
        'files': []
    }
    
    # ... 로직만 유지 (start/end 제거) ...
    
    result['success'] = True
    result['message'] = 'Sequence diagram generated successfully'
    # ...
    
    return result
```

#### 2.2 `crud_matrix` 명령어 (라인 1740-1874)

**수정 전:**

```python
@cli.command()
def crud_matrix(...):
    # 1. start() 호출
    context = start('crud-matrix')
    
    result = {...}
    
    try:
        # ... 로직 ...
    finally:
        end(context, result)
    
    return result
```

**수정 후:**

```python
@cli.command()
@with_command_lifecycle('crud-matrix')
def crud_matrix(...):
    result = {
        'success': False,
        'message': '',
        'stats': {},
        'error': None,
        'files': []
    }
    
    # ... 로직만 유지 ...
    
    return result
```

#### 2.3 `analyze` 명령어 (라인 2625-2667)

**수정 전:**

```python
@cli.command()
def analyze(...):
    # start() 함수로 공통 초기화
    context = start('analyze')
    logger = context['logger']
    
    try:
        # ... 로직 ...
        result = analyze_project(...)
        end(context, result)
    except Exception as e:
        logger.error(...)
        end(context, {'success': False, 'error': str(e)})
        raise click.ClickException(...)
```

**수정 후:**

```python
@cli.command()
@with_command_lifecycle('analyze')
def analyze(...):
    # logger는 get_logger로 직접 가져오기
    logger = get_logger(__name__, command='analyze')
    
    # ... 로직만 유지 ...
    
    result = analyze_project(...)
    return result
```

### 3. start()/end() 미사용 명령어에 데코레이터 적용

모든 명령어에 일관되게 데코레이터를 적용합니다:

```python
# 예시: query 명령어
@cli.command()
@with_command_lifecycle('query')
def query(...):
    # 기존 로직 유지
    # ...
```

**적용할 명령어 목록:**

- `query` (라인 1391)
- `list_classes` (라인 1660) - 단순 조회이므로 선택적
- `list_methods` (라인 1701) - 단순 조회이므로 선택적
- `db_analysis` (라인 1898)
- `table_summary` (라인 1979)
- `db_call_chain` (라인 2038)
- `crud_analysis` (라인 2144)
- `db_call_diagram` (라인 2265)
- `crud_visualization` (라인 2348)
- `table_impact` (라인 2446)
- `db_statistics` (라인 2537)

### 4. 주의사항 및 예외 처리

#### 4.1 logger 접근 방식 변경

- 기존: `logger = context['logger']`
- 변경: `logger = get_logger(__name__, command='command_name')`

#### 4.2 단순 조회 명령어도 모두 적용

`list_classes`, `list_methods` 등 단순 조회 명령어도 모두 데코레이터를 적용하여 일관성 확보:

- 모든 명령어에서 로깅 및 통계 수집
- 실행 시간 추적으로 성능 모니터링 가능
- 일관된 에러 처리

#### 4.3 result 구조 표준화

모든 명령어가 다음 구조를 반환하도록 권장:

```python
{
    'success': bool,
    'message': str,
    'stats': dict,
    'error': str | None,
    # 명령어별 추가 필드
}
```

### 5. 테스트 계획

수정 후 다음 명령어들을 테스트:

1. `analyze` - 전체 분석 기능
2. `sequence` - 시퀀스 다이어그램 생성
3. `crud-matrix` - CRUD 매트릭스 생성
4. `query` - 쿼리 실행

각 명령어에서 다음 확인:

- 로그 출력이 정상적으로 되는가?
- 시작/종료 시간이 올바르게 기록되는가?
- 에러 처리가 정상적으로 되는가?

## 예상 효과

1. **코드 중복 제거**: 14개 명령어의 중복 로직 제거 (약 50-100 라인 감소)
2. **일관성 향상**: 모든 명령어가 동일한 방식으로 초기화/정리
3. **유지보수성**: 공통 로직 변경 시 데코레이터만 수정
4. **확장성**: 새로운 명령어 추가 시 데코레이터만 적용하면 됨

## 영향받는 파일

- `csa/cli/main.py` - 데코레이터 추가 및 모든 명령어 수정