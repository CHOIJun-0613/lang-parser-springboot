# 영향도 분석 기능 추가 계획서

**작성일**: 2025-10-20
**수정일**: 2025-10-20
**상태**: 계획 수립 완료 (검토 대기)

## 📌 주요 수정사항 (2025-10-20)

### 1. CLI 옵션 변경
- **`--project-name` 옵션**: 테이블 영향도 분석 시 **선택 사항**으로 변경
  - 이유: 테이블은 여러 프로젝트에서 공통으로 사용될 수 있음
  - 특정 프로젝트로 범위를 제한하려는 경우에만 사용

### 2. 출력 형식 변경
- **기본 출력**: Markdown + Excel (항상 생성)
- **선택 출력**: JSON (--include-json 플래그 사용 시에만 생성)
- ~~`--output-format excel,markdown` 옵션 제거~~
- 새로운 플래그: `--include-json` (JSON 파일 추가 생성)

## 1. 개요

### 1.1 목적
- **테이블 변경 영향도 분석**: DB 테이블 변경 시 영향받는 모든 코드(SQL → Mapper → Class → Method) 역추적
- **메서드 변경 영향도 분석**: 특정 메서드 변경 시 해당 메서드를 호출하는 모든 상위 호출자 역추적
- **국내 SI 표준 산출물 생성**: 영향도 분석표, 변경영향도표 등 실무에서 요구되는 표준 문서 자동 생성

### 1.2 현재 상태 분석

#### 기존 구현 기능
- **파일**: `csa/services/db_call_analysis/impact.py`
- **명령어**: `python -m csa.cli.main table-impact --table-name {table_name}`
- **기능**: 특정 테이블을 사용하는 클래스/메서드 목록 조회 (정방향)
- **한계**:
  - 단순 조회만 가능 (역방향 호출 체인 추적 불가)
  - 영향도 레벨/단계 구분 없음
  - 통계 및 리스크 분석 부재
  - 국내 SI 표준 양식 미지원

#### 기존 Call Chain 기능
- **파일**: `csa/services/db_call_analysis/call_chain.py`
- **기능**: Controller → Service → Repository → SQL → Table (정방향 호출 체인)
- **한계**: 역방향 피호출 관계 분석 미지원

---

## 2. 요구사항 정의

### 2.1 기능 요구사항

#### 2.1.1 테이블 영향도 분석
```
Table → SqlStatement → MyBatisMapper → Method → Method → ... (역방향 체인)
```

**분석 흐름**:
1. SqlStatement 노드의 `tables` 속성에서 대상 테이블 포함 여부 확인
2. SqlStatement를 포함하는 MyBatisMapper/JpaRepository 조회
3. Mapper를 호출하는 Method 조회 (`:CALLS` 관계 역방향)
4. 해당 Method를 호출하는 상위 Method 재귀 조회 (최대 N-depth)
5. 영향도 레벨별 분류 (직접 영향: Level 1, 간접 영향: Level 2+)

#### 2.1.2 메서드 영향도 분석
```
Method → Caller Method → Caller Method → ... (역방향 체인)
```

**분석 흐름**:
1. 대상 Method 노드 조회
2. 해당 Method를 호출하는 모든 Method 조회 (`:CALLS` 관계 역방향)
3. 호출자를 다시 호출하는 상위 Method 재귀 조회
4. 영향도 레벨별 분류 및 통계 생성

#### 2.1.3 영향도 메트릭 계산
- **영향 범위**: 영향받는 클래스 수, 메서드 수, 패키지 수
- **영향 깊이**: 최대/평균 호출 깊이 (Max/Avg Depth)
- **복잡도 점수**: SQL 복잡도, 메서드 복잡도 합산
- **리스크 등급**: High/Medium/Low (영향 범위 × 복잡도 기반)
- **테스트 범위**: 영향받는 테스트 클래스 자동 식별

### 2.2 CLI 명령어 인터페이스

#### 명령어 1: 테이블 영향도 분석
```bash
python -m csa.cli.main impact-analysis \
  --table-name {table_name} \
  --max-depth 10 \
  --include-json
```

**옵션 설명**:
- `--table-name`: 분석 대상 테이블명 (필수)
- `--project-name`: 프로젝트명 (선택, 생략 시 전체 프로젝트 대상 분석)
  - **중요**: 테이블은 여러 프로젝트에서 공통으로 사용될 수 있으므로 필수 아님
  - 특정 프로젝트로 범위를 제한하려는 경우에만 사용
- `--max-depth`: 최대 호출 깊이 (기본값: 10)
- `--include-json`: JSON 형식 파일 추가 생성 (기본값: False)
  - **기본 출력**: Markdown + Excel (항상 생성)
  - JSON이 필요한 경우에만 이 플래그 사용
- `--output-dir`: 출력 디렉터리 (기본값: 환경변수 `IMPACT_ANALYSIS_OUTPUT_DIR`)

#### 명령어 2: 메서드 영향도 분석
```bash
python -m csa.cli.main impact-analysis \
  --class-name {class_name} \
  --method-name {method_name} \
  --project-name {project_name} \
  --max-depth 10 \
  --include-json
```

**옵션 설명**:
- `--class-name`: 분석 대상 클래스명 (필수)
- `--method-name`: 분석 대상 메서드명 (선택, 생략 시 클래스의 모든 public 메서드 분석)
- `--project-name`: 프로젝트명 (권장)
  - 클래스명이 여러 프로젝트에 중복되는 경우 범위 지정에 사용
  - 생략 시 전체 프로젝트에서 해당 클래스 검색
- `--max-depth`: 최대 호출 깊이 (기본값: 10)
- `--include-json`: JSON 형식 파일 추가 생성 (기본값: False)
  - **기본 출력**: Markdown + Excel (항상 생성)
  - JSON이 필요한 경우에만 이 플래그 사용

### 2.3 출력 파일 형식

#### 파일 위치
- 환경변수: `IMPACT_ANALYSIS_OUTPUT_DIR` (기본값: `./output/impact-analysis`)
- `.env` 파일에 추가 (이미 설정됨):
  ```ini
  IMPACT_ANALYSIS_OUTPUT_DIR=output/impact-analysis
  ```

#### 파일명 규칙
- **테이블 영향도**:
  - Markdown: `IMPACT_TABLE_{Table}_{YYYYMMDD-HHmmSS}.md` (기본 생성)
  - Excel: `IMPACT_TABLE_{Table}_{YYYYMMDD-HHmmSS}.xlsx` (기본 생성)
  - JSON: `IMPACT_TABLE_{Table}_{YYYYMMDD-HHmmSS}.json` (--include-json 플래그 사용 시)

- **메서드 영향도**:
  - Markdown: `IMPACT_METHOD_{Class}_{Method}_{YYYYMMDD-HHmmSS}.md` (기본 생성)
  - Excel: `IMPACT_METHOD_{Class}_{Method}_{YYYYMMDD-HHmmSS}.xlsx` (기본 생성)
  - JSON: `IMPACT_METHOD_{Class}_{Method}_{YYYYMMDD-HHmmSS}.json` (--include-json 플래그 사용 시)

**출력 형식**:
- **기본 출력**: Markdown + Excel (항상 생성)
- **선택 출력**: JSON (--include-json 플래그 사용 시에만 생성)

---

## 3. 국내 SI 환경 표준 및 개선 제안

### 3.1 국내 SI 프로젝트에서 많이 사용하는 방법

#### 3.1.1 영향도 분석표 표준 양식
국내 SI 환경에서는 다음과 같은 표준 산출물이 요구됩니다:

| 항목 | 설명 | CSA 매핑 |
|------|------|---------|
| **변경영향도표** | 변경 대상 및 영향받는 프로그램 목록 | Excel 메인 시트 |
| **영향도 레벨** | 직접/간접 영향 단계 구분 (1차, 2차, 3차...) | Impact Level (1~N) |
| **변경 우선순위** | High/Medium/Low 분류 | Risk Grade |
| **영향 통계** | 프로그램 수, 화면 수, 배치 수 등 | Summary 통계 |
| **테스트 범위** | 영향받는 단위/통합 테스트 목록 | Test Classes |
| **배포 영향도** | 서버별 배포 대상 모듈 | Package별 그룹핑 |

#### 3.1.2 Excel 템플릿 구조 (개선 제안)

**시트 1: 요약 (Summary)**
- 분석 대상 (테이블명 또는 메서드명)
- 분석 일시
- 총 영향 범위 (클래스 수, 메서드 수, 패키지 수)
- 리스크 등급 (High/Medium/Low)
- 최대 호출 깊이
- 권장 테스트 범위

**시트 2: 영향도 분석 상세 (Impact Detail)**
| Level | Depth | Package | Class | Method | SQL Type | Complexity | Risk | 비고 |
|-------|-------|---------|-------|--------|----------|-----------|------|------|
| 1 | 0 | com.example.repository | UserMapper | selectUserById | SELECT | 3 | Low | 직접 사용 |
| 2 | 1 | com.example.service | UserService | getUser | - | 5 | Medium | 1차 호출자 |
| 2 | 2 | com.example.controller | UserController | getUserInfo | - | 7 | High | 2차 호출자 |

**시트 3: 패키지별 집계 (Package Summary)**
| Package | 영향 클래스 수 | 영향 메서드 수 | 평균 Depth | Risk 분포 |
|---------|------------|------------|-----------|----------|
| com.example.controller | 5 | 12 | 2.5 | High: 3, Medium: 2 |
| com.example.service | 8 | 20 | 1.8 | High: 1, Medium: 7 |

**시트 4: SQL 상세 (SQL Detail)** (테이블 영향도만)
| SQL ID | SQL Type | Mapper | Complexity | Query Preview |
|--------|----------|--------|-----------|---------------|
| SQL001 | SELECT | UserMapper.selectUserById | 3 | SELECT * FROM USER WHERE... |

**시트 5: 테스트 범위 (Test Scope)**
| 영향받는 클래스 | 대응 테스트 클래스 | 테스트 메서드 수 | 상태 |
|-------------|----------------|-------------|------|
| UserController | UserControllerTest | 5 | 존재 |
| UserService | UserServiceTest | 8 | 존재 |

#### 3.1.3 Markdown 템플릿 구조 (개선 제안)

```markdown
# 영향도 분석 보고서

## 1. 분석 개요
- **분석 대상**: `USER` 테이블
- **프로젝트**: car-center-devlab
- **분석 일시**: 2025-10-20 15:30:00
- **최대 호출 깊이**: 10

## 2. 영향도 요약
- **총 영향 범위**:
  - 영향받는 클래스: 15개
  - 영향받는 메서드: 45개
  - 영향받는 패키지: 5개
- **영향 깊이**:
  - 최대 호출 깊이: 5
  - 평균 호출 깊이: 2.8
- **리스크 등급**: **HIGH** ⚠️
  - High: 8개 메서드
  - Medium: 12개 메서드
  - Low: 25개 메서드

## 3. 영향도 트리 (Level별)

### Level 1 (직접 영향 - 0 depth)
- **com.example.repository.UserMapper**
  - `selectUserById` (SELECT, Complexity: 3, Risk: Low)
  - `updateUserStatus` (UPDATE, Complexity: 5, Risk: Medium)
  - `deleteUser` (DELETE, Complexity: 2, Risk: Low)

### Level 2 (간접 영향 - 1 depth)
- **com.example.service.UserService**
  - `getUser` → UserMapper.selectUserById (Risk: Medium)
  - `updateUser` → UserMapper.updateUserStatus (Risk: High)

### Level 3 (간접 영향 - 2 depth)
- **com.example.controller.UserController**
  - `getUserInfo` → UserService.getUser (Risk: High)
  - `updateUserInfo` → UserService.updateUser (Risk: High)

## 4. 패키지별 통계
| Package | 클래스 수 | 메서드 수 | 평균 Depth | High Risk |
|---------|---------|---------|----------|-----------|
| com.example.controller | 5 | 12 | 2.5 | 3 |
| com.example.service | 8 | 20 | 1.8 | 1 |
| com.example.repository | 3 | 8 | 0.5 | 0 |

## 5. SQL 상세 정보
| SQL ID | Type | Mapper | Complexity | Query |
|--------|------|--------|-----------|-------|
| SQL001 | SELECT | UserMapper.selectUserById | 3 | `SELECT * FROM USER WHERE id = #{id}` |

## 6. 권장 테스트 범위
- **필수 테스트**:
  - `UserControllerTest.testGetUserInfo()`
  - `UserServiceTest.testGetUser()`
  - `UserMapperTest.testSelectUserById()`
- **회귀 테스트**:
  - `UserIntegrationTest` 전체 실행 권장

## 7. 변경 시 주의사항
- ⚠️ **High Risk** 메서드 8개 포함
- 🔄 **순환 참조** 없음
- 📝 **테스트 커버리지**: 80% (35/45 메서드)
```

### 3.2 개선 제안 사항

#### 3.2.1 영향도 점수 계산 알고리즘
```python
# 리스크 점수 계산
risk_score = (
    영향_범위_점수 * 0.4 +      # 영향받는 메서드 수
    복잡도_점수 * 0.3 +          # SQL/메서드 복잡도
    호출_깊이_점수 * 0.2 +       # 호출 체인 깊이
    테스트_커버리지_점수 * 0.1   # 테스트 부재 시 가중치
)

# 리스크 등급
if risk_score >= 70: return "HIGH"
elif risk_score >= 40: return "MEDIUM"
else: return "LOW"
```

#### 3.2.2 시각화 개선
- **트리 다이어그램**: PlantUML/Mermaid로 호출 트리 시각화
- **히트맵**: 패키지별 영향도 히트맵 생성
- **그래프**: 영향도 분포 차트 (Bar/Pie Chart)

#### 3.2.3 추가 메트릭
- **순환 참조 탐지**: 호출 체인에 순환 참조 존재 시 경고
- **테스트 커버리지 연동**: 영향받는 메서드의 테스트 존재 여부 체크
- **변경 이력 연동**: Git 변경 이력 기반 변경 빈도 분석 (선택사항)

---

## 4. 기술 설계

### 4.1 Neo4j 그래프 쿼리

#### 4.1.1 테이블 영향도 분석 쿼리
```cypher
// 1단계: 테이블을 사용하는 SQL 조회
MATCH (sql:SqlStatement)
WHERE ($project_name IS NULL OR sql.project_name = $project_name)
  AND (sql.tables CONTAINS $table_name
       OR ANY(table IN sql.tables WHERE table.name = $table_name))

// 2단계: SQL을 호출하는 Method 조회 (역방향)
MATCH (m:Method)-[:CALLS]->(sql)
MATCH (c:Class)-[:HAS_METHOD]->(m)

// 3단계: Method를 호출하는 상위 Method 재귀 조회
OPTIONAL MATCH path = (caller:Method)-[:CALLS*1..10]->(m)
OPTIONAL MATCH (caller_class:Class)-[:HAS_METHOD]->(caller)

WITH DISTINCT
  c.name AS class_name,
  c.package_name AS package_name,
  c.project_name AS project_name,
  m.name AS method_name,
  sql.id AS sql_id,
  sql.sql_type AS sql_type,
  sql.complexity_score AS sql_complexity,
  caller_class.name AS caller_class_name,
  caller_class.package_name AS caller_package_name,
  caller.name AS caller_method_name,
  length(path) AS depth

RETURN
  project_name, class_name, package_name, method_name,
  sql_id, sql_type, sql_complexity,
  caller_class_name, caller_package_name, caller_method_name,
  depth
ORDER BY depth ASC, caller_package_name, caller_class_name

// 참고: $project_name이 NULL인 경우 전체 프로젝트 대상 분석
```

#### 4.1.2 메서드 영향도 분석 쿼리
```cypher
// 1단계: 대상 Method 조회 (project_name 선택사항)
MATCH (target_class:Class {name: $class_name})-[:HAS_METHOD]->(target_method:Method {name: $method_name})
WHERE $project_name IS NULL OR target_class.project_name = $project_name

// 2단계: 해당 Method를 호출하는 모든 상위 Method 재귀 조회
OPTIONAL MATCH path = (caller:Method)-[:CALLS*1..10]->(target_method)
MATCH (caller_class:Class)-[:HAS_METHOD]->(caller)

WITH DISTINCT
  target_class.name AS target_class_name,
  target_class.project_name AS target_project_name,
  target_method.name AS target_method_name,
  caller_class.name AS caller_class_name,
  caller_class.package_name AS caller_package_name,
  caller_class.project_name AS caller_project_name,
  caller.name AS caller_method_name,
  length(path) AS depth

RETURN
  target_project_name, target_class_name, target_method_name,
  caller_project_name, caller_class_name, caller_package_name, caller_method_name,
  depth
ORDER BY depth ASC, caller_package_name, caller_class_name

// 참고: $project_name이 NULL인 경우 전체 프로젝트에서 해당 클래스 검색
```

### 4.2 데이터 모델

#### 4.2.1 ImpactAnalysisResult (Pydantic Model)
```python
from typing import List, Dict, Optional
from pydantic import BaseModel, Field

class ImpactNode(BaseModel):
    """영향도 분석 노드"""
    level: int = Field(description="영향도 레벨 (1: 직접, 2+: 간접)")
    depth: int = Field(description="호출 깊이 (0: 직접 호출)")
    package_name: str
    class_name: str
    method_name: str
    sql_id: Optional[str] = None
    sql_type: Optional[str] = None
    sql_complexity: Optional[int] = None
    risk_grade: str = Field(description="High/Medium/Low")

class ImpactSummary(BaseModel):
    """영향도 분석 요약"""
    target_type: str = Field(description="table 또는 method")
    target_name: str
    total_impacted_classes: int
    total_impacted_methods: int
    total_impacted_packages: int
    max_depth: int
    avg_depth: float
    risk_distribution: Dict[str, int] = Field(description="High/Medium/Low 개수")

class PackageSummary(BaseModel):
    """패키지별 통계"""
    package_name: str
    impacted_classes: int
    impacted_methods: int
    avg_depth: float
    risk_distribution: Dict[str, int]

class ImpactAnalysisResult(BaseModel):
    """영향도 분석 결과"""
    project_name: str
    analysis_type: str = Field(description="table 또는 method")
    target_name: str
    timestamp: str
    summary: ImpactSummary
    impact_tree: Dict[int, List[ImpactNode]] = Field(description="Level별 노드 목록")
    package_summary: List[PackageSummary]
    test_scope: List[str] = Field(description="영향받는 테스트 클래스")
```

### 4.3 모듈 구조

#### 4.3.1 파일 추가/수정
```
csa/
├── services/
│   └── db_call_analysis/
│       ├── impact.py              # 기존 파일 (확장)
│       ├── reverse_impact.py      # 신규 파일 (역방향 영향도 분석)
│       └── impact_reporter.py     # 신규 파일 (리포트 생성)
│
├── cli/
│   └── commands/
│       └── impact.py              # 신규 파일 (CLI 명령어)
│
└── models/
    └── impact.py                  # 신규 파일 (Pydantic 모델)
```

#### 4.3.2 주요 클래스 및 메서드

**ReverseImpactMixin** (`csa/services/db_call_analysis/reverse_impact.py`)
```python
class ReverseImpactMixin:
    """역방향 영향도 분석"""

    def analyze_table_impact_reverse(
        self,
        project_name: str,
        table_name: str,
        max_depth: int = 10
    ) -> ImpactAnalysisResult:
        """테이블 역방향 영향도 분석"""

    def analyze_method_impact_reverse(
        self,
        project_name: str,
        class_name: str,
        method_name: str,
        max_depth: int = 10
    ) -> ImpactAnalysisResult:
        """메서드 역방향 영향도 분석"""

    def _build_impact_tree(
        self,
        nodes: List[Dict],
        max_depth: int
    ) -> Dict[int, List[ImpactNode]]:
        """영향도 트리 구축"""

    def _calculate_risk_grade(
        self,
        node: ImpactNode,
        total_nodes: int
    ) -> str:
        """리스크 등급 계산"""

    def _identify_test_scope(
        self,
        session,
        impacted_classes: List[str]
    ) -> List[str]:
        """테스트 범위 식별"""
```

**ImpactReporter** (`csa/services/db_call_analysis/impact_reporter.py`)
```python
class ImpactReporter:
    """영향도 분석 리포트 생성"""

    def generate_markdown(
        self,
        result: ImpactAnalysisResult,
        filepath: str
    ) -> bool:
        """Markdown 리포트 생성"""

    def generate_excel(
        self,
        result: ImpactAnalysisResult,
        filepath: str
    ) -> bool:
        """Excel 리포트 생성 (다중 시트)"""

    def generate_json(
        self,
        result: ImpactAnalysisResult,
        filepath: str
    ) -> bool:
        """JSON 리포트 생성"""

    def _generate_summary_sheet(
        self,
        workbook,
        result: ImpactAnalysisResult
    ):
        """Excel 요약 시트 생성"""

    def _generate_detail_sheet(
        self,
        workbook,
        result: ImpactAnalysisResult
    ):
        """Excel 상세 시트 생성"""

    def _generate_package_sheet(
        self,
        workbook,
        result: ImpactAnalysisResult
    ):
        """Excel 패키지 시트 생성"""
```

---

## 5. 구현 계획

### 5.1 Phase 1: 핵심 기능 구현 (2-3일)
1. **데이터 모델 정의** (`csa/models/impact.py`)
   - ImpactNode, ImpactSummary, PackageSummary, ImpactAnalysisResult 모델 생성

2. **역방향 영향도 분석 로직** (`csa/services/db_call_analysis/reverse_impact.py`)
   - Neo4j 쿼리 작성 및 테스트
   - 영향도 트리 구축 알고리즘 구현
   - 리스크 등급 계산 로직 구현

3. **CLI 명령어 추가** (`csa/cli/commands/impact.py`)
   - `impact-analysis` 명령어 구현
   - 옵션 파싱 및 검증

### 5.2 Phase 2: 리포트 생성 (2일)
1. **Markdown 리포트** (`csa/services/db_call_analysis/impact_reporter.py`)
   - 템플릿 기반 Markdown 생성
   - 영향도 트리 텍스트 렌더링

2. **Excel 리포트**
   - openpyxl 사용하여 다중 시트 생성
   - 요약/상세/패키지/SQL/테스트 시트 구현
   - 스타일링 (헤더 색상, 조건부 서식)

3. **JSON 리포트**
   - Pydantic 모델 직렬화

### 5.3 Phase 3: 고급 기능 (1-2일, 선택사항)
1. **테스트 범위 자동 식별**
   - Test 클래스 자동 매핑 (네이밍 컨벤션 기반)

2. **순환 참조 탐지**
   - Neo4j 순환 경로 탐지 쿼리

3. **시각화 (선택사항)**
   - PlantUML 트리 다이어그램 생성
   - Mermaid 그래프 생성

### 5.4 Phase 4: 테스트 및 문서화 (1일)
1. **단위 테스트**
   - `tests/unit/test_reverse_impact.py`
   - `tests/unit/test_impact_reporter.py`

2. **통합 테스트**
   - `tests/integration/test_impact_analysis_end_to_end.py`

3. **사용자 문서**
   - `docs/impact_analysis_usage.md` 작성

---

## 6. 테스트 계획

### 6.1 테스트 시나리오

#### 시나리오 1: 테이블 영향도 분석 (기본 출력)
```bash
# 1. USER 테이블 영향도 분석 (Markdown + Excel 자동 생성)
python -m csa.cli.main impact-analysis \
  --table-name USER \
  --max-depth 10

# 예상 결과 (기본 출력):
# - output/impact-analysis/IMPACT_TABLE_USER_20251020-153000.md
# - output/impact-analysis/IMPACT_TABLE_USER_20251020-153000.xlsx
```

#### 시나리오 2: 테이블 영향도 분석 (프로젝트 필터링 + JSON 포함)
```bash
# 2. USER 테이블 영향도 분석 (특정 프로젝트만 대상, JSON 포함)
python -m csa.cli.main impact-analysis \
  --table-name USER \
  --project-name car-center-devlab \
  --max-depth 10 \
  --include-json

# 예상 결과:
# - output/impact-analysis/IMPACT_TABLE_USER_20251020-153000.md
# - output/impact-analysis/IMPACT_TABLE_USER_20251020-153000.xlsx
# - output/impact-analysis/IMPACT_TABLE_USER_20251020-153000.json
```

#### 시나리오 3: 메서드 영향도 분석
```bash
# 3. UserService.getUser 메서드 영향도 분석
python -m csa.cli.main impact-analysis \
  --class-name UserService \
  --method-name getUser \
  --project-name car-center-devlab \
  --max-depth 5

# 예상 결과 (기본 출력):
# - output/impact-analysis/IMPACT_METHOD_UserService_getUser_20251020-153100.md
# - output/impact-analysis/IMPACT_METHOD_UserService_getUser_20251020-153100.xlsx
```

### 6.2 테스트 데이터 요구사항
- Neo4j 데이터베이스에 car-center-devlab 프로젝트 분석 완료 상태
- SqlStatement 노드에 `tables` 속성 포함
- Method 간 `:CALLS` 관계 생성 완료

### 6.3 검증 항목
- [ ] 역방향 호출 체인 정확성 검증
- [ ] 영향도 레벨/Depth 계산 정확성
- [ ] 리스크 등급 분류 적정성
- [ ] Excel 다중 시트 정상 생성
- [ ] Markdown 포맷 가독성
- [ ] 한글 파일명 정상 처리 (윈도우 환경)

---

## 7. 참고사항

### 7.1 기술 스택
- **Neo4j Cypher**: 역방향 그래프 쿼리
- **Pydantic**: 데이터 모델 검증
- **openpyxl**: Excel 파일 생성
- **Click**: CLI 인터페이스

### 7.2 성능 고려사항
- **쿼리 최적화**: 재귀 호출 깊이 제한 (기본값: 10)
- **인덱스 활용**: Class.name, Method.name, SqlStatement.tables 인덱스 사용
- **배치 처리**: 대량 데이터 시 페이징 처리 고려

### 7.3 제약사항
- **순환 참조**: 무한 루프 방지를 위해 최대 깊이 제한 필수
- **대용량 프로젝트**: 수천 개 이상 메서드 시 메모리 사용량 증가 가능

### 7.4 향후 확장 가능성
- **변경 이력 연동**: Git blame/log 기반 변경 빈도 분석
- **배포 영향도**: 서버/모듈별 배포 범위 자동 산출
- **알림 연동**: High Risk 영향도 발생 시 Slack/Email 알림
- **AI 분석**: LLM 기반 변경 영향 예측 및 권장사항 제시

---

## 8. 결론

### 8.1 핵심 가치
1. **자동화**: 수작업 영향도 분석 → 자동 생성 (작업 시간 90% 절감)
2. **표준화**: 국내 SI 표준 양식 준수 (검토 시간 단축)
3. **정확성**: 그래프 DB 기반 정확한 호출 관계 추적 (누락 방지)

### 8.2 기대 효과
- **개발자**: 코드 변경 전 영향 범위 사전 파악 → 안정성 향상
- **QA**: 정확한 테스트 범위 산출 → 테스트 효율성 증대
- **PM**: 변경 리스크 정량화 → 의사결정 지원

### 8.3 후속 조치
- **검토 및 승인**: 본 계획서 검토 후 구현 여부 결정
- **파일럿 구현**: Phase 1 핵심 기능 구현 후 실제 프로젝트 테스트
- **피드백 수집**: 사용자 피드백 기반 기능 개선

---

**작성자**: CSA 개발팀
**검토 요청**: 계획 검토 후 구현 진행 여부 결정 바랍니다.
