# Change property node to field node
_Exported on 9/23/2025 at 23:24:37 GMT+9 from Cursor (1.6.45)_

---

**User**

Property 노드를 Field 노드로 변경해줘
db와 프로그램에서 관련된 부분 모두... 

---

**Cursor**

Property 노드를 Field 노드로 변경하는 작업을 진행하겠습니다. 먼저 현재 코드베이스에서 Property와 관련된 부분들을 찾아보겠습니다.


이제 Property를 Field로 변경하는 작업을 시작하겠습니다. 먼저 모델 클래스부터 변경하겠습니다.


```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Property] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Property] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""


```

이제 Method 클래스에서 Property를 Field로 변경하겠습니다.


```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Property] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""


```

이제 Class 클래스에서 Property를 Field로 변경하겠습니다.


```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""


```

이제 TestConfiguration 클래스에서도 Property를 Field로 변경하겠습니다.


```python
    properties: list[Field] = []
```

TestConfiguration 클래스의 properties 필드를 확인해보겠습니다.


TestConfiguration 클래스의 properties 필드를 찾아보겠습니다.


TestConfiguration 클래스의 properties는 dict 타입이므로 변경할 필요가 없습니다. 이제 모델 클래스 변경이 완료되었습니다.


이제 파서 서비스에서 Property를 Field로 변경하겠습니다.


```python
import os
import yaml
import re
from pathlib import Path

import javalang

from src.models.graph_entities import Class, Method, MethodCall, Field, Package, Annotation, Bean, BeanDependency, Endpoint, MyBatisMapper, MyBatisSqlStatement, MyBatisResultMap, SqlStatement, JpaEntity, JpaColumn, JpaRelationship, ConfigFile, DatabaseConfig, ServerConfig, SecurityConfig, LoggingConfig, TestClass, TestMethod, TestConfiguration
from src.utils.logger import get_logger
from typing import Optional, List, Literal


def extract_project_name(java_source_folder: str) -> str:
    """
    JAVA_SOURCE_FOLDER 경로에서 프로젝트 이름을 추출합니다.
    
    Args:
        java_source_folder: Java 소스 폴더 경로
        
    Returns:
        프로젝트 이름 (마지막 디렉토리명)
    """
    # 경로를 정규화하고 마지막 디렉토리명 추출
    path = Path(java_source_folder).resolve()
    return path.name


def extract_sql_statements_from_mappers(mybatis_mappers: list[MyBatisMapper], project_name: str) -> list[SqlStatement]:
    """
    MyBatis mappers에서 SQL statements를 추출합니다.
    
    Args:
        mybatis_mappers: MyBatis mapper 객체들의 리스트
        project_name: 프로젝트 이름
        
    Returns:
        SqlStatement 객체들의 리스트
    """
    sql_statements = []
    
    for mapper in mybatis_mappers:
        for sql_dict in mapper.sql_statements:
            # MyBatisSqlStatement를 SqlStatement로 변환
            sql_statement = SqlStatement(
                id=sql_dict.get('id', ''),
                sql_type=sql_dict.get('sql_type', ''),
                sql_content=sql_dict.get('sql_content', ''),
                parameter_type=sql_dict.get('parameter_type', ''),
                result_type=sql_dict.get('result_type', ''),
                result_map=sql_dict.get('result_map', ''),
                mapper_name=mapper.name,
                annotations=[],  # TODO: annotations를 파싱하여 추가
                project_name=project_name
            )
            sql_statements.append(sql_statement)
    
    return sql_statements


def parse_annotations(annotations, target_type: str = "class") -> list[Annotation]:
    """Parse Java annotations into Annotation objects.
    
    Args:
        annotations: List of annotation nodes from javalang
        target_type: Type of target ("class", "method", "field")
    """
    result = []
    for annotation in annotations:
        annotation_name = annotation.name
        parameters = {}
        
        # Parse annotation parameters if they exist
        if hasattr(annotation, 'element') and annotation.element:
            for element in annotation.element:
                if hasattr(element, 'name') and hasattr(element, 'value'):
                    parameters[element.name] = element.value.value if hasattr(element.value, 'value') else str(element.value)
        
        result.append(Annotation(
            name=annotation_name,
            parameters=parameters,
            target_type=target_type,
            category=classify_springboot_annotation(annotation_name)
        ))
    
    return result


def classify_springboot_annotation(annotation_name: str) -> str:
    """Classify SpringBoot annotations into categories.
    
    Args:
        annotation_name: Name of the annotation (e.g., "@Component", "@Service")
        
    Returns:
        Category of the annotation
    """
    # Component annotations
    component_annotations = {
        "Component", "Service", "Repository", "Controller", 
        "RestController", "Configuration", "Bean"
    }
    
    # Injection annotations
    injection_annotations = {
        "Autowired", "Resource", "Value", "Qualifier", "Primary"
    }
    
    # Web annotations
    web_annotations = {
        "RequestMapping", "GetMapping", "PostMapping", "PutMapping", 
        "DeleteMapping", "PatchMapping", "RequestParam", "PathVariable",
        "RequestBody", "ResponseBody", "ResponseStatus"
    }
    
    # JPA annotations
    jpa_annotations = {
        "Entity", "Table", "Id", "Column", "OneToMany", "ManyToOne",
        "OneToOne", "ManyToMany", "JoinColumn", "GeneratedValue"
    }
    
    # Test annotations
    test_annotations = {
        "Test", "SpringBootTest", "DataJpaTest", "WebMvcTest",
        "MockBean", "SpyBean", "TestPropertySource"
    }
    
    # Security annotations
    security_annotations = {
        "PreAuthorize", "PostAuthorize", "Secured", "RolesAllowed",
        "EnableWebSecurity", "EnableGlobalMethodSecurity"
    }
    
    # Validation annotations
    validation_annotations = {
        "Valid", "NotNull", "NotBlank", "NotEmpty", "Size", "Min", "Max",
        "Pattern", "Email", "AssertTrue", "AssertFalse"
    }
    
    # MyBatis annotations
    mybatis_annotations = {
        "Mapper", "Select", "Insert", "Update", "Delete", "SelectProvider",
        "InsertProvider", "UpdateProvider", "DeleteProvider", "Results",
        "Result", "One", "Many", "MapKey", "Options", "SelectKey"
    }
    
    if annotation_name in component_annotations:
        return "component"
    elif annotation_name in injection_annotations:
        return "injection"
    elif annotation_name in web_annotations:
        return "web"
    elif annotation_name in jpa_annotations:
        return "jpa"
    elif annotation_name in test_annotations:
        return "test"
    elif annotation_name in security_annotations:
        return "security"
    elif annotation_name in validation_annotations:
        return "validation"
    elif annotation_name in mybatis_annotations:
        return "mybatis"
    else:
        return "other"


def classify_test_annotation(annotation_name: str) -> str:
    """Classify test annotations into categories.
    
    Args:
        annotation_name: Name of the annotation
        
    Returns:
        Category of the test annotation
    """
    # JUnit annotations
    junit_annotations = {
        "Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll",
        "DisplayName", "ParameterizedTest", "ValueSource", "CsvSource",
        "MethodSource", "Timeout", "Disabled", "Nested", "RepeatedTest",
        "Order", "TestMethodOrder", "TestInstance", "TestClassOrder"
    }
    
    # Spring Boot Test annotations
    spring_test_annotations = {
        "SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest",
        "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest",
        "MockBean", "SpyBean", "TestConfiguration", "ActiveProfiles",
        "TestPropertySource", "DirtiesContext", "Transactional",
        "Rollback", "Commit", "Sql", "SqlGroup", "AutoConfigureTestDatabase",
        "AutoConfigureMockMvc", "AutoConfigureWebMvc", "AutoConfigureWebClient",
        "MockMvc", "TestEntityManager", "TestContainers", "DynamicPropertySource"
    }
    
    # TestNG annotations
    testng_annotations = {
        "TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass",
        "BeforeSuite", "AfterSuite", "BeforeGroups", "AfterGroups",
        "DataProvider", "Parameters", "Groups", "Priority", "DependsOnMethods",
        "DependsOnGroups", "ExpectedExceptions", "InvocationCount",
        "SuccessPercentage", "TimeOut"
    }
    
    # Mockito annotations
    mockito_annotations = {
        "Mock", "Spy", "InjectMocks", "Captor", "MockedStatic"
    }
    
    # AssertJ annotations
    assertj_annotations = {
        "AssertJ"
    }
    
    # Other test annotations
    other_test_annotations = {
        "Ignore", "Category", "RunWith", "ExtendWith", "ContextConfiguration"
    }
    
    if annotation_name in junit_annotations:
        return "junit"
    elif annotation_name in spring_test_annotations:
        return "spring_test"
    elif annotation_name in testng_annotations:
        return "testng"
    elif annotation_name in mockito_annotations:
        return "mockito"
    elif annotation_name in assertj_annotations:
        return "assertj"
    elif annotation_name in other_test_annotations:
        return "other_test"
    else:
        return "other"


def extract_beans_from_classes(classes: list[Class]) -> list[Bean]:
    """Extract Spring Beans from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Bean objects
    """
    beans = []
    
    for cls in classes:
        # Check if class has Spring component annotations
        component_annotations = [ann for ann in cls.annotations if ann.category == "component"]
        
        # Also check for @Repository on interfaces
        has_repository_annotation = any(ann.name == "Repository" for ann in cls.annotations)
        
        if component_annotations or has_repository_annotation:
            # Determine bean type based on annotations
            bean_type = "component"  # default
            if any(ann.name in ["Service", "Service"] for ann in cls.annotations):
                bean_type = "service"
            elif any(ann.name in ["Repository", "Repository"] for ann in cls.annotations):
                bean_type = "repository"
            elif any(ann.name in ["Controller", "RestController"] for ann in cls.annotations):
                bean_type = "controller"
            elif any(ann.name in ["Configuration", "Configuration"] for ann in cls.annotations):
                bean_type = "configuration"
            
            # Determine scope (default is singleton)
            scope = "singleton"
            for ann in cls.annotations:
                if ann.name == "Scope":
                    if "value" in ann.parameters:
                        scope = ann.parameters["value"]
                    elif "prototype" in str(ann.parameters):
                        scope = "prototype"
                    elif "request" in str(ann.parameters):
                        scope = "request"
                    elif "session" in str(ann.parameters):
                        scope = "session"
            
            # Create bean name (use class name with first letter lowercase)
            bean_name = cls.name[0].lower() + cls.name[1:] if cls.name else cls.name
            
            # Check for @Bean methods in configuration classes
            bean_methods = []
            if bean_type == "configuration":
                for method in cls.methods:
                    if any(ann.name == "Bean" for ann in method.annotations):
                        bean_methods.append(method)
            
            bean = Bean(
                name=bean_name,
                type=bean_type,
                scope=scope,
                class_name=cls.name,
                package_name=cls.package_name,
                annotation_names=[ann.name for ann in cls.annotations] if cls.annotations else [],
                method_count=len(bean_methods) if bean_type == "configuration" else len(cls.methods) if cls.methods else 0,
                property_count=len(cls.properties) if cls.properties else 0
            )
            beans.append(bean)
    
    return beans


def analyze_bean_dependencies(classes: list[Class], beans: list[Bean]) -> list[BeanDependency]:
    """Analyze dependencies between Spring Beans.
    
    Args:
        classes: List of parsed Class objects
        beans: List of Bean objects
        
    Returns:
        List of BeanDependency objects
    """
    dependencies = []
    
    # Create a mapping from class names to bean names
    class_to_bean = {}
    for bean in beans:
        class_to_bean[bean.class_name] = bean.name
    
    for cls in classes:
        # Check if this class is a bean
        if cls.name not in class_to_bean:
            continue
            
        source_bean = class_to_bean[cls.name]
        
        # Analyze field injections (@Autowired, @Resource, @Value)
        for prop in cls.properties:
            if any(ann.category == "injection" for ann in prop.annotations):
                # Try to determine target bean from field type
                target_bean = None
                field_type = prop.type
                
                # Look for exact class name match
                if field_type in class_to_bean:
                    target_bean = class_to_bean[field_type]
                else:
                    # Look for interface implementations (simplified - just check if type matches any bean class name)
                    for bean in beans:
                        if field_type == bean.class_name:
                            target_bean = bean.name
                            break
                
                if target_bean:
                    injection_type = "field"
                    for ann in prop.annotations:
                        if ann.name == "Autowired":
                            injection_type = "field"
                        elif ann.name == "Resource":
                            injection_type = "field"
                        elif ann.name == "Value":
                            injection_type = "field"
                    
                    dependency = BeanDependency(
                        source_bean=source_bean,
                        target_bean=target_bean,
                        injection_type=injection_type,
                        field_name=prop.name
                    )
                    dependencies.append(dependency)
        
        # Analyze constructor injections
        for method in cls.methods:
            if method.name == cls.name:  # Constructor
                for param in method.parameters:
                    if any(ann.category == "injection" for ann in param.annotations):
                        target_bean = None
                        param_type = param.type
                        
                        if param_type in class_to_bean:
                            target_bean = class_to_bean[param_type]
                        else:
                            # Look for interface implementations (simplified)
                            for bean in beans:
                                if param_type == bean.class_name:
                                    target_bean = bean.name
                                    break
                        
                        if target_bean:
                            dependency = BeanDependency(
                                source_bean=source_bean,
                                target_bean=target_bean,
                                injection_type="constructor",
                                parameter_name=param.name
                            )
                            dependencies.append(dependency)
        
        # Analyze setter injections
        for method in cls.methods:
            if method.name.startswith("set") and len(method.parameters) == 1:
                if any(ann.category == "injection" for ann in method.annotations):
                    param = method.parameters[0]
                    target_bean = None
                    param_type = param.type
                    
                    if param_type in class_to_bean:
                        target_bean = class_to_bean[param_type]
                    else:
                        # Look for interface implementations (simplified)
                        for bean in beans:
                            if param_type == bean.class_name:
                                target_bean = bean.name
                                break
                    
                    if target_bean:
                        dependency = BeanDependency(
                            source_bean=source_bean,
                            target_bean=target_bean,
                            injection_type="setter",
                            method_name=method.name,
                            parameter_name=param.name
                        )
                        dependencies.append(dependency)
    
    return dependencies


def extract_endpoints_from_classes(classes: list[Class]) -> list[Endpoint]:
    """Extract REST API endpoints from controller classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Endpoint objects
    """
    endpoints = []
    
    for cls in classes:
        # Check if class is a controller
        is_controller = any(ann.name in ["Controller", "RestController"] for ann in cls.annotations)
        
        if not is_controller:
            continue
            
        # Get class-level path mapping
        class_path = ""
        for ann in cls.annotations:
            if ann.name == "RequestMapping":
                if "value" in ann.parameters:
                    class_path = ann.parameters["value"]
                break
        
        # Process each method in the controller
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
                
            # Check if method has web mapping annotations
            web_annotations = [ann for ann in method.annotations if ann.category == "web"]
            
            if not web_annotations:
                continue
            
            # Extract endpoint information
            endpoint_path = ""
            http_method = "GET"  # default
            
            for ann in web_annotations:
                if ann.name in ["RequestMapping", "GetMapping", "PostMapping", "PutMapping", "DeleteMapping", "PatchMapping"]:
                    # Extract path
                    if "value" in ann.parameters:
                        endpoint_path = ann.parameters["value"]
                    elif "path" in ann.parameters:
                        endpoint_path = ann.parameters["path"]
                    
                    # Extract HTTP method
                    if ann.name == "GetMapping":
                        http_method = "GET"
                    elif ann.name == "PostMapping":
                        http_method = "POST"
                    elif ann.name == "PutMapping":
                        http_method = "PUT"
                    elif ann.name == "DeleteMapping":
                        http_method = "DELETE"
                    elif ann.name == "PatchMapping":
                        http_method = "PATCH"
                    elif ann.name == "RequestMapping":
                        if "method" in ann.parameters:
                            method_value = ann.parameters["method"]
                            if isinstance(method_value, list) and len(method_value) > 0:
                                http_method = method_value[0]
                            else:
                                http_method = str(method_value)
                        else:
                            http_method = "GET"  # default for RequestMapping
                    break
            
            # Build full path
            full_path = class_path
            if endpoint_path:
                if full_path and not full_path.endswith("/") and not endpoint_path.startswith("/"):
                    full_path += "/"
                full_path += endpoint_path
            elif not full_path:
                full_path = "/"
            
            # Extract method parameters
            parameters = []
            for param in method.parameters:
                param_info = {
                    "name": param.name,
                    "type": param.type,
                    "annotations": [ann.name for ann in param.annotations if ann.category == "web"]
                }
                parameters.append(param_info)
            
            # Extract return type
            return_type = method.return_type if method.return_type != "constructor" else "void"
            
            # Create endpoint
            endpoint = Endpoint(
                path=endpoint_path or "/",
                method=http_method,
                controller_class=cls.name,
                handler_method=method.name,
                parameters=parameters,
                return_type=return_type,
                annotations=[ann.name for ann in web_annotations],
                full_path=full_path
            )
            endpoints.append(endpoint)
    
    return endpoints


def extract_mybatis_mappers_from_classes(classes: list[Class]) -> list[MyBatisMapper]:
    """Extract MyBatis Mappers from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for cls in classes:
        # Check if class is a MyBatis Mapper interface
        is_mapper = any(ann.name == "Mapper" for ann in cls.annotations)
        
        if not is_mapper:
            continue
        
        # Extract mapper methods with MyBatis annotations
        mapper_methods = []
        sql_statements = []
        
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
            
            # Check if method has MyBatis annotations
            mybatis_annotations = [ann for ann in method.annotations if ann.category == "mybatis"]
            
            if not mybatis_annotations:
                continue
            
            # Extract SQL statement information
            sql_type = "SELECT"  # default
            sql_content = ""
            parameter_type = ""
            result_type = ""
            result_map = ""
            
            for ann in mybatis_annotations:
                if ann.name in ["Select", "SelectProvider"]:
                    sql_type = "SELECT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Insert", "InsertProvider"]:
                    sql_type = "INSERT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Update", "UpdateProvider"]:
                    sql_type = "UPDATE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Delete", "DeleteProvider"]:
                    sql_type = "DELETE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                
                # Extract parameter and result type information
                if "parameterType" in ann.parameters:
                    parameter_type = ann.parameters["parameterType"]
                if "resultType" in ann.parameters:
                    result_type = ann.parameters["resultType"]
                if "resultMap" in ann.parameters:
                    result_map = ann.parameters["resultMap"]
            
            # Create method info
            method_info = {
                "name": method.name,
                "return_type": method.return_type,
                "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            mapper_methods.append(method_info)
            
            # Create SQL statement info
            sql_statement = {
                "id": method.name,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            sql_statements.append(sql_statement)
        
        # Create mapper
        mapper = MyBatisMapper(
            name=cls.name,
            type="interface",
            namespace=f"{cls.package_name}.{cls.name}",
            methods=mapper_methods,
            sql_statements=sql_statements,
            file_path=cls.file_path,
            package_name=cls.package_name
        )
        mappers.append(mapper)
    
    return mappers


def parse_mybatis_xml_file(file_path: str) -> MyBatisMapper:
    """Parse MyBatis XML mapper file.
    
    Args:
        file_path: Path to the XML mapper file
        
    Returns:
        MyBatisMapper object
    """
    import xml.etree.ElementTree as ET
    
    try:
        tree = ET.parse(file_path)
        root = tree.getroot()
        
        # Extract namespace
        namespace = root.get("namespace", "")
        
        # Extract SQL statements
        sql_statements = []
        for statement in root.findall(".//*[@id]"):
            statement_id = statement.get("id")
            tag_name = statement.tag.lower()
            
            # Determine SQL type
            sql_type = "SELECT"
            if tag_name == "insert":
                sql_type = "INSERT"
            elif tag_name == "update":
                sql_type = "UPDATE"
            elif tag_name == "delete":
                sql_type = "DELETE"
            
            # Extract SQL content
            sql_content = statement.text.strip() if statement.text else ""
            
            # Extract parameter and result information
            parameter_type = statement.get("parameterType", "")
            result_type = statement.get("resultType", "")
            result_map = statement.get("resultMap", "")
            
            sql_statement = {
                "id": statement_id,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": []
            }
            sql_statements.append(sql_statement)
        
        # Extract ResultMaps
        result_maps = []
        for result_map in root.findall(".//resultMap"):
            result_map_id = result_map.get("id")
            result_map_type = result_map.get("type", "")
            
            properties = []
            for property_elem in result_map.findall(".//result"):
                prop = {
                    "property": property_elem.get("property", ""),
                    "column": property_elem.get("column", ""),
                    "jdbc_type": property_elem.get("jdbcType", "")
                }
                properties.append(prop)
            
            result_map_info = {
                "id": result_map_id,
                "type": result_map_type,
                "properties": properties,
                "associations": [],
                "collections": []
            }
            result_maps.append(result_map_info)
        
        # Create mapper
        mapper_name = namespace.split(".")[-1] if namespace else os.path.basename(file_path).replace(".xml", "")
        package_name = ".".join(namespace.split(".")[:-1]) if namespace else ""
        
        mapper = MyBatisMapper(
            name=mapper_name,
            type="xml",
            namespace=namespace,
            methods=[],  # XML mappers don't have Java methods
            sql_statements=sql_statements,
            file_path=file_path,
            package_name=package_name
        )
        
        return mapper
        
    except ET.ParseError as e:
        print(f"Error parsing XML file {file_path}: {e}")
        return None
    except Exception as e:
        print(f"Error reading XML file {file_path}: {e}")
        return None


def extract_mybatis_xml_mappers(directory: str) -> list[MyBatisMapper]:
    """Extract MyBatis XML mappers from directory.
    
    Args:
        directory: Directory to search for XML mapper files
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith("Mapper.xml") or file.endswith("Dao.xml"):
                file_path = os.path.join(root, file)
                mapper = parse_mybatis_xml_file(file_path)
                if mapper:
                    mappers.append(mapper)
    
    return mappers


def extract_jpa_entities_from_classes(classes: list[Class]) -> list[JpaEntity]:
    """Extract JPA Entities from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of JpaEntity objects
    """
    entities = []
    
    for cls in classes:
        # Check if class is a JPA Entity
        is_entity = any(ann.name == "Entity" for ann in cls.annotations)
        
        if not is_entity:
            continue
        
        # Extract table name
        table_name = cls.name.lower()  # default table name
        for ann in cls.annotations:
            if ann.name == "Table":
                if "name" in ann.parameters:
                    table_name = ann.parameters["name"]
                break
        
        # Extract columns from properties
        columns = []
        relationships = []
        
        for prop in cls.properties:
            # Check if property has JPA column annotations
            jpa_annotations = [ann for ann in prop.annotations if ann.category == "jpa"]
            
            if jpa_annotations:
                # Extract column information
                column_name = prop.name  # default column name
                nullable = True
                unique = False
                length = 0
                precision = 0
                scale = 0
                
                for ann in jpa_annotations:
                    if ann.name == "Column":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                        if "nullable" in ann.parameters:
                            nullable = ann.parameters["nullable"]
                        if "unique" in ann.parameters:
                            unique = ann.parameters["unique"]
                        if "length" in ann.parameters:
                            length = ann.parameters["length"]
                        if "precision" in ann.parameters:
                            precision = ann.parameters["precision"]
                        if "scale" in ann.parameters:
                            scale = ann.parameters["scale"]
                    elif ann.name == "Id":
                        column_name = "id"  # Primary key column
                        nullable = False
                        unique = True
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                
                # Check for relationship annotations
                relationship_type = None
                target_entity = ""
                mapped_by = ""
                join_column = ""
                join_table = ""
                cascade = []
                fetch = "LAZY"
                
                for ann in jpa_annotations:
                    if ann.name in ["OneToOne", "OneToMany", "ManyToOne", "ManyToMany"]:
                        relationship_type = ann.name
                        if "targetEntity" in ann.parameters:
                            target_entity = ann.parameters["targetEntity"]
                        if "mappedBy" in ann.parameters:
                            mapped_by = ann.parameters["mappedBy"]
                        if "cascade" in ann.parameters:
                            cascade = ann.parameters["cascade"] if isinstance(ann.parameters["cascade"], list) else [ann.parameters["cascade"]]
                        if "fetch" in ann.parameters:
                            fetch = ann.parameters["fetch"]
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            join_column = ann.parameters["name"]
                    elif ann.name == "JoinTable":
                        if "name" in ann.parameters:
                            join_table = ann.parameters["name"]
                
                # Create column info
                column_info = {
                    "property_name": prop.name,
                    "column_name": column_name,
                    "data_type": prop.type,
                    "nullable": nullable,
                    "unique": unique,
                    "length": length,
                    "precision": precision,
                    "scale": scale,
                    "annotations": [ann.name for ann in jpa_annotations]
                }
                columns.append(column_info)
                
                # Create relationship info if it's a relationship
                if relationship_type:
                    relationship_info = {
                        "type": relationship_type,
                        "target_entity": target_entity,
                        "mapped_by": mapped_by,
                        "join_column": join_column,
                        "join_table": join_table,
                        "cascade": cascade,
                        "fetch": fetch,
                        "annotations": [ann.name for ann in jpa_annotations]
                    }
                    relationships.append(relationship_info)
        
        # Create entity
        entity = JpaEntity(
            name=cls.name,
            table_name=table_name,
            columns=columns,
            relationships=relationships,
            annotations=[ann.name for ann in cls.annotations if ann.category == "jpa"],
            package_name=cls.package_name,
            file_path=cls.file_path
        )
        entities.append(entity)
    
    return entities


def parse_yaml_config(file_path: str) -> ConfigFile:
    """Parse YAML configuration file.
    
    Args:
        file_path: Path to the YAML file
        
    Returns:
        ConfigFile object
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = yaml.safe_load(f)
        
        if not content:
            content = {}
        
        # Extract file info
        file_name = os.path.basename(file_path)
        file_type = "yaml" if file_path.endswith('.yaml') else "yml"
        
        # Extract profiles
        profiles = []
        if 'spring' in content and 'profiles' in content['spring']:
            if 'active' in content['spring']['profiles']:
                profiles = content['spring']['profiles']['active']
                if isinstance(profiles, str):
                    profiles = [profiles]
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        # Extract sections
        sections = []
        for key, value in content.items():
            if isinstance(value, dict):
                sections.append({
                    "name": key,
                    "properties": value,
                    "type": "section"
                })
        
        return ConfigFile(
            name=file_name,
            file_path=file_path,
            file_type=file_type,
            properties=content,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing YAML file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="yaml",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def parse_properties_config(file_path: str) -> ConfigFile:
    """Parse Properties configuration file.
    
    Args:
        file_path: Path to the properties file
        
    Returns:
        ConfigFile object
    """
    try:
        properties = {}
        sections = []
        profiles = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                
                # Skip empty lines and comments
                if not line or line.startswith('#'):
                    continue
                
                # Parse key=value pairs
                if '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    
                    # Remove quotes if present
                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]
                    elif value.startswith("'") and value.endswith("'"):
                        value = value[1:-1]
                    
                    properties[key] = value
                    
                    # Check for profiles
                    if key == 'spring.profiles.active':
                        profiles = [p.strip() for p in value.split(',')]
        
        # Group properties by section
        section_map = {}
        for key, value in properties.items():
            if '.' in key:
                section = key.split('.')[0]
                if section not in section_map:
                    section_map[section] = {}
                section_map[section][key] = value
            else:
                if 'root' not in section_map:
                    section_map['root'] = {}
                section_map['root'][key] = value
        
        for section_name, section_props in section_map.items():
            sections.append({
                "name": section_name,
                "properties": section_props,
                "type": "section"
            })
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties=properties,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing Properties file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def extract_database_config(config_file: ConfigFile) -> DatabaseConfig:
    """Extract database configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        DatabaseConfig object
    """
    db_config = DatabaseConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        spring_config = config_file.properties.get('spring', {})
        datasource_config = spring_config.get('datasource', {})
        jpa_config = spring_config.get('jpa', {})
        
        db_config.driver = datasource_config.get('driver-class-name', '')
        db_config.url = datasource_config.get('url', '')
        db_config.username = datasource_config.get('username', '')
        db_config.password = datasource_config.get('password', '')
        db_config.dialect = jpa_config.get('database-platform', '')
        db_config.hibernate_ddl_auto = jpa_config.get('hibernate', {}).get('ddl-auto', '')
        db_config.show_sql = jpa_config.get('show-sql', False)
        db_config.format_sql = jpa_config.get('properties', {}).get('hibernate', {}).get('format_sql', False)
        
        # Store additional JPA properties
        if 'properties' in jpa_config:
            db_config.jpa_properties = jpa_config['properties']
    
    else:
        # Properties format
        props = config_file.properties
        
        db_config.driver = props.get('spring.datasource.driver-class-name', '')
        db_config.url = props.get('spring.datasource.url', '')
        db_config.username = props.get('spring.datasource.username', '')
        db_config.password = props.get('spring.datasource.password', '')
        db_config.dialect = props.get('spring.jpa.database-platform', '')
        db_config.hibernate_ddl_auto = props.get('spring.jpa.hibernate.ddl-auto', '')
        db_config.show_sql = props.get('spring.jpa.show-sql', 'false').lower() == 'true'
        db_config.format_sql = props.get('spring.jpa.properties.hibernate.format_sql', 'false').lower() == 'true'
        
        # Store additional JPA properties
        jpa_props = {}
        for key, value in props.items():
            if key.startswith('spring.jpa.properties.'):
                jpa_props[key] = value
        db_config.jpa_properties = jpa_props
    
    return db_config


def extract_server_config(config_file: ConfigFile) -> ServerConfig:
    """Extract server configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        ServerConfig object
    """
    server_config = ServerConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        server_props = config_file.properties.get('server', {})
        
        server_config.port = server_props.get('port', 8080)
        server_config.context_path = server_props.get('servlet', {}).get('context-path', '')
        server_config.servlet_path = server_props.get('servlet', {}).get('path', '')
        
        # SSL configuration
        ssl_config = server_props.get('ssl', {})
        server_config.ssl_enabled = bool(ssl_config)
        server_config.ssl_key_store = ssl_config.get('key-store', '')
        server_config.ssl_key_store_password = ssl_config.get('key-store-password', '')
        server_config.ssl_key_store_type = ssl_config.get('key-store-type', '')
    
    else:
        # Properties format
        props = config_file.properties
        
        server_config.port = int(props.get('server.port', '8080'))
        server_config.context_path = props.get('server.servlet.context-path', '')
        server_config.servlet_path = props.get('server.servlet.path', '')
        
        # SSL configuration
        server_config.ssl_enabled = any(key.startswith('server.ssl.') for key in props.keys())
        server_config.ssl_key_store = props.get('server.ssl.key-store', '')
        server_config.ssl_key_store_password = props.get('server.ssl.key-store-password', '')
        server_config.ssl_key_store_type = props.get('server.ssl.key-store-type', '')
    
    return server_config


def extract_security_config(config_file: ConfigFile) -> SecurityConfig:
    """Extract security configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        SecurityConfig object
    """
    security_config = SecurityConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        security_props = config_file.properties.get('security', {})
        jwt_props = security_props.get('jwt', {})
        cors_props = security_props.get('cors', {})
        
        security_config.enabled = bool(security_props)
        security_config.authentication_type = security_props.get('authentication-type', '')
        security_config.jwt_secret = jwt_props.get('secret', '')
        security_config.jwt_expiration = jwt_props.get('expiration', 0)
        security_config.cors_allowed_origins = cors_props.get('allowed-origins', [])
        security_config.cors_allowed_methods = cors_props.get('allowed-methods', [])
        security_config.cors_allowed_headers = cors_props.get('allowed-headers', [])
    
    else:
        # Properties format
        props = config_file.properties
        
        security_config.enabled = any(key.startswith('security.') for key in props.keys())
        security_config.authentication_type = props.get('security.authentication-type', '')
        security_config.jwt_secret = props.get('security.jwt.secret', '')
        security_config.jwt_expiration = int(props.get('security.jwt.expiration', '0'))
        
        # CORS configuration
        origins = props.get('security.cors.allowed-origins', '')
        if origins:
            security_config.cors_allowed_origins = [o.strip() for o in origins.split(',')]
        
        methods = props.get('security.cors.allowed-methods', '')
        if methods:
            security_config.cors_allowed_methods = [m.strip() for m in methods.split(',')]
        
        headers = props.get('security.cors.allowed-headers', '')
        if headers:
            security_config.cors_allowed_headers = [h.strip() for h in headers.split(',')]
    
    return security_config


def extract_logging_config(config_file: ConfigFile) -> LoggingConfig:
    """Extract logging configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        LoggingConfig object
    """
    logging_config = LoggingConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        logging_props = config_file.properties.get('logging', {})
        
        logging_config.level = logging_props.get('level', {}).get('root', 'INFO')
        logging_config.pattern = logging_props.get('pattern', {}).get('console', '')
        logging_config.file_path = logging_props.get('file', {}).get('name', '')
        logging_config.max_file_size = logging_props.get('file', {}).get('max-size', '')
        logging_config.max_history = logging_props.get('file', {}).get('max-history', 0)
        logging_config.console_output = logging_props.get('console', {}).get('enabled', True)
    
    else:
        # Properties format
        props = config_file.properties
        
        logging_config.level = props.get('logging.level.root', 'INFO')
        logging_config.pattern = props.get('logging.pattern.console', '')
        logging_config.file_path = props.get('logging.file.name', '')
        logging_config.max_file_size = props.get('logging.file.max-size', '')
        logging_config.max_history = int(props.get('logging.file.max-history', '0'))
        logging_config.console_output = props.get('logging.console.enabled', 'true').lower() == 'true'
    
    return logging_config


def extract_config_files(directory: str) -> list[ConfigFile]:
    """Extract configuration files from directory.
    
    Args:
        directory: Directory to search for config files
        
    Returns:
        List of ConfigFile objects
    """
    config_files = []
    
    # Common config file patterns
    config_patterns = [
        "application.yml",
        "application.yaml", 
        "application.properties",
        "application-*.properties",
        "bootstrap.yml",
        "bootstrap.yaml",
        "bootstrap.properties"
    ]
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            # Check if file matches any config pattern
            is_config_file = False
            for pattern in config_patterns:
                if pattern == file or (pattern.endswith('*') and file.startswith(pattern[:-1])):
                    is_config_file = True
                    break
            
            if is_config_file:
                file_path = os.path.join(root, file)
                
                if file.endswith(('.yml', '.yaml')):
                    config_file = parse_yaml_config(file_path)
                elif file.endswith('.properties'):
                    config_file = parse_properties_config(file_path)
                else:
                    continue
                
                config_files.append(config_file)
    
    return config_files


def extract_test_classes_from_classes(classes: list[Class]) -> list[TestClass]:
    """Extract test classes from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of TestClass objects
    """
    test_classes = []
    
    for cls in classes:
        # Check if class is a test class
        test_annotations = [ann for ann in cls.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
        
        if not test_annotations:
            continue
        
        # Determine test framework and type
        test_framework = "junit"  # default
        test_type = "unit"  # default
        
        for ann in test_annotations:
            if ann.name in ["SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest", "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest"]:
                test_framework = "spring_test"
                if ann.name == "SpringBootTest":
                    test_type = "integration"
                else:
                    test_type = "slice"
            elif ann.name in ["TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass"]:
                test_framework = "testng"
            elif ann.name in ["Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll"]:
                test_framework = "junit"
        
        # Extract test methods
        test_methods = []
        setup_methods = []
        
        for method in cls.methods:
            method_annotations = [ann.name for ann in method.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
            
            if method_annotations:
                # Check if it's a setup/teardown method
                if any(ann in method_annotations for ann in ["BeforeEach", "AfterEach", "BeforeAll", "AfterAll", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass", "BeforeSuite", "AfterSuite"]):
                    setup_methods.append({
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters]
                    })
                else:
                    # Regular test method
                    test_method_info = {
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                        "assertions": [],
                        "mock_calls": [],
                        "test_data": [],
                        "expected_exceptions": [],
                        "timeout": 0,
                        "display_name": ""
                    }
                    
                    # Extract display name
                    for ann in method.annotations:
                        if ann.name == "DisplayName" and "value" in ann.parameters:
                            test_method_info["display_name"] = ann.parameters["value"]
                        elif ann.name == "Timeout" and "value" in ann.parameters:
                            test_method_info["timeout"] = ann.parameters["value"]
                    
                    # Extract expected exceptions
                    for ann in method.annotations:
                        if ann.name == "ExpectedExceptions" and "value" in ann.parameters:
                            test_method_info["expected_exceptions"] = ann.parameters["value"] if isinstance(ann.parameters["value"], list) else [ann.parameters["value"]]
                    
                    test_methods.append(test_method_info)
        
        # Extract mock dependencies
        mock_dependencies = []
        for prop in cls.properties:
            prop_annotations = [ann.name for ann in prop.annotations if classify_test_annotation(ann.name) in ["mockito", "spring_test"]]
            if prop_annotations:
                mock_dependencies.append({
                    "name": prop.name,
                    "type": prop.type,
                    "annotations": prop_annotations,
                    "mock_type": "mock" if "Mock" in prop_annotations else "spy" if "Spy" in prop_annotations else "bean"
                })
        
        # Extract test configurations
        test_configurations = []
        for ann in cls.annotations:
            if ann.name in ["TestConfiguration", "ActiveProfiles", "TestPropertySource"]:
                config_info = {
                    "name": ann.name,
                    "type": "configuration" if ann.name == "TestConfiguration" else "profile" if ann.name == "ActiveProfiles" else "property",
                    "properties": ann.parameters,
                    "active_profiles": ann.parameters.get("value", []) if ann.name == "ActiveProfiles" else [],
                    "test_slices": [],
                    "mock_beans": [],
                    "spy_beans": []
                }
                test_configurations.append(config_info)
        
        # Create test class
        test_class = TestClass(
            name=cls.name,
            package_name=cls.package_name,
            test_framework=test_framework,
            test_type=test_type,
            annotations=[ann.name for ann in test_annotations],
            test_methods=test_methods,
            setup_methods=setup_methods,
            mock_dependencies=mock_dependencies,
            test_configurations=test_configurations,
            file_path=cls.file_path
        )
        test_classes.append(test_class)
    
    return test_classes


def analyze_test_methods(test_class: TestClass, class_obj: Class) -> list[TestMethod]:
    """Analyze test methods for assertions, mock calls, and test data.
    
    Args:
        test_class: TestClass object
        class_obj: Original Class object
        
    Returns:
        List of analyzed TestMethod objects
    """
    test_methods = []
    
    for method_info in test_class.test_methods:
        # Find the corresponding method in the class
        method_obj = None
        for method in class_obj.methods:
            if method.name == method_info["name"]:
                method_obj = method
                break
        
        if not method_obj:
            continue
        
        # Analyze method source code for assertions and mock calls
        assertions = []
        mock_calls = []
        test_data = []
        
        if method_obj.source:
            source_code = method_obj.source
            
            # Find assertions (JUnit, AssertJ, etc.)
            assertion_patterns = [
                r'assert\w+\(',  # JUnit assertions
                r'assertThat\(',  # AssertJ
                r'assertEquals\(',  # JUnit
                r'assertTrue\(',  # JUnit
                r'assertFalse\(',  # JUnit
                r'assertNotNull\(',  # JUnit
                r'assertNull\(',  # JUnit
                r'assertThrows\(',  # JUnit 5
                r'assertDoesNotThrow\(',  # JUnit 5
                r'verify\(',  # Mockito verify
                r'when\(',  # Mockito when
                r'then\(',  # Mockito then
                r'given\(',  # BDDMockito given
                r'willReturn\(',  # Mockito willReturn
                r'willThrow\(',  # Mockito willThrow
            ]
            
            for pattern in assertion_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    assertions.append({
                        "type": match,
                        "line": source_code.find(match) + 1
                    })
            
            # Find mock calls
            mock_call_patterns = [
                r'(\w+)\.(\w+)\(',  # Method calls on objects
                r'mock\(',  # Mockito mock creation
                r'spy\(',  # Mockito spy creation
                r'@Mock\s+(\w+)',  # @Mock annotation
                r'@Spy\s+(\w+)',  # @Spy annotation
                r'@InjectMocks\s+(\w+)',  # @InjectMocks annotation
            ]
            
            for pattern in mock_call_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        mock_calls.append({
                            "object": match[0],
                            "method": match[1],
                            "type": "method_call"
                        })
                    else:
                        mock_calls.append({
                            "type": match,
                            "line": source_code.find(match) + 1
                        })
            
            # Find test data setup
            test_data_patterns = [
                r'new\s+(\w+)\(',  # Object creation
                r'(\w+)\s*=\s*new\s+(\w+)\(',  # Variable assignment with new
                r'@ValueSource\(',  # JUnit 5 @ValueSource
                r'@CsvSource\(',  # JUnit 5 @CsvSource
                r'@MethodSource\(',  # JUnit 5 @MethodSource
            ]
            
            for pattern in test_data_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        test_data.append({
                            "variable": match[0],
                            "type": match[1],
                            "pattern": "object_creation"
                        })
                    else:
                        test_data.append({
                            "type": match,
                            "pattern": "annotation"
                        })
        
        # Create TestMethod object
        test_method = TestMethod(
            name=method_info["name"],
            return_type=method_info["return_type"],
            annotations=method_info["annotations"],
            assertions=assertions,
            mock_calls=mock_calls,
            test_data=test_data,
            expected_exceptions=method_info["expected_exceptions"],
            timeout=method_info["timeout"],
            display_name=method_info["display_name"]
        )
        test_methods.append(test_method)
    
    return test_methods


def generate_lombok_methods(properties: list[Property], class_name: str, package_name: str) -> list[Method]:
    """Generate Lombok @Data methods (getters, setters, equals, hashCode, toString) for properties."""
    methods = []
    
    # Generate getters and setters for each property
    for prop in properties:
        # Getter
        getter_name = f"get{prop.name[0].upper()}{prop.name[1:]}"
        if prop.type == "Boolean" and prop.name.startswith("is"):
            # For boolean fields starting with 'is', use the field name as getter
            getter_name = prop.name
        
        getter = Method(
            name=getter_name,
            logical_name=f"{package_name}.{class_name}.{getter_name}",
            return_type=prop.type,
            parameters=[],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[]
        )
        methods.append(getter)
        
        # Setter
        setter_name = f"set{prop.name[0].upper()}{prop.name[1:]}"
        setter_param = Property(
            name=prop.name,
            logical_name=f"{package_name}.{class_name}.{prop.name}",
            type=prop.type,
            package_name=package_name,
            class_name=class_name
        )
        
        setter = Method(
            name=setter_name,
            logical_name=f"{package_name}.{class_name}.{setter_name}",
            return_type="void",
            parameters=[setter_param],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[]
        )
        methods.append(setter)
    
    # Generate equals method
    equals_method = Method(
        name="equals",
        logical_name=f"{package_name}.{class_name}.equals",
        return_type="boolean",
        parameters=[Property(name="obj", logical_name=f"{package_name}.{class_name}.obj", type="Object", package_name=package_name, class_name=class_name)],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(equals_method)
    
    # Generate hashCode method
    hashcode_method = Method(
        name="hashCode",
        logical_name=f"{package_name}.{class_name}.hashCode",
        return_type="int",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(hashcode_method)
    
    # Generate toString method
    tostring_method = Method(
        name="toString",
        logical_name=f"{package_name}.{class_name}.toString",
        return_type="String",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(tostring_method)
    
    return methods


def parse_java_project(directory: str) -> tuple[list[Package], list[Class], dict[str, str], list[Bean], list[BeanDependency], list[Endpoint], list[MyBatisMapper], list[JpaEntity], list[ConfigFile], list[TestClass], list[SqlStatement], str]:
    """Parse Java project and return parsed entities."""
    logger = get_logger(__name__)
    """Parses all Java files in a directory and returns a tuple of (packages, classes, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name)."""
    
    # Extract project name from directory path
    project_name = extract_project_name(directory)
    packages = {}
    classes = {}
    class_to_package_map = {}  # Maps class_key to package_name

    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith(".java"):
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    file_content = f.read() # Read file content once
                try:
                    tree = javalang.parse.parse(file_content)
                    package_name = tree.package.name if tree.package else ""
                    
                    # Create or update package node
                    if package_name and package_name not in packages:
                        packages[package_name] = Package(
                            name=package_name
                        )
                    elif not package_name:
                        # Handle classes without package (default package)
                        package_name = "default"
                        if package_name not in packages:
                            packages[package_name] = Package(
                                name=package_name
                            )
                    
                    import_map = {}
                    for imp in tree.imports:
                        class_name = imp.path.split('.')[-1]
                        import_map[class_name] = imp.path

                    for _, class_declaration in tree.filter(
                        javalang.tree.ClassDeclaration
                    ):
                        class_name = class_declaration.name
                        class_key = f"{package_name}.{class_name}"
                        
                        # Debug: Check if this is the User class
                        if "User" in class_name:
                            logger.debug(f"Found User class - {class_key}")
                            logger.debug(f"Methods count: {len(class_declaration.methods)}")
                            logger.debug(f"Constructors count: {len(class_declaration.constructors)}")
                        
                        # Extract class source code - use the entire file content
                        class_source = file_content


                        if class_key not in classes:
                            # Parse class annotations
                            class_annotations = parse_annotations(class_declaration.annotations, "class") if hasattr(class_declaration, 'annotations') else []
                            
                            classes[class_key] = Class(
                                name=class_name,
                                logical_name=class_key,  # Add logical_name
                                file_path=file_path,
                                type="class", # Simplified for now
                                source=class_source, # Add class source
                                annotations=class_annotations,
                                package_name=package_name
                            )
                            class_to_package_map[class_key] = package_name
                        
                        # --- Start of new import logic ---
                        for imp in tree.imports:
                            classes[class_key].imports.append(imp.path)
                        # --- End of new import logic ---

                        # --- Start of new inheritance logic ---
                        # Handle 'extends'
                        if class_declaration.extends:
                            superclass_name = class_declaration.extends.name
                            # Try to resolve fully qualified name for superclass
                            if superclass_name in import_map:
                                classes[class_key].superclass = import_map[superclass_name]
                            else:
                                # Assume same package or fully qualified if not in import_map
                                classes[class_key].superclass = f"{package_name}.{superclass_name}" if package_name else superclass_name

                        # Handle 'implements'
                        if class_declaration.implements: # Add this check
                            for impl_ref in class_declaration.implements:
                                interface_name = impl_ref.name
                                # Try to resolve fully qualified name for interface
                                if interface_name in import_map:
                                    classes[class_key].interfaces.append(import_map[interface_name])
                                else:
                                    # Assume same package or fully qualified if not in import_map
                                    classes[class_key].interfaces.append(f"{package_name}.{interface_name}" if package_name else interface_name)
                        # --- End of new inheritance logic ---

                        field_map = {}
                        for field_declaration in class_declaration.fields:
                            for declarator in field_declaration.declarators:
                                field_map[declarator.name] = field_declaration.type.name
                                
                                # Parse field annotations
                                field_annotations = parse_annotations(field_declaration.annotations, "field") if hasattr(field_declaration, 'annotations') else []
                                
                                # Extract initial value if present
                                initial_value = ""
                                if hasattr(declarator, 'initializer') and declarator.initializer:
                                    # Convert the initializer to string representation
                                    if hasattr(declarator.initializer, 'value'):
                                        initial_value = str(declarator.initializer.value)
                                    elif hasattr(declarator.initializer, 'type'):
                                        initial_value = str(declarator.initializer.type)
                                    else:
                                        initial_value = str(declarator.initializer)
                                
                                prop = Property(
                                    name=declarator.name,
                                    logical_name=f"{package_name}.{class_name}.{declarator.name}",
                                    type=field_declaration.type.name,
                                    modifiers=list(field_declaration.modifiers), # Add modifiers
                                    package_name=package_name,
                                    class_name=class_name,
                                    annotations=field_annotations,
                                    initial_value=initial_value
                                )
                                classes[class_key].properties.append(prop)

                        all_declarations = class_declaration.methods + class_declaration.constructors
                        
                        # Debug: Check User class method processing
                        if "User" in class_name:
                            logger.debug(f"Processing User class methods - total declarations: {len(all_declarations)}")
                            for i, decl in enumerate(all_declarations):
                                logger.debug(f"Declaration {i}: {type(decl).__name__} - {decl.name}")
                        
                        for declaration in all_declarations:
                            local_var_map = field_map.copy()
                            params = []
                            for param in declaration.parameters:
                                param_type_name = 'Unknown'
                                if hasattr(param.type, 'name'):
                                    param_type_name = param.type.name
                                local_var_map[param.name] = param_type_name
                                params.append(Property(name=param.name, logical_name=f"{package_name}.{class_name}.{param.name}", type=param_type_name, package_name=package_name, class_name=class_name))

                            if declaration.body:
                                for _, var_decl in declaration.filter(javalang.tree.LocalVariableDeclaration):
                                    for declarator in var_decl.declarators:
                                        local_var_map[declarator.name] = var_decl.type.name
                            
                            if isinstance(declaration, javalang.tree.MethodDeclaration):
                                return_type = declaration.return_type.name if declaration.return_type else "void"
                            else: # ConstructorDeclaration
                                return_type = "constructor"

                            # Extract modifiers
                            modifiers = list(declaration.modifiers)
                            
                            # Parse method annotations
                            method_annotations = parse_annotations(declaration.annotations, "method") if hasattr(declaration, 'annotations') else []

                            # Extract method source code
                            method_source = ""
                            if declaration.position:
                                lines = file_content.splitlines(keepends=True) # Keep line endings
                                start_line = declaration.position.line - 1
                                
                                # Find the end of the method by matching braces
                                brace_count = 0
                                end_line = start_line
                                for i in range(start_line, len(lines)):
                                    line = lines[i]
                                    for char in line:
                                        if char == '{':
                                            brace_count += 1
                                        elif char == '}':
                                            brace_count -= 1
                                            if brace_count == 0:
                                                end_line = i
                                                break
                                    if brace_count == 0:
                                        break
                                
                                method_source = "".join(lines[start_line:end_line + 1])

                            method = Method(
                                name=declaration.name,
                                logical_name=f"{class_key}.{declaration.name}",  # Add logical_name
                                return_type=return_type,
                                parameters=params,
                                modifiers=modifiers,
                                source=method_source, # Add method source
                                package_name=package_name,
                                annotations=method_annotations
                            )
                            classes[class_key].methods.append(method)

                            # Extract method calls with order information
                            call_order = 0
                            for _, invocation in declaration.filter(javalang.tree.MethodInvocation):
                                target_class_name = None
                                resolved_target_package = ""
                                resolved_target_class_name = ""
                                
                                if invocation.qualifier:
                                    # External method call
                                    if invocation.qualifier in local_var_map:
                                        target_class_name = local_var_map[invocation.qualifier]
                                    else:
                                        target_class_name = invocation.qualifier
                                    
                                    if target_class_name:
                                        if target_class_name == "System.out":
                                            resolved_target_package = "java.io"
                                            resolved_target_class_name = "PrintStream"
                                        else:
                                            if target_class_name in import_map:
                                                resolved_target_package = ".".join(import_map[target_class_name].split(".")[:-1])
                                            else:
                                                resolved_target_package = package_name
                                                resolved_target_class_name = target_class_name
                                else:
                                    # Same class method call
                                    resolved_target_package = package_name
                                    resolved_target_class_name = class_name

                                if resolved_target_class_name:
                                    # Get line number from invocation position
                                    line_number = invocation.position.line if invocation.position else 0

                                    call = MethodCall(
                                        source_package=package_name,
                                        source_class=class_name,
                                        source_method=declaration.name,
                                        target_package=resolved_target_package,
                                        target_class=resolved_target_class_name,
                                        target_method=invocation.member,
                                        call_order=call_order,
                                        line_number=line_number,
                                        return_type="void"  # Default return type, can be enhanced later
                                    )
                                    classes[class_key].calls.append(call)
                                    call_order += 1
                        
                        # Check for Lombok @Data annotation and generate methods
                        has_data_annotation = any(ann.name == "Data" for ann in classes[class_key].annotations)
                        if has_data_annotation:
                            logger.debug(f"Found @Data annotation on {class_name}, generating Lombok methods")
                            lombok_methods = generate_lombok_methods(classes[class_key].properties, class_name, package_name)
                            classes[class_key].methods.extend(lombok_methods)
                            logger.debug(f"Generated {len(lombok_methods)} Lombok methods for {class_name}")
                except javalang.parser.JavaSyntaxError as e:
                    print(f"Syntax error in {file_path}: {e}")
                    continue
                except Exception as e:
                    print(f"Error parsing {file_path}: {e}")
                    continue
    
    # Extract beans, analyze dependencies, extract endpoints, extract MyBatis mappers, extract JPA entities, extract config files, and extract test classes
    classes_list = list(classes.values())
    beans = extract_beans_from_classes(classes_list)
    dependencies = analyze_bean_dependencies(classes_list, beans)
    endpoints = extract_endpoints_from_classes(classes_list)
    mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
    jpa_entities = extract_jpa_entities_from_classes(classes_list)
    config_files = extract_config_files(directory)
    test_classes = extract_test_classes_from_classes(classes_list)
    
    # Also extract XML mappers
    xml_mappers = extract_mybatis_xml_mappers(directory)
    mybatis_mappers.extend(xml_mappers)
    
    # Extract SQL statements from MyBatis mappers
    sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
    
    return list(packages.values()), classes_list, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name
```

이제 java_parser.py 파일에서 Property를 Field로 변경하겠습니다.


```python
import os
import yaml
import re
from pathlib import Path

import javalang

from src.models.graph_entities import Class, Method, MethodCall, Field, Package, Annotation, Bean, BeanDependency, Endpoint, MyBatisMapper, MyBatisSqlStatement, MyBatisResultMap, SqlStatement, JpaEntity, JpaColumn, JpaRelationship, ConfigFile, DatabaseConfig, ServerConfig, SecurityConfig, LoggingConfig, TestClass, TestMethod, TestConfiguration
from src.utils.logger import get_logger
from typing import Optional, List, Literal


def extract_project_name(java_source_folder: str) -> str:
    """
    JAVA_SOURCE_FOLDER 경로에서 프로젝트 이름을 추출합니다.
    
    Args:
        java_source_folder: Java 소스 폴더 경로
        
    Returns:
        프로젝트 이름 (마지막 디렉토리명)
    """
    # 경로를 정규화하고 마지막 디렉토리명 추출
    path = Path(java_source_folder).resolve()
    return path.name


def extract_sql_statements_from_mappers(mybatis_mappers: list[MyBatisMapper], project_name: str) -> list[SqlStatement]:
    """
    MyBatis mappers에서 SQL statements를 추출합니다.
    
    Args:
        mybatis_mappers: MyBatis mapper 객체들의 리스트
        project_name: 프로젝트 이름
        
    Returns:
        SqlStatement 객체들의 리스트
    """
    sql_statements = []
    
    for mapper in mybatis_mappers:
        for sql_dict in mapper.sql_statements:
            # MyBatisSqlStatement를 SqlStatement로 변환
            sql_statement = SqlStatement(
                id=sql_dict.get('id', ''),
                sql_type=sql_dict.get('sql_type', ''),
                sql_content=sql_dict.get('sql_content', ''),
                parameter_type=sql_dict.get('parameter_type', ''),
                result_type=sql_dict.get('result_type', ''),
                result_map=sql_dict.get('result_map', ''),
                mapper_name=mapper.name,
                annotations=[],  # TODO: annotations를 파싱하여 추가
                project_name=project_name
            )
            sql_statements.append(sql_statement)
    
    return sql_statements


def parse_annotations(annotations, target_type: str = "class") -> list[Annotation]:
    """Parse Java annotations into Annotation objects.
    
    Args:
        annotations: List of annotation nodes from javalang
        target_type: Type of target ("class", "method", "field")
    """
    result = []
    for annotation in annotations:
        annotation_name = annotation.name
        parameters = {}
        
        # Parse annotation parameters if they exist
        if hasattr(annotation, 'element') and annotation.element:
            for element in annotation.element:
                if hasattr(element, 'name') and hasattr(element, 'value'):
                    parameters[element.name] = element.value.value if hasattr(element.value, 'value') else str(element.value)
        
        result.append(Annotation(
            name=annotation_name,
            parameters=parameters,
            target_type=target_type,
            category=classify_springboot_annotation(annotation_name)
        ))
    
    return result


def classify_springboot_annotation(annotation_name: str) -> str:
    """Classify SpringBoot annotations into categories.
    
    Args:
        annotation_name: Name of the annotation (e.g., "@Component", "@Service")
        
    Returns:
        Category of the annotation
    """
    # Component annotations
    component_annotations = {
        "Component", "Service", "Repository", "Controller", 
        "RestController", "Configuration", "Bean"
    }
    
    # Injection annotations
    injection_annotations = {
        "Autowired", "Resource", "Value", "Qualifier", "Primary"
    }
    
    # Web annotations
    web_annotations = {
        "RequestMapping", "GetMapping", "PostMapping", "PutMapping", 
        "DeleteMapping", "PatchMapping", "RequestParam", "PathVariable",
        "RequestBody", "ResponseBody", "ResponseStatus"
    }
    
    # JPA annotations
    jpa_annotations = {
        "Entity", "Table", "Id", "Column", "OneToMany", "ManyToOne",
        "OneToOne", "ManyToMany", "JoinColumn", "GeneratedValue"
    }
    
    # Test annotations
    test_annotations = {
        "Test", "SpringBootTest", "DataJpaTest", "WebMvcTest",
        "MockBean", "SpyBean", "TestPropertySource"
    }
    
    # Security annotations
    security_annotations = {
        "PreAuthorize", "PostAuthorize", "Secured", "RolesAllowed",
        "EnableWebSecurity", "EnableGlobalMethodSecurity"
    }
    
    # Validation annotations
    validation_annotations = {
        "Valid", "NotNull", "NotBlank", "NotEmpty", "Size", "Min", "Max",
        "Pattern", "Email", "AssertTrue", "AssertFalse"
    }
    
    # MyBatis annotations
    mybatis_annotations = {
        "Mapper", "Select", "Insert", "Update", "Delete", "SelectProvider",
        "InsertProvider", "UpdateProvider", "DeleteProvider", "Results",
        "Result", "One", "Many", "MapKey", "Options", "SelectKey"
    }
    
    if annotation_name in component_annotations:
        return "component"
    elif annotation_name in injection_annotations:
        return "injection"
    elif annotation_name in web_annotations:
        return "web"
    elif annotation_name in jpa_annotations:
        return "jpa"
    elif annotation_name in test_annotations:
        return "test"
    elif annotation_name in security_annotations:
        return "security"
    elif annotation_name in validation_annotations:
        return "validation"
    elif annotation_name in mybatis_annotations:
        return "mybatis"
    else:
        return "other"


def classify_test_annotation(annotation_name: str) -> str:
    """Classify test annotations into categories.
    
    Args:
        annotation_name: Name of the annotation
        
    Returns:
        Category of the test annotation
    """
    # JUnit annotations
    junit_annotations = {
        "Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll",
        "DisplayName", "ParameterizedTest", "ValueSource", "CsvSource",
        "MethodSource", "Timeout", "Disabled", "Nested", "RepeatedTest",
        "Order", "TestMethodOrder", "TestInstance", "TestClassOrder"
    }
    
    # Spring Boot Test annotations
    spring_test_annotations = {
        "SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest",
        "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest",
        "MockBean", "SpyBean", "TestConfiguration", "ActiveProfiles",
        "TestPropertySource", "DirtiesContext", "Transactional",
        "Rollback", "Commit", "Sql", "SqlGroup", "AutoConfigureTestDatabase",
        "AutoConfigureMockMvc", "AutoConfigureWebMvc", "AutoConfigureWebClient",
        "MockMvc", "TestEntityManager", "TestContainers", "DynamicPropertySource"
    }
    
    # TestNG annotations
    testng_annotations = {
        "TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass",
        "BeforeSuite", "AfterSuite", "BeforeGroups", "AfterGroups",
        "DataProvider", "Parameters", "Groups", "Priority", "DependsOnMethods",
        "DependsOnGroups", "ExpectedExceptions", "InvocationCount",
        "SuccessPercentage", "TimeOut"
    }
    
    # Mockito annotations
    mockito_annotations = {
        "Mock", "Spy", "InjectMocks", "Captor", "MockedStatic"
    }
    
    # AssertJ annotations
    assertj_annotations = {
        "AssertJ"
    }
    
    # Other test annotations
    other_test_annotations = {
        "Ignore", "Category", "RunWith", "ExtendWith", "ContextConfiguration"
    }
    
    if annotation_name in junit_annotations:
        return "junit"
    elif annotation_name in spring_test_annotations:
        return "spring_test"
    elif annotation_name in testng_annotations:
        return "testng"
    elif annotation_name in mockito_annotations:
        return "mockito"
    elif annotation_name in assertj_annotations:
        return "assertj"
    elif annotation_name in other_test_annotations:
        return "other_test"
    else:
        return "other"


def extract_beans_from_classes(classes: list[Class]) -> list[Bean]:
    """Extract Spring Beans from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Bean objects
    """
    beans = []
    
    for cls in classes:
        # Check if class has Spring component annotations
        component_annotations = [ann for ann in cls.annotations if ann.category == "component"]
        
        # Also check for @Repository on interfaces
        has_repository_annotation = any(ann.name == "Repository" for ann in cls.annotations)
        
        if component_annotations or has_repository_annotation:
            # Determine bean type based on annotations
            bean_type = "component"  # default
            if any(ann.name in ["Service", "Service"] for ann in cls.annotations):
                bean_type = "service"
            elif any(ann.name in ["Repository", "Repository"] for ann in cls.annotations):
                bean_type = "repository"
            elif any(ann.name in ["Controller", "RestController"] for ann in cls.annotations):
                bean_type = "controller"
            elif any(ann.name in ["Configuration", "Configuration"] for ann in cls.annotations):
                bean_type = "configuration"
            
            # Determine scope (default is singleton)
            scope = "singleton"
            for ann in cls.annotations:
                if ann.name == "Scope":
                    if "value" in ann.parameters:
                        scope = ann.parameters["value"]
                    elif "prototype" in str(ann.parameters):
                        scope = "prototype"
                    elif "request" in str(ann.parameters):
                        scope = "request"
                    elif "session" in str(ann.parameters):
                        scope = "session"
            
            # Create bean name (use class name with first letter lowercase)
            bean_name = cls.name[0].lower() + cls.name[1:] if cls.name else cls.name
            
            # Check for @Bean methods in configuration classes
            bean_methods = []
            if bean_type == "configuration":
                for method in cls.methods:
                    if any(ann.name == "Bean" for ann in method.annotations):
                        bean_methods.append(method)
            
            bean = Bean(
                name=bean_name,
                type=bean_type,
                scope=scope,
                class_name=cls.name,
                package_name=cls.package_name,
                annotation_names=[ann.name for ann in cls.annotations] if cls.annotations else [],
                method_count=len(bean_methods) if bean_type == "configuration" else len(cls.methods) if cls.methods else 0,
                property_count=len(cls.properties) if cls.properties else 0
            )
            beans.append(bean)
    
    return beans


def analyze_bean_dependencies(classes: list[Class], beans: list[Bean]) -> list[BeanDependency]:
    """Analyze dependencies between Spring Beans.
    
    Args:
        classes: List of parsed Class objects
        beans: List of Bean objects
        
    Returns:
        List of BeanDependency objects
    """
    dependencies = []
    
    # Create a mapping from class names to bean names
    class_to_bean = {}
    for bean in beans:
        class_to_bean[bean.class_name] = bean.name
    
    for cls in classes:
        # Check if this class is a bean
        if cls.name not in class_to_bean:
            continue
            
        source_bean = class_to_bean[cls.name]
        
        # Analyze field injections (@Autowired, @Resource, @Value)
        for prop in cls.properties:
            if any(ann.category == "injection" for ann in prop.annotations):
                # Try to determine target bean from field type
                target_bean = None
                field_type = prop.type
                
                # Look for exact class name match
                if field_type in class_to_bean:
                    target_bean = class_to_bean[field_type]
                else:
                    # Look for interface implementations (simplified - just check if type matches any bean class name)
                    for bean in beans:
                        if field_type == bean.class_name:
                            target_bean = bean.name
                            break
                
                if target_bean:
                    injection_type = "field"
                    for ann in prop.annotations:
                        if ann.name == "Autowired":
                            injection_type = "field"
                        elif ann.name == "Resource":
                            injection_type = "field"
                        elif ann.name == "Value":
                            injection_type = "field"
                    
                    dependency = BeanDependency(
                        source_bean=source_bean,
                        target_bean=target_bean,
                        injection_type=injection_type,
                        field_name=prop.name
                    )
                    dependencies.append(dependency)
        
        # Analyze constructor injections
        for method in cls.methods:
            if method.name == cls.name:  # Constructor
                for param in method.parameters:
                    if any(ann.category == "injection" for ann in param.annotations):
                        target_bean = None
                        param_type = param.type
                        
                        if param_type in class_to_bean:
                            target_bean = class_to_bean[param_type]
                        else:
                            # Look for interface implementations (simplified)
                            for bean in beans:
                                if param_type == bean.class_name:
                                    target_bean = bean.name
                                    break
                        
                        if target_bean:
                            dependency = BeanDependency(
                                source_bean=source_bean,
                                target_bean=target_bean,
                                injection_type="constructor",
                                parameter_name=param.name
                            )
                            dependencies.append(dependency)
        
        # Analyze setter injections
        for method in cls.methods:
            if method.name.startswith("set") and len(method.parameters) == 1:
                if any(ann.category == "injection" for ann in method.annotations):
                    param = method.parameters[0]
                    target_bean = None
                    param_type = param.type
                    
                    if param_type in class_to_bean:
                        target_bean = class_to_bean[param_type]
                    else:
                        # Look for interface implementations (simplified)
                        for bean in beans:
                            if param_type == bean.class_name:
                                target_bean = bean.name
                                break
                    
                    if target_bean:
                        dependency = BeanDependency(
                            source_bean=source_bean,
                            target_bean=target_bean,
                            injection_type="setter",
                            method_name=method.name,
                            parameter_name=param.name
                        )
                        dependencies.append(dependency)
    
    return dependencies


def extract_endpoints_from_classes(classes: list[Class]) -> list[Endpoint]:
    """Extract REST API endpoints from controller classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Endpoint objects
    """
    endpoints = []
    
    for cls in classes:
        # Check if class is a controller
        is_controller = any(ann.name in ["Controller", "RestController"] for ann in cls.annotations)
        
        if not is_controller:
            continue
            
        # Get class-level path mapping
        class_path = ""
        for ann in cls.annotations:
            if ann.name == "RequestMapping":
                if "value" in ann.parameters:
                    class_path = ann.parameters["value"]
                break
        
        # Process each method in the controller
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
                
            # Check if method has web mapping annotations
            web_annotations = [ann for ann in method.annotations if ann.category == "web"]
            
            if not web_annotations:
                continue
            
            # Extract endpoint information
            endpoint_path = ""
            http_method = "GET"  # default
            
            for ann in web_annotations:
                if ann.name in ["RequestMapping", "GetMapping", "PostMapping", "PutMapping", "DeleteMapping", "PatchMapping"]:
                    # Extract path
                    if "value" in ann.parameters:
                        endpoint_path = ann.parameters["value"]
                    elif "path" in ann.parameters:
                        endpoint_path = ann.parameters["path"]
                    
                    # Extract HTTP method
                    if ann.name == "GetMapping":
                        http_method = "GET"
                    elif ann.name == "PostMapping":
                        http_method = "POST"
                    elif ann.name == "PutMapping":
                        http_method = "PUT"
                    elif ann.name == "DeleteMapping":
                        http_method = "DELETE"
                    elif ann.name == "PatchMapping":
                        http_method = "PATCH"
                    elif ann.name == "RequestMapping":
                        if "method" in ann.parameters:
                            method_value = ann.parameters["method"]
                            if isinstance(method_value, list) and len(method_value) > 0:
                                http_method = method_value[0]
                            else:
                                http_method = str(method_value)
                        else:
                            http_method = "GET"  # default for RequestMapping
                    break
            
            # Build full path
            full_path = class_path
            if endpoint_path:
                if full_path and not full_path.endswith("/") and not endpoint_path.startswith("/"):
                    full_path += "/"
                full_path += endpoint_path
            elif not full_path:
                full_path = "/"
            
            # Extract method parameters
            parameters = []
            for param in method.parameters:
                param_info = {
                    "name": param.name,
                    "type": param.type,
                    "annotations": [ann.name for ann in param.annotations if ann.category == "web"]
                }
                parameters.append(param_info)
            
            # Extract return type
            return_type = method.return_type if method.return_type != "constructor" else "void"
            
            # Create endpoint
            endpoint = Endpoint(
                path=endpoint_path or "/",
                method=http_method,
                controller_class=cls.name,
                handler_method=method.name,
                parameters=parameters,
                return_type=return_type,
                annotations=[ann.name for ann in web_annotations],
                full_path=full_path
            )
            endpoints.append(endpoint)
    
    return endpoints


def extract_mybatis_mappers_from_classes(classes: list[Class]) -> list[MyBatisMapper]:
    """Extract MyBatis Mappers from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for cls in classes:
        # Check if class is a MyBatis Mapper interface
        is_mapper = any(ann.name == "Mapper" for ann in cls.annotations)
        
        if not is_mapper:
            continue
        
        # Extract mapper methods with MyBatis annotations
        mapper_methods = []
        sql_statements = []
        
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
            
            # Check if method has MyBatis annotations
            mybatis_annotations = [ann for ann in method.annotations if ann.category == "mybatis"]
            
            if not mybatis_annotations:
                continue
            
            # Extract SQL statement information
            sql_type = "SELECT"  # default
            sql_content = ""
            parameter_type = ""
            result_type = ""
            result_map = ""
            
            for ann in mybatis_annotations:
                if ann.name in ["Select", "SelectProvider"]:
                    sql_type = "SELECT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Insert", "InsertProvider"]:
                    sql_type = "INSERT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Update", "UpdateProvider"]:
                    sql_type = "UPDATE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Delete", "DeleteProvider"]:
                    sql_type = "DELETE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                
                # Extract parameter and result type information
                if "parameterType" in ann.parameters:
                    parameter_type = ann.parameters["parameterType"]
                if "resultType" in ann.parameters:
                    result_type = ann.parameters["resultType"]
                if "resultMap" in ann.parameters:
                    result_map = ann.parameters["resultMap"]
            
            # Create method info
            method_info = {
                "name": method.name,
                "return_type": method.return_type,
                "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            mapper_methods.append(method_info)
            
            # Create SQL statement info
            sql_statement = {
                "id": method.name,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            sql_statements.append(sql_statement)
        
        # Create mapper
        mapper = MyBatisMapper(
            name=cls.name,
            type="interface",
            namespace=f"{cls.package_name}.{cls.name}",
            methods=mapper_methods,
            sql_statements=sql_statements,
            file_path=cls.file_path,
            package_name=cls.package_name
        )
        mappers.append(mapper)
    
    return mappers


def parse_mybatis_xml_file(file_path: str) -> MyBatisMapper:
    """Parse MyBatis XML mapper file.
    
    Args:
        file_path: Path to the XML mapper file
        
    Returns:
        MyBatisMapper object
    """
    import xml.etree.ElementTree as ET
    
    try:
        tree = ET.parse(file_path)
        root = tree.getroot()
        
        # Extract namespace
        namespace = root.get("namespace", "")
        
        # Extract SQL statements
        sql_statements = []
        for statement in root.findall(".//*[@id]"):
            statement_id = statement.get("id")
            tag_name = statement.tag.lower()
            
            # Determine SQL type
            sql_type = "SELECT"
            if tag_name == "insert":
                sql_type = "INSERT"
            elif tag_name == "update":
                sql_type = "UPDATE"
            elif tag_name == "delete":
                sql_type = "DELETE"
            
            # Extract SQL content
            sql_content = statement.text.strip() if statement.text else ""
            
            # Extract parameter and result information
            parameter_type = statement.get("parameterType", "")
            result_type = statement.get("resultType", "")
            result_map = statement.get("resultMap", "")
            
            sql_statement = {
                "id": statement_id,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": []
            }
            sql_statements.append(sql_statement)
        
        # Extract ResultMaps
        result_maps = []
        for result_map in root.findall(".//resultMap"):
            result_map_id = result_map.get("id")
            result_map_type = result_map.get("type", "")
            
            properties = []
            for property_elem in result_map.findall(".//result"):
                prop = {
                    "property": property_elem.get("property", ""),
                    "column": property_elem.get("column", ""),
                    "jdbc_type": property_elem.get("jdbcType", "")
                }
                properties.append(prop)
            
            result_map_info = {
                "id": result_map_id,
                "type": result_map_type,
                "properties": properties,
                "associations": [],
                "collections": []
            }
            result_maps.append(result_map_info)
        
        # Create mapper
        mapper_name = namespace.split(".")[-1] if namespace else os.path.basename(file_path).replace(".xml", "")
        package_name = ".".join(namespace.split(".")[:-1]) if namespace else ""
        
        mapper = MyBatisMapper(
            name=mapper_name,
            type="xml",
            namespace=namespace,
            methods=[],  # XML mappers don't have Java methods
            sql_statements=sql_statements,
            file_path=file_path,
            package_name=package_name
        )
        
        return mapper
        
    except ET.ParseError as e:
        print(f"Error parsing XML file {file_path}: {e}")
        return None
    except Exception as e:
        print(f"Error reading XML file {file_path}: {e}")
        return None


def extract_mybatis_xml_mappers(directory: str) -> list[MyBatisMapper]:
    """Extract MyBatis XML mappers from directory.
    
    Args:
        directory: Directory to search for XML mapper files
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith("Mapper.xml") or file.endswith("Dao.xml"):
                file_path = os.path.join(root, file)
                mapper = parse_mybatis_xml_file(file_path)
                if mapper:
                    mappers.append(mapper)
    
    return mappers


def extract_jpa_entities_from_classes(classes: list[Class]) -> list[JpaEntity]:
    """Extract JPA Entities from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of JpaEntity objects
    """
    entities = []
    
    for cls in classes:
        # Check if class is a JPA Entity
        is_entity = any(ann.name == "Entity" for ann in cls.annotations)
        
        if not is_entity:
            continue
        
        # Extract table name
        table_name = cls.name.lower()  # default table name
        for ann in cls.annotations:
            if ann.name == "Table":
                if "name" in ann.parameters:
                    table_name = ann.parameters["name"]
                break
        
        # Extract columns from properties
        columns = []
        relationships = []
        
        for prop in cls.properties:
            # Check if property has JPA column annotations
            jpa_annotations = [ann for ann in prop.annotations if ann.category == "jpa"]
            
            if jpa_annotations:
                # Extract column information
                column_name = prop.name  # default column name
                nullable = True
                unique = False
                length = 0
                precision = 0
                scale = 0
                
                for ann in jpa_annotations:
                    if ann.name == "Column":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                        if "nullable" in ann.parameters:
                            nullable = ann.parameters["nullable"]
                        if "unique" in ann.parameters:
                            unique = ann.parameters["unique"]
                        if "length" in ann.parameters:
                            length = ann.parameters["length"]
                        if "precision" in ann.parameters:
                            precision = ann.parameters["precision"]
                        if "scale" in ann.parameters:
                            scale = ann.parameters["scale"]
                    elif ann.name == "Id":
                        column_name = "id"  # Primary key column
                        nullable = False
                        unique = True
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                
                # Check for relationship annotations
                relationship_type = None
                target_entity = ""
                mapped_by = ""
                join_column = ""
                join_table = ""
                cascade = []
                fetch = "LAZY"
                
                for ann in jpa_annotations:
                    if ann.name in ["OneToOne", "OneToMany", "ManyToOne", "ManyToMany"]:
                        relationship_type = ann.name
                        if "targetEntity" in ann.parameters:
                            target_entity = ann.parameters["targetEntity"]
                        if "mappedBy" in ann.parameters:
                            mapped_by = ann.parameters["mappedBy"]
                        if "cascade" in ann.parameters:
                            cascade = ann.parameters["cascade"] if isinstance(ann.parameters["cascade"], list) else [ann.parameters["cascade"]]
                        if "fetch" in ann.parameters:
                            fetch = ann.parameters["fetch"]
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            join_column = ann.parameters["name"]
                    elif ann.name == "JoinTable":
                        if "name" in ann.parameters:
                            join_table = ann.parameters["name"]
                
                # Create column info
                column_info = {
                    "property_name": prop.name,
                    "column_name": column_name,
                    "data_type": prop.type,
                    "nullable": nullable,
                    "unique": unique,
                    "length": length,
                    "precision": precision,
                    "scale": scale,
                    "annotations": [ann.name for ann in jpa_annotations]
                }
                columns.append(column_info)
                
                # Create relationship info if it's a relationship
                if relationship_type:
                    relationship_info = {
                        "type": relationship_type,
                        "target_entity": target_entity,
                        "mapped_by": mapped_by,
                        "join_column": join_column,
                        "join_table": join_table,
                        "cascade": cascade,
                        "fetch": fetch,
                        "annotations": [ann.name for ann in jpa_annotations]
                    }
                    relationships.append(relationship_info)
        
        # Create entity
        entity = JpaEntity(
            name=cls.name,
            table_name=table_name,
            columns=columns,
            relationships=relationships,
            annotations=[ann.name for ann in cls.annotations if ann.category == "jpa"],
            package_name=cls.package_name,
            file_path=cls.file_path
        )
        entities.append(entity)
    
    return entities


def parse_yaml_config(file_path: str) -> ConfigFile:
    """Parse YAML configuration file.
    
    Args:
        file_path: Path to the YAML file
        
    Returns:
        ConfigFile object
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = yaml.safe_load(f)
        
        if not content:
            content = {}
        
        # Extract file info
        file_name = os.path.basename(file_path)
        file_type = "yaml" if file_path.endswith('.yaml') else "yml"
        
        # Extract profiles
        profiles = []
        if 'spring' in content and 'profiles' in content['spring']:
            if 'active' in content['spring']['profiles']:
                profiles = content['spring']['profiles']['active']
                if isinstance(profiles, str):
                    profiles = [profiles]
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        # Extract sections
        sections = []
        for key, value in content.items():
            if isinstance(value, dict):
                sections.append({
                    "name": key,
                    "properties": value,
                    "type": "section"
                })
        
        return ConfigFile(
            name=file_name,
            file_path=file_path,
            file_type=file_type,
            properties=content,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing YAML file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="yaml",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def parse_properties_config(file_path: str) -> ConfigFile:
    """Parse Properties configuration file.
    
    Args:
        file_path: Path to the properties file
        
    Returns:
        ConfigFile object
    """
    try:
        properties = {}
        sections = []
        profiles = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                
                # Skip empty lines and comments
                if not line or line.startswith('#'):
                    continue
                
                # Parse key=value pairs
                if '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    
                    # Remove quotes if present
                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]
                    elif value.startswith("'") and value.endswith("'"):
                        value = value[1:-1]
                    
                    properties[key] = value
                    
                    # Check for profiles
                    if key == 'spring.profiles.active':
                        profiles = [p.strip() for p in value.split(',')]
        
        # Group properties by section
        section_map = {}
        for key, value in properties.items():
            if '.' in key:
                section = key.split('.')[0]
                if section not in section_map:
                    section_map[section] = {}
                section_map[section][key] = value
            else:
                if 'root' not in section_map:
                    section_map['root'] = {}
                section_map['root'][key] = value
        
        for section_name, section_props in section_map.items():
            sections.append({
                "name": section_name,
                "properties": section_props,
                "type": "section"
            })
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties=properties,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing Properties file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def extract_database_config(config_file: ConfigFile) -> DatabaseConfig:
    """Extract database configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        DatabaseConfig object
    """
    db_config = DatabaseConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        spring_config = config_file.properties.get('spring', {})
        datasource_config = spring_config.get('datasource', {})
        jpa_config = spring_config.get('jpa', {})
        
        db_config.driver = datasource_config.get('driver-class-name', '')
        db_config.url = datasource_config.get('url', '')
        db_config.username = datasource_config.get('username', '')
        db_config.password = datasource_config.get('password', '')
        db_config.dialect = jpa_config.get('database-platform', '')
        db_config.hibernate_ddl_auto = jpa_config.get('hibernate', {}).get('ddl-auto', '')
        db_config.show_sql = jpa_config.get('show-sql', False)
        db_config.format_sql = jpa_config.get('properties', {}).get('hibernate', {}).get('format_sql', False)
        
        # Store additional JPA properties
        if 'properties' in jpa_config:
            db_config.jpa_properties = jpa_config['properties']
    
    else:
        # Properties format
        props = config_file.properties
        
        db_config.driver = props.get('spring.datasource.driver-class-name', '')
        db_config.url = props.get('spring.datasource.url', '')
        db_config.username = props.get('spring.datasource.username', '')
        db_config.password = props.get('spring.datasource.password', '')
        db_config.dialect = props.get('spring.jpa.database-platform', '')
        db_config.hibernate_ddl_auto = props.get('spring.jpa.hibernate.ddl-auto', '')
        db_config.show_sql = props.get('spring.jpa.show-sql', 'false').lower() == 'true'
        db_config.format_sql = props.get('spring.jpa.properties.hibernate.format_sql', 'false').lower() == 'true'
        
        # Store additional JPA properties
        jpa_props = {}
        for key, value in props.items():
            if key.startswith('spring.jpa.properties.'):
                jpa_props[key] = value
        db_config.jpa_properties = jpa_props
    
    return db_config


def extract_server_config(config_file: ConfigFile) -> ServerConfig:
    """Extract server configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        ServerConfig object
    """
    server_config = ServerConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        server_props = config_file.properties.get('server', {})
        
        server_config.port = server_props.get('port', 8080)
        server_config.context_path = server_props.get('servlet', {}).get('context-path', '')
        server_config.servlet_path = server_props.get('servlet', {}).get('path', '')
        
        # SSL configuration
        ssl_config = server_props.get('ssl', {})
        server_config.ssl_enabled = bool(ssl_config)
        server_config.ssl_key_store = ssl_config.get('key-store', '')
        server_config.ssl_key_store_password = ssl_config.get('key-store-password', '')
        server_config.ssl_key_store_type = ssl_config.get('key-store-type', '')
    
    else:
        # Properties format
        props = config_file.properties
        
        server_config.port = int(props.get('server.port', '8080'))
        server_config.context_path = props.get('server.servlet.context-path', '')
        server_config.servlet_path = props.get('server.servlet.path', '')
        
        # SSL configuration
        server_config.ssl_enabled = any(key.startswith('server.ssl.') for key in props.keys())
        server_config.ssl_key_store = props.get('server.ssl.key-store', '')
        server_config.ssl_key_store_password = props.get('server.ssl.key-store-password', '')
        server_config.ssl_key_store_type = props.get('server.ssl.key-store-type', '')
    
    return server_config


def extract_security_config(config_file: ConfigFile) -> SecurityConfig:
    """Extract security configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        SecurityConfig object
    """
    security_config = SecurityConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        security_props = config_file.properties.get('security', {})
        jwt_props = security_props.get('jwt', {})
        cors_props = security_props.get('cors', {})
        
        security_config.enabled = bool(security_props)
        security_config.authentication_type = security_props.get('authentication-type', '')
        security_config.jwt_secret = jwt_props.get('secret', '')
        security_config.jwt_expiration = jwt_props.get('expiration', 0)
        security_config.cors_allowed_origins = cors_props.get('allowed-origins', [])
        security_config.cors_allowed_methods = cors_props.get('allowed-methods', [])
        security_config.cors_allowed_headers = cors_props.get('allowed-headers', [])
    
    else:
        # Properties format
        props = config_file.properties
        
        security_config.enabled = any(key.startswith('security.') for key in props.keys())
        security_config.authentication_type = props.get('security.authentication-type', '')
        security_config.jwt_secret = props.get('security.jwt.secret', '')
        security_config.jwt_expiration = int(props.get('security.jwt.expiration', '0'))
        
        # CORS configuration
        origins = props.get('security.cors.allowed-origins', '')
        if origins:
            security_config.cors_allowed_origins = [o.strip() for o in origins.split(',')]
        
        methods = props.get('security.cors.allowed-methods', '')
        if methods:
            security_config.cors_allowed_methods = [m.strip() for m in methods.split(',')]
        
        headers = props.get('security.cors.allowed-headers', '')
        if headers:
            security_config.cors_allowed_headers = [h.strip() for h in headers.split(',')]
    
    return security_config


def extract_logging_config(config_file: ConfigFile) -> LoggingConfig:
    """Extract logging configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        LoggingConfig object
    """
    logging_config = LoggingConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        logging_props = config_file.properties.get('logging', {})
        
        logging_config.level = logging_props.get('level', {}).get('root', 'INFO')
        logging_config.pattern = logging_props.get('pattern', {}).get('console', '')
        logging_config.file_path = logging_props.get('file', {}).get('name', '')
        logging_config.max_file_size = logging_props.get('file', {}).get('max-size', '')
        logging_config.max_history = logging_props.get('file', {}).get('max-history', 0)
        logging_config.console_output = logging_props.get('console', {}).get('enabled', True)
    
    else:
        # Properties format
        props = config_file.properties
        
        logging_config.level = props.get('logging.level.root', 'INFO')
        logging_config.pattern = props.get('logging.pattern.console', '')
        logging_config.file_path = props.get('logging.file.name', '')
        logging_config.max_file_size = props.get('logging.file.max-size', '')
        logging_config.max_history = int(props.get('logging.file.max-history', '0'))
        logging_config.console_output = props.get('logging.console.enabled', 'true').lower() == 'true'
    
    return logging_config


def extract_config_files(directory: str) -> list[ConfigFile]:
    """Extract configuration files from directory.
    
    Args:
        directory: Directory to search for config files
        
    Returns:
        List of ConfigFile objects
    """
    config_files = []
    
    # Common config file patterns
    config_patterns = [
        "application.yml",
        "application.yaml", 
        "application.properties",
        "application-*.properties",
        "bootstrap.yml",
        "bootstrap.yaml",
        "bootstrap.properties"
    ]
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            # Check if file matches any config pattern
            is_config_file = False
            for pattern in config_patterns:
                if pattern == file or (pattern.endswith('*') and file.startswith(pattern[:-1])):
                    is_config_file = True
                    break
            
            if is_config_file:
                file_path = os.path.join(root, file)
                
                if file.endswith(('.yml', '.yaml')):
                    config_file = parse_yaml_config(file_path)
                elif file.endswith('.properties'):
                    config_file = parse_properties_config(file_path)
                else:
                    continue
                
                config_files.append(config_file)
    
    return config_files


def extract_test_classes_from_classes(classes: list[Class]) -> list[TestClass]:
    """Extract test classes from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of TestClass objects
    """
    test_classes = []
    
    for cls in classes:
        # Check if class is a test class
        test_annotations = [ann for ann in cls.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
        
        if not test_annotations:
            continue
        
        # Determine test framework and type
        test_framework = "junit"  # default
        test_type = "unit"  # default
        
        for ann in test_annotations:
            if ann.name in ["SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest", "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest"]:
                test_framework = "spring_test"
                if ann.name == "SpringBootTest":
                    test_type = "integration"
                else:
                    test_type = "slice"
            elif ann.name in ["TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass"]:
                test_framework = "testng"
            elif ann.name in ["Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll"]:
                test_framework = "junit"
        
        # Extract test methods
        test_methods = []
        setup_methods = []
        
        for method in cls.methods:
            method_annotations = [ann.name for ann in method.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
            
            if method_annotations:
                # Check if it's a setup/teardown method
                if any(ann in method_annotations for ann in ["BeforeEach", "AfterEach", "BeforeAll", "AfterAll", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass", "BeforeSuite", "AfterSuite"]):
                    setup_methods.append({
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters]
                    })
                else:
                    # Regular test method
                    test_method_info = {
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                        "assertions": [],
                        "mock_calls": [],
                        "test_data": [],
                        "expected_exceptions": [],
                        "timeout": 0,
                        "display_name": ""
                    }
                    
                    # Extract display name
                    for ann in method.annotations:
                        if ann.name == "DisplayName" and "value" in ann.parameters:
                            test_method_info["display_name"] = ann.parameters["value"]
                        elif ann.name == "Timeout" and "value" in ann.parameters:
                            test_method_info["timeout"] = ann.parameters["value"]
                    
                    # Extract expected exceptions
                    for ann in method.annotations:
                        if ann.name == "ExpectedExceptions" and "value" in ann.parameters:
                            test_method_info["expected_exceptions"] = ann.parameters["value"] if isinstance(ann.parameters["value"], list) else [ann.parameters["value"]]
                    
                    test_methods.append(test_method_info)
        
        # Extract mock dependencies
        mock_dependencies = []
        for prop in cls.properties:
            prop_annotations = [ann.name for ann in prop.annotations if classify_test_annotation(ann.name) in ["mockito", "spring_test"]]
            if prop_annotations:
                mock_dependencies.append({
                    "name": prop.name,
                    "type": prop.type,
                    "annotations": prop_annotations,
                    "mock_type": "mock" if "Mock" in prop_annotations else "spy" if "Spy" in prop_annotations else "bean"
                })
        
        # Extract test configurations
        test_configurations = []
        for ann in cls.annotations:
            if ann.name in ["TestConfiguration", "ActiveProfiles", "TestPropertySource"]:
                config_info = {
                    "name": ann.name,
                    "type": "configuration" if ann.name == "TestConfiguration" else "profile" if ann.name == "ActiveProfiles" else "property",
                    "properties": ann.parameters,
                    "active_profiles": ann.parameters.get("value", []) if ann.name == "ActiveProfiles" else [],
                    "test_slices": [],
                    "mock_beans": [],
                    "spy_beans": []
                }
                test_configurations.append(config_info)
        
        # Create test class
        test_class = TestClass(
            name=cls.name,
            package_name=cls.package_name,
            test_framework=test_framework,
            test_type=test_type,
            annotations=[ann.name for ann in test_annotations],
            test_methods=test_methods,
            setup_methods=setup_methods,
            mock_dependencies=mock_dependencies,
            test_configurations=test_configurations,
            file_path=cls.file_path
        )
        test_classes.append(test_class)
    
    return test_classes


def analyze_test_methods(test_class: TestClass, class_obj: Class) -> list[TestMethod]:
    """Analyze test methods for assertions, mock calls, and test data.
    
    Args:
        test_class: TestClass object
        class_obj: Original Class object
        
    Returns:
        List of analyzed TestMethod objects
    """
    test_methods = []
    
    for method_info in test_class.test_methods:
        # Find the corresponding method in the class
        method_obj = None
        for method in class_obj.methods:
            if method.name == method_info["name"]:
                method_obj = method
                break
        
        if not method_obj:
            continue
        
        # Analyze method source code for assertions and mock calls
        assertions = []
        mock_calls = []
        test_data = []
        
        if method_obj.source:
            source_code = method_obj.source
            
            # Find assertions (JUnit, AssertJ, etc.)
            assertion_patterns = [
                r'assert\w+\(',  # JUnit assertions
                r'assertThat\(',  # AssertJ
                r'assertEquals\(',  # JUnit
                r'assertTrue\(',  # JUnit
                r'assertFalse\(',  # JUnit
                r'assertNotNull\(',  # JUnit
                r'assertNull\(',  # JUnit
                r'assertThrows\(',  # JUnit 5
                r'assertDoesNotThrow\(',  # JUnit 5
                r'verify\(',  # Mockito verify
                r'when\(',  # Mockito when
                r'then\(',  # Mockito then
                r'given\(',  # BDDMockito given
                r'willReturn\(',  # Mockito willReturn
                r'willThrow\(',  # Mockito willThrow
            ]
            
            for pattern in assertion_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    assertions.append({
                        "type": match,
                        "line": source_code.find(match) + 1
                    })
            
            # Find mock calls
            mock_call_patterns = [
                r'(\w+)\.(\w+)\(',  # Method calls on objects
                r'mock\(',  # Mockito mock creation
                r'spy\(',  # Mockito spy creation
                r'@Mock\s+(\w+)',  # @Mock annotation
                r'@Spy\s+(\w+)',  # @Spy annotation
                r'@InjectMocks\s+(\w+)',  # @InjectMocks annotation
            ]
            
            for pattern in mock_call_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        mock_calls.append({
                            "object": match[0],
                            "method": match[1],
                            "type": "method_call"
                        })
                    else:
                        mock_calls.append({
                            "type": match,
                            "line": source_code.find(match) + 1
                        })
            
            # Find test data setup
            test_data_patterns = [
                r'new\s+(\w+)\(',  # Object creation
                r'(\w+)\s*=\s*new\s+(\w+)\(',  # Variable assignment with new
                r'@ValueSource\(',  # JUnit 5 @ValueSource
                r'@CsvSource\(',  # JUnit 5 @CsvSource
                r'@MethodSource\(',  # JUnit 5 @MethodSource
            ]
            
            for pattern in test_data_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        test_data.append({
                            "variable": match[0],
                            "type": match[1],
                            "pattern": "object_creation"
                        })
                    else:
                        test_data.append({
                            "type": match,
                            "pattern": "annotation"
                        })
        
        # Create TestMethod object
        test_method = TestMethod(
            name=method_info["name"],
            return_type=method_info["return_type"],
            annotations=method_info["annotations"],
            assertions=assertions,
            mock_calls=mock_calls,
            test_data=test_data,
            expected_exceptions=method_info["expected_exceptions"],
            timeout=method_info["timeout"],
            display_name=method_info["display_name"]
        )
        test_methods.append(test_method)
    
    return test_methods


def generate_lombok_methods(properties: list[Field], class_name: str, package_name: str) -> list[Method]:
    """Generate Lombok @Data methods (getters, setters, equals, hashCode, toString) for properties."""
    methods = []
    
    # Generate getters and setters for each property
    for prop in properties:
        # Getter
        getter_name = f"get{prop.name[0].upper()}{prop.name[1:]}"
        if prop.type == "Boolean" and prop.name.startswith("is"):
            # For boolean fields starting with 'is', use the field name as getter
            getter_name = prop.name
        
        getter = Method(
            name=getter_name,
            logical_name=f"{package_name}.{class_name}.{getter_name}",
            return_type=prop.type,
            parameters=[],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[]
        )
        methods.append(getter)
        
        # Setter
        setter_name = f"set{prop.name[0].upper()}{prop.name[1:]}"
        setter_param = Property(
            name=prop.name,
            logical_name=f"{package_name}.{class_name}.{prop.name}",
            type=prop.type,
            package_name=package_name,
            class_name=class_name
        )
        
        setter = Method(
            name=setter_name,
            logical_name=f"{package_name}.{class_name}.{setter_name}",
            return_type="void",
            parameters=[setter_param],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[]
        )
        methods.append(setter)
    
    # Generate equals method
    equals_method = Method(
        name="equals",
        logical_name=f"{package_name}.{class_name}.equals",
        return_type="boolean",
        parameters=[Property(name="obj", logical_name=f"{package_name}.{class_name}.obj", type="Object", package_name=package_name, class_name=class_name)],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(equals_method)
    
    # Generate hashCode method
    hashcode_method = Method(
        name="hashCode",
        logical_name=f"{package_name}.{class_name}.hashCode",
        return_type="int",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(hashcode_method)
    
    # Generate toString method
    tostring_method = Method(
        name="toString",
        logical_name=f"{package_name}.{class_name}.toString",
        return_type="String",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(tostring_method)
    
    return methods


def parse_java_project(directory: str) -> tuple[list[Package], list[Class], dict[str, str], list[Bean], list[BeanDependency], list[Endpoint], list[MyBatisMapper], list[JpaEntity], list[ConfigFile], list[TestClass], list[SqlStatement], str]:
    """Parse Java project and return parsed entities."""
    logger = get_logger(__name__)
    """Parses all Java files in a directory and returns a tuple of (packages, classes, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name)."""
    
    # Extract project name from directory path
    project_name = extract_project_name(directory)
    packages = {}
    classes = {}
    class_to_package_map = {}  # Maps class_key to package_name

    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith(".java"):
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    file_content = f.read() # Read file content once
                try:
                    tree = javalang.parse.parse(file_content)
                    package_name = tree.package.name if tree.package else ""
                    
                    # Create or update package node
                    if package_name and package_name not in packages:
                        packages[package_name] = Package(
                            name=package_name
                        )
                    elif not package_name:
                        # Handle classes without package (default package)
                        package_name = "default"
                        if package_name not in packages:
                            packages[package_name] = Package(
                                name=package_name
                            )
                    
                    import_map = {}
                    for imp in tree.imports:
                        class_name = imp.path.split('.')[-1]
                        import_map[class_name] = imp.path

                    for _, class_declaration in tree.filter(
                        javalang.tree.ClassDeclaration
                    ):
                        class_name = class_declaration.name
                        class_key = f"{package_name}.{class_name}"
                        
                        # Debug: Check if this is the User class
                        if "User" in class_name:
                            logger.debug(f"Found User class - {class_key}")
                            logger.debug(f"Methods count: {len(class_declaration.methods)}")
                            logger.debug(f"Constructors count: {len(class_declaration.constructors)}")
                        
                        # Extract class source code - use the entire file content
                        class_source = file_content


                        if class_key not in classes:
                            # Parse class annotations
                            class_annotations = parse_annotations(class_declaration.annotations, "class") if hasattr(class_declaration, 'annotations') else []
                            
                            classes[class_key] = Class(
                                name=class_name,
                                logical_name=class_key,  # Add logical_name
                                file_path=file_path,
                                type="class", # Simplified for now
                                source=class_source, # Add class source
                                annotations=class_annotations,
                                package_name=package_name
                            )
                            class_to_package_map[class_key] = package_name
                        
                        # --- Start of new import logic ---
                        for imp in tree.imports:
                            classes[class_key].imports.append(imp.path)
                        # --- End of new import logic ---

                        # --- Start of new inheritance logic ---
                        # Handle 'extends'
                        if class_declaration.extends:
                            superclass_name = class_declaration.extends.name
                            # Try to resolve fully qualified name for superclass
                            if superclass_name in import_map:
                                classes[class_key].superclass = import_map[superclass_name]
                            else:
                                # Assume same package or fully qualified if not in import_map
                                classes[class_key].superclass = f"{package_name}.{superclass_name}" if package_name else superclass_name

                        # Handle 'implements'
                        if class_declaration.implements: # Add this check
                            for impl_ref in class_declaration.implements:
                                interface_name = impl_ref.name
                                # Try to resolve fully qualified name for interface
                                if interface_name in import_map:
                                    classes[class_key].interfaces.append(import_map[interface_name])
                                else:
                                    # Assume same package or fully qualified if not in import_map
                                    classes[class_key].interfaces.append(f"{package_name}.{interface_name}" if package_name else interface_name)
                        # --- End of new inheritance logic ---

                        field_map = {}
                        for field_declaration in class_declaration.fields:
                            for declarator in field_declaration.declarators:
                                field_map[declarator.name] = field_declaration.type.name
                                
                                # Parse field annotations
                                field_annotations = parse_annotations(field_declaration.annotations, "field") if hasattr(field_declaration, 'annotations') else []
                                
                                # Extract initial value if present
                                initial_value = ""
                                if hasattr(declarator, 'initializer') and declarator.initializer:
                                    # Convert the initializer to string representation
                                    if hasattr(declarator.initializer, 'value'):
                                        initial_value = str(declarator.initializer.value)
                                    elif hasattr(declarator.initializer, 'type'):
                                        initial_value = str(declarator.initializer.type)
                                    else:
                                        initial_value = str(declarator.initializer)
                                
                                prop = Property(
                                    name=declarator.name,
                                    logical_name=f"{package_name}.{class_name}.{declarator.name}",
                                    type=field_declaration.type.name,
                                    modifiers=list(field_declaration.modifiers), # Add modifiers
                                    package_name=package_name,
                                    class_name=class_name,
                                    annotations=field_annotations,
                                    initial_value=initial_value
                                )
                                classes[class_key].properties.append(prop)

                        all_declarations = class_declaration.methods + class_declaration.constructors
                        
                        # Debug: Check User class method processing
                        if "User" in class_name:
                            logger.debug(f"Processing User class methods - total declarations: {len(all_declarations)}")
                            for i, decl in enumerate(all_declarations):
                                logger.debug(f"Declaration {i}: {type(decl).__name__} - {decl.name}")
                        
                        for declaration in all_declarations:
                            local_var_map = field_map.copy()
                            params = []
                            for param in declaration.parameters:
                                param_type_name = 'Unknown'
                                if hasattr(param.type, 'name'):
                                    param_type_name = param.type.name
                                local_var_map[param.name] = param_type_name
                                params.append(Property(name=param.name, logical_name=f"{package_name}.{class_name}.{param.name}", type=param_type_name, package_name=package_name, class_name=class_name))

                            if declaration.body:
                                for _, var_decl in declaration.filter(javalang.tree.LocalVariableDeclaration):
                                    for declarator in var_decl.declarators:
                                        local_var_map[declarator.name] = var_decl.type.name
                            
                            if isinstance(declaration, javalang.tree.MethodDeclaration):
                                return_type = declaration.return_type.name if declaration.return_type else "void"
                            else: # ConstructorDeclaration
                                return_type = "constructor"

                            # Extract modifiers
                            modifiers = list(declaration.modifiers)
                            
                            # Parse method annotations
                            method_annotations = parse_annotations(declaration.annotations, "method") if hasattr(declaration, 'annotations') else []

                            # Extract method source code
                            method_source = ""
                            if declaration.position:
                                lines = file_content.splitlines(keepends=True) # Keep line endings
                                start_line = declaration.position.line - 1
                                
                                # Find the end of the method by matching braces
                                brace_count = 0
                                end_line = start_line
                                for i in range(start_line, len(lines)):
                                    line = lines[i]
                                    for char in line:
                                        if char == '{':
                                            brace_count += 1
                                        elif char == '}':
                                            brace_count -= 1
                                            if brace_count == 0:
                                                end_line = i
                                                break
                                    if brace_count == 0:
                                        break
                                
                                method_source = "".join(lines[start_line:end_line + 1])

                            method = Method(
                                name=declaration.name,
                                logical_name=f"{class_key}.{declaration.name}",  # Add logical_name
                                return_type=return_type,
                                parameters=params,
                                modifiers=modifiers,
                                source=method_source, # Add method source
                                package_name=package_name,
                                annotations=method_annotations
                            )
                            classes[class_key].methods.append(method)

                            # Extract method calls with order information
                            call_order = 0
                            for _, invocation in declaration.filter(javalang.tree.MethodInvocation):
                                target_class_name = None
                                resolved_target_package = ""
                                resolved_target_class_name = ""
                                
                                if invocation.qualifier:
                                    # External method call
                                    if invocation.qualifier in local_var_map:
                                        target_class_name = local_var_map[invocation.qualifier]
                                    else:
                                        target_class_name = invocation.qualifier
                                    
                                    if target_class_name:
                                        if target_class_name == "System.out":
                                            resolved_target_package = "java.io"
                                            resolved_target_class_name = "PrintStream"
                                        else:
                                            if target_class_name in import_map:
                                                resolved_target_package = ".".join(import_map[target_class_name].split(".")[:-1])
                                            else:
                                                resolved_target_package = package_name
                                                resolved_target_class_name = target_class_name
                                else:
                                    # Same class method call
                                    resolved_target_package = package_name
                                    resolved_target_class_name = class_name

                                if resolved_target_class_name:
                                    # Get line number from invocation position
                                    line_number = invocation.position.line if invocation.position else 0

                                    call = MethodCall(
                                        source_package=package_name,
                                        source_class=class_name,
                                        source_method=declaration.name,
                                        target_package=resolved_target_package,
                                        target_class=resolved_target_class_name,
                                        target_method=invocation.member,
                                        call_order=call_order,
                                        line_number=line_number,
                                        return_type="void"  # Default return type, can be enhanced later
                                    )
                                    classes[class_key].calls.append(call)
                                    call_order += 1
                        
                        # Check for Lombok @Data annotation and generate methods
                        has_data_annotation = any(ann.name == "Data" for ann in classes[class_key].annotations)
                        if has_data_annotation:
                            logger.debug(f"Found @Data annotation on {class_name}, generating Lombok methods")
                            lombok_methods = generate_lombok_methods(classes[class_key].properties, class_name, package_name)
                            classes[class_key].methods.extend(lombok_methods)
                            logger.debug(f"Generated {len(lombok_methods)} Lombok methods for {class_name}")
                except javalang.parser.JavaSyntaxError as e:
                    print(f"Syntax error in {file_path}: {e}")
                    continue
                except Exception as e:
                    print(f"Error parsing {file_path}: {e}")
                    continue
    
    # Extract beans, analyze dependencies, extract endpoints, extract MyBatis mappers, extract JPA entities, extract config files, and extract test classes
    classes_list = list(classes.values())
    beans = extract_beans_from_classes(classes_list)
    dependencies = analyze_bean_dependencies(classes_list, beans)
    endpoints = extract_endpoints_from_classes(classes_list)
    mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
    jpa_entities = extract_jpa_entities_from_classes(classes_list)
    config_files = extract_config_files(directory)
    test_classes = extract_test_classes_from_classes(classes_list)
    
    # Also extract XML mappers
    xml_mappers = extract_mybatis_xml_mappers(directory)
    mybatis_mappers.extend(xml_mappers)
    
    # Extract SQL statements from MyBatis mappers
    sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
    
    return list(packages.values()), classes_list, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name
```

이제 Property 생성 부분들을 Field로 변경하겠습니다.


```python
import os
import yaml
import re
from pathlib import Path

import javalang

from src.models.graph_entities import Class, Method, MethodCall, Field, Package, Annotation, Bean, BeanDependency, Endpoint, MyBatisMapper, MyBatisSqlStatement, MyBatisResultMap, SqlStatement, JpaEntity, JpaColumn, JpaRelationship, ConfigFile, DatabaseConfig, ServerConfig, SecurityConfig, LoggingConfig, TestClass, TestMethod, TestConfiguration
from src.utils.logger import get_logger
from typing import Optional, List, Literal


def extract_project_name(java_source_folder: str) -> str:
    """
    JAVA_SOURCE_FOLDER 경로에서 프로젝트 이름을 추출합니다.
    
    Args:
        java_source_folder: Java 소스 폴더 경로
        
    Returns:
        프로젝트 이름 (마지막 디렉토리명)
    """
    # 경로를 정규화하고 마지막 디렉토리명 추출
    path = Path(java_source_folder).resolve()
    return path.name


def extract_sql_statements_from_mappers(mybatis_mappers: list[MyBatisMapper], project_name: str) -> list[SqlStatement]:
    """
    MyBatis mappers에서 SQL statements를 추출합니다.
    
    Args:
        mybatis_mappers: MyBatis mapper 객체들의 리스트
        project_name: 프로젝트 이름
        
    Returns:
        SqlStatement 객체들의 리스트
    """
    sql_statements = []
    
    for mapper in mybatis_mappers:
        for sql_dict in mapper.sql_statements:
            # MyBatisSqlStatement를 SqlStatement로 변환
            sql_statement = SqlStatement(
                id=sql_dict.get('id', ''),
                sql_type=sql_dict.get('sql_type', ''),
                sql_content=sql_dict.get('sql_content', ''),
                parameter_type=sql_dict.get('parameter_type', ''),
                result_type=sql_dict.get('result_type', ''),
                result_map=sql_dict.get('result_map', ''),
                mapper_name=mapper.name,
                annotations=[],  # TODO: annotations를 파싱하여 추가
                project_name=project_name
            )
            sql_statements.append(sql_statement)
    
    return sql_statements


def parse_annotations(annotations, target_type: str = "class") -> list[Annotation]:
    """Parse Java annotations into Annotation objects.
    
    Args:
        annotations: List of annotation nodes from javalang
        target_type: Type of target ("class", "method", "field")
    """
    result = []
    for annotation in annotations:
        annotation_name = annotation.name
        parameters = {}
        
        # Parse annotation parameters if they exist
        if hasattr(annotation, 'element') and annotation.element:
            for element in annotation.element:
                if hasattr(element, 'name') and hasattr(element, 'value'):
                    parameters[element.name] = element.value.value if hasattr(element.value, 'value') else str(element.value)
        
        result.append(Annotation(
            name=annotation_name,
            parameters=parameters,
            target_type=target_type,
            category=classify_springboot_annotation(annotation_name)
        ))
    
    return result


def classify_springboot_annotation(annotation_name: str) -> str:
    """Classify SpringBoot annotations into categories.
    
    Args:
        annotation_name: Name of the annotation (e.g., "@Component", "@Service")
        
    Returns:
        Category of the annotation
    """
    # Component annotations
    component_annotations = {
        "Component", "Service", "Repository", "Controller", 
        "RestController", "Configuration", "Bean"
    }
    
    # Injection annotations
    injection_annotations = {
        "Autowired", "Resource", "Value", "Qualifier", "Primary"
    }
    
    # Web annotations
    web_annotations = {
        "RequestMapping", "GetMapping", "PostMapping", "PutMapping", 
        "DeleteMapping", "PatchMapping", "RequestParam", "PathVariable",
        "RequestBody", "ResponseBody", "ResponseStatus"
    }
    
    # JPA annotations
    jpa_annotations = {
        "Entity", "Table", "Id", "Column", "OneToMany", "ManyToOne",
        "OneToOne", "ManyToMany", "JoinColumn", "GeneratedValue"
    }
    
    # Test annotations
    test_annotations = {
        "Test", "SpringBootTest", "DataJpaTest", "WebMvcTest",
        "MockBean", "SpyBean", "TestPropertySource"
    }
    
    # Security annotations
    security_annotations = {
        "PreAuthorize", "PostAuthorize", "Secured", "RolesAllowed",
        "EnableWebSecurity", "EnableGlobalMethodSecurity"
    }
    
    # Validation annotations
    validation_annotations = {
        "Valid", "NotNull", "NotBlank", "NotEmpty", "Size", "Min", "Max",
        "Pattern", "Email", "AssertTrue", "AssertFalse"
    }
    
    # MyBatis annotations
    mybatis_annotations = {
        "Mapper", "Select", "Insert", "Update", "Delete", "SelectProvider",
        "InsertProvider", "UpdateProvider", "DeleteProvider", "Results",
        "Result", "One", "Many", "MapKey", "Options", "SelectKey"
    }
    
    if annotation_name in component_annotations:
        return "component"
    elif annotation_name in injection_annotations:
        return "injection"
    elif annotation_name in web_annotations:
        return "web"
    elif annotation_name in jpa_annotations:
        return "jpa"
    elif annotation_name in test_annotations:
        return "test"
    elif annotation_name in security_annotations:
        return "security"
    elif annotation_name in validation_annotations:
        return "validation"
    elif annotation_name in mybatis_annotations:
        return "mybatis"
    else:
        return "other"


def classify_test_annotation(annotation_name: str) -> str:
    """Classify test annotations into categories.
    
    Args:
        annotation_name: Name of the annotation
        
    Returns:
        Category of the test annotation
    """
    # JUnit annotations
    junit_annotations = {
        "Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll",
        "DisplayName", "ParameterizedTest", "ValueSource", "CsvSource",
        "MethodSource", "Timeout", "Disabled", "Nested", "RepeatedTest",
        "Order", "TestMethodOrder", "TestInstance", "TestClassOrder"
    }
    
    # Spring Boot Test annotations
    spring_test_annotations = {
        "SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest",
        "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest",
        "MockBean", "SpyBean", "TestConfiguration", "ActiveProfiles",
        "TestPropertySource", "DirtiesContext", "Transactional",
        "Rollback", "Commit", "Sql", "SqlGroup", "AutoConfigureTestDatabase",
        "AutoConfigureMockMvc", "AutoConfigureWebMvc", "AutoConfigureWebClient",
        "MockMvc", "TestEntityManager", "TestContainers", "DynamicPropertySource"
    }
    
    # TestNG annotations
    testng_annotations = {
        "TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass",
        "BeforeSuite", "AfterSuite", "BeforeGroups", "AfterGroups",
        "DataProvider", "Parameters", "Groups", "Priority", "DependsOnMethods",
        "DependsOnGroups", "ExpectedExceptions", "InvocationCount",
        "SuccessPercentage", "TimeOut"
    }
    
    # Mockito annotations
    mockito_annotations = {
        "Mock", "Spy", "InjectMocks", "Captor", "MockedStatic"
    }
    
    # AssertJ annotations
    assertj_annotations = {
        "AssertJ"
    }
    
    # Other test annotations
    other_test_annotations = {
        "Ignore", "Category", "RunWith", "ExtendWith", "ContextConfiguration"
    }
    
    if annotation_name in junit_annotations:
        return "junit"
    elif annotation_name in spring_test_annotations:
        return "spring_test"
    elif annotation_name in testng_annotations:
        return "testng"
    elif annotation_name in mockito_annotations:
        return "mockito"
    elif annotation_name in assertj_annotations:
        return "assertj"
    elif annotation_name in other_test_annotations:
        return "other_test"
    else:
        return "other"


def extract_beans_from_classes(classes: list[Class]) -> list[Bean]:
    """Extract Spring Beans from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Bean objects
    """
    beans = []
    
    for cls in classes:
        # Check if class has Spring component annotations
        component_annotations = [ann for ann in cls.annotations if ann.category == "component"]
        
        # Also check for @Repository on interfaces
        has_repository_annotation = any(ann.name == "Repository" for ann in cls.annotations)
        
        if component_annotations or has_repository_annotation:
            # Determine bean type based on annotations
            bean_type = "component"  # default
            if any(ann.name in ["Service", "Service"] for ann in cls.annotations):
                bean_type = "service"
            elif any(ann.name in ["Repository", "Repository"] for ann in cls.annotations):
                bean_type = "repository"
            elif any(ann.name in ["Controller", "RestController"] for ann in cls.annotations):
                bean_type = "controller"
            elif any(ann.name in ["Configuration", "Configuration"] for ann in cls.annotations):
                bean_type = "configuration"
            
            # Determine scope (default is singleton)
            scope = "singleton"
            for ann in cls.annotations:
                if ann.name == "Scope":
                    if "value" in ann.parameters:
                        scope = ann.parameters["value"]
                    elif "prototype" in str(ann.parameters):
                        scope = "prototype"
                    elif "request" in str(ann.parameters):
                        scope = "request"
                    elif "session" in str(ann.parameters):
                        scope = "session"
            
            # Create bean name (use class name with first letter lowercase)
            bean_name = cls.name[0].lower() + cls.name[1:] if cls.name else cls.name
            
            # Check for @Bean methods in configuration classes
            bean_methods = []
            if bean_type == "configuration":
                for method in cls.methods:
                    if any(ann.name == "Bean" for ann in method.annotations):
                        bean_methods.append(method)
            
            bean = Bean(
                name=bean_name,
                type=bean_type,
                scope=scope,
                class_name=cls.name,
                package_name=cls.package_name,
                annotation_names=[ann.name for ann in cls.annotations] if cls.annotations else [],
                method_count=len(bean_methods) if bean_type == "configuration" else len(cls.methods) if cls.methods else 0,
                property_count=len(cls.properties) if cls.properties else 0
            )
            beans.append(bean)
    
    return beans


def analyze_bean_dependencies(classes: list[Class], beans: list[Bean]) -> list[BeanDependency]:
    """Analyze dependencies between Spring Beans.
    
    Args:
        classes: List of parsed Class objects
        beans: List of Bean objects
        
    Returns:
        List of BeanDependency objects
    """
    dependencies = []
    
    # Create a mapping from class names to bean names
    class_to_bean = {}
    for bean in beans:
        class_to_bean[bean.class_name] = bean.name
    
    for cls in classes:
        # Check if this class is a bean
        if cls.name not in class_to_bean:
            continue
            
        source_bean = class_to_bean[cls.name]
        
        # Analyze field injections (@Autowired, @Resource, @Value)
        for prop in cls.properties:
            if any(ann.category == "injection" for ann in prop.annotations):
                # Try to determine target bean from field type
                target_bean = None
                field_type = prop.type
                
                # Look for exact class name match
                if field_type in class_to_bean:
                    target_bean = class_to_bean[field_type]
                else:
                    # Look for interface implementations (simplified - just check if type matches any bean class name)
                    for bean in beans:
                        if field_type == bean.class_name:
                            target_bean = bean.name
                            break
                
                if target_bean:
                    injection_type = "field"
                    for ann in prop.annotations:
                        if ann.name == "Autowired":
                            injection_type = "field"
                        elif ann.name == "Resource":
                            injection_type = "field"
                        elif ann.name == "Value":
                            injection_type = "field"
                    
                    dependency = BeanDependency(
                        source_bean=source_bean,
                        target_bean=target_bean,
                        injection_type=injection_type,
                        field_name=prop.name
                    )
                    dependencies.append(dependency)
        
        # Analyze constructor injections
        for method in cls.methods:
            if method.name == cls.name:  # Constructor
                for param in method.parameters:
                    if any(ann.category == "injection" for ann in param.annotations):
                        target_bean = None
                        param_type = param.type
                        
                        if param_type in class_to_bean:
                            target_bean = class_to_bean[param_type]
                        else:
                            # Look for interface implementations (simplified)
                            for bean in beans:
                                if param_type == bean.class_name:
                                    target_bean = bean.name
                                    break
                        
                        if target_bean:
                            dependency = BeanDependency(
                                source_bean=source_bean,
                                target_bean=target_bean,
                                injection_type="constructor",
                                parameter_name=param.name
                            )
                            dependencies.append(dependency)
        
        # Analyze setter injections
        for method in cls.methods:
            if method.name.startswith("set") and len(method.parameters) == 1:
                if any(ann.category == "injection" for ann in method.annotations):
                    param = method.parameters[0]
                    target_bean = None
                    param_type = param.type
                    
                    if param_type in class_to_bean:
                        target_bean = class_to_bean[param_type]
                    else:
                        # Look for interface implementations (simplified)
                        for bean in beans:
                            if param_type == bean.class_name:
                                target_bean = bean.name
                                break
                    
                    if target_bean:
                        dependency = BeanDependency(
                            source_bean=source_bean,
                            target_bean=target_bean,
                            injection_type="setter",
                            method_name=method.name,
                            parameter_name=param.name
                        )
                        dependencies.append(dependency)
    
    return dependencies


def extract_endpoints_from_classes(classes: list[Class]) -> list[Endpoint]:
    """Extract REST API endpoints from controller classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Endpoint objects
    """
    endpoints = []
    
    for cls in classes:
        # Check if class is a controller
        is_controller = any(ann.name in ["Controller", "RestController"] for ann in cls.annotations)
        
        if not is_controller:
            continue
            
        # Get class-level path mapping
        class_path = ""
        for ann in cls.annotations:
            if ann.name == "RequestMapping":
                if "value" in ann.parameters:
                    class_path = ann.parameters["value"]
                break
        
        # Process each method in the controller
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
                
            # Check if method has web mapping annotations
            web_annotations = [ann for ann in method.annotations if ann.category == "web"]
            
            if not web_annotations:
                continue
            
            # Extract endpoint information
            endpoint_path = ""
            http_method = "GET"  # default
            
            for ann in web_annotations:
                if ann.name in ["RequestMapping", "GetMapping", "PostMapping", "PutMapping", "DeleteMapping", "PatchMapping"]:
                    # Extract path
                    if "value" in ann.parameters:
                        endpoint_path = ann.parameters["value"]
                    elif "path" in ann.parameters:
                        endpoint_path = ann.parameters["path"]
                    
                    # Extract HTTP method
                    if ann.name == "GetMapping":
                        http_method = "GET"
                    elif ann.name == "PostMapping":
                        http_method = "POST"
                    elif ann.name == "PutMapping":
                        http_method = "PUT"
                    elif ann.name == "DeleteMapping":
                        http_method = "DELETE"
                    elif ann.name == "PatchMapping":
                        http_method = "PATCH"
                    elif ann.name == "RequestMapping":
                        if "method" in ann.parameters:
                            method_value = ann.parameters["method"]
                            if isinstance(method_value, list) and len(method_value) > 0:
                                http_method = method_value[0]
                            else:
                                http_method = str(method_value)
                        else:
                            http_method = "GET"  # default for RequestMapping
                    break
            
            # Build full path
            full_path = class_path
            if endpoint_path:
                if full_path and not full_path.endswith("/") and not endpoint_path.startswith("/"):
                    full_path += "/"
                full_path += endpoint_path
            elif not full_path:
                full_path = "/"
            
            # Extract method parameters
            parameters = []
            for param in method.parameters:
                param_info = {
                    "name": param.name,
                    "type": param.type,
                    "annotations": [ann.name for ann in param.annotations if ann.category == "web"]
                }
                parameters.append(param_info)
            
            # Extract return type
            return_type = method.return_type if method.return_type != "constructor" else "void"
            
            # Create endpoint
            endpoint = Endpoint(
                path=endpoint_path or "/",
                method=http_method,
                controller_class=cls.name,
                handler_method=method.name,
                parameters=parameters,
                return_type=return_type,
                annotations=[ann.name for ann in web_annotations],
                full_path=full_path
            )
            endpoints.append(endpoint)
    
    return endpoints


def extract_mybatis_mappers_from_classes(classes: list[Class]) -> list[MyBatisMapper]:
    """Extract MyBatis Mappers from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for cls in classes:
        # Check if class is a MyBatis Mapper interface
        is_mapper = any(ann.name == "Mapper" for ann in cls.annotations)
        
        if not is_mapper:
            continue
        
        # Extract mapper methods with MyBatis annotations
        mapper_methods = []
        sql_statements = []
        
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
            
            # Check if method has MyBatis annotations
            mybatis_annotations = [ann for ann in method.annotations if ann.category == "mybatis"]
            
            if not mybatis_annotations:
                continue
            
            # Extract SQL statement information
            sql_type = "SELECT"  # default
            sql_content = ""
            parameter_type = ""
            result_type = ""
            result_map = ""
            
            for ann in mybatis_annotations:
                if ann.name in ["Select", "SelectProvider"]:
                    sql_type = "SELECT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Insert", "InsertProvider"]:
                    sql_type = "INSERT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Update", "UpdateProvider"]:
                    sql_type = "UPDATE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Delete", "DeleteProvider"]:
                    sql_type = "DELETE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                
                # Extract parameter and result type information
                if "parameterType" in ann.parameters:
                    parameter_type = ann.parameters["parameterType"]
                if "resultType" in ann.parameters:
                    result_type = ann.parameters["resultType"]
                if "resultMap" in ann.parameters:
                    result_map = ann.parameters["resultMap"]
            
            # Create method info
            method_info = {
                "name": method.name,
                "return_type": method.return_type,
                "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            mapper_methods.append(method_info)
            
            # Create SQL statement info
            sql_statement = {
                "id": method.name,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            sql_statements.append(sql_statement)
        
        # Create mapper
        mapper = MyBatisMapper(
            name=cls.name,
            type="interface",
            namespace=f"{cls.package_name}.{cls.name}",
            methods=mapper_methods,
            sql_statements=sql_statements,
            file_path=cls.file_path,
            package_name=cls.package_name
        )
        mappers.append(mapper)
    
    return mappers


def parse_mybatis_xml_file(file_path: str) -> MyBatisMapper:
    """Parse MyBatis XML mapper file.
    
    Args:
        file_path: Path to the XML mapper file
        
    Returns:
        MyBatisMapper object
    """
    import xml.etree.ElementTree as ET
    
    try:
        tree = ET.parse(file_path)
        root = tree.getroot()
        
        # Extract namespace
        namespace = root.get("namespace", "")
        
        # Extract SQL statements
        sql_statements = []
        for statement in root.findall(".//*[@id]"):
            statement_id = statement.get("id")
            tag_name = statement.tag.lower()
            
            # Determine SQL type
            sql_type = "SELECT"
            if tag_name == "insert":
                sql_type = "INSERT"
            elif tag_name == "update":
                sql_type = "UPDATE"
            elif tag_name == "delete":
                sql_type = "DELETE"
            
            # Extract SQL content
            sql_content = statement.text.strip() if statement.text else ""
            
            # Extract parameter and result information
            parameter_type = statement.get("parameterType", "")
            result_type = statement.get("resultType", "")
            result_map = statement.get("resultMap", "")
            
            sql_statement = {
                "id": statement_id,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": []
            }
            sql_statements.append(sql_statement)
        
        # Extract ResultMaps
        result_maps = []
        for result_map in root.findall(".//resultMap"):
            result_map_id = result_map.get("id")
            result_map_type = result_map.get("type", "")
            
            properties = []
            for property_elem in result_map.findall(".//result"):
                prop = {
                    "property": property_elem.get("property", ""),
                    "column": property_elem.get("column", ""),
                    "jdbc_type": property_elem.get("jdbcType", "")
                }
                properties.append(prop)
            
            result_map_info = {
                "id": result_map_id,
                "type": result_map_type,
                "properties": properties,
                "associations": [],
                "collections": []
            }
            result_maps.append(result_map_info)
        
        # Create mapper
        mapper_name = namespace.split(".")[-1] if namespace else os.path.basename(file_path).replace(".xml", "")
        package_name = ".".join(namespace.split(".")[:-1]) if namespace else ""
        
        mapper = MyBatisMapper(
            name=mapper_name,
            type="xml",
            namespace=namespace,
            methods=[],  # XML mappers don't have Java methods
            sql_statements=sql_statements,
            file_path=file_path,
            package_name=package_name
        )
        
        return mapper
        
    except ET.ParseError as e:
        print(f"Error parsing XML file {file_path}: {e}")
        return None
    except Exception as e:
        print(f"Error reading XML file {file_path}: {e}")
        return None


def extract_mybatis_xml_mappers(directory: str) -> list[MyBatisMapper]:
    """Extract MyBatis XML mappers from directory.
    
    Args:
        directory: Directory to search for XML mapper files
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith("Mapper.xml") or file.endswith("Dao.xml"):
                file_path = os.path.join(root, file)
                mapper = parse_mybatis_xml_file(file_path)
                if mapper:
                    mappers.append(mapper)
    
    return mappers


def extract_jpa_entities_from_classes(classes: list[Class]) -> list[JpaEntity]:
    """Extract JPA Entities from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of JpaEntity objects
    """
    entities = []
    
    for cls in classes:
        # Check if class is a JPA Entity
        is_entity = any(ann.name == "Entity" for ann in cls.annotations)
        
        if not is_entity:
            continue
        
        # Extract table name
        table_name = cls.name.lower()  # default table name
        for ann in cls.annotations:
            if ann.name == "Table":
                if "name" in ann.parameters:
                    table_name = ann.parameters["name"]
                break
        
        # Extract columns from properties
        columns = []
        relationships = []
        
        for prop in cls.properties:
            # Check if property has JPA column annotations
            jpa_annotations = [ann for ann in prop.annotations if ann.category == "jpa"]
            
            if jpa_annotations:
                # Extract column information
                column_name = prop.name  # default column name
                nullable = True
                unique = False
                length = 0
                precision = 0
                scale = 0
                
                for ann in jpa_annotations:
                    if ann.name == "Column":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                        if "nullable" in ann.parameters:
                            nullable = ann.parameters["nullable"]
                        if "unique" in ann.parameters:
                            unique = ann.parameters["unique"]
                        if "length" in ann.parameters:
                            length = ann.parameters["length"]
                        if "precision" in ann.parameters:
                            precision = ann.parameters["precision"]
                        if "scale" in ann.parameters:
                            scale = ann.parameters["scale"]
                    elif ann.name == "Id":
                        column_name = "id"  # Primary key column
                        nullable = False
                        unique = True
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                
                # Check for relationship annotations
                relationship_type = None
                target_entity = ""
                mapped_by = ""
                join_column = ""
                join_table = ""
                cascade = []
                fetch = "LAZY"
                
                for ann in jpa_annotations:
                    if ann.name in ["OneToOne", "OneToMany", "ManyToOne", "ManyToMany"]:
                        relationship_type = ann.name
                        if "targetEntity" in ann.parameters:
                            target_entity = ann.parameters["targetEntity"]
                        if "mappedBy" in ann.parameters:
                            mapped_by = ann.parameters["mappedBy"]
                        if "cascade" in ann.parameters:
                            cascade = ann.parameters["cascade"] if isinstance(ann.parameters["cascade"], list) else [ann.parameters["cascade"]]
                        if "fetch" in ann.parameters:
                            fetch = ann.parameters["fetch"]
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            join_column = ann.parameters["name"]
                    elif ann.name == "JoinTable":
                        if "name" in ann.parameters:
                            join_table = ann.parameters["name"]
                
                # Create column info
                column_info = {
                    "property_name": prop.name,
                    "column_name": column_name,
                    "data_type": prop.type,
                    "nullable": nullable,
                    "unique": unique,
                    "length": length,
                    "precision": precision,
                    "scale": scale,
                    "annotations": [ann.name for ann in jpa_annotations]
                }
                columns.append(column_info)
                
                # Create relationship info if it's a relationship
                if relationship_type:
                    relationship_info = {
                        "type": relationship_type,
                        "target_entity": target_entity,
                        "mapped_by": mapped_by,
                        "join_column": join_column,
                        "join_table": join_table,
                        "cascade": cascade,
                        "fetch": fetch,
                        "annotations": [ann.name for ann in jpa_annotations]
                    }
                    relationships.append(relationship_info)
        
        # Create entity
        entity = JpaEntity(
            name=cls.name,
            table_name=table_name,
            columns=columns,
            relationships=relationships,
            annotations=[ann.name for ann in cls.annotations if ann.category == "jpa"],
            package_name=cls.package_name,
            file_path=cls.file_path
        )
        entities.append(entity)
    
    return entities


def parse_yaml_config(file_path: str) -> ConfigFile:
    """Parse YAML configuration file.
    
    Args:
        file_path: Path to the YAML file
        
    Returns:
        ConfigFile object
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = yaml.safe_load(f)
        
        if not content:
            content = {}
        
        # Extract file info
        file_name = os.path.basename(file_path)
        file_type = "yaml" if file_path.endswith('.yaml') else "yml"
        
        # Extract profiles
        profiles = []
        if 'spring' in content and 'profiles' in content['spring']:
            if 'active' in content['spring']['profiles']:
                profiles = content['spring']['profiles']['active']
                if isinstance(profiles, str):
                    profiles = [profiles]
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        # Extract sections
        sections = []
        for key, value in content.items():
            if isinstance(value, dict):
                sections.append({
                    "name": key,
                    "properties": value,
                    "type": "section"
                })
        
        return ConfigFile(
            name=file_name,
            file_path=file_path,
            file_type=file_type,
            properties=content,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing YAML file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="yaml",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def parse_properties_config(file_path: str) -> ConfigFile:
    """Parse Properties configuration file.
    
    Args:
        file_path: Path to the properties file
        
    Returns:
        ConfigFile object
    """
    try:
        properties = {}
        sections = []
        profiles = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                
                # Skip empty lines and comments
                if not line or line.startswith('#'):
                    continue
                
                # Parse key=value pairs
                if '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    
                    # Remove quotes if present
                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]
                    elif value.startswith("'") and value.endswith("'"):
                        value = value[1:-1]
                    
                    properties[key] = value
                    
                    # Check for profiles
                    if key == 'spring.profiles.active':
                        profiles = [p.strip() for p in value.split(',')]
        
        # Group properties by section
        section_map = {}
        for key, value in properties.items():
            if '.' in key:
                section = key.split('.')[0]
                if section not in section_map:
                    section_map[section] = {}
                section_map[section][key] = value
            else:
                if 'root' not in section_map:
                    section_map['root'] = {}
                section_map['root'][key] = value
        
        for section_name, section_props in section_map.items():
            sections.append({
                "name": section_name,
                "properties": section_props,
                "type": "section"
            })
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties=properties,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing Properties file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def extract_database_config(config_file: ConfigFile) -> DatabaseConfig:
    """Extract database configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        DatabaseConfig object
    """
    db_config = DatabaseConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        spring_config = config_file.properties.get('spring', {})
        datasource_config = spring_config.get('datasource', {})
        jpa_config = spring_config.get('jpa', {})
        
        db_config.driver = datasource_config.get('driver-class-name', '')
        db_config.url = datasource_config.get('url', '')
        db_config.username = datasource_config.get('username', '')
        db_config.password = datasource_config.get('password', '')
        db_config.dialect = jpa_config.get('database-platform', '')
        db_config.hibernate_ddl_auto = jpa_config.get('hibernate', {}).get('ddl-auto', '')
        db_config.show_sql = jpa_config.get('show-sql', False)
        db_config.format_sql = jpa_config.get('properties', {}).get('hibernate', {}).get('format_sql', False)
        
        # Store additional JPA properties
        if 'properties' in jpa_config:
            db_config.jpa_properties = jpa_config['properties']
    
    else:
        # Properties format
        props = config_file.properties
        
        db_config.driver = props.get('spring.datasource.driver-class-name', '')
        db_config.url = props.get('spring.datasource.url', '')
        db_config.username = props.get('spring.datasource.username', '')
        db_config.password = props.get('spring.datasource.password', '')
        db_config.dialect = props.get('spring.jpa.database-platform', '')
        db_config.hibernate_ddl_auto = props.get('spring.jpa.hibernate.ddl-auto', '')
        db_config.show_sql = props.get('spring.jpa.show-sql', 'false').lower() == 'true'
        db_config.format_sql = props.get('spring.jpa.properties.hibernate.format_sql', 'false').lower() == 'true'
        
        # Store additional JPA properties
        jpa_props = {}
        for key, value in props.items():
            if key.startswith('spring.jpa.properties.'):
                jpa_props[key] = value
        db_config.jpa_properties = jpa_props
    
    return db_config


def extract_server_config(config_file: ConfigFile) -> ServerConfig:
    """Extract server configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        ServerConfig object
    """
    server_config = ServerConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        server_props = config_file.properties.get('server', {})
        
        server_config.port = server_props.get('port', 8080)
        server_config.context_path = server_props.get('servlet', {}).get('context-path', '')
        server_config.servlet_path = server_props.get('servlet', {}).get('path', '')
        
        # SSL configuration
        ssl_config = server_props.get('ssl', {})
        server_config.ssl_enabled = bool(ssl_config)
        server_config.ssl_key_store = ssl_config.get('key-store', '')
        server_config.ssl_key_store_password = ssl_config.get('key-store-password', '')
        server_config.ssl_key_store_type = ssl_config.get('key-store-type', '')
    
    else:
        # Properties format
        props = config_file.properties
        
        server_config.port = int(props.get('server.port', '8080'))
        server_config.context_path = props.get('server.servlet.context-path', '')
        server_config.servlet_path = props.get('server.servlet.path', '')
        
        # SSL configuration
        server_config.ssl_enabled = any(key.startswith('server.ssl.') for key in props.keys())
        server_config.ssl_key_store = props.get('server.ssl.key-store', '')
        server_config.ssl_key_store_password = props.get('server.ssl.key-store-password', '')
        server_config.ssl_key_store_type = props.get('server.ssl.key-store-type', '')
    
    return server_config


def extract_security_config(config_file: ConfigFile) -> SecurityConfig:
    """Extract security configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        SecurityConfig object
    """
    security_config = SecurityConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        security_props = config_file.properties.get('security', {})
        jwt_props = security_props.get('jwt', {})
        cors_props = security_props.get('cors', {})
        
        security_config.enabled = bool(security_props)
        security_config.authentication_type = security_props.get('authentication-type', '')
        security_config.jwt_secret = jwt_props.get('secret', '')
        security_config.jwt_expiration = jwt_props.get('expiration', 0)
        security_config.cors_allowed_origins = cors_props.get('allowed-origins', [])
        security_config.cors_allowed_methods = cors_props.get('allowed-methods', [])
        security_config.cors_allowed_headers = cors_props.get('allowed-headers', [])
    
    else:
        # Properties format
        props = config_file.properties
        
        security_config.enabled = any(key.startswith('security.') for key in props.keys())
        security_config.authentication_type = props.get('security.authentication-type', '')
        security_config.jwt_secret = props.get('security.jwt.secret', '')
        security_config.jwt_expiration = int(props.get('security.jwt.expiration', '0'))
        
        # CORS configuration
        origins = props.get('security.cors.allowed-origins', '')
        if origins:
            security_config.cors_allowed_origins = [o.strip() for o in origins.split(',')]
        
        methods = props.get('security.cors.allowed-methods', '')
        if methods:
            security_config.cors_allowed_methods = [m.strip() for m in methods.split(',')]
        
        headers = props.get('security.cors.allowed-headers', '')
        if headers:
            security_config.cors_allowed_headers = [h.strip() for h in headers.split(',')]
    
    return security_config


def extract_logging_config(config_file: ConfigFile) -> LoggingConfig:
    """Extract logging configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        LoggingConfig object
    """
    logging_config = LoggingConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        logging_props = config_file.properties.get('logging', {})
        
        logging_config.level = logging_props.get('level', {}).get('root', 'INFO')
        logging_config.pattern = logging_props.get('pattern', {}).get('console', '')
        logging_config.file_path = logging_props.get('file', {}).get('name', '')
        logging_config.max_file_size = logging_props.get('file', {}).get('max-size', '')
        logging_config.max_history = logging_props.get('file', {}).get('max-history', 0)
        logging_config.console_output = logging_props.get('console', {}).get('enabled', True)
    
    else:
        # Properties format
        props = config_file.properties
        
        logging_config.level = props.get('logging.level.root', 'INFO')
        logging_config.pattern = props.get('logging.pattern.console', '')
        logging_config.file_path = props.get('logging.file.name', '')
        logging_config.max_file_size = props.get('logging.file.max-size', '')
        logging_config.max_history = int(props.get('logging.file.max-history', '0'))
        logging_config.console_output = props.get('logging.console.enabled', 'true').lower() == 'true'
    
    return logging_config


def extract_config_files(directory: str) -> list[ConfigFile]:
    """Extract configuration files from directory.
    
    Args:
        directory: Directory to search for config files
        
    Returns:
        List of ConfigFile objects
    """
    config_files = []
    
    # Common config file patterns
    config_patterns = [
        "application.yml",
        "application.yaml", 
        "application.properties",
        "application-*.properties",
        "bootstrap.yml",
        "bootstrap.yaml",
        "bootstrap.properties"
    ]
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            # Check if file matches any config pattern
            is_config_file = False
            for pattern in config_patterns:
                if pattern == file or (pattern.endswith('*') and file.startswith(pattern[:-1])):
                    is_config_file = True
                    break
            
            if is_config_file:
                file_path = os.path.join(root, file)
                
                if file.endswith(('.yml', '.yaml')):
                    config_file = parse_yaml_config(file_path)
                elif file.endswith('.properties'):
                    config_file = parse_properties_config(file_path)
                else:
                    continue
                
                config_files.append(config_file)
    
    return config_files


def extract_test_classes_from_classes(classes: list[Class]) -> list[TestClass]:
    """Extract test classes from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of TestClass objects
    """
    test_classes = []
    
    for cls in classes:
        # Check if class is a test class
        test_annotations = [ann for ann in cls.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
        
        if not test_annotations:
            continue
        
        # Determine test framework and type
        test_framework = "junit"  # default
        test_type = "unit"  # default
        
        for ann in test_annotations:
            if ann.name in ["SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest", "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest"]:
                test_framework = "spring_test"
                if ann.name == "SpringBootTest":
                    test_type = "integration"
                else:
                    test_type = "slice"
            elif ann.name in ["TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass"]:
                test_framework = "testng"
            elif ann.name in ["Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll"]:
                test_framework = "junit"
        
        # Extract test methods
        test_methods = []
        setup_methods = []
        
        for method in cls.methods:
            method_annotations = [ann.name for ann in method.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
            
            if method_annotations:
                # Check if it's a setup/teardown method
                if any(ann in method_annotations for ann in ["BeforeEach", "AfterEach", "BeforeAll", "AfterAll", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass", "BeforeSuite", "AfterSuite"]):
                    setup_methods.append({
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters]
                    })
                else:
                    # Regular test method
                    test_method_info = {
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                        "assertions": [],
                        "mock_calls": [],
                        "test_data": [],
                        "expected_exceptions": [],
                        "timeout": 0,
                        "display_name": ""
                    }
                    
                    # Extract display name
                    for ann in method.annotations:
                        if ann.name == "DisplayName" and "value" in ann.parameters:
                            test_method_info["display_name"] = ann.parameters["value"]
                        elif ann.name == "Timeout" and "value" in ann.parameters:
                            test_method_info["timeout"] = ann.parameters["value"]
                    
                    # Extract expected exceptions
                    for ann in method.annotations:
                        if ann.name == "ExpectedExceptions" and "value" in ann.parameters:
                            test_method_info["expected_exceptions"] = ann.parameters["value"] if isinstance(ann.parameters["value"], list) else [ann.parameters["value"]]
                    
                    test_methods.append(test_method_info)
        
        # Extract mock dependencies
        mock_dependencies = []
        for prop in cls.properties:
            prop_annotations = [ann.name for ann in prop.annotations if classify_test_annotation(ann.name) in ["mockito", "spring_test"]]
            if prop_annotations:
                mock_dependencies.append({
                    "name": prop.name,
                    "type": prop.type,
                    "annotations": prop_annotations,
                    "mock_type": "mock" if "Mock" in prop_annotations else "spy" if "Spy" in prop_annotations else "bean"
                })
        
        # Extract test configurations
        test_configurations = []
        for ann in cls.annotations:
            if ann.name in ["TestConfiguration", "ActiveProfiles", "TestPropertySource"]:
                config_info = {
                    "name": ann.name,
                    "type": "configuration" if ann.name == "TestConfiguration" else "profile" if ann.name == "ActiveProfiles" else "property",
                    "properties": ann.parameters,
                    "active_profiles": ann.parameters.get("value", []) if ann.name == "ActiveProfiles" else [],
                    "test_slices": [],
                    "mock_beans": [],
                    "spy_beans": []
                }
                test_configurations.append(config_info)
        
        # Create test class
        test_class = TestClass(
            name=cls.name,
            package_name=cls.package_name,
            test_framework=test_framework,
            test_type=test_type,
            annotations=[ann.name for ann in test_annotations],
            test_methods=test_methods,
            setup_methods=setup_methods,
            mock_dependencies=mock_dependencies,
            test_configurations=test_configurations,
            file_path=cls.file_path
        )
        test_classes.append(test_class)
    
    return test_classes


def analyze_test_methods(test_class: TestClass, class_obj: Class) -> list[TestMethod]:
    """Analyze test methods for assertions, mock calls, and test data.
    
    Args:
        test_class: TestClass object
        class_obj: Original Class object
        
    Returns:
        List of analyzed TestMethod objects
    """
    test_methods = []
    
    for method_info in test_class.test_methods:
        # Find the corresponding method in the class
        method_obj = None
        for method in class_obj.methods:
            if method.name == method_info["name"]:
                method_obj = method
                break
        
        if not method_obj:
            continue
        
        # Analyze method source code for assertions and mock calls
        assertions = []
        mock_calls = []
        test_data = []
        
        if method_obj.source:
            source_code = method_obj.source
            
            # Find assertions (JUnit, AssertJ, etc.)
            assertion_patterns = [
                r'assert\w+\(',  # JUnit assertions
                r'assertThat\(',  # AssertJ
                r'assertEquals\(',  # JUnit
                r'assertTrue\(',  # JUnit
                r'assertFalse\(',  # JUnit
                r'assertNotNull\(',  # JUnit
                r'assertNull\(',  # JUnit
                r'assertThrows\(',  # JUnit 5
                r'assertDoesNotThrow\(',  # JUnit 5
                r'verify\(',  # Mockito verify
                r'when\(',  # Mockito when
                r'then\(',  # Mockito then
                r'given\(',  # BDDMockito given
                r'willReturn\(',  # Mockito willReturn
                r'willThrow\(',  # Mockito willThrow
            ]
            
            for pattern in assertion_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    assertions.append({
                        "type": match,
                        "line": source_code.find(match) + 1
                    })
            
            # Find mock calls
            mock_call_patterns = [
                r'(\w+)\.(\w+)\(',  # Method calls on objects
                r'mock\(',  # Mockito mock creation
                r'spy\(',  # Mockito spy creation
                r'@Mock\s+(\w+)',  # @Mock annotation
                r'@Spy\s+(\w+)',  # @Spy annotation
                r'@InjectMocks\s+(\w+)',  # @InjectMocks annotation
            ]
            
            for pattern in mock_call_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        mock_calls.append({
                            "object": match[0],
                            "method": match[1],
                            "type": "method_call"
                        })
                    else:
                        mock_calls.append({
                            "type": match,
                            "line": source_code.find(match) + 1
                        })
            
            # Find test data setup
            test_data_patterns = [
                r'new\s+(\w+)\(',  # Object creation
                r'(\w+)\s*=\s*new\s+(\w+)\(',  # Variable assignment with new
                r'@ValueSource\(',  # JUnit 5 @ValueSource
                r'@CsvSource\(',  # JUnit 5 @CsvSource
                r'@MethodSource\(',  # JUnit 5 @MethodSource
            ]
            
            for pattern in test_data_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        test_data.append({
                            "variable": match[0],
                            "type": match[1],
                            "pattern": "object_creation"
                        })
                    else:
                        test_data.append({
                            "type": match,
                            "pattern": "annotation"
                        })
        
        # Create TestMethod object
        test_method = TestMethod(
            name=method_info["name"],
            return_type=method_info["return_type"],
            annotations=method_info["annotations"],
            assertions=assertions,
            mock_calls=mock_calls,
            test_data=test_data,
            expected_exceptions=method_info["expected_exceptions"],
            timeout=method_info["timeout"],
            display_name=method_info["display_name"]
        )
        test_methods.append(test_method)
    
    return test_methods


def generate_lombok_methods(properties: list[Field], class_name: str, package_name: str) -> list[Method]:
    """Generate Lombok @Data methods (getters, setters, equals, hashCode, toString) for properties."""
    methods = []
    
    # Generate getters and setters for each property
    for prop in properties:
        # Getter
        getter_name = f"get{prop.name[0].upper()}{prop.name[1:]}"
        if prop.type == "Boolean" and prop.name.startswith("is"):
            # For boolean fields starting with 'is', use the field name as getter
            getter_name = prop.name
        
        getter = Method(
            name=getter_name,
            logical_name=f"{package_name}.{class_name}.{getter_name}",
            return_type=prop.type,
            parameters=[],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[]
        )
        methods.append(getter)
        
        # Setter
        setter_name = f"set{prop.name[0].upper()}{prop.name[1:]}"
        setter_param = Field(
            name=prop.name,
            logical_name=f"{package_name}.{class_name}.{prop.name}",
            type=prop.type,
            package_name=package_name,
            class_name=class_name
        )
        
        setter = Method(
            name=setter_name,
            logical_name=f"{package_name}.{class_name}.{setter_name}",
            return_type="void",
            parameters=[setter_param],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[]
        )
        methods.append(setter)
    
    # Generate equals method
    equals_method = Method(
        name="equals",
        logical_name=f"{package_name}.{class_name}.equals",
        return_type="boolean",
        parameters=[Property(name="obj", logical_name=f"{package_name}.{class_name}.obj", type="Object", package_name=package_name, class_name=class_name)],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(equals_method)
    
    # Generate hashCode method
    hashcode_method = Method(
        name="hashCode",
        logical_name=f"{package_name}.{class_name}.hashCode",
        return_type="int",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(hashcode_method)
    
    # Generate toString method
    tostring_method = Method(
        name="toString",
        logical_name=f"{package_name}.{class_name}.toString",
        return_type="String",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(tostring_method)
    
    return methods


def parse_java_project(directory: str) -> tuple[list[Package], list[Class], dict[str, str], list[Bean], list[BeanDependency], list[Endpoint], list[MyBatisMapper], list[JpaEntity], list[ConfigFile], list[TestClass], list[SqlStatement], str]:
    """Parse Java project and return parsed entities."""
    logger = get_logger(__name__)
    """Parses all Java files in a directory and returns a tuple of (packages, classes, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name)."""
    
    # Extract project name from directory path
    project_name = extract_project_name(directory)
    packages = {}
    classes = {}
    class_to_package_map = {}  # Maps class_key to package_name

    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith(".java"):
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    file_content = f.read() # Read file content once
                try:
                    tree = javalang.parse.parse(file_content)
                    package_name = tree.package.name if tree.package else ""
                    
                    # Create or update package node
                    if package_name and package_name not in packages:
                        packages[package_name] = Package(
                            name=package_name
                        )
                    elif not package_name:
                        # Handle classes without package (default package)
                        package_name = "default"
                        if package_name not in packages:
                            packages[package_name] = Package(
                                name=package_name
                            )
                    
                    import_map = {}
                    for imp in tree.imports:
                        class_name = imp.path.split('.')[-1]
                        import_map[class_name] = imp.path

                    for _, class_declaration in tree.filter(
                        javalang.tree.ClassDeclaration
                    ):
                        class_name = class_declaration.name
                        class_key = f"{package_name}.{class_name}"
                        
                        # Debug: Check if this is the User class
                        if "User" in class_name:
                            logger.debug(f"Found User class - {class_key}")
                            logger.debug(f"Methods count: {len(class_declaration.methods)}")
                            logger.debug(f"Constructors count: {len(class_declaration.constructors)}")
                        
                        # Extract class source code - use the entire file content
                        class_source = file_content


                        if class_key not in classes:
                            # Parse class annotations
                            class_annotations = parse_annotations(class_declaration.annotations, "class") if hasattr(class_declaration, 'annotations') else []
                            
                            classes[class_key] = Class(
                                name=class_name,
                                logical_name=class_key,  # Add logical_name
                                file_path=file_path,
                                type="class", # Simplified for now
                                source=class_source, # Add class source
                                annotations=class_annotations,
                                package_name=package_name
                            )
                            class_to_package_map[class_key] = package_name
                        
                        # --- Start of new import logic ---
                        for imp in tree.imports:
                            classes[class_key].imports.append(imp.path)
                        # --- End of new import logic ---

                        # --- Start of new inheritance logic ---
                        # Handle 'extends'
                        if class_declaration.extends:
                            superclass_name = class_declaration.extends.name
                            # Try to resolve fully qualified name for superclass
                            if superclass_name in import_map:
                                classes[class_key].superclass = import_map[superclass_name]
                            else:
                                # Assume same package or fully qualified if not in import_map
                                classes[class_key].superclass = f"{package_name}.{superclass_name}" if package_name else superclass_name

                        # Handle 'implements'
                        if class_declaration.implements: # Add this check
                            for impl_ref in class_declaration.implements:
                                interface_name = impl_ref.name
                                # Try to resolve fully qualified name for interface
                                if interface_name in import_map:
                                    classes[class_key].interfaces.append(import_map[interface_name])
                                else:
                                    # Assume same package or fully qualified if not in import_map
                                    classes[class_key].interfaces.append(f"{package_name}.{interface_name}" if package_name else interface_name)
                        # --- End of new inheritance logic ---

                        field_map = {}
                        for field_declaration in class_declaration.fields:
                            for declarator in field_declaration.declarators:
                                field_map[declarator.name] = field_declaration.type.name
                                
                                # Parse field annotations
                                field_annotations = parse_annotations(field_declaration.annotations, "field") if hasattr(field_declaration, 'annotations') else []
                                
                                # Extract initial value if present
                                initial_value = ""
                                if hasattr(declarator, 'initializer') and declarator.initializer:
                                    # Convert the initializer to string representation
                                    if hasattr(declarator.initializer, 'value'):
                                        initial_value = str(declarator.initializer.value)
                                    elif hasattr(declarator.initializer, 'type'):
                                        initial_value = str(declarator.initializer.type)
                                    else:
                                        initial_value = str(declarator.initializer)
                                
                                prop = Property(
                                    name=declarator.name,
                                    logical_name=f"{package_name}.{class_name}.{declarator.name}",
                                    type=field_declaration.type.name,
                                    modifiers=list(field_declaration.modifiers), # Add modifiers
                                    package_name=package_name,
                                    class_name=class_name,
                                    annotations=field_annotations,
                                    initial_value=initial_value
                                )
                                classes[class_key].properties.append(prop)

                        all_declarations = class_declaration.methods + class_declaration.constructors
                        
                        # Debug: Check User class method processing
                        if "User" in class_name:
                            logger.debug(f"Processing User class methods - total declarations: {len(all_declarations)}")
                            for i, decl in enumerate(all_declarations):
                                logger.debug(f"Declaration {i}: {type(decl).__name__} - {decl.name}")
                        
                        for declaration in all_declarations:
                            local_var_map = field_map.copy()
                            params = []
                            for param in declaration.parameters:
                                param_type_name = 'Unknown'
                                if hasattr(param.type, 'name'):
                                    param_type_name = param.type.name
                                local_var_map[param.name] = param_type_name
                                params.append(Property(name=param.name, logical_name=f"{package_name}.{class_name}.{param.name}", type=param_type_name, package_name=package_name, class_name=class_name))

                            if declaration.body:
                                for _, var_decl in declaration.filter(javalang.tree.LocalVariableDeclaration):
                                    for declarator in var_decl.declarators:
                                        local_var_map[declarator.name] = var_decl.type.name
                            
                            if isinstance(declaration, javalang.tree.MethodDeclaration):
                                return_type = declaration.return_type.name if declaration.return_type else "void"
                            else: # ConstructorDeclaration
                                return_type = "constructor"

                            # Extract modifiers
                            modifiers = list(declaration.modifiers)
                            
                            # Parse method annotations
                            method_annotations = parse_annotations(declaration.annotations, "method") if hasattr(declaration, 'annotations') else []

                            # Extract method source code
                            method_source = ""
                            if declaration.position:
                                lines = file_content.splitlines(keepends=True) # Keep line endings
                                start_line = declaration.position.line - 1
                                
                                # Find the end of the method by matching braces
                                brace_count = 0
                                end_line = start_line
                                for i in range(start_line, len(lines)):
                                    line = lines[i]
                                    for char in line:
                                        if char == '{':
                                            brace_count += 1
                                        elif char == '}':
                                            brace_count -= 1
                                            if brace_count == 0:
                                                end_line = i
                                                break
                                    if brace_count == 0:
                                        break
                                
                                method_source = "".join(lines[start_line:end_line + 1])

                            method = Method(
                                name=declaration.name,
                                logical_name=f"{class_key}.{declaration.name}",  # Add logical_name
                                return_type=return_type,
                                parameters=params,
                                modifiers=modifiers,
                                source=method_source, # Add method source
                                package_name=package_name,
                                annotations=method_annotations
                            )
                            classes[class_key].methods.append(method)

                            # Extract method calls with order information
                            call_order = 0
                            for _, invocation in declaration.filter(javalang.tree.MethodInvocation):
                                target_class_name = None
                                resolved_target_package = ""
                                resolved_target_class_name = ""
                                
                                if invocation.qualifier:
                                    # External method call
                                    if invocation.qualifier in local_var_map:
                                        target_class_name = local_var_map[invocation.qualifier]
                                    else:
                                        target_class_name = invocation.qualifier
                                    
                                    if target_class_name:
                                        if target_class_name == "System.out":
                                            resolved_target_package = "java.io"
                                            resolved_target_class_name = "PrintStream"
                                        else:
                                            if target_class_name in import_map:
                                                resolved_target_package = ".".join(import_map[target_class_name].split(".")[:-1])
                                            else:
                                                resolved_target_package = package_name
                                                resolved_target_class_name = target_class_name
                                else:
                                    # Same class method call
                                    resolved_target_package = package_name
                                    resolved_target_class_name = class_name

                                if resolved_target_class_name:
                                    # Get line number from invocation position
                                    line_number = invocation.position.line if invocation.position else 0

                                    call = MethodCall(
                                        source_package=package_name,
                                        source_class=class_name,
                                        source_method=declaration.name,
                                        target_package=resolved_target_package,
                                        target_class=resolved_target_class_name,
                                        target_method=invocation.member,
                                        call_order=call_order,
                                        line_number=line_number,
                                        return_type="void"  # Default return type, can be enhanced later
                                    )
                                    classes[class_key].calls.append(call)
                                    call_order += 1
                        
                        # Check for Lombok @Data annotation and generate methods
                        has_data_annotation = any(ann.name == "Data" for ann in classes[class_key].annotations)
                        if has_data_annotation:
                            logger.debug(f"Found @Data annotation on {class_name}, generating Lombok methods")
                            lombok_methods = generate_lombok_methods(classes[class_key].properties, class_name, package_name)
                            classes[class_key].methods.extend(lombok_methods)
                            logger.debug(f"Generated {len(lombok_methods)} Lombok methods for {class_name}")
                except javalang.parser.JavaSyntaxError as e:
                    print(f"Syntax error in {file_path}: {e}")
                    continue
                except Exception as e:
                    print(f"Error parsing {file_path}: {e}")
                    continue
    
    # Extract beans, analyze dependencies, extract endpoints, extract MyBatis mappers, extract JPA entities, extract config files, and extract test classes
    classes_list = list(classes.values())
    beans = extract_beans_from_classes(classes_list)
    dependencies = analyze_bean_dependencies(classes_list, beans)
    endpoints = extract_endpoints_from_classes(classes_list)
    mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
    jpa_entities = extract_jpa_entities_from_classes(classes_list)
    config_files = extract_config_files(directory)
    test_classes = extract_test_classes_from_classes(classes_list)
    
    # Also extract XML mappers
    xml_mappers = extract_mybatis_xml_mappers(directory)
    mybatis_mappers.extend(xml_mappers)
    
    # Extract SQL statements from MyBatis mappers
    sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
    
    return list(packages.values()), classes_list, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name
```

```python
import os
import yaml
import re
from pathlib import Path

import javalang

from src.models.graph_entities import Class, Method, MethodCall, Field, Package, Annotation, Bean, BeanDependency, Endpoint, MyBatisMapper, MyBatisSqlStatement, MyBatisResultMap, SqlStatement, JpaEntity, JpaColumn, JpaRelationship, ConfigFile, DatabaseConfig, ServerConfig, SecurityConfig, LoggingConfig, TestClass, TestMethod, TestConfiguration
from src.utils.logger import get_logger
from typing import Optional, List, Literal


def extract_project_name(java_source_folder: str) -> str:
    """
    JAVA_SOURCE_FOLDER 경로에서 프로젝트 이름을 추출합니다.
    
    Args:
        java_source_folder: Java 소스 폴더 경로
        
    Returns:
        프로젝트 이름 (마지막 디렉토리명)
    """
    # 경로를 정규화하고 마지막 디렉토리명 추출
    path = Path(java_source_folder).resolve()
    return path.name


def extract_sql_statements_from_mappers(mybatis_mappers: list[MyBatisMapper], project_name: str) -> list[SqlStatement]:
    """
    MyBatis mappers에서 SQL statements를 추출합니다.
    
    Args:
        mybatis_mappers: MyBatis mapper 객체들의 리스트
        project_name: 프로젝트 이름
        
    Returns:
        SqlStatement 객체들의 리스트
    """
    sql_statements = []
    
    for mapper in mybatis_mappers:
        for sql_dict in mapper.sql_statements:
            # MyBatisSqlStatement를 SqlStatement로 변환
            sql_statement = SqlStatement(
                id=sql_dict.get('id', ''),
                sql_type=sql_dict.get('sql_type', ''),
                sql_content=sql_dict.get('sql_content', ''),
                parameter_type=sql_dict.get('parameter_type', ''),
                result_type=sql_dict.get('result_type', ''),
                result_map=sql_dict.get('result_map', ''),
                mapper_name=mapper.name,
                annotations=[],  # TODO: annotations를 파싱하여 추가
                project_name=project_name
            )
            sql_statements.append(sql_statement)
    
    return sql_statements


def parse_annotations(annotations, target_type: str = "class") -> list[Annotation]:
    """Parse Java annotations into Annotation objects.
    
    Args:
        annotations: List of annotation nodes from javalang
        target_type: Type of target ("class", "method", "field")
    """
    result = []
    for annotation in annotations:
        annotation_name = annotation.name
        parameters = {}
        
        # Parse annotation parameters if they exist
        if hasattr(annotation, 'element') and annotation.element:
            for element in annotation.element:
                if hasattr(element, 'name') and hasattr(element, 'value'):
                    parameters[element.name] = element.value.value if hasattr(element.value, 'value') else str(element.value)
        
        result.append(Annotation(
            name=annotation_name,
            parameters=parameters,
            target_type=target_type,
            category=classify_springboot_annotation(annotation_name)
        ))
    
    return result


def classify_springboot_annotation(annotation_name: str) -> str:
    """Classify SpringBoot annotations into categories.
    
    Args:
        annotation_name: Name of the annotation (e.g., "@Component", "@Service")
        
    Returns:
        Category of the annotation
    """
    # Component annotations
    component_annotations = {
        "Component", "Service", "Repository", "Controller", 
        "RestController", "Configuration", "Bean"
    }
    
    # Injection annotations
    injection_annotations = {
        "Autowired", "Resource", "Value", "Qualifier", "Primary"
    }
    
    # Web annotations
    web_annotations = {
        "RequestMapping", "GetMapping", "PostMapping", "PutMapping", 
        "DeleteMapping", "PatchMapping", "RequestParam", "PathVariable",
        "RequestBody", "ResponseBody", "ResponseStatus"
    }
    
    # JPA annotations
    jpa_annotations = {
        "Entity", "Table", "Id", "Column", "OneToMany", "ManyToOne",
        "OneToOne", "ManyToMany", "JoinColumn", "GeneratedValue"
    }
    
    # Test annotations
    test_annotations = {
        "Test", "SpringBootTest", "DataJpaTest", "WebMvcTest",
        "MockBean", "SpyBean", "TestPropertySource"
    }
    
    # Security annotations
    security_annotations = {
        "PreAuthorize", "PostAuthorize", "Secured", "RolesAllowed",
        "EnableWebSecurity", "EnableGlobalMethodSecurity"
    }
    
    # Validation annotations
    validation_annotations = {
        "Valid", "NotNull", "NotBlank", "NotEmpty", "Size", "Min", "Max",
        "Pattern", "Email", "AssertTrue", "AssertFalse"
    }
    
    # MyBatis annotations
    mybatis_annotations = {
        "Mapper", "Select", "Insert", "Update", "Delete", "SelectProvider",
        "InsertProvider", "UpdateProvider", "DeleteProvider", "Results",
        "Result", "One", "Many", "MapKey", "Options", "SelectKey"
    }
    
    if annotation_name in component_annotations:
        return "component"
    elif annotation_name in injection_annotations:
        return "injection"
    elif annotation_name in web_annotations:
        return "web"
    elif annotation_name in jpa_annotations:
        return "jpa"
    elif annotation_name in test_annotations:
        return "test"
    elif annotation_name in security_annotations:
        return "security"
    elif annotation_name in validation_annotations:
        return "validation"
    elif annotation_name in mybatis_annotations:
        return "mybatis"
    else:
        return "other"


def classify_test_annotation(annotation_name: str) -> str:
    """Classify test annotations into categories.
    
    Args:
        annotation_name: Name of the annotation
        
    Returns:
        Category of the test annotation
    """
    # JUnit annotations
    junit_annotations = {
        "Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll",
        "DisplayName", "ParameterizedTest", "ValueSource", "CsvSource",
        "MethodSource", "Timeout", "Disabled", "Nested", "RepeatedTest",
        "Order", "TestMethodOrder", "TestInstance", "TestClassOrder"
    }
    
    # Spring Boot Test annotations
    spring_test_annotations = {
        "SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest",
        "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest",
        "MockBean", "SpyBean", "TestConfiguration", "ActiveProfiles",
        "TestPropertySource", "DirtiesContext", "Transactional",
        "Rollback", "Commit", "Sql", "SqlGroup", "AutoConfigureTestDatabase",
        "AutoConfigureMockMvc", "AutoConfigureWebMvc", "AutoConfigureWebClient",
        "MockMvc", "TestEntityManager", "TestContainers", "DynamicPropertySource"
    }
    
    # TestNG annotations
    testng_annotations = {
        "TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass",
        "BeforeSuite", "AfterSuite", "BeforeGroups", "AfterGroups",
        "DataProvider", "Parameters", "Groups", "Priority", "DependsOnMethods",
        "DependsOnGroups", "ExpectedExceptions", "InvocationCount",
        "SuccessPercentage", "TimeOut"
    }
    
    # Mockito annotations
    mockito_annotations = {
        "Mock", "Spy", "InjectMocks", "Captor", "MockedStatic"
    }
    
    # AssertJ annotations
    assertj_annotations = {
        "AssertJ"
    }
    
    # Other test annotations
    other_test_annotations = {
        "Ignore", "Category", "RunWith", "ExtendWith", "ContextConfiguration"
    }
    
    if annotation_name in junit_annotations:
        return "junit"
    elif annotation_name in spring_test_annotations:
        return "spring_test"
    elif annotation_name in testng_annotations:
        return "testng"
    elif annotation_name in mockito_annotations:
        return "mockito"
    elif annotation_name in assertj_annotations:
        return "assertj"
    elif annotation_name in other_test_annotations:
        return "other_test"
    else:
        return "other"


def extract_beans_from_classes(classes: list[Class]) -> list[Bean]:
    """Extract Spring Beans from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Bean objects
    """
    beans = []
    
    for cls in classes:
        # Check if class has Spring component annotations
        component_annotations = [ann for ann in cls.annotations if ann.category == "component"]
        
        # Also check for @Repository on interfaces
        has_repository_annotation = any(ann.name == "Repository" for ann in cls.annotations)
        
        if component_annotations or has_repository_annotation:
            # Determine bean type based on annotations
            bean_type = "component"  # default
            if any(ann.name in ["Service", "Service"] for ann in cls.annotations):
                bean_type = "service"
            elif any(ann.name in ["Repository", "Repository"] for ann in cls.annotations):
                bean_type = "repository"
            elif any(ann.name in ["Controller", "RestController"] for ann in cls.annotations):
                bean_type = "controller"
            elif any(ann.name in ["Configuration", "Configuration"] for ann in cls.annotations):
                bean_type = "configuration"
            
            # Determine scope (default is singleton)
            scope = "singleton"
            for ann in cls.annotations:
                if ann.name == "Scope":
                    if "value" in ann.parameters:
                        scope = ann.parameters["value"]
                    elif "prototype" in str(ann.parameters):
                        scope = "prototype"
                    elif "request" in str(ann.parameters):
                        scope = "request"
                    elif "session" in str(ann.parameters):
                        scope = "session"
            
            # Create bean name (use class name with first letter lowercase)
            bean_name = cls.name[0].lower() + cls.name[1:] if cls.name else cls.name
            
            # Check for @Bean methods in configuration classes
            bean_methods = []
            if bean_type == "configuration":
                for method in cls.methods:
                    if any(ann.name == "Bean" for ann in method.annotations):
                        bean_methods.append(method)
            
            bean = Bean(
                name=bean_name,
                type=bean_type,
                scope=scope,
                class_name=cls.name,
                package_name=cls.package_name,
                annotation_names=[ann.name for ann in cls.annotations] if cls.annotations else [],
                method_count=len(bean_methods) if bean_type == "configuration" else len(cls.methods) if cls.methods else 0,
                property_count=len(cls.properties) if cls.properties else 0
            )
            beans.append(bean)
    
    return beans


def analyze_bean_dependencies(classes: list[Class], beans: list[Bean]) -> list[BeanDependency]:
    """Analyze dependencies between Spring Beans.
    
    Args:
        classes: List of parsed Class objects
        beans: List of Bean objects
        
    Returns:
        List of BeanDependency objects
    """
    dependencies = []
    
    # Create a mapping from class names to bean names
    class_to_bean = {}
    for bean in beans:
        class_to_bean[bean.class_name] = bean.name
    
    for cls in classes:
        # Check if this class is a bean
        if cls.name not in class_to_bean:
            continue
            
        source_bean = class_to_bean[cls.name]
        
        # Analyze field injections (@Autowired, @Resource, @Value)
        for prop in cls.properties:
            if any(ann.category == "injection" for ann in prop.annotations):
                # Try to determine target bean from field type
                target_bean = None
                field_type = prop.type
                
                # Look for exact class name match
                if field_type in class_to_bean:
                    target_bean = class_to_bean[field_type]
                else:
                    # Look for interface implementations (simplified - just check if type matches any bean class name)
                    for bean in beans:
                        if field_type == bean.class_name:
                            target_bean = bean.name
                            break
                
                if target_bean:
                    injection_type = "field"
                    for ann in prop.annotations:
                        if ann.name == "Autowired":
                            injection_type = "field"
                        elif ann.name == "Resource":
                            injection_type = "field"
                        elif ann.name == "Value":
                            injection_type = "field"
                    
                    dependency = BeanDependency(
                        source_bean=source_bean,
                        target_bean=target_bean,
                        injection_type=injection_type,
                        field_name=prop.name
                    )
                    dependencies.append(dependency)
        
        # Analyze constructor injections
        for method in cls.methods:
            if method.name == cls.name:  # Constructor
                for param in method.parameters:
                    if any(ann.category == "injection" for ann in param.annotations):
                        target_bean = None
                        param_type = param.type
                        
                        if param_type in class_to_bean:
                            target_bean = class_to_bean[param_type]
                        else:
                            # Look for interface implementations (simplified)
                            for bean in beans:
                                if param_type == bean.class_name:
                                    target_bean = bean.name
                                    break
                        
                        if target_bean:
                            dependency = BeanDependency(
                                source_bean=source_bean,
                                target_bean=target_bean,
                                injection_type="constructor",
                                parameter_name=param.name
                            )
                            dependencies.append(dependency)
        
        # Analyze setter injections
        for method in cls.methods:
            if method.name.startswith("set") and len(method.parameters) == 1:
                if any(ann.category == "injection" for ann in method.annotations):
                    param = method.parameters[0]
                    target_bean = None
                    param_type = param.type
                    
                    if param_type in class_to_bean:
                        target_bean = class_to_bean[param_type]
                    else:
                        # Look for interface implementations (simplified)
                        for bean in beans:
                            if param_type == bean.class_name:
                                target_bean = bean.name
                                break
                    
                    if target_bean:
                        dependency = BeanDependency(
                            source_bean=source_bean,
                            target_bean=target_bean,
                            injection_type="setter",
                            method_name=method.name,
                            parameter_name=param.name
                        )
                        dependencies.append(dependency)
    
    return dependencies


def extract_endpoints_from_classes(classes: list[Class]) -> list[Endpoint]:
    """Extract REST API endpoints from controller classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Endpoint objects
    """
    endpoints = []
    
    for cls in classes:
        # Check if class is a controller
        is_controller = any(ann.name in ["Controller", "RestController"] for ann in cls.annotations)
        
        if not is_controller:
            continue
            
        # Get class-level path mapping
        class_path = ""
        for ann in cls.annotations:
            if ann.name == "RequestMapping":
                if "value" in ann.parameters:
                    class_path = ann.parameters["value"]
                break
        
        # Process each method in the controller
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
                
            # Check if method has web mapping annotations
            web_annotations = [ann for ann in method.annotations if ann.category == "web"]
            
            if not web_annotations:
                continue
            
            # Extract endpoint information
            endpoint_path = ""
            http_method = "GET"  # default
            
            for ann in web_annotations:
                if ann.name in ["RequestMapping", "GetMapping", "PostMapping", "PutMapping", "DeleteMapping", "PatchMapping"]:
                    # Extract path
                    if "value" in ann.parameters:
                        endpoint_path = ann.parameters["value"]
                    elif "path" in ann.parameters:
                        endpoint_path = ann.parameters["path"]
                    
                    # Extract HTTP method
                    if ann.name == "GetMapping":
                        http_method = "GET"
                    elif ann.name == "PostMapping":
                        http_method = "POST"
                    elif ann.name == "PutMapping":
                        http_method = "PUT"
                    elif ann.name == "DeleteMapping":
                        http_method = "DELETE"
                    elif ann.name == "PatchMapping":
                        http_method = "PATCH"
                    elif ann.name == "RequestMapping":
                        if "method" in ann.parameters:
                            method_value = ann.parameters["method"]
                            if isinstance(method_value, list) and len(method_value) > 0:
                                http_method = method_value[0]
                            else:
                                http_method = str(method_value)
                        else:
                            http_method = "GET"  # default for RequestMapping
                    break
            
            # Build full path
            full_path = class_path
            if endpoint_path:
                if full_path and not full_path.endswith("/") and not endpoint_path.startswith("/"):
                    full_path += "/"
                full_path += endpoint_path
            elif not full_path:
                full_path = "/"
            
            # Extract method parameters
            parameters = []
            for param in method.parameters:
                param_info = {
                    "name": param.name,
                    "type": param.type,
                    "annotations": [ann.name for ann in param.annotations if ann.category == "web"]
                }
                parameters.append(param_info)
            
            # Extract return type
            return_type = method.return_type if method.return_type != "constructor" else "void"
            
            # Create endpoint
            endpoint = Endpoint(
                path=endpoint_path or "/",
                method=http_method,
                controller_class=cls.name,
                handler_method=method.name,
                parameters=parameters,
                return_type=return_type,
                annotations=[ann.name for ann in web_annotations],
                full_path=full_path
            )
            endpoints.append(endpoint)
    
    return endpoints


def extract_mybatis_mappers_from_classes(classes: list[Class]) -> list[MyBatisMapper]:
    """Extract MyBatis Mappers from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for cls in classes:
        # Check if class is a MyBatis Mapper interface
        is_mapper = any(ann.name == "Mapper" for ann in cls.annotations)
        
        if not is_mapper:
            continue
        
        # Extract mapper methods with MyBatis annotations
        mapper_methods = []
        sql_statements = []
        
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
            
            # Check if method has MyBatis annotations
            mybatis_annotations = [ann for ann in method.annotations if ann.category == "mybatis"]
            
            if not mybatis_annotations:
                continue
            
            # Extract SQL statement information
            sql_type = "SELECT"  # default
            sql_content = ""
            parameter_type = ""
            result_type = ""
            result_map = ""
            
            for ann in mybatis_annotations:
                if ann.name in ["Select", "SelectProvider"]:
                    sql_type = "SELECT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Insert", "InsertProvider"]:
                    sql_type = "INSERT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Update", "UpdateProvider"]:
                    sql_type = "UPDATE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Delete", "DeleteProvider"]:
                    sql_type = "DELETE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                
                # Extract parameter and result type information
                if "parameterType" in ann.parameters:
                    parameter_type = ann.parameters["parameterType"]
                if "resultType" in ann.parameters:
                    result_type = ann.parameters["resultType"]
                if "resultMap" in ann.parameters:
                    result_map = ann.parameters["resultMap"]
            
            # Create method info
            method_info = {
                "name": method.name,
                "return_type": method.return_type,
                "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            mapper_methods.append(method_info)
            
            # Create SQL statement info
            sql_statement = {
                "id": method.name,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            sql_statements.append(sql_statement)
        
        # Create mapper
        mapper = MyBatisMapper(
            name=cls.name,
            type="interface",
            namespace=f"{cls.package_name}.{cls.name}",
            methods=mapper_methods,
            sql_statements=sql_statements,
            file_path=cls.file_path,
            package_name=cls.package_name
        )
        mappers.append(mapper)
    
    return mappers


def parse_mybatis_xml_file(file_path: str) -> MyBatisMapper:
    """Parse MyBatis XML mapper file.
    
    Args:
        file_path: Path to the XML mapper file
        
    Returns:
        MyBatisMapper object
    """
    import xml.etree.ElementTree as ET
    
    try:
        tree = ET.parse(file_path)
        root = tree.getroot()
        
        # Extract namespace
        namespace = root.get("namespace", "")
        
        # Extract SQL statements
        sql_statements = []
        for statement in root.findall(".//*[@id]"):
            statement_id = statement.get("id")
            tag_name = statement.tag.lower()
            
            # Determine SQL type
            sql_type = "SELECT"
            if tag_name == "insert":
                sql_type = "INSERT"
            elif tag_name == "update":
                sql_type = "UPDATE"
            elif tag_name == "delete":
                sql_type = "DELETE"
            
            # Extract SQL content
            sql_content = statement.text.strip() if statement.text else ""
            
            # Extract parameter and result information
            parameter_type = statement.get("parameterType", "")
            result_type = statement.get("resultType", "")
            result_map = statement.get("resultMap", "")
            
            sql_statement = {
                "id": statement_id,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": []
            }
            sql_statements.append(sql_statement)
        
        # Extract ResultMaps
        result_maps = []
        for result_map in root.findall(".//resultMap"):
            result_map_id = result_map.get("id")
            result_map_type = result_map.get("type", "")
            
            properties = []
            for property_elem in result_map.findall(".//result"):
                prop = {
                    "property": property_elem.get("property", ""),
                    "column": property_elem.get("column", ""),
                    "jdbc_type": property_elem.get("jdbcType", "")
                }
                properties.append(prop)
            
            result_map_info = {
                "id": result_map_id,
                "type": result_map_type,
                "properties": properties,
                "associations": [],
                "collections": []
            }
            result_maps.append(result_map_info)
        
        # Create mapper
        mapper_name = namespace.split(".")[-1] if namespace else os.path.basename(file_path).replace(".xml", "")
        package_name = ".".join(namespace.split(".")[:-1]) if namespace else ""
        
        mapper = MyBatisMapper(
            name=mapper_name,
            type="xml",
            namespace=namespace,
            methods=[],  # XML mappers don't have Java methods
            sql_statements=sql_statements,
            file_path=file_path,
            package_name=package_name
        )
        
        return mapper
        
    except ET.ParseError as e:
        print(f"Error parsing XML file {file_path}: {e}")
        return None
    except Exception as e:
        print(f"Error reading XML file {file_path}: {e}")
        return None


def extract_mybatis_xml_mappers(directory: str) -> list[MyBatisMapper]:
    """Extract MyBatis XML mappers from directory.
    
    Args:
        directory: Directory to search for XML mapper files
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith("Mapper.xml") or file.endswith("Dao.xml"):
                file_path = os.path.join(root, file)
                mapper = parse_mybatis_xml_file(file_path)
                if mapper:
                    mappers.append(mapper)
    
    return mappers


def extract_jpa_entities_from_classes(classes: list[Class]) -> list[JpaEntity]:
    """Extract JPA Entities from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of JpaEntity objects
    """
    entities = []
    
    for cls in classes:
        # Check if class is a JPA Entity
        is_entity = any(ann.name == "Entity" for ann in cls.annotations)
        
        if not is_entity:
            continue
        
        # Extract table name
        table_name = cls.name.lower()  # default table name
        for ann in cls.annotations:
            if ann.name == "Table":
                if "name" in ann.parameters:
                    table_name = ann.parameters["name"]
                break
        
        # Extract columns from properties
        columns = []
        relationships = []
        
        for prop in cls.properties:
            # Check if property has JPA column annotations
            jpa_annotations = [ann for ann in prop.annotations if ann.category == "jpa"]
            
            if jpa_annotations:
                # Extract column information
                column_name = prop.name  # default column name
                nullable = True
                unique = False
                length = 0
                precision = 0
                scale = 0
                
                for ann in jpa_annotations:
                    if ann.name == "Column":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                        if "nullable" in ann.parameters:
                            nullable = ann.parameters["nullable"]
                        if "unique" in ann.parameters:
                            unique = ann.parameters["unique"]
                        if "length" in ann.parameters:
                            length = ann.parameters["length"]
                        if "precision" in ann.parameters:
                            precision = ann.parameters["precision"]
                        if "scale" in ann.parameters:
                            scale = ann.parameters["scale"]
                    elif ann.name == "Id":
                        column_name = "id"  # Primary key column
                        nullable = False
                        unique = True
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                
                # Check for relationship annotations
                relationship_type = None
                target_entity = ""
                mapped_by = ""
                join_column = ""
                join_table = ""
                cascade = []
                fetch = "LAZY"
                
                for ann in jpa_annotations:
                    if ann.name in ["OneToOne", "OneToMany", "ManyToOne", "ManyToMany"]:
                        relationship_type = ann.name
                        if "targetEntity" in ann.parameters:
                            target_entity = ann.parameters["targetEntity"]
                        if "mappedBy" in ann.parameters:
                            mapped_by = ann.parameters["mappedBy"]
                        if "cascade" in ann.parameters:
                            cascade = ann.parameters["cascade"] if isinstance(ann.parameters["cascade"], list) else [ann.parameters["cascade"]]
                        if "fetch" in ann.parameters:
                            fetch = ann.parameters["fetch"]
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            join_column = ann.parameters["name"]
                    elif ann.name == "JoinTable":
                        if "name" in ann.parameters:
                            join_table = ann.parameters["name"]
                
                # Create column info
                column_info = {
                    "property_name": prop.name,
                    "column_name": column_name,
                    "data_type": prop.type,
                    "nullable": nullable,
                    "unique": unique,
                    "length": length,
                    "precision": precision,
                    "scale": scale,
                    "annotations": [ann.name for ann in jpa_annotations]
                }
                columns.append(column_info)
                
                # Create relationship info if it's a relationship
                if relationship_type:
                    relationship_info = {
                        "type": relationship_type,
                        "target_entity": target_entity,
                        "mapped_by": mapped_by,
                        "join_column": join_column,
                        "join_table": join_table,
                        "cascade": cascade,
                        "fetch": fetch,
                        "annotations": [ann.name for ann in jpa_annotations]
                    }
                    relationships.append(relationship_info)
        
        # Create entity
        entity = JpaEntity(
            name=cls.name,
            table_name=table_name,
            columns=columns,
            relationships=relationships,
            annotations=[ann.name for ann in cls.annotations if ann.category == "jpa"],
            package_name=cls.package_name,
            file_path=cls.file_path
        )
        entities.append(entity)
    
    return entities


def parse_yaml_config(file_path: str) -> ConfigFile:
    """Parse YAML configuration file.
    
    Args:
        file_path: Path to the YAML file
        
    Returns:
        ConfigFile object
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = yaml.safe_load(f)
        
        if not content:
            content = {}
        
        # Extract file info
        file_name = os.path.basename(file_path)
        file_type = "yaml" if file_path.endswith('.yaml') else "yml"
        
        # Extract profiles
        profiles = []
        if 'spring' in content and 'profiles' in content['spring']:
            if 'active' in content['spring']['profiles']:
                profiles = content['spring']['profiles']['active']
                if isinstance(profiles, str):
                    profiles = [profiles]
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        # Extract sections
        sections = []
        for key, value in content.items():
            if isinstance(value, dict):
                sections.append({
                    "name": key,
                    "properties": value,
                    "type": "section"
                })
        
        return ConfigFile(
            name=file_name,
            file_path=file_path,
            file_type=file_type,
            properties=content,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing YAML file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="yaml",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def parse_properties_config(file_path: str) -> ConfigFile:
    """Parse Properties configuration file.
    
    Args:
        file_path: Path to the properties file
        
    Returns:
        ConfigFile object
    """
    try:
        properties = {}
        sections = []
        profiles = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                
                # Skip empty lines and comments
                if not line or line.startswith('#'):
                    continue
                
                # Parse key=value pairs
                if '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    
                    # Remove quotes if present
                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]
                    elif value.startswith("'") and value.endswith("'"):
                        value = value[1:-1]
                    
                    properties[key] = value
                    
                    # Check for profiles
                    if key == 'spring.profiles.active':
                        profiles = [p.strip() for p in value.split(',')]
        
        # Group properties by section
        section_map = {}
        for key, value in properties.items():
            if '.' in key:
                section = key.split('.')[0]
                if section not in section_map:
                    section_map[section] = {}
                section_map[section][key] = value
            else:
                if 'root' not in section_map:
                    section_map['root'] = {}
                section_map['root'][key] = value
        
        for section_name, section_props in section_map.items():
            sections.append({
                "name": section_name,
                "properties": section_props,
                "type": "section"
            })
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties=properties,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing Properties file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def extract_database_config(config_file: ConfigFile) -> DatabaseConfig:
    """Extract database configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        DatabaseConfig object
    """
    db_config = DatabaseConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        spring_config = config_file.properties.get('spring', {})
        datasource_config = spring_config.get('datasource', {})
        jpa_config = spring_config.get('jpa', {})
        
        db_config.driver = datasource_config.get('driver-class-name', '')
        db_config.url = datasource_config.get('url', '')
        db_config.username = datasource_config.get('username', '')
        db_config.password = datasource_config.get('password', '')
        db_config.dialect = jpa_config.get('database-platform', '')
        db_config.hibernate_ddl_auto = jpa_config.get('hibernate', {}).get('ddl-auto', '')
        db_config.show_sql = jpa_config.get('show-sql', False)
        db_config.format_sql = jpa_config.get('properties', {}).get('hibernate', {}).get('format_sql', False)
        
        # Store additional JPA properties
        if 'properties' in jpa_config:
            db_config.jpa_properties = jpa_config['properties']
    
    else:
        # Properties format
        props = config_file.properties
        
        db_config.driver = props.get('spring.datasource.driver-class-name', '')
        db_config.url = props.get('spring.datasource.url', '')
        db_config.username = props.get('spring.datasource.username', '')
        db_config.password = props.get('spring.datasource.password', '')
        db_config.dialect = props.get('spring.jpa.database-platform', '')
        db_config.hibernate_ddl_auto = props.get('spring.jpa.hibernate.ddl-auto', '')
        db_config.show_sql = props.get('spring.jpa.show-sql', 'false').lower() == 'true'
        db_config.format_sql = props.get('spring.jpa.properties.hibernate.format_sql', 'false').lower() == 'true'
        
        # Store additional JPA properties
        jpa_props = {}
        for key, value in props.items():
            if key.startswith('spring.jpa.properties.'):
                jpa_props[key] = value
        db_config.jpa_properties = jpa_props
    
    return db_config


def extract_server_config(config_file: ConfigFile) -> ServerConfig:
    """Extract server configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        ServerConfig object
    """
    server_config = ServerConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        server_props = config_file.properties.get('server', {})
        
        server_config.port = server_props.get('port', 8080)
        server_config.context_path = server_props.get('servlet', {}).get('context-path', '')
        server_config.servlet_path = server_props.get('servlet', {}).get('path', '')
        
        # SSL configuration
        ssl_config = server_props.get('ssl', {})
        server_config.ssl_enabled = bool(ssl_config)
        server_config.ssl_key_store = ssl_config.get('key-store', '')
        server_config.ssl_key_store_password = ssl_config.get('key-store-password', '')
        server_config.ssl_key_store_type = ssl_config.get('key-store-type', '')
    
    else:
        # Properties format
        props = config_file.properties
        
        server_config.port = int(props.get('server.port', '8080'))
        server_config.context_path = props.get('server.servlet.context-path', '')
        server_config.servlet_path = props.get('server.servlet.path', '')
        
        # SSL configuration
        server_config.ssl_enabled = any(key.startswith('server.ssl.') for key in props.keys())
        server_config.ssl_key_store = props.get('server.ssl.key-store', '')
        server_config.ssl_key_store_password = props.get('server.ssl.key-store-password', '')
        server_config.ssl_key_store_type = props.get('server.ssl.key-store-type', '')
    
    return server_config


def extract_security_config(config_file: ConfigFile) -> SecurityConfig:
    """Extract security configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        SecurityConfig object
    """
    security_config = SecurityConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        security_props = config_file.properties.get('security', {})
        jwt_props = security_props.get('jwt', {})
        cors_props = security_props.get('cors', {})
        
        security_config.enabled = bool(security_props)
        security_config.authentication_type = security_props.get('authentication-type', '')
        security_config.jwt_secret = jwt_props.get('secret', '')
        security_config.jwt_expiration = jwt_props.get('expiration', 0)
        security_config.cors_allowed_origins = cors_props.get('allowed-origins', [])
        security_config.cors_allowed_methods = cors_props.get('allowed-methods', [])
        security_config.cors_allowed_headers = cors_props.get('allowed-headers', [])
    
    else:
        # Properties format
        props = config_file.properties
        
        security_config.enabled = any(key.startswith('security.') for key in props.keys())
        security_config.authentication_type = props.get('security.authentication-type', '')
        security_config.jwt_secret = props.get('security.jwt.secret', '')
        security_config.jwt_expiration = int(props.get('security.jwt.expiration', '0'))
        
        # CORS configuration
        origins = props.get('security.cors.allowed-origins', '')
        if origins:
            security_config.cors_allowed_origins = [o.strip() for o in origins.split(',')]
        
        methods = props.get('security.cors.allowed-methods', '')
        if methods:
            security_config.cors_allowed_methods = [m.strip() for m in methods.split(',')]
        
        headers = props.get('security.cors.allowed-headers', '')
        if headers:
            security_config.cors_allowed_headers = [h.strip() for h in headers.split(',')]
    
    return security_config


def extract_logging_config(config_file: ConfigFile) -> LoggingConfig:
    """Extract logging configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        LoggingConfig object
    """
    logging_config = LoggingConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        logging_props = config_file.properties.get('logging', {})
        
        logging_config.level = logging_props.get('level', {}).get('root', 'INFO')
        logging_config.pattern = logging_props.get('pattern', {}).get('console', '')
        logging_config.file_path = logging_props.get('file', {}).get('name', '')
        logging_config.max_file_size = logging_props.get('file', {}).get('max-size', '')
        logging_config.max_history = logging_props.get('file', {}).get('max-history', 0)
        logging_config.console_output = logging_props.get('console', {}).get('enabled', True)
    
    else:
        # Properties format
        props = config_file.properties
        
        logging_config.level = props.get('logging.level.root', 'INFO')
        logging_config.pattern = props.get('logging.pattern.console', '')
        logging_config.file_path = props.get('logging.file.name', '')
        logging_config.max_file_size = props.get('logging.file.max-size', '')
        logging_config.max_history = int(props.get('logging.file.max-history', '0'))
        logging_config.console_output = props.get('logging.console.enabled', 'true').lower() == 'true'
    
    return logging_config


def extract_config_files(directory: str) -> list[ConfigFile]:
    """Extract configuration files from directory.
    
    Args:
        directory: Directory to search for config files
        
    Returns:
        List of ConfigFile objects
    """
    config_files = []
    
    # Common config file patterns
    config_patterns = [
        "application.yml",
        "application.yaml", 
        "application.properties",
        "application-*.properties",
        "bootstrap.yml",
        "bootstrap.yaml",
        "bootstrap.properties"
    ]
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            # Check if file matches any config pattern
            is_config_file = False
            for pattern in config_patterns:
                if pattern == file or (pattern.endswith('*') and file.startswith(pattern[:-1])):
                    is_config_file = True
                    break
            
            if is_config_file:
                file_path = os.path.join(root, file)
                
                if file.endswith(('.yml', '.yaml')):
                    config_file = parse_yaml_config(file_path)
                elif file.endswith('.properties'):
                    config_file = parse_properties_config(file_path)
                else:
                    continue
                
                config_files.append(config_file)
    
    return config_files


def extract_test_classes_from_classes(classes: list[Class]) -> list[TestClass]:
    """Extract test classes from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of TestClass objects
    """
    test_classes = []
    
    for cls in classes:
        # Check if class is a test class
        test_annotations = [ann for ann in cls.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
        
        if not test_annotations:
            continue
        
        # Determine test framework and type
        test_framework = "junit"  # default
        test_type = "unit"  # default
        
        for ann in test_annotations:
            if ann.name in ["SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest", "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest"]:
                test_framework = "spring_test"
                if ann.name == "SpringBootTest":
                    test_type = "integration"
                else:
                    test_type = "slice"
            elif ann.name in ["TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass"]:
                test_framework = "testng"
            elif ann.name in ["Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll"]:
                test_framework = "junit"
        
        # Extract test methods
        test_methods = []
        setup_methods = []
        
        for method in cls.methods:
            method_annotations = [ann.name for ann in method.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
            
            if method_annotations:
                # Check if it's a setup/teardown method
                if any(ann in method_annotations for ann in ["BeforeEach", "AfterEach", "BeforeAll", "AfterAll", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass", "BeforeSuite", "AfterSuite"]):
                    setup_methods.append({
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters]
                    })
                else:
                    # Regular test method
                    test_method_info = {
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                        "assertions": [],
                        "mock_calls": [],
                        "test_data": [],
                        "expected_exceptions": [],
                        "timeout": 0,
                        "display_name": ""
                    }
                    
                    # Extract display name
                    for ann in method.annotations:
                        if ann.name == "DisplayName" and "value" in ann.parameters:
                            test_method_info["display_name"] = ann.parameters["value"]
                        elif ann.name == "Timeout" and "value" in ann.parameters:
                            test_method_info["timeout"] = ann.parameters["value"]
                    
                    # Extract expected exceptions
                    for ann in method.annotations:
                        if ann.name == "ExpectedExceptions" and "value" in ann.parameters:
                            test_method_info["expected_exceptions"] = ann.parameters["value"] if isinstance(ann.parameters["value"], list) else [ann.parameters["value"]]
                    
                    test_methods.append(test_method_info)
        
        # Extract mock dependencies
        mock_dependencies = []
        for prop in cls.properties:
            prop_annotations = [ann.name for ann in prop.annotations if classify_test_annotation(ann.name) in ["mockito", "spring_test"]]
            if prop_annotations:
                mock_dependencies.append({
                    "name": prop.name,
                    "type": prop.type,
                    "annotations": prop_annotations,
                    "mock_type": "mock" if "Mock" in prop_annotations else "spy" if "Spy" in prop_annotations else "bean"
                })
        
        # Extract test configurations
        test_configurations = []
        for ann in cls.annotations:
            if ann.name in ["TestConfiguration", "ActiveProfiles", "TestPropertySource"]:
                config_info = {
                    "name": ann.name,
                    "type": "configuration" if ann.name == "TestConfiguration" else "profile" if ann.name == "ActiveProfiles" else "property",
                    "properties": ann.parameters,
                    "active_profiles": ann.parameters.get("value", []) if ann.name == "ActiveProfiles" else [],
                    "test_slices": [],
                    "mock_beans": [],
                    "spy_beans": []
                }
                test_configurations.append(config_info)
        
        # Create test class
        test_class = TestClass(
            name=cls.name,
            package_name=cls.package_name,
            test_framework=test_framework,
            test_type=test_type,
            annotations=[ann.name for ann in test_annotations],
            test_methods=test_methods,
            setup_methods=setup_methods,
            mock_dependencies=mock_dependencies,
            test_configurations=test_configurations,
            file_path=cls.file_path
        )
        test_classes.append(test_class)
    
    return test_classes


def analyze_test_methods(test_class: TestClass, class_obj: Class) -> list[TestMethod]:
    """Analyze test methods for assertions, mock calls, and test data.
    
    Args:
        test_class: TestClass object
        class_obj: Original Class object
        
    Returns:
        List of analyzed TestMethod objects
    """
    test_methods = []
    
    for method_info in test_class.test_methods:
        # Find the corresponding method in the class
        method_obj = None
        for method in class_obj.methods:
            if method.name == method_info["name"]:
                method_obj = method
                break
        
        if not method_obj:
            continue
        
        # Analyze method source code for assertions and mock calls
        assertions = []
        mock_calls = []
        test_data = []
        
        if method_obj.source:
            source_code = method_obj.source
            
            # Find assertions (JUnit, AssertJ, etc.)
            assertion_patterns = [
                r'assert\w+\(',  # JUnit assertions
                r'assertThat\(',  # AssertJ
                r'assertEquals\(',  # JUnit
                r'assertTrue\(',  # JUnit
                r'assertFalse\(',  # JUnit
                r'assertNotNull\(',  # JUnit
                r'assertNull\(',  # JUnit
                r'assertThrows\(',  # JUnit 5
                r'assertDoesNotThrow\(',  # JUnit 5
                r'verify\(',  # Mockito verify
                r'when\(',  # Mockito when
                r'then\(',  # Mockito then
                r'given\(',  # BDDMockito given
                r'willReturn\(',  # Mockito willReturn
                r'willThrow\(',  # Mockito willThrow
            ]
            
            for pattern in assertion_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    assertions.append({
                        "type": match,
                        "line": source_code.find(match) + 1
                    })
            
            # Find mock calls
            mock_call_patterns = [
                r'(\w+)\.(\w+)\(',  # Method calls on objects
                r'mock\(',  # Mockito mock creation
                r'spy\(',  # Mockito spy creation
                r'@Mock\s+(\w+)',  # @Mock annotation
                r'@Spy\s+(\w+)',  # @Spy annotation
                r'@InjectMocks\s+(\w+)',  # @InjectMocks annotation
            ]
            
            for pattern in mock_call_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        mock_calls.append({
                            "object": match[0],
                            "method": match[1],
                            "type": "method_call"
                        })
                    else:
                        mock_calls.append({
                            "type": match,
                            "line": source_code.find(match) + 1
                        })
            
            # Find test data setup
            test_data_patterns = [
                r'new\s+(\w+)\(',  # Object creation
                r'(\w+)\s*=\s*new\s+(\w+)\(',  # Variable assignment with new
                r'@ValueSource\(',  # JUnit 5 @ValueSource
                r'@CsvSource\(',  # JUnit 5 @CsvSource
                r'@MethodSource\(',  # JUnit 5 @MethodSource
            ]
            
            for pattern in test_data_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        test_data.append({
                            "variable": match[0],
                            "type": match[1],
                            "pattern": "object_creation"
                        })
                    else:
                        test_data.append({
                            "type": match,
                            "pattern": "annotation"
                        })
        
        # Create TestMethod object
        test_method = TestMethod(
            name=method_info["name"],
            return_type=method_info["return_type"],
            annotations=method_info["annotations"],
            assertions=assertions,
            mock_calls=mock_calls,
            test_data=test_data,
            expected_exceptions=method_info["expected_exceptions"],
            timeout=method_info["timeout"],
            display_name=method_info["display_name"]
        )
        test_methods.append(test_method)
    
    return test_methods


def generate_lombok_methods(properties: list[Field], class_name: str, package_name: str) -> list[Method]:
    """Generate Lombok @Data methods (getters, setters, equals, hashCode, toString) for properties."""
    methods = []
    
    # Generate getters and setters for each property
    for prop in properties:
        # Getter
        getter_name = f"get{prop.name[0].upper()}{prop.name[1:]}"
        if prop.type == "Boolean" and prop.name.startswith("is"):
            # For boolean fields starting with 'is', use the field name as getter
            getter_name = prop.name
        
        getter = Method(
            name=getter_name,
            logical_name=f"{package_name}.{class_name}.{getter_name}",
            return_type=prop.type,
            parameters=[],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[]
        )
        methods.append(getter)
        
        # Setter
        setter_name = f"set{prop.name[0].upper()}{prop.name[1:]}"
        setter_param = Field(
            name=prop.name,
            logical_name=f"{package_name}.{class_name}.{prop.name}",
            type=prop.type,
            package_name=package_name,
            class_name=class_name
        )
        
        setter = Method(
            name=setter_name,
            logical_name=f"{package_name}.{class_name}.{setter_name}",
            return_type="void",
            parameters=[setter_param],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[]
        )
        methods.append(setter)
    
    # Generate equals method
    equals_method = Method(
        name="equals",
        logical_name=f"{package_name}.{class_name}.equals",
        return_type="boolean",
        parameters=[Field(name="obj", logical_name=f"{package_name}.{class_name}.obj", type="Object", package_name=package_name, class_name=class_name)],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(equals_method)
    
    # Generate hashCode method
    hashcode_method = Method(
        name="hashCode",
        logical_name=f"{package_name}.{class_name}.hashCode",
        return_type="int",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(hashcode_method)
    
    # Generate toString method
    tostring_method = Method(
        name="toString",
        logical_name=f"{package_name}.{class_name}.toString",
        return_type="String",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(tostring_method)
    
    return methods


def parse_java_project(directory: str) -> tuple[list[Package], list[Class], dict[str, str], list[Bean], list[BeanDependency], list[Endpoint], list[MyBatisMapper], list[JpaEntity], list[ConfigFile], list[TestClass], list[SqlStatement], str]:
    """Parse Java project and return parsed entities."""
    logger = get_logger(__name__)
    """Parses all Java files in a directory and returns a tuple of (packages, classes, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name)."""
    
    # Extract project name from directory path
    project_name = extract_project_name(directory)
    packages = {}
    classes = {}
    class_to_package_map = {}  # Maps class_key to package_name

    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith(".java"):
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    file_content = f.read() # Read file content once
                try:
                    tree = javalang.parse.parse(file_content)
                    package_name = tree.package.name if tree.package else ""
                    
                    # Create or update package node
                    if package_name and package_name not in packages:
                        packages[package_name] = Package(
                            name=package_name
                        )
                    elif not package_name:
                        # Handle classes without package (default package)
                        package_name = "default"
                        if package_name not in packages:
                            packages[package_name] = Package(
                                name=package_name
                            )
                    
                    import_map = {}
                    for imp in tree.imports:
                        class_name = imp.path.split('.')[-1]
                        import_map[class_name] = imp.path

                    for _, class_declaration in tree.filter(
                        javalang.tree.ClassDeclaration
                    ):
                        class_name = class_declaration.name
                        class_key = f"{package_name}.{class_name}"
                        
                        # Debug: Check if this is the User class
                        if "User" in class_name:
                            logger.debug(f"Found User class - {class_key}")
                            logger.debug(f"Methods count: {len(class_declaration.methods)}")
                            logger.debug(f"Constructors count: {len(class_declaration.constructors)}")
                        
                        # Extract class source code - use the entire file content
                        class_source = file_content


                        if class_key not in classes:
                            # Parse class annotations
                            class_annotations = parse_annotations(class_declaration.annotations, "class") if hasattr(class_declaration, 'annotations') else []
                            
                            classes[class_key] = Class(
                                name=class_name,
                                logical_name=class_key,  # Add logical_name
                                file_path=file_path,
                                type="class", # Simplified for now
                                source=class_source, # Add class source
                                annotations=class_annotations,
                                package_name=package_name
                            )
                            class_to_package_map[class_key] = package_name
                        
                        # --- Start of new import logic ---
                        for imp in tree.imports:
                            classes[class_key].imports.append(imp.path)
                        # --- End of new import logic ---

                        # --- Start of new inheritance logic ---
                        # Handle 'extends'
                        if class_declaration.extends:
                            superclass_name = class_declaration.extends.name
                            # Try to resolve fully qualified name for superclass
                            if superclass_name in import_map:
                                classes[class_key].superclass = import_map[superclass_name]
                            else:
                                # Assume same package or fully qualified if not in import_map
                                classes[class_key].superclass = f"{package_name}.{superclass_name}" if package_name else superclass_name

                        # Handle 'implements'
                        if class_declaration.implements: # Add this check
                            for impl_ref in class_declaration.implements:
                                interface_name = impl_ref.name
                                # Try to resolve fully qualified name for interface
                                if interface_name in import_map:
                                    classes[class_key].interfaces.append(import_map[interface_name])
                                else:
                                    # Assume same package or fully qualified if not in import_map
                                    classes[class_key].interfaces.append(f"{package_name}.{interface_name}" if package_name else interface_name)
                        # --- End of new inheritance logic ---

                        field_map = {}
                        for field_declaration in class_declaration.fields:
                            for declarator in field_declaration.declarators:
                                field_map[declarator.name] = field_declaration.type.name
                                
                                # Parse field annotations
                                field_annotations = parse_annotations(field_declaration.annotations, "field") if hasattr(field_declaration, 'annotations') else []
                                
                                # Extract initial value if present
                                initial_value = ""
                                if hasattr(declarator, 'initializer') and declarator.initializer:
                                    # Convert the initializer to string representation
                                    if hasattr(declarator.initializer, 'value'):
                                        initial_value = str(declarator.initializer.value)
                                    elif hasattr(declarator.initializer, 'type'):
                                        initial_value = str(declarator.initializer.type)
                                    else:
                                        initial_value = str(declarator.initializer)
                                
                                prop = Property(
                                    name=declarator.name,
                                    logical_name=f"{package_name}.{class_name}.{declarator.name}",
                                    type=field_declaration.type.name,
                                    modifiers=list(field_declaration.modifiers), # Add modifiers
                                    package_name=package_name,
                                    class_name=class_name,
                                    annotations=field_annotations,
                                    initial_value=initial_value
                                )
                                classes[class_key].properties.append(prop)

                        all_declarations = class_declaration.methods + class_declaration.constructors
                        
                        # Debug: Check User class method processing
                        if "User" in class_name:
                            logger.debug(f"Processing User class methods - total declarations: {len(all_declarations)}")
                            for i, decl in enumerate(all_declarations):
                                logger.debug(f"Declaration {i}: {type(decl).__name__} - {decl.name}")
                        
                        for declaration in all_declarations:
                            local_var_map = field_map.copy()
                            params = []
                            for param in declaration.parameters:
                                param_type_name = 'Unknown'
                                if hasattr(param.type, 'name'):
                                    param_type_name = param.type.name
                                local_var_map[param.name] = param_type_name
                                params.append(Property(name=param.name, logical_name=f"{package_name}.{class_name}.{param.name}", type=param_type_name, package_name=package_name, class_name=class_name))

                            if declaration.body:
                                for _, var_decl in declaration.filter(javalang.tree.LocalVariableDeclaration):
                                    for declarator in var_decl.declarators:
                                        local_var_map[declarator.name] = var_decl.type.name
                            
                            if isinstance(declaration, javalang.tree.MethodDeclaration):
                                return_type = declaration.return_type.name if declaration.return_type else "void"
                            else: # ConstructorDeclaration
                                return_type = "constructor"

                            # Extract modifiers
                            modifiers = list(declaration.modifiers)
                            
                            # Parse method annotations
                            method_annotations = parse_annotations(declaration.annotations, "method") if hasattr(declaration, 'annotations') else []

                            # Extract method source code
                            method_source = ""
                            if declaration.position:
                                lines = file_content.splitlines(keepends=True) # Keep line endings
                                start_line = declaration.position.line - 1
                                
                                # Find the end of the method by matching braces
                                brace_count = 0
                                end_line = start_line
                                for i in range(start_line, len(lines)):
                                    line = lines[i]
                                    for char in line:
                                        if char == '{':
                                            brace_count += 1
                                        elif char == '}':
                                            brace_count -= 1
                                            if brace_count == 0:
                                                end_line = i
                                                break
                                    if brace_count == 0:
                                        break
                                
                                method_source = "".join(lines[start_line:end_line + 1])

                            method = Method(
                                name=declaration.name,
                                logical_name=f"{class_key}.{declaration.name}",  # Add logical_name
                                return_type=return_type,
                                parameters=params,
                                modifiers=modifiers,
                                source=method_source, # Add method source
                                package_name=package_name,
                                annotations=method_annotations
                            )
                            classes[class_key].methods.append(method)

                            # Extract method calls with order information
                            call_order = 0
                            for _, invocation in declaration.filter(javalang.tree.MethodInvocation):
                                target_class_name = None
                                resolved_target_package = ""
                                resolved_target_class_name = ""
                                
                                if invocation.qualifier:
                                    # External method call
                                    if invocation.qualifier in local_var_map:
                                        target_class_name = local_var_map[invocation.qualifier]
                                    else:
                                        target_class_name = invocation.qualifier
                                    
                                    if target_class_name:
                                        if target_class_name == "System.out":
                                            resolved_target_package = "java.io"
                                            resolved_target_class_name = "PrintStream"
                                        else:
                                            if target_class_name in import_map:
                                                resolved_target_package = ".".join(import_map[target_class_name].split(".")[:-1])
                                            else:
                                                resolved_target_package = package_name
                                                resolved_target_class_name = target_class_name
                                else:
                                    # Same class method call
                                    resolved_target_package = package_name
                                    resolved_target_class_name = class_name

                                if resolved_target_class_name:
                                    # Get line number from invocation position
                                    line_number = invocation.position.line if invocation.position else 0

                                    call = MethodCall(
                                        source_package=package_name,
                                        source_class=class_name,
                                        source_method=declaration.name,
                                        target_package=resolved_target_package,
                                        target_class=resolved_target_class_name,
                                        target_method=invocation.member,
                                        call_order=call_order,
                                        line_number=line_number,
                                        return_type="void"  # Default return type, can be enhanced later
                                    )
                                    classes[class_key].calls.append(call)
                                    call_order += 1
                        
                        # Check for Lombok @Data annotation and generate methods
                        has_data_annotation = any(ann.name == "Data" for ann in classes[class_key].annotations)
                        if has_data_annotation:
                            logger.debug(f"Found @Data annotation on {class_name}, generating Lombok methods")
                            lombok_methods = generate_lombok_methods(classes[class_key].properties, class_name, package_name)
                            classes[class_key].methods.extend(lombok_methods)
                            logger.debug(f"Generated {len(lombok_methods)} Lombok methods for {class_name}")
                except javalang.parser.JavaSyntaxError as e:
                    print(f"Syntax error in {file_path}: {e}")
                    continue
                except Exception as e:
                    print(f"Error parsing {file_path}: {e}")
                    continue
    
    # Extract beans, analyze dependencies, extract endpoints, extract MyBatis mappers, extract JPA entities, extract config files, and extract test classes
    classes_list = list(classes.values())
    beans = extract_beans_from_classes(classes_list)
    dependencies = analyze_bean_dependencies(classes_list, beans)
    endpoints = extract_endpoints_from_classes(classes_list)
    mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
    jpa_entities = extract_jpa_entities_from_classes(classes_list)
    config_files = extract_config_files(directory)
    test_classes = extract_test_classes_from_classes(classes_list)
    
    # Also extract XML mappers
    xml_mappers = extract_mybatis_xml_mappers(directory)
    mybatis_mappers.extend(xml_mappers)
    
    # Extract SQL statements from MyBatis mappers
    sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
    
    return list(packages.values()), classes_list, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name
```

이제 다른 Property 생성 부분들을 찾아서 변경하겠습니다.


이제 이 두 부분을 Field로 변경하겠습니다.


```python
import os
import yaml
import re
from pathlib import Path

import javalang

from src.models.graph_entities import Class, Method, MethodCall, Field, Package, Annotation, Bean, BeanDependency, Endpoint, MyBatisMapper, MyBatisSqlStatement, MyBatisResultMap, SqlStatement, JpaEntity, JpaColumn, JpaRelationship, ConfigFile, DatabaseConfig, ServerConfig, SecurityConfig, LoggingConfig, TestClass, TestMethod, TestConfiguration
from src.utils.logger import get_logger
from typing import Optional, List, Literal


def extract_project_name(java_source_folder: str) -> str:
    """
    JAVA_SOURCE_FOLDER 경로에서 프로젝트 이름을 추출합니다.
    
    Args:
        java_source_folder: Java 소스 폴더 경로
        
    Returns:
        프로젝트 이름 (마지막 디렉토리명)
    """
    # 경로를 정규화하고 마지막 디렉토리명 추출
    path = Path(java_source_folder).resolve()
    return path.name


def extract_sql_statements_from_mappers(mybatis_mappers: list[MyBatisMapper], project_name: str) -> list[SqlStatement]:
    """
    MyBatis mappers에서 SQL statements를 추출합니다.
    
    Args:
        mybatis_mappers: MyBatis mapper 객체들의 리스트
        project_name: 프로젝트 이름
        
    Returns:
        SqlStatement 객체들의 리스트
    """
    sql_statements = []
    
    for mapper in mybatis_mappers:
        for sql_dict in mapper.sql_statements:
            # MyBatisSqlStatement를 SqlStatement로 변환
            sql_statement = SqlStatement(
                id=sql_dict.get('id', ''),
                sql_type=sql_dict.get('sql_type', ''),
                sql_content=sql_dict.get('sql_content', ''),
                parameter_type=sql_dict.get('parameter_type', ''),
                result_type=sql_dict.get('result_type', ''),
                result_map=sql_dict.get('result_map', ''),
                mapper_name=mapper.name,
                annotations=[],  # TODO: annotations를 파싱하여 추가
                project_name=project_name
            )
            sql_statements.append(sql_statement)
    
    return sql_statements


def parse_annotations(annotations, target_type: str = "class") -> list[Annotation]:
    """Parse Java annotations into Annotation objects.
    
    Args:
        annotations: List of annotation nodes from javalang
        target_type: Type of target ("class", "method", "field")
    """
    result = []
    for annotation in annotations:
        annotation_name = annotation.name
        parameters = {}
        
        # Parse annotation parameters if they exist
        if hasattr(annotation, 'element') and annotation.element:
            for element in annotation.element:
                if hasattr(element, 'name') and hasattr(element, 'value'):
                    parameters[element.name] = element.value.value if hasattr(element.value, 'value') else str(element.value)
        
        result.append(Annotation(
            name=annotation_name,
            parameters=parameters,
            target_type=target_type,
            category=classify_springboot_annotation(annotation_name)
        ))
    
    return result


def classify_springboot_annotation(annotation_name: str) -> str:
    """Classify SpringBoot annotations into categories.
    
    Args:
        annotation_name: Name of the annotation (e.g., "@Component", "@Service")
        
    Returns:
        Category of the annotation
    """
    # Component annotations
    component_annotations = {
        "Component", "Service", "Repository", "Controller", 
        "RestController", "Configuration", "Bean"
    }
    
    # Injection annotations
    injection_annotations = {
        "Autowired", "Resource", "Value", "Qualifier", "Primary"
    }
    
    # Web annotations
    web_annotations = {
        "RequestMapping", "GetMapping", "PostMapping", "PutMapping", 
        "DeleteMapping", "PatchMapping", "RequestParam", "PathVariable",
        "RequestBody", "ResponseBody", "ResponseStatus"
    }
    
    # JPA annotations
    jpa_annotations = {
        "Entity", "Table", "Id", "Column", "OneToMany", "ManyToOne",
        "OneToOne", "ManyToMany", "JoinColumn", "GeneratedValue"
    }
    
    # Test annotations
    test_annotations = {
        "Test", "SpringBootTest", "DataJpaTest", "WebMvcTest",
        "MockBean", "SpyBean", "TestPropertySource"
    }
    
    # Security annotations
    security_annotations = {
        "PreAuthorize", "PostAuthorize", "Secured", "RolesAllowed",
        "EnableWebSecurity", "EnableGlobalMethodSecurity"
    }
    
    # Validation annotations
    validation_annotations = {
        "Valid", "NotNull", "NotBlank", "NotEmpty", "Size", "Min", "Max",
        "Pattern", "Email", "AssertTrue", "AssertFalse"
    }
    
    # MyBatis annotations
    mybatis_annotations = {
        "Mapper", "Select", "Insert", "Update", "Delete", "SelectProvider",
        "InsertProvider", "UpdateProvider", "DeleteProvider", "Results",
        "Result", "One", "Many", "MapKey", "Options", "SelectKey"
    }
    
    if annotation_name in component_annotations:
        return "component"
    elif annotation_name in injection_annotations:
        return "injection"
    elif annotation_name in web_annotations:
        return "web"
    elif annotation_name in jpa_annotations:
        return "jpa"
    elif annotation_name in test_annotations:
        return "test"
    elif annotation_name in security_annotations:
        return "security"
    elif annotation_name in validation_annotations:
        return "validation"
    elif annotation_name in mybatis_annotations:
        return "mybatis"
    else:
        return "other"


def classify_test_annotation(annotation_name: str) -> str:
    """Classify test annotations into categories.
    
    Args:
        annotation_name: Name of the annotation
        
    Returns:
        Category of the test annotation
    """
    # JUnit annotations
    junit_annotations = {
        "Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll",
        "DisplayName", "ParameterizedTest", "ValueSource", "CsvSource",
        "MethodSource", "Timeout", "Disabled", "Nested", "RepeatedTest",
        "Order", "TestMethodOrder", "TestInstance", "TestClassOrder"
    }
    
    # Spring Boot Test annotations
    spring_test_annotations = {
        "SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest",
        "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest",
        "MockBean", "SpyBean", "TestConfiguration", "ActiveProfiles",
        "TestPropertySource", "DirtiesContext", "Transactional",
        "Rollback", "Commit", "Sql", "SqlGroup", "AutoConfigureTestDatabase",
        "AutoConfigureMockMvc", "AutoConfigureWebMvc", "AutoConfigureWebClient",
        "MockMvc", "TestEntityManager", "TestContainers", "DynamicPropertySource"
    }
    
    # TestNG annotations
    testng_annotations = {
        "TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass",
        "BeforeSuite", "AfterSuite", "BeforeGroups", "AfterGroups",
        "DataProvider", "Parameters", "Groups", "Priority", "DependsOnMethods",
        "DependsOnGroups", "ExpectedExceptions", "InvocationCount",
        "SuccessPercentage", "TimeOut"
    }
    
    # Mockito annotations
    mockito_annotations = {
        "Mock", "Spy", "InjectMocks", "Captor", "MockedStatic"
    }
    
    # AssertJ annotations
    assertj_annotations = {
        "AssertJ"
    }
    
    # Other test annotations
    other_test_annotations = {
        "Ignore", "Category", "RunWith", "ExtendWith", "ContextConfiguration"
    }
    
    if annotation_name in junit_annotations:
        return "junit"
    elif annotation_name in spring_test_annotations:
        return "spring_test"
    elif annotation_name in testng_annotations:
        return "testng"
    elif annotation_name in mockito_annotations:
        return "mockito"
    elif annotation_name in assertj_annotations:
        return "assertj"
    elif annotation_name in other_test_annotations:
        return "other_test"
    else:
        return "other"


def extract_beans_from_classes(classes: list[Class]) -> list[Bean]:
    """Extract Spring Beans from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Bean objects
    """
    beans = []
    
    for cls in classes:
        # Check if class has Spring component annotations
        component_annotations = [ann for ann in cls.annotations if ann.category == "component"]
        
        # Also check for @Repository on interfaces
        has_repository_annotation = any(ann.name == "Repository" for ann in cls.annotations)
        
        if component_annotations or has_repository_annotation:
            # Determine bean type based on annotations
            bean_type = "component"  # default
            if any(ann.name in ["Service", "Service"] for ann in cls.annotations):
                bean_type = "service"
            elif any(ann.name in ["Repository", "Repository"] for ann in cls.annotations):
                bean_type = "repository"
            elif any(ann.name in ["Controller", "RestController"] for ann in cls.annotations):
                bean_type = "controller"
            elif any(ann.name in ["Configuration", "Configuration"] for ann in cls.annotations):
                bean_type = "configuration"
            
            # Determine scope (default is singleton)
            scope = "singleton"
            for ann in cls.annotations:
                if ann.name == "Scope":
                    if "value" in ann.parameters:
                        scope = ann.parameters["value"]
                    elif "prototype" in str(ann.parameters):
                        scope = "prototype"
                    elif "request" in str(ann.parameters):
                        scope = "request"
                    elif "session" in str(ann.parameters):
                        scope = "session"
            
            # Create bean name (use class name with first letter lowercase)
            bean_name = cls.name[0].lower() + cls.name[1:] if cls.name else cls.name
            
            # Check for @Bean methods in configuration classes
            bean_methods = []
            if bean_type == "configuration":
                for method in cls.methods:
                    if any(ann.name == "Bean" for ann in method.annotations):
                        bean_methods.append(method)
            
            bean = Bean(
                name=bean_name,
                type=bean_type,
                scope=scope,
                class_name=cls.name,
                package_name=cls.package_name,
                annotation_names=[ann.name for ann in cls.annotations] if cls.annotations else [],
                method_count=len(bean_methods) if bean_type == "configuration" else len(cls.methods) if cls.methods else 0,
                property_count=len(cls.properties) if cls.properties else 0
            )
            beans.append(bean)
    
    return beans


def analyze_bean_dependencies(classes: list[Class], beans: list[Bean]) -> list[BeanDependency]:
    """Analyze dependencies between Spring Beans.
    
    Args:
        classes: List of parsed Class objects
        beans: List of Bean objects
        
    Returns:
        List of BeanDependency objects
    """
    dependencies = []
    
    # Create a mapping from class names to bean names
    class_to_bean = {}
    for bean in beans:
        class_to_bean[bean.class_name] = bean.name
    
    for cls in classes:
        # Check if this class is a bean
        if cls.name not in class_to_bean:
            continue
            
        source_bean = class_to_bean[cls.name]
        
        # Analyze field injections (@Autowired, @Resource, @Value)
        for prop in cls.properties:
            if any(ann.category == "injection" for ann in prop.annotations):
                # Try to determine target bean from field type
                target_bean = None
                field_type = prop.type
                
                # Look for exact class name match
                if field_type in class_to_bean:
                    target_bean = class_to_bean[field_type]
                else:
                    # Look for interface implementations (simplified - just check if type matches any bean class name)
                    for bean in beans:
                        if field_type == bean.class_name:
                            target_bean = bean.name
                            break
                
                if target_bean:
                    injection_type = "field"
                    for ann in prop.annotations:
                        if ann.name == "Autowired":
                            injection_type = "field"
                        elif ann.name == "Resource":
                            injection_type = "field"
                        elif ann.name == "Value":
                            injection_type = "field"
                    
                    dependency = BeanDependency(
                        source_bean=source_bean,
                        target_bean=target_bean,
                        injection_type=injection_type,
                        field_name=prop.name
                    )
                    dependencies.append(dependency)
        
        # Analyze constructor injections
        for method in cls.methods:
            if method.name == cls.name:  # Constructor
                for param in method.parameters:
                    if any(ann.category == "injection" for ann in param.annotations):
                        target_bean = None
                        param_type = param.type
                        
                        if param_type in class_to_bean:
                            target_bean = class_to_bean[param_type]
                        else:
                            # Look for interface implementations (simplified)
                            for bean in beans:
                                if param_type == bean.class_name:
                                    target_bean = bean.name
                                    break
                        
                        if target_bean:
                            dependency = BeanDependency(
                                source_bean=source_bean,
                                target_bean=target_bean,
                                injection_type="constructor",
                                parameter_name=param.name
                            )
                            dependencies.append(dependency)
        
        # Analyze setter injections
        for method in cls.methods:
            if method.name.startswith("set") and len(method.parameters) == 1:
                if any(ann.category == "injection" for ann in method.annotations):
                    param = method.parameters[0]
                    target_bean = None
                    param_type = param.type
                    
                    if param_type in class_to_bean:
                        target_bean = class_to_bean[param_type]
                    else:
                        # Look for interface implementations (simplified)
                        for bean in beans:
                            if param_type == bean.class_name:
                                target_bean = bean.name
                                break
                    
                    if target_bean:
                        dependency = BeanDependency(
                            source_bean=source_bean,
                            target_bean=target_bean,
                            injection_type="setter",
                            method_name=method.name,
                            parameter_name=param.name
                        )
                        dependencies.append(dependency)
    
    return dependencies


def extract_endpoints_from_classes(classes: list[Class]) -> list[Endpoint]:
    """Extract REST API endpoints from controller classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Endpoint objects
    """
    endpoints = []
    
    for cls in classes:
        # Check if class is a controller
        is_controller = any(ann.name in ["Controller", "RestController"] for ann in cls.annotations)
        
        if not is_controller:
            continue
            
        # Get class-level path mapping
        class_path = ""
        for ann in cls.annotations:
            if ann.name == "RequestMapping":
                if "value" in ann.parameters:
                    class_path = ann.parameters["value"]
                break
        
        # Process each method in the controller
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
                
            # Check if method has web mapping annotations
            web_annotations = [ann for ann in method.annotations if ann.category == "web"]
            
            if not web_annotations:
                continue
            
            # Extract endpoint information
            endpoint_path = ""
            http_method = "GET"  # default
            
            for ann in web_annotations:
                if ann.name in ["RequestMapping", "GetMapping", "PostMapping", "PutMapping", "DeleteMapping", "PatchMapping"]:
                    # Extract path
                    if "value" in ann.parameters:
                        endpoint_path = ann.parameters["value"]
                    elif "path" in ann.parameters:
                        endpoint_path = ann.parameters["path"]
                    
                    # Extract HTTP method
                    if ann.name == "GetMapping":
                        http_method = "GET"
                    elif ann.name == "PostMapping":
                        http_method = "POST"
                    elif ann.name == "PutMapping":
                        http_method = "PUT"
                    elif ann.name == "DeleteMapping":
                        http_method = "DELETE"
                    elif ann.name == "PatchMapping":
                        http_method = "PATCH"
                    elif ann.name == "RequestMapping":
                        if "method" in ann.parameters:
                            method_value = ann.parameters["method"]
                            if isinstance(method_value, list) and len(method_value) > 0:
                                http_method = method_value[0]
                            else:
                                http_method = str(method_value)
                        else:
                            http_method = "GET"  # default for RequestMapping
                    break
            
            # Build full path
            full_path = class_path
            if endpoint_path:
                if full_path and not full_path.endswith("/") and not endpoint_path.startswith("/"):
                    full_path += "/"
                full_path += endpoint_path
            elif not full_path:
                full_path = "/"
            
            # Extract method parameters
            parameters = []
            for param in method.parameters:
                param_info = {
                    "name": param.name,
                    "type": param.type,
                    "annotations": [ann.name for ann in param.annotations if ann.category == "web"]
                }
                parameters.append(param_info)
            
            # Extract return type
            return_type = method.return_type if method.return_type != "constructor" else "void"
            
            # Create endpoint
            endpoint = Endpoint(
                path=endpoint_path or "/",
                method=http_method,
                controller_class=cls.name,
                handler_method=method.name,
                parameters=parameters,
                return_type=return_type,
                annotations=[ann.name for ann in web_annotations],
                full_path=full_path
            )
            endpoints.append(endpoint)
    
    return endpoints


def extract_mybatis_mappers_from_classes(classes: list[Class]) -> list[MyBatisMapper]:
    """Extract MyBatis Mappers from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for cls in classes:
        # Check if class is a MyBatis Mapper interface
        is_mapper = any(ann.name == "Mapper" for ann in cls.annotations)
        
        if not is_mapper:
            continue
        
        # Extract mapper methods with MyBatis annotations
        mapper_methods = []
        sql_statements = []
        
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
            
            # Check if method has MyBatis annotations
            mybatis_annotations = [ann for ann in method.annotations if ann.category == "mybatis"]
            
            if not mybatis_annotations:
                continue
            
            # Extract SQL statement information
            sql_type = "SELECT"  # default
            sql_content = ""
            parameter_type = ""
            result_type = ""
            result_map = ""
            
            for ann in mybatis_annotations:
                if ann.name in ["Select", "SelectProvider"]:
                    sql_type = "SELECT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Insert", "InsertProvider"]:
                    sql_type = "INSERT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Update", "UpdateProvider"]:
                    sql_type = "UPDATE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Delete", "DeleteProvider"]:
                    sql_type = "DELETE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                
                # Extract parameter and result type information
                if "parameterType" in ann.parameters:
                    parameter_type = ann.parameters["parameterType"]
                if "resultType" in ann.parameters:
                    result_type = ann.parameters["resultType"]
                if "resultMap" in ann.parameters:
                    result_map = ann.parameters["resultMap"]
            
            # Create method info
            method_info = {
                "name": method.name,
                "return_type": method.return_type,
                "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            mapper_methods.append(method_info)
            
            # Create SQL statement info
            sql_statement = {
                "id": method.name,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            sql_statements.append(sql_statement)
        
        # Create mapper
        mapper = MyBatisMapper(
            name=cls.name,
            type="interface",
            namespace=f"{cls.package_name}.{cls.name}",
            methods=mapper_methods,
            sql_statements=sql_statements,
            file_path=cls.file_path,
            package_name=cls.package_name
        )
        mappers.append(mapper)
    
    return mappers


def parse_mybatis_xml_file(file_path: str) -> MyBatisMapper:
    """Parse MyBatis XML mapper file.
    
    Args:
        file_path: Path to the XML mapper file
        
    Returns:
        MyBatisMapper object
    """
    import xml.etree.ElementTree as ET
    
    try:
        tree = ET.parse(file_path)
        root = tree.getroot()
        
        # Extract namespace
        namespace = root.get("namespace", "")
        
        # Extract SQL statements
        sql_statements = []
        for statement in root.findall(".//*[@id]"):
            statement_id = statement.get("id")
            tag_name = statement.tag.lower()
            
            # Determine SQL type
            sql_type = "SELECT"
            if tag_name == "insert":
                sql_type = "INSERT"
            elif tag_name == "update":
                sql_type = "UPDATE"
            elif tag_name == "delete":
                sql_type = "DELETE"
            
            # Extract SQL content
            sql_content = statement.text.strip() if statement.text else ""
            
            # Extract parameter and result information
            parameter_type = statement.get("parameterType", "")
            result_type = statement.get("resultType", "")
            result_map = statement.get("resultMap", "")
            
            sql_statement = {
                "id": statement_id,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": []
            }
            sql_statements.append(sql_statement)
        
        # Extract ResultMaps
        result_maps = []
        for result_map in root.findall(".//resultMap"):
            result_map_id = result_map.get("id")
            result_map_type = result_map.get("type", "")
            
            properties = []
            for property_elem in result_map.findall(".//result"):
                prop = {
                    "property": property_elem.get("property", ""),
                    "column": property_elem.get("column", ""),
                    "jdbc_type": property_elem.get("jdbcType", "")
                }
                properties.append(prop)
            
            result_map_info = {
                "id": result_map_id,
                "type": result_map_type,
                "properties": properties,
                "associations": [],
                "collections": []
            }
            result_maps.append(result_map_info)
        
        # Create mapper
        mapper_name = namespace.split(".")[-1] if namespace else os.path.basename(file_path).replace(".xml", "")
        package_name = ".".join(namespace.split(".")[:-1]) if namespace else ""
        
        mapper = MyBatisMapper(
            name=mapper_name,
            type="xml",
            namespace=namespace,
            methods=[],  # XML mappers don't have Java methods
            sql_statements=sql_statements,
            file_path=file_path,
            package_name=package_name
        )
        
        return mapper
        
    except ET.ParseError as e:
        print(f"Error parsing XML file {file_path}: {e}")
        return None
    except Exception as e:
        print(f"Error reading XML file {file_path}: {e}")
        return None


def extract_mybatis_xml_mappers(directory: str) -> list[MyBatisMapper]:
    """Extract MyBatis XML mappers from directory.
    
    Args:
        directory: Directory to search for XML mapper files
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith("Mapper.xml") or file.endswith("Dao.xml"):
                file_path = os.path.join(root, file)
                mapper = parse_mybatis_xml_file(file_path)
                if mapper:
                    mappers.append(mapper)
    
    return mappers


def extract_jpa_entities_from_classes(classes: list[Class]) -> list[JpaEntity]:
    """Extract JPA Entities from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of JpaEntity objects
    """
    entities = []
    
    for cls in classes:
        # Check if class is a JPA Entity
        is_entity = any(ann.name == "Entity" for ann in cls.annotations)
        
        if not is_entity:
            continue
        
        # Extract table name
        table_name = cls.name.lower()  # default table name
        for ann in cls.annotations:
            if ann.name == "Table":
                if "name" in ann.parameters:
                    table_name = ann.parameters["name"]
                break
        
        # Extract columns from properties
        columns = []
        relationships = []
        
        for prop in cls.properties:
            # Check if property has JPA column annotations
            jpa_annotations = [ann for ann in prop.annotations if ann.category == "jpa"]
            
            if jpa_annotations:
                # Extract column information
                column_name = prop.name  # default column name
                nullable = True
                unique = False
                length = 0
                precision = 0
                scale = 0
                
                for ann in jpa_annotations:
                    if ann.name == "Column":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                        if "nullable" in ann.parameters:
                            nullable = ann.parameters["nullable"]
                        if "unique" in ann.parameters:
                            unique = ann.parameters["unique"]
                        if "length" in ann.parameters:
                            length = ann.parameters["length"]
                        if "precision" in ann.parameters:
                            precision = ann.parameters["precision"]
                        if "scale" in ann.parameters:
                            scale = ann.parameters["scale"]
                    elif ann.name == "Id":
                        column_name = "id"  # Primary key column
                        nullable = False
                        unique = True
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                
                # Check for relationship annotations
                relationship_type = None
                target_entity = ""
                mapped_by = ""
                join_column = ""
                join_table = ""
                cascade = []
                fetch = "LAZY"
                
                for ann in jpa_annotations:
                    if ann.name in ["OneToOne", "OneToMany", "ManyToOne", "ManyToMany"]:
                        relationship_type = ann.name
                        if "targetEntity" in ann.parameters:
                            target_entity = ann.parameters["targetEntity"]
                        if "mappedBy" in ann.parameters:
                            mapped_by = ann.parameters["mappedBy"]
                        if "cascade" in ann.parameters:
                            cascade = ann.parameters["cascade"] if isinstance(ann.parameters["cascade"], list) else [ann.parameters["cascade"]]
                        if "fetch" in ann.parameters:
                            fetch = ann.parameters["fetch"]
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            join_column = ann.parameters["name"]
                    elif ann.name == "JoinTable":
                        if "name" in ann.parameters:
                            join_table = ann.parameters["name"]
                
                # Create column info
                column_info = {
                    "property_name": prop.name,
                    "column_name": column_name,
                    "data_type": prop.type,
                    "nullable": nullable,
                    "unique": unique,
                    "length": length,
                    "precision": precision,
                    "scale": scale,
                    "annotations": [ann.name for ann in jpa_annotations]
                }
                columns.append(column_info)
                
                # Create relationship info if it's a relationship
                if relationship_type:
                    relationship_info = {
                        "type": relationship_type,
                        "target_entity": target_entity,
                        "mapped_by": mapped_by,
                        "join_column": join_column,
                        "join_table": join_table,
                        "cascade": cascade,
                        "fetch": fetch,
                        "annotations": [ann.name for ann in jpa_annotations]
                    }
                    relationships.append(relationship_info)
        
        # Create entity
        entity = JpaEntity(
            name=cls.name,
            table_name=table_name,
            columns=columns,
            relationships=relationships,
            annotations=[ann.name for ann in cls.annotations if ann.category == "jpa"],
            package_name=cls.package_name,
            file_path=cls.file_path
        )
        entities.append(entity)
    
    return entities


def parse_yaml_config(file_path: str) -> ConfigFile:
    """Parse YAML configuration file.
    
    Args:
        file_path: Path to the YAML file
        
    Returns:
        ConfigFile object
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = yaml.safe_load(f)
        
        if not content:
            content = {}
        
        # Extract file info
        file_name = os.path.basename(file_path)
        file_type = "yaml" if file_path.endswith('.yaml') else "yml"
        
        # Extract profiles
        profiles = []
        if 'spring' in content and 'profiles' in content['spring']:
            if 'active' in content['spring']['profiles']:
                profiles = content['spring']['profiles']['active']
                if isinstance(profiles, str):
                    profiles = [profiles]
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        # Extract sections
        sections = []
        for key, value in content.items():
            if isinstance(value, dict):
                sections.append({
                    "name": key,
                    "properties": value,
                    "type": "section"
                })
        
        return ConfigFile(
            name=file_name,
            file_path=file_path,
            file_type=file_type,
            properties=content,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing YAML file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="yaml",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def parse_properties_config(file_path: str) -> ConfigFile:
    """Parse Properties configuration file.
    
    Args:
        file_path: Path to the properties file
        
    Returns:
        ConfigFile object
    """
    try:
        properties = {}
        sections = []
        profiles = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                
                # Skip empty lines and comments
                if not line or line.startswith('#'):
                    continue
                
                # Parse key=value pairs
                if '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    
                    # Remove quotes if present
                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]
                    elif value.startswith("'") and value.endswith("'"):
                        value = value[1:-1]
                    
                    properties[key] = value
                    
                    # Check for profiles
                    if key == 'spring.profiles.active':
                        profiles = [p.strip() for p in value.split(',')]
        
        # Group properties by section
        section_map = {}
        for key, value in properties.items():
            if '.' in key:
                section = key.split('.')[0]
                if section not in section_map:
                    section_map[section] = {}
                section_map[section][key] = value
            else:
                if 'root' not in section_map:
                    section_map['root'] = {}
                section_map['root'][key] = value
        
        for section_name, section_props in section_map.items():
            sections.append({
                "name": section_name,
                "properties": section_props,
                "type": "section"
            })
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties=properties,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing Properties file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def extract_database_config(config_file: ConfigFile) -> DatabaseConfig:
    """Extract database configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        DatabaseConfig object
    """
    db_config = DatabaseConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        spring_config = config_file.properties.get('spring', {})
        datasource_config = spring_config.get('datasource', {})
        jpa_config = spring_config.get('jpa', {})
        
        db_config.driver = datasource_config.get('driver-class-name', '')
        db_config.url = datasource_config.get('url', '')
        db_config.username = datasource_config.get('username', '')
        db_config.password = datasource_config.get('password', '')
        db_config.dialect = jpa_config.get('database-platform', '')
        db_config.hibernate_ddl_auto = jpa_config.get('hibernate', {}).get('ddl-auto', '')
        db_config.show_sql = jpa_config.get('show-sql', False)
        db_config.format_sql = jpa_config.get('properties', {}).get('hibernate', {}).get('format_sql', False)
        
        # Store additional JPA properties
        if 'properties' in jpa_config:
            db_config.jpa_properties = jpa_config['properties']
    
    else:
        # Properties format
        props = config_file.properties
        
        db_config.driver = props.get('spring.datasource.driver-class-name', '')
        db_config.url = props.get('spring.datasource.url', '')
        db_config.username = props.get('spring.datasource.username', '')
        db_config.password = props.get('spring.datasource.password', '')
        db_config.dialect = props.get('spring.jpa.database-platform', '')
        db_config.hibernate_ddl_auto = props.get('spring.jpa.hibernate.ddl-auto', '')
        db_config.show_sql = props.get('spring.jpa.show-sql', 'false').lower() == 'true'
        db_config.format_sql = props.get('spring.jpa.properties.hibernate.format_sql', 'false').lower() == 'true'
        
        # Store additional JPA properties
        jpa_props = {}
        for key, value in props.items():
            if key.startswith('spring.jpa.properties.'):
                jpa_props[key] = value
        db_config.jpa_properties = jpa_props
    
    return db_config


def extract_server_config(config_file: ConfigFile) -> ServerConfig:
    """Extract server configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        ServerConfig object
    """
    server_config = ServerConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        server_props = config_file.properties.get('server', {})
        
        server_config.port = server_props.get('port', 8080)
        server_config.context_path = server_props.get('servlet', {}).get('context-path', '')
        server_config.servlet_path = server_props.get('servlet', {}).get('path', '')
        
        # SSL configuration
        ssl_config = server_props.get('ssl', {})
        server_config.ssl_enabled = bool(ssl_config)
        server_config.ssl_key_store = ssl_config.get('key-store', '')
        server_config.ssl_key_store_password = ssl_config.get('key-store-password', '')
        server_config.ssl_key_store_type = ssl_config.get('key-store-type', '')
    
    else:
        # Properties format
        props = config_file.properties
        
        server_config.port = int(props.get('server.port', '8080'))
        server_config.context_path = props.get('server.servlet.context-path', '')
        server_config.servlet_path = props.get('server.servlet.path', '')
        
        # SSL configuration
        server_config.ssl_enabled = any(key.startswith('server.ssl.') for key in props.keys())
        server_config.ssl_key_store = props.get('server.ssl.key-store', '')
        server_config.ssl_key_store_password = props.get('server.ssl.key-store-password', '')
        server_config.ssl_key_store_type = props.get('server.ssl.key-store-type', '')
    
    return server_config


def extract_security_config(config_file: ConfigFile) -> SecurityConfig:
    """Extract security configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        SecurityConfig object
    """
    security_config = SecurityConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        security_props = config_file.properties.get('security', {})
        jwt_props = security_props.get('jwt', {})
        cors_props = security_props.get('cors', {})
        
        security_config.enabled = bool(security_props)
        security_config.authentication_type = security_props.get('authentication-type', '')
        security_config.jwt_secret = jwt_props.get('secret', '')
        security_config.jwt_expiration = jwt_props.get('expiration', 0)
        security_config.cors_allowed_origins = cors_props.get('allowed-origins', [])
        security_config.cors_allowed_methods = cors_props.get('allowed-methods', [])
        security_config.cors_allowed_headers = cors_props.get('allowed-headers', [])
    
    else:
        # Properties format
        props = config_file.properties
        
        security_config.enabled = any(key.startswith('security.') for key in props.keys())
        security_config.authentication_type = props.get('security.authentication-type', '')
        security_config.jwt_secret = props.get('security.jwt.secret', '')
        security_config.jwt_expiration = int(props.get('security.jwt.expiration', '0'))
        
        # CORS configuration
        origins = props.get('security.cors.allowed-origins', '')
        if origins:
            security_config.cors_allowed_origins = [o.strip() for o in origins.split(',')]
        
        methods = props.get('security.cors.allowed-methods', '')
        if methods:
            security_config.cors_allowed_methods = [m.strip() for m in methods.split(',')]
        
        headers = props.get('security.cors.allowed-headers', '')
        if headers:
            security_config.cors_allowed_headers = [h.strip() for h in headers.split(',')]
    
    return security_config


def extract_logging_config(config_file: ConfigFile) -> LoggingConfig:
    """Extract logging configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        LoggingConfig object
    """
    logging_config = LoggingConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        logging_props = config_file.properties.get('logging', {})
        
        logging_config.level = logging_props.get('level', {}).get('root', 'INFO')
        logging_config.pattern = logging_props.get('pattern', {}).get('console', '')
        logging_config.file_path = logging_props.get('file', {}).get('name', '')
        logging_config.max_file_size = logging_props.get('file', {}).get('max-size', '')
        logging_config.max_history = logging_props.get('file', {}).get('max-history', 0)
        logging_config.console_output = logging_props.get('console', {}).get('enabled', True)
    
    else:
        # Properties format
        props = config_file.properties
        
        logging_config.level = props.get('logging.level.root', 'INFO')
        logging_config.pattern = props.get('logging.pattern.console', '')
        logging_config.file_path = props.get('logging.file.name', '')
        logging_config.max_file_size = props.get('logging.file.max-size', '')
        logging_config.max_history = int(props.get('logging.file.max-history', '0'))
        logging_config.console_output = props.get('logging.console.enabled', 'true').lower() == 'true'
    
    return logging_config


def extract_config_files(directory: str) -> list[ConfigFile]:
    """Extract configuration files from directory.
    
    Args:
        directory: Directory to search for config files
        
    Returns:
        List of ConfigFile objects
    """
    config_files = []
    
    # Common config file patterns
    config_patterns = [
        "application.yml",
        "application.yaml", 
        "application.properties",
        "application-*.properties",
        "bootstrap.yml",
        "bootstrap.yaml",
        "bootstrap.properties"
    ]
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            # Check if file matches any config pattern
            is_config_file = False
            for pattern in config_patterns:
                if pattern == file or (pattern.endswith('*') and file.startswith(pattern[:-1])):
                    is_config_file = True
                    break
            
            if is_config_file:
                file_path = os.path.join(root, file)
                
                if file.endswith(('.yml', '.yaml')):
                    config_file = parse_yaml_config(file_path)
                elif file.endswith('.properties'):
                    config_file = parse_properties_config(file_path)
                else:
                    continue
                
                config_files.append(config_file)
    
    return config_files


def extract_test_classes_from_classes(classes: list[Class]) -> list[TestClass]:
    """Extract test classes from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of TestClass objects
    """
    test_classes = []
    
    for cls in classes:
        # Check if class is a test class
        test_annotations = [ann for ann in cls.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
        
        if not test_annotations:
            continue
        
        # Determine test framework and type
        test_framework = "junit"  # default
        test_type = "unit"  # default
        
        for ann in test_annotations:
            if ann.name in ["SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest", "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest"]:
                test_framework = "spring_test"
                if ann.name == "SpringBootTest":
                    test_type = "integration"
                else:
                    test_type = "slice"
            elif ann.name in ["TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass"]:
                test_framework = "testng"
            elif ann.name in ["Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll"]:
                test_framework = "junit"
        
        # Extract test methods
        test_methods = []
        setup_methods = []
        
        for method in cls.methods:
            method_annotations = [ann.name for ann in method.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
            
            if method_annotations:
                # Check if it's a setup/teardown method
                if any(ann in method_annotations for ann in ["BeforeEach", "AfterEach", "BeforeAll", "AfterAll", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass", "BeforeSuite", "AfterSuite"]):
                    setup_methods.append({
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters]
                    })
                else:
                    # Regular test method
                    test_method_info = {
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                        "assertions": [],
                        "mock_calls": [],
                        "test_data": [],
                        "expected_exceptions": [],
                        "timeout": 0,
                        "display_name": ""
                    }
                    
                    # Extract display name
                    for ann in method.annotations:
                        if ann.name == "DisplayName" and "value" in ann.parameters:
                            test_method_info["display_name"] = ann.parameters["value"]
                        elif ann.name == "Timeout" and "value" in ann.parameters:
                            test_method_info["timeout"] = ann.parameters["value"]
                    
                    # Extract expected exceptions
                    for ann in method.annotations:
                        if ann.name == "ExpectedExceptions" and "value" in ann.parameters:
                            test_method_info["expected_exceptions"] = ann.parameters["value"] if isinstance(ann.parameters["value"], list) else [ann.parameters["value"]]
                    
                    test_methods.append(test_method_info)
        
        # Extract mock dependencies
        mock_dependencies = []
        for prop in cls.properties:
            prop_annotations = [ann.name for ann in prop.annotations if classify_test_annotation(ann.name) in ["mockito", "spring_test"]]
            if prop_annotations:
                mock_dependencies.append({
                    "name": prop.name,
                    "type": prop.type,
                    "annotations": prop_annotations,
                    "mock_type": "mock" if "Mock" in prop_annotations else "spy" if "Spy" in prop_annotations else "bean"
                })
        
        # Extract test configurations
        test_configurations = []
        for ann in cls.annotations:
            if ann.name in ["TestConfiguration", "ActiveProfiles", "TestPropertySource"]:
                config_info = {
                    "name": ann.name,
                    "type": "configuration" if ann.name == "TestConfiguration" else "profile" if ann.name == "ActiveProfiles" else "property",
                    "properties": ann.parameters,
                    "active_profiles": ann.parameters.get("value", []) if ann.name == "ActiveProfiles" else [],
                    "test_slices": [],
                    "mock_beans": [],
                    "spy_beans": []
                }
                test_configurations.append(config_info)
        
        # Create test class
        test_class = TestClass(
            name=cls.name,
            package_name=cls.package_name,
            test_framework=test_framework,
            test_type=test_type,
            annotations=[ann.name for ann in test_annotations],
            test_methods=test_methods,
            setup_methods=setup_methods,
            mock_dependencies=mock_dependencies,
            test_configurations=test_configurations,
            file_path=cls.file_path
        )
        test_classes.append(test_class)
    
    return test_classes


def analyze_test_methods(test_class: TestClass, class_obj: Class) -> list[TestMethod]:
    """Analyze test methods for assertions, mock calls, and test data.
    
    Args:
        test_class: TestClass object
        class_obj: Original Class object
        
    Returns:
        List of analyzed TestMethod objects
    """
    test_methods = []
    
    for method_info in test_class.test_methods:
        # Find the corresponding method in the class
        method_obj = None
        for method in class_obj.methods:
            if method.name == method_info["name"]:
                method_obj = method
                break
        
        if not method_obj:
            continue
        
        # Analyze method source code for assertions and mock calls
        assertions = []
        mock_calls = []
        test_data = []
        
        if method_obj.source:
            source_code = method_obj.source
            
            # Find assertions (JUnit, AssertJ, etc.)
            assertion_patterns = [
                r'assert\w+\(',  # JUnit assertions
                r'assertThat\(',  # AssertJ
                r'assertEquals\(',  # JUnit
                r'assertTrue\(',  # JUnit
                r'assertFalse\(',  # JUnit
                r'assertNotNull\(',  # JUnit
                r'assertNull\(',  # JUnit
                r'assertThrows\(',  # JUnit 5
                r'assertDoesNotThrow\(',  # JUnit 5
                r'verify\(',  # Mockito verify
                r'when\(',  # Mockito when
                r'then\(',  # Mockito then
                r'given\(',  # BDDMockito given
                r'willReturn\(',  # Mockito willReturn
                r'willThrow\(',  # Mockito willThrow
            ]
            
            for pattern in assertion_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    assertions.append({
                        "type": match,
                        "line": source_code.find(match) + 1
                    })
            
            # Find mock calls
            mock_call_patterns = [
                r'(\w+)\.(\w+)\(',  # Method calls on objects
                r'mock\(',  # Mockito mock creation
                r'spy\(',  # Mockito spy creation
                r'@Mock\s+(\w+)',  # @Mock annotation
                r'@Spy\s+(\w+)',  # @Spy annotation
                r'@InjectMocks\s+(\w+)',  # @InjectMocks annotation
            ]
            
            for pattern in mock_call_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        mock_calls.append({
                            "object": match[0],
                            "method": match[1],
                            "type": "method_call"
                        })
                    else:
                        mock_calls.append({
                            "type": match,
                            "line": source_code.find(match) + 1
                        })
            
            # Find test data setup
            test_data_patterns = [
                r'new\s+(\w+)\(',  # Object creation
                r'(\w+)\s*=\s*new\s+(\w+)\(',  # Variable assignment with new
                r'@ValueSource\(',  # JUnit 5 @ValueSource
                r'@CsvSource\(',  # JUnit 5 @CsvSource
                r'@MethodSource\(',  # JUnit 5 @MethodSource
            ]
            
            for pattern in test_data_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        test_data.append({
                            "variable": match[0],
                            "type": match[1],
                            "pattern": "object_creation"
                        })
                    else:
                        test_data.append({
                            "type": match,
                            "pattern": "annotation"
                        })
        
        # Create TestMethod object
        test_method = TestMethod(
            name=method_info["name"],
            return_type=method_info["return_type"],
            annotations=method_info["annotations"],
            assertions=assertions,
            mock_calls=mock_calls,
            test_data=test_data,
            expected_exceptions=method_info["expected_exceptions"],
            timeout=method_info["timeout"],
            display_name=method_info["display_name"]
        )
        test_methods.append(test_method)
    
    return test_methods


def generate_lombok_methods(properties: list[Field], class_name: str, package_name: str) -> list[Method]:
    """Generate Lombok @Data methods (getters, setters, equals, hashCode, toString) for properties."""
    methods = []
    
    # Generate getters and setters for each property
    for prop in properties:
        # Getter
        getter_name = f"get{prop.name[0].upper()}{prop.name[1:]}"
        if prop.type == "Boolean" and prop.name.startswith("is"):
            # For boolean fields starting with 'is', use the field name as getter
            getter_name = prop.name
        
        getter = Method(
            name=getter_name,
            logical_name=f"{package_name}.{class_name}.{getter_name}",
            return_type=prop.type,
            parameters=[],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[]
        )
        methods.append(getter)
        
        # Setter
        setter_name = f"set{prop.name[0].upper()}{prop.name[1:]}"
        setter_param = Field(
            name=prop.name,
            logical_name=f"{package_name}.{class_name}.{prop.name}",
            type=prop.type,
            package_name=package_name,
            class_name=class_name
        )
        
        setter = Method(
            name=setter_name,
            logical_name=f"{package_name}.{class_name}.{setter_name}",
            return_type="void",
            parameters=[setter_param],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[]
        )
        methods.append(setter)
    
    # Generate equals method
    equals_method = Method(
        name="equals",
        logical_name=f"{package_name}.{class_name}.equals",
        return_type="boolean",
        parameters=[Field(name="obj", logical_name=f"{package_name}.{class_name}.obj", type="Object", package_name=package_name, class_name=class_name)],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(equals_method)
    
    # Generate hashCode method
    hashcode_method = Method(
        name="hashCode",
        logical_name=f"{package_name}.{class_name}.hashCode",
        return_type="int",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(hashcode_method)
    
    # Generate toString method
    tostring_method = Method(
        name="toString",
        logical_name=f"{package_name}.{class_name}.toString",
        return_type="String",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(tostring_method)
    
    return methods


def parse_java_project(directory: str) -> tuple[list[Package], list[Class], dict[str, str], list[Bean], list[BeanDependency], list[Endpoint], list[MyBatisMapper], list[JpaEntity], list[ConfigFile], list[TestClass], list[SqlStatement], str]:
    """Parse Java project and return parsed entities."""
    logger = get_logger(__name__)
    """Parses all Java files in a directory and returns a tuple of (packages, classes, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name)."""
    
    # Extract project name from directory path
    project_name = extract_project_name(directory)
    packages = {}
    classes = {}
    class_to_package_map = {}  # Maps class_key to package_name

    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith(".java"):
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    file_content = f.read() # Read file content once
                try:
                    tree = javalang.parse.parse(file_content)
                    package_name = tree.package.name if tree.package else ""
                    
                    # Create or update package node
                    if package_name and package_name not in packages:
                        packages[package_name] = Package(
                            name=package_name
                        )
                    elif not package_name:
                        # Handle classes without package (default package)
                        package_name = "default"
                        if package_name not in packages:
                            packages[package_name] = Package(
                                name=package_name
                            )
                    
                    import_map = {}
                    for imp in tree.imports:
                        class_name = imp.path.split('.')[-1]
                        import_map[class_name] = imp.path

                    for _, class_declaration in tree.filter(
                        javalang.tree.ClassDeclaration
                    ):
                        class_name = class_declaration.name
                        class_key = f"{package_name}.{class_name}"
                        
                        # Debug: Check if this is the User class
                        if "User" in class_name:
                            logger.debug(f"Found User class - {class_key}")
                            logger.debug(f"Methods count: {len(class_declaration.methods)}")
                            logger.debug(f"Constructors count: {len(class_declaration.constructors)}")
                        
                        # Extract class source code - use the entire file content
                        class_source = file_content


                        if class_key not in classes:
                            # Parse class annotations
                            class_annotations = parse_annotations(class_declaration.annotations, "class") if hasattr(class_declaration, 'annotations') else []
                            
                            classes[class_key] = Class(
                                name=class_name,
                                logical_name=class_key,  # Add logical_name
                                file_path=file_path,
                                type="class", # Simplified for now
                                source=class_source, # Add class source
                                annotations=class_annotations,
                                package_name=package_name
                            )
                            class_to_package_map[class_key] = package_name
                        
                        # --- Start of new import logic ---
                        for imp in tree.imports:
                            classes[class_key].imports.append(imp.path)
                        # --- End of new import logic ---

                        # --- Start of new inheritance logic ---
                        # Handle 'extends'
                        if class_declaration.extends:
                            superclass_name = class_declaration.extends.name
                            # Try to resolve fully qualified name for superclass
                            if superclass_name in import_map:
                                classes[class_key].superclass = import_map[superclass_name]
                            else:
                                # Assume same package or fully qualified if not in import_map
                                classes[class_key].superclass = f"{package_name}.{superclass_name}" if package_name else superclass_name

                        # Handle 'implements'
                        if class_declaration.implements: # Add this check
                            for impl_ref in class_declaration.implements:
                                interface_name = impl_ref.name
                                # Try to resolve fully qualified name for interface
                                if interface_name in import_map:
                                    classes[class_key].interfaces.append(import_map[interface_name])
                                else:
                                    # Assume same package or fully qualified if not in import_map
                                    classes[class_key].interfaces.append(f"{package_name}.{interface_name}" if package_name else interface_name)
                        # --- End of new inheritance logic ---

                        field_map = {}
                        for field_declaration in class_declaration.fields:
                            for declarator in field_declaration.declarators:
                                field_map[declarator.name] = field_declaration.type.name
                                
                                # Parse field annotations
                                field_annotations = parse_annotations(field_declaration.annotations, "field") if hasattr(field_declaration, 'annotations') else []
                                
                                # Extract initial value if present
                                initial_value = ""
                                if hasattr(declarator, 'initializer') and declarator.initializer:
                                    # Convert the initializer to string representation
                                    if hasattr(declarator.initializer, 'value'):
                                        initial_value = str(declarator.initializer.value)
                                    elif hasattr(declarator.initializer, 'type'):
                                        initial_value = str(declarator.initializer.type)
                                    else:
                                        initial_value = str(declarator.initializer)
                                
                                prop = Field(
                                    name=declarator.name,
                                    logical_name=f"{package_name}.{class_name}.{declarator.name}",
                                    type=field_declaration.type.name,
                                    modifiers=list(field_declaration.modifiers), # Add modifiers
                                    package_name=package_name,
                                    class_name=class_name,
                                    annotations=field_annotations,
                                    initial_value=initial_value
                                )
                                classes[class_key].properties.append(prop)

                        all_declarations = class_declaration.methods + class_declaration.constructors
                        
                        # Debug: Check User class method processing
                        if "User" in class_name:
                            logger.debug(f"Processing User class methods - total declarations: {len(all_declarations)}")
                            for i, decl in enumerate(all_declarations):
                                logger.debug(f"Declaration {i}: {type(decl).__name__} - {decl.name}")
                        
                        for declaration in all_declarations:
                            local_var_map = field_map.copy()
                            params = []
                            for param in declaration.parameters:
                                param_type_name = 'Unknown'
                                if hasattr(param.type, 'name'):
                                    param_type_name = param.type.name
                                local_var_map[param.name] = param_type_name
                                params.append(Property(name=param.name, logical_name=f"{package_name}.{class_name}.{param.name}", type=param_type_name, package_name=package_name, class_name=class_name))

                            if declaration.body:
                                for _, var_decl in declaration.filter(javalang.tree.LocalVariableDeclaration):
                                    for declarator in var_decl.declarators:
                                        local_var_map[declarator.name] = var_decl.type.name
                            
                            if isinstance(declaration, javalang.tree.MethodDeclaration):
                                return_type = declaration.return_type.name if declaration.return_type else "void"
                            else: # ConstructorDeclaration
                                return_type = "constructor"

                            # Extract modifiers
                            modifiers = list(declaration.modifiers)
                            
                            # Parse method annotations
                            method_annotations = parse_annotations(declaration.annotations, "method") if hasattr(declaration, 'annotations') else []

                            # Extract method source code
                            method_source = ""
                            if declaration.position:
                                lines = file_content.splitlines(keepends=True) # Keep line endings
                                start_line = declaration.position.line - 1
                                
                                # Find the end of the method by matching braces
                                brace_count = 0
                                end_line = start_line
                                for i in range(start_line, len(lines)):
                                    line = lines[i]
                                    for char in line:
                                        if char == '{':
                                            brace_count += 1
                                        elif char == '}':
                                            brace_count -= 1
                                            if brace_count == 0:
                                                end_line = i
                                                break
                                    if brace_count == 0:
                                        break
                                
                                method_source = "".join(lines[start_line:end_line + 1])

                            method = Method(
                                name=declaration.name,
                                logical_name=f"{class_key}.{declaration.name}",  # Add logical_name
                                return_type=return_type,
                                parameters=params,
                                modifiers=modifiers,
                                source=method_source, # Add method source
                                package_name=package_name,
                                annotations=method_annotations
                            )
                            classes[class_key].methods.append(method)

                            # Extract method calls with order information
                            call_order = 0
                            for _, invocation in declaration.filter(javalang.tree.MethodInvocation):
                                target_class_name = None
                                resolved_target_package = ""
                                resolved_target_class_name = ""
                                
                                if invocation.qualifier:
                                    # External method call
                                    if invocation.qualifier in local_var_map:
                                        target_class_name = local_var_map[invocation.qualifier]
                                    else:
                                        target_class_name = invocation.qualifier
                                    
                                    if target_class_name:
                                        if target_class_name == "System.out":
                                            resolved_target_package = "java.io"
                                            resolved_target_class_name = "PrintStream"
                                        else:
                                            if target_class_name in import_map:
                                                resolved_target_package = ".".join(import_map[target_class_name].split(".")[:-1])
                                            else:
                                                resolved_target_package = package_name
                                                resolved_target_class_name = target_class_name
                                else:
                                    # Same class method call
                                    resolved_target_package = package_name
                                    resolved_target_class_name = class_name

                                if resolved_target_class_name:
                                    # Get line number from invocation position
                                    line_number = invocation.position.line if invocation.position else 0

                                    call = MethodCall(
                                        source_package=package_name,
                                        source_class=class_name,
                                        source_method=declaration.name,
                                        target_package=resolved_target_package,
                                        target_class=resolved_target_class_name,
                                        target_method=invocation.member,
                                        call_order=call_order,
                                        line_number=line_number,
                                        return_type="void"  # Default return type, can be enhanced later
                                    )
                                    classes[class_key].calls.append(call)
                                    call_order += 1
                        
                        # Check for Lombok @Data annotation and generate methods
                        has_data_annotation = any(ann.name == "Data" for ann in classes[class_key].annotations)
                        if has_data_annotation:
                            logger.debug(f"Found @Data annotation on {class_name}, generating Lombok methods")
                            lombok_methods = generate_lombok_methods(classes[class_key].properties, class_name, package_name)
                            classes[class_key].methods.extend(lombok_methods)
                            logger.debug(f"Generated {len(lombok_methods)} Lombok methods for {class_name}")
                except javalang.parser.JavaSyntaxError as e:
                    print(f"Syntax error in {file_path}: {e}")
                    continue
                except Exception as e:
                    print(f"Error parsing {file_path}: {e}")
                    continue
    
    # Extract beans, analyze dependencies, extract endpoints, extract MyBatis mappers, extract JPA entities, extract config files, and extract test classes
    classes_list = list(classes.values())
    beans = extract_beans_from_classes(classes_list)
    dependencies = analyze_bean_dependencies(classes_list, beans)
    endpoints = extract_endpoints_from_classes(classes_list)
    mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
    jpa_entities = extract_jpa_entities_from_classes(classes_list)
    config_files = extract_config_files(directory)
    test_classes = extract_test_classes_from_classes(classes_list)
    
    # Also extract XML mappers
    xml_mappers = extract_mybatis_xml_mappers(directory)
    mybatis_mappers.extend(xml_mappers)
    
    # Extract SQL statements from MyBatis mappers
    sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
    
    return list(packages.values()), classes_list, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name
```

```python
import os
import yaml
import re
from pathlib import Path

import javalang

from src.models.graph_entities import Class, Method, MethodCall, Field, Package, Annotation, Bean, BeanDependency, Endpoint, MyBatisMapper, MyBatisSqlStatement, MyBatisResultMap, SqlStatement, JpaEntity, JpaColumn, JpaRelationship, ConfigFile, DatabaseConfig, ServerConfig, SecurityConfig, LoggingConfig, TestClass, TestMethod, TestConfiguration
from src.utils.logger import get_logger
from typing import Optional, List, Literal


def extract_project_name(java_source_folder: str) -> str:
    """
    JAVA_SOURCE_FOLDER 경로에서 프로젝트 이름을 추출합니다.
    
    Args:
        java_source_folder: Java 소스 폴더 경로
        
    Returns:
        프로젝트 이름 (마지막 디렉토리명)
    """
    # 경로를 정규화하고 마지막 디렉토리명 추출
    path = Path(java_source_folder).resolve()
    return path.name


def extract_sql_statements_from_mappers(mybatis_mappers: list[MyBatisMapper], project_name: str) -> list[SqlStatement]:
    """
    MyBatis mappers에서 SQL statements를 추출합니다.
    
    Args:
        mybatis_mappers: MyBatis mapper 객체들의 리스트
        project_name: 프로젝트 이름
        
    Returns:
        SqlStatement 객체들의 리스트
    """
    sql_statements = []
    
    for mapper in mybatis_mappers:
        for sql_dict in mapper.sql_statements:
            # MyBatisSqlStatement를 SqlStatement로 변환
            sql_statement = SqlStatement(
                id=sql_dict.get('id', ''),
                sql_type=sql_dict.get('sql_type', ''),
                sql_content=sql_dict.get('sql_content', ''),
                parameter_type=sql_dict.get('parameter_type', ''),
                result_type=sql_dict.get('result_type', ''),
                result_map=sql_dict.get('result_map', ''),
                mapper_name=mapper.name,
                annotations=[],  # TODO: annotations를 파싱하여 추가
                project_name=project_name
            )
            sql_statements.append(sql_statement)
    
    return sql_statements


def parse_annotations(annotations, target_type: str = "class") -> list[Annotation]:
    """Parse Java annotations into Annotation objects.
    
    Args:
        annotations: List of annotation nodes from javalang
        target_type: Type of target ("class", "method", "field")
    """
    result = []
    for annotation in annotations:
        annotation_name = annotation.name
        parameters = {}
        
        # Parse annotation parameters if they exist
        if hasattr(annotation, 'element') and annotation.element:
            for element in annotation.element:
                if hasattr(element, 'name') and hasattr(element, 'value'):
                    parameters[element.name] = element.value.value if hasattr(element.value, 'value') else str(element.value)
        
        result.append(Annotation(
            name=annotation_name,
            parameters=parameters,
            target_type=target_type,
            category=classify_springboot_annotation(annotation_name)
        ))
    
    return result


def classify_springboot_annotation(annotation_name: str) -> str:
    """Classify SpringBoot annotations into categories.
    
    Args:
        annotation_name: Name of the annotation (e.g., "@Component", "@Service")
        
    Returns:
        Category of the annotation
    """
    # Component annotations
    component_annotations = {
        "Component", "Service", "Repository", "Controller", 
        "RestController", "Configuration", "Bean"
    }
    
    # Injection annotations
    injection_annotations = {
        "Autowired", "Resource", "Value", "Qualifier", "Primary"
    }
    
    # Web annotations
    web_annotations = {
        "RequestMapping", "GetMapping", "PostMapping", "PutMapping", 
        "DeleteMapping", "PatchMapping", "RequestParam", "PathVariable",
        "RequestBody", "ResponseBody", "ResponseStatus"
    }
    
    # JPA annotations
    jpa_annotations = {
        "Entity", "Table", "Id", "Column", "OneToMany", "ManyToOne",
        "OneToOne", "ManyToMany", "JoinColumn", "GeneratedValue"
    }
    
    # Test annotations
    test_annotations = {
        "Test", "SpringBootTest", "DataJpaTest", "WebMvcTest",
        "MockBean", "SpyBean", "TestPropertySource"
    }
    
    # Security annotations
    security_annotations = {
        "PreAuthorize", "PostAuthorize", "Secured", "RolesAllowed",
        "EnableWebSecurity", "EnableGlobalMethodSecurity"
    }
    
    # Validation annotations
    validation_annotations = {
        "Valid", "NotNull", "NotBlank", "NotEmpty", "Size", "Min", "Max",
        "Pattern", "Email", "AssertTrue", "AssertFalse"
    }
    
    # MyBatis annotations
    mybatis_annotations = {
        "Mapper", "Select", "Insert", "Update", "Delete", "SelectProvider",
        "InsertProvider", "UpdateProvider", "DeleteProvider", "Results",
        "Result", "One", "Many", "MapKey", "Options", "SelectKey"
    }
    
    if annotation_name in component_annotations:
        return "component"
    elif annotation_name in injection_annotations:
        return "injection"
    elif annotation_name in web_annotations:
        return "web"
    elif annotation_name in jpa_annotations:
        return "jpa"
    elif annotation_name in test_annotations:
        return "test"
    elif annotation_name in security_annotations:
        return "security"
    elif annotation_name in validation_annotations:
        return "validation"
    elif annotation_name in mybatis_annotations:
        return "mybatis"
    else:
        return "other"


def classify_test_annotation(annotation_name: str) -> str:
    """Classify test annotations into categories.
    
    Args:
        annotation_name: Name of the annotation
        
    Returns:
        Category of the test annotation
    """
    # JUnit annotations
    junit_annotations = {
        "Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll",
        "DisplayName", "ParameterizedTest", "ValueSource", "CsvSource",
        "MethodSource", "Timeout", "Disabled", "Nested", "RepeatedTest",
        "Order", "TestMethodOrder", "TestInstance", "TestClassOrder"
    }
    
    # Spring Boot Test annotations
    spring_test_annotations = {
        "SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest",
        "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest",
        "MockBean", "SpyBean", "TestConfiguration", "ActiveProfiles",
        "TestPropertySource", "DirtiesContext", "Transactional",
        "Rollback", "Commit", "Sql", "SqlGroup", "AutoConfigureTestDatabase",
        "AutoConfigureMockMvc", "AutoConfigureWebMvc", "AutoConfigureWebClient",
        "MockMvc", "TestEntityManager", "TestContainers", "DynamicPropertySource"
    }
    
    # TestNG annotations
    testng_annotations = {
        "TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass",
        "BeforeSuite", "AfterSuite", "BeforeGroups", "AfterGroups",
        "DataProvider", "Parameters", "Groups", "Priority", "DependsOnMethods",
        "DependsOnGroups", "ExpectedExceptions", "InvocationCount",
        "SuccessPercentage", "TimeOut"
    }
    
    # Mockito annotations
    mockito_annotations = {
        "Mock", "Spy", "InjectMocks", "Captor", "MockedStatic"
    }
    
    # AssertJ annotations
    assertj_annotations = {
        "AssertJ"
    }
    
    # Other test annotations
    other_test_annotations = {
        "Ignore", "Category", "RunWith", "ExtendWith", "ContextConfiguration"
    }
    
    if annotation_name in junit_annotations:
        return "junit"
    elif annotation_name in spring_test_annotations:
        return "spring_test"
    elif annotation_name in testng_annotations:
        return "testng"
    elif annotation_name in mockito_annotations:
        return "mockito"
    elif annotation_name in assertj_annotations:
        return "assertj"
    elif annotation_name in other_test_annotations:
        return "other_test"
    else:
        return "other"


def extract_beans_from_classes(classes: list[Class]) -> list[Bean]:
    """Extract Spring Beans from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Bean objects
    """
    beans = []
    
    for cls in classes:
        # Check if class has Spring component annotations
        component_annotations = [ann for ann in cls.annotations if ann.category == "component"]
        
        # Also check for @Repository on interfaces
        has_repository_annotation = any(ann.name == "Repository" for ann in cls.annotations)
        
        if component_annotations or has_repository_annotation:
            # Determine bean type based on annotations
            bean_type = "component"  # default
            if any(ann.name in ["Service", "Service"] for ann in cls.annotations):
                bean_type = "service"
            elif any(ann.name in ["Repository", "Repository"] for ann in cls.annotations):
                bean_type = "repository"
            elif any(ann.name in ["Controller", "RestController"] for ann in cls.annotations):
                bean_type = "controller"
            elif any(ann.name in ["Configuration", "Configuration"] for ann in cls.annotations):
                bean_type = "configuration"
            
            # Determine scope (default is singleton)
            scope = "singleton"
            for ann in cls.annotations:
                if ann.name == "Scope":
                    if "value" in ann.parameters:
                        scope = ann.parameters["value"]
                    elif "prototype" in str(ann.parameters):
                        scope = "prototype"
                    elif "request" in str(ann.parameters):
                        scope = "request"
                    elif "session" in str(ann.parameters):
                        scope = "session"
            
            # Create bean name (use class name with first letter lowercase)
            bean_name = cls.name[0].lower() + cls.name[1:] if cls.name else cls.name
            
            # Check for @Bean methods in configuration classes
            bean_methods = []
            if bean_type == "configuration":
                for method in cls.methods:
                    if any(ann.name == "Bean" for ann in method.annotations):
                        bean_methods.append(method)
            
            bean = Bean(
                name=bean_name,
                type=bean_type,
                scope=scope,
                class_name=cls.name,
                package_name=cls.package_name,
                annotation_names=[ann.name for ann in cls.annotations] if cls.annotations else [],
                method_count=len(bean_methods) if bean_type == "configuration" else len(cls.methods) if cls.methods else 0,
                property_count=len(cls.properties) if cls.properties else 0
            )
            beans.append(bean)
    
    return beans


def analyze_bean_dependencies(classes: list[Class], beans: list[Bean]) -> list[BeanDependency]:
    """Analyze dependencies between Spring Beans.
    
    Args:
        classes: List of parsed Class objects
        beans: List of Bean objects
        
    Returns:
        List of BeanDependency objects
    """
    dependencies = []
    
    # Create a mapping from class names to bean names
    class_to_bean = {}
    for bean in beans:
        class_to_bean[bean.class_name] = bean.name
    
    for cls in classes:
        # Check if this class is a bean
        if cls.name not in class_to_bean:
            continue
            
        source_bean = class_to_bean[cls.name]
        
        # Analyze field injections (@Autowired, @Resource, @Value)
        for prop in cls.properties:
            if any(ann.category == "injection" for ann in prop.annotations):
                # Try to determine target bean from field type
                target_bean = None
                field_type = prop.type
                
                # Look for exact class name match
                if field_type in class_to_bean:
                    target_bean = class_to_bean[field_type]
                else:
                    # Look for interface implementations (simplified - just check if type matches any bean class name)
                    for bean in beans:
                        if field_type == bean.class_name:
                            target_bean = bean.name
                            break
                
                if target_bean:
                    injection_type = "field"
                    for ann in prop.annotations:
                        if ann.name == "Autowired":
                            injection_type = "field"
                        elif ann.name == "Resource":
                            injection_type = "field"
                        elif ann.name == "Value":
                            injection_type = "field"
                    
                    dependency = BeanDependency(
                        source_bean=source_bean,
                        target_bean=target_bean,
                        injection_type=injection_type,
                        field_name=prop.name
                    )
                    dependencies.append(dependency)
        
        # Analyze constructor injections
        for method in cls.methods:
            if method.name == cls.name:  # Constructor
                for param in method.parameters:
                    if any(ann.category == "injection" for ann in param.annotations):
                        target_bean = None
                        param_type = param.type
                        
                        if param_type in class_to_bean:
                            target_bean = class_to_bean[param_type]
                        else:
                            # Look for interface implementations (simplified)
                            for bean in beans:
                                if param_type == bean.class_name:
                                    target_bean = bean.name
                                    break
                        
                        if target_bean:
                            dependency = BeanDependency(
                                source_bean=source_bean,
                                target_bean=target_bean,
                                injection_type="constructor",
                                parameter_name=param.name
                            )
                            dependencies.append(dependency)
        
        # Analyze setter injections
        for method in cls.methods:
            if method.name.startswith("set") and len(method.parameters) == 1:
                if any(ann.category == "injection" for ann in method.annotations):
                    param = method.parameters[0]
                    target_bean = None
                    param_type = param.type
                    
                    if param_type in class_to_bean:
                        target_bean = class_to_bean[param_type]
                    else:
                        # Look for interface implementations (simplified)
                        for bean in beans:
                            if param_type == bean.class_name:
                                target_bean = bean.name
                                break
                    
                    if target_bean:
                        dependency = BeanDependency(
                            source_bean=source_bean,
                            target_bean=target_bean,
                            injection_type="setter",
                            method_name=method.name,
                            parameter_name=param.name
                        )
                        dependencies.append(dependency)
    
    return dependencies


def extract_endpoints_from_classes(classes: list[Class]) -> list[Endpoint]:
    """Extract REST API endpoints from controller classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Endpoint objects
    """
    endpoints = []
    
    for cls in classes:
        # Check if class is a controller
        is_controller = any(ann.name in ["Controller", "RestController"] for ann in cls.annotations)
        
        if not is_controller:
            continue
            
        # Get class-level path mapping
        class_path = ""
        for ann in cls.annotations:
            if ann.name == "RequestMapping":
                if "value" in ann.parameters:
                    class_path = ann.parameters["value"]
                break
        
        # Process each method in the controller
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
                
            # Check if method has web mapping annotations
            web_annotations = [ann for ann in method.annotations if ann.category == "web"]
            
            if not web_annotations:
                continue
            
            # Extract endpoint information
            endpoint_path = ""
            http_method = "GET"  # default
            
            for ann in web_annotations:
                if ann.name in ["RequestMapping", "GetMapping", "PostMapping", "PutMapping", "DeleteMapping", "PatchMapping"]:
                    # Extract path
                    if "value" in ann.parameters:
                        endpoint_path = ann.parameters["value"]
                    elif "path" in ann.parameters:
                        endpoint_path = ann.parameters["path"]
                    
                    # Extract HTTP method
                    if ann.name == "GetMapping":
                        http_method = "GET"
                    elif ann.name == "PostMapping":
                        http_method = "POST"
                    elif ann.name == "PutMapping":
                        http_method = "PUT"
                    elif ann.name == "DeleteMapping":
                        http_method = "DELETE"
                    elif ann.name == "PatchMapping":
                        http_method = "PATCH"
                    elif ann.name == "RequestMapping":
                        if "method" in ann.parameters:
                            method_value = ann.parameters["method"]
                            if isinstance(method_value, list) and len(method_value) > 0:
                                http_method = method_value[0]
                            else:
                                http_method = str(method_value)
                        else:
                            http_method = "GET"  # default for RequestMapping
                    break
            
            # Build full path
            full_path = class_path
            if endpoint_path:
                if full_path and not full_path.endswith("/") and not endpoint_path.startswith("/"):
                    full_path += "/"
                full_path += endpoint_path
            elif not full_path:
                full_path = "/"
            
            # Extract method parameters
            parameters = []
            for param in method.parameters:
                param_info = {
                    "name": param.name,
                    "type": param.type,
                    "annotations": [ann.name for ann in param.annotations if ann.category == "web"]
                }
                parameters.append(param_info)
            
            # Extract return type
            return_type = method.return_type if method.return_type != "constructor" else "void"
            
            # Create endpoint
            endpoint = Endpoint(
                path=endpoint_path or "/",
                method=http_method,
                controller_class=cls.name,
                handler_method=method.name,
                parameters=parameters,
                return_type=return_type,
                annotations=[ann.name for ann in web_annotations],
                full_path=full_path
            )
            endpoints.append(endpoint)
    
    return endpoints


def extract_mybatis_mappers_from_classes(classes: list[Class]) -> list[MyBatisMapper]:
    """Extract MyBatis Mappers from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for cls in classes:
        # Check if class is a MyBatis Mapper interface
        is_mapper = any(ann.name == "Mapper" for ann in cls.annotations)
        
        if not is_mapper:
            continue
        
        # Extract mapper methods with MyBatis annotations
        mapper_methods = []
        sql_statements = []
        
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
            
            # Check if method has MyBatis annotations
            mybatis_annotations = [ann for ann in method.annotations if ann.category == "mybatis"]
            
            if not mybatis_annotations:
                continue
            
            # Extract SQL statement information
            sql_type = "SELECT"  # default
            sql_content = ""
            parameter_type = ""
            result_type = ""
            result_map = ""
            
            for ann in mybatis_annotations:
                if ann.name in ["Select", "SelectProvider"]:
                    sql_type = "SELECT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Insert", "InsertProvider"]:
                    sql_type = "INSERT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Update", "UpdateProvider"]:
                    sql_type = "UPDATE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Delete", "DeleteProvider"]:
                    sql_type = "DELETE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                
                # Extract parameter and result type information
                if "parameterType" in ann.parameters:
                    parameter_type = ann.parameters["parameterType"]
                if "resultType" in ann.parameters:
                    result_type = ann.parameters["resultType"]
                if "resultMap" in ann.parameters:
                    result_map = ann.parameters["resultMap"]
            
            # Create method info
            method_info = {
                "name": method.name,
                "return_type": method.return_type,
                "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            mapper_methods.append(method_info)
            
            # Create SQL statement info
            sql_statement = {
                "id": method.name,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            sql_statements.append(sql_statement)
        
        # Create mapper
        mapper = MyBatisMapper(
            name=cls.name,
            type="interface",
            namespace=f"{cls.package_name}.{cls.name}",
            methods=mapper_methods,
            sql_statements=sql_statements,
            file_path=cls.file_path,
            package_name=cls.package_name
        )
        mappers.append(mapper)
    
    return mappers


def parse_mybatis_xml_file(file_path: str) -> MyBatisMapper:
    """Parse MyBatis XML mapper file.
    
    Args:
        file_path: Path to the XML mapper file
        
    Returns:
        MyBatisMapper object
    """
    import xml.etree.ElementTree as ET
    
    try:
        tree = ET.parse(file_path)
        root = tree.getroot()
        
        # Extract namespace
        namespace = root.get("namespace", "")
        
        # Extract SQL statements
        sql_statements = []
        for statement in root.findall(".//*[@id]"):
            statement_id = statement.get("id")
            tag_name = statement.tag.lower()
            
            # Determine SQL type
            sql_type = "SELECT"
            if tag_name == "insert":
                sql_type = "INSERT"
            elif tag_name == "update":
                sql_type = "UPDATE"
            elif tag_name == "delete":
                sql_type = "DELETE"
            
            # Extract SQL content
            sql_content = statement.text.strip() if statement.text else ""
            
            # Extract parameter and result information
            parameter_type = statement.get("parameterType", "")
            result_type = statement.get("resultType", "")
            result_map = statement.get("resultMap", "")
            
            sql_statement = {
                "id": statement_id,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": []
            }
            sql_statements.append(sql_statement)
        
        # Extract ResultMaps
        result_maps = []
        for result_map in root.findall(".//resultMap"):
            result_map_id = result_map.get("id")
            result_map_type = result_map.get("type", "")
            
            properties = []
            for property_elem in result_map.findall(".//result"):
                prop = {
                    "property": property_elem.get("property", ""),
                    "column": property_elem.get("column", ""),
                    "jdbc_type": property_elem.get("jdbcType", "")
                }
                properties.append(prop)
            
            result_map_info = {
                "id": result_map_id,
                "type": result_map_type,
                "properties": properties,
                "associations": [],
                "collections": []
            }
            result_maps.append(result_map_info)
        
        # Create mapper
        mapper_name = namespace.split(".")[-1] if namespace else os.path.basename(file_path).replace(".xml", "")
        package_name = ".".join(namespace.split(".")[:-1]) if namespace else ""
        
        mapper = MyBatisMapper(
            name=mapper_name,
            type="xml",
            namespace=namespace,
            methods=[],  # XML mappers don't have Java methods
            sql_statements=sql_statements,
            file_path=file_path,
            package_name=package_name
        )
        
        return mapper
        
    except ET.ParseError as e:
        print(f"Error parsing XML file {file_path}: {e}")
        return None
    except Exception as e:
        print(f"Error reading XML file {file_path}: {e}")
        return None


def extract_mybatis_xml_mappers(directory: str) -> list[MyBatisMapper]:
    """Extract MyBatis XML mappers from directory.
    
    Args:
        directory: Directory to search for XML mapper files
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith("Mapper.xml") or file.endswith("Dao.xml"):
                file_path = os.path.join(root, file)
                mapper = parse_mybatis_xml_file(file_path)
                if mapper:
                    mappers.append(mapper)
    
    return mappers


def extract_jpa_entities_from_classes(classes: list[Class]) -> list[JpaEntity]:
    """Extract JPA Entities from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of JpaEntity objects
    """
    entities = []
    
    for cls in classes:
        # Check if class is a JPA Entity
        is_entity = any(ann.name == "Entity" for ann in cls.annotations)
        
        if not is_entity:
            continue
        
        # Extract table name
        table_name = cls.name.lower()  # default table name
        for ann in cls.annotations:
            if ann.name == "Table":
                if "name" in ann.parameters:
                    table_name = ann.parameters["name"]
                break
        
        # Extract columns from properties
        columns = []
        relationships = []
        
        for prop in cls.properties:
            # Check if property has JPA column annotations
            jpa_annotations = [ann for ann in prop.annotations if ann.category == "jpa"]
            
            if jpa_annotations:
                # Extract column information
                column_name = prop.name  # default column name
                nullable = True
                unique = False
                length = 0
                precision = 0
                scale = 0
                
                for ann in jpa_annotations:
                    if ann.name == "Column":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                        if "nullable" in ann.parameters:
                            nullable = ann.parameters["nullable"]
                        if "unique" in ann.parameters:
                            unique = ann.parameters["unique"]
                        if "length" in ann.parameters:
                            length = ann.parameters["length"]
                        if "precision" in ann.parameters:
                            precision = ann.parameters["precision"]
                        if "scale" in ann.parameters:
                            scale = ann.parameters["scale"]
                    elif ann.name == "Id":
                        column_name = "id"  # Primary key column
                        nullable = False
                        unique = True
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                
                # Check for relationship annotations
                relationship_type = None
                target_entity = ""
                mapped_by = ""
                join_column = ""
                join_table = ""
                cascade = []
                fetch = "LAZY"
                
                for ann in jpa_annotations:
                    if ann.name in ["OneToOne", "OneToMany", "ManyToOne", "ManyToMany"]:
                        relationship_type = ann.name
                        if "targetEntity" in ann.parameters:
                            target_entity = ann.parameters["targetEntity"]
                        if "mappedBy" in ann.parameters:
                            mapped_by = ann.parameters["mappedBy"]
                        if "cascade" in ann.parameters:
                            cascade = ann.parameters["cascade"] if isinstance(ann.parameters["cascade"], list) else [ann.parameters["cascade"]]
                        if "fetch" in ann.parameters:
                            fetch = ann.parameters["fetch"]
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            join_column = ann.parameters["name"]
                    elif ann.name == "JoinTable":
                        if "name" in ann.parameters:
                            join_table = ann.parameters["name"]
                
                # Create column info
                column_info = {
                    "property_name": prop.name,
                    "column_name": column_name,
                    "data_type": prop.type,
                    "nullable": nullable,
                    "unique": unique,
                    "length": length,
                    "precision": precision,
                    "scale": scale,
                    "annotations": [ann.name for ann in jpa_annotations]
                }
                columns.append(column_info)
                
                # Create relationship info if it's a relationship
                if relationship_type:
                    relationship_info = {
                        "type": relationship_type,
                        "target_entity": target_entity,
                        "mapped_by": mapped_by,
                        "join_column": join_column,
                        "join_table": join_table,
                        "cascade": cascade,
                        "fetch": fetch,
                        "annotations": [ann.name for ann in jpa_annotations]
                    }
                    relationships.append(relationship_info)
        
        # Create entity
        entity = JpaEntity(
            name=cls.name,
            table_name=table_name,
            columns=columns,
            relationships=relationships,
            annotations=[ann.name for ann in cls.annotations if ann.category == "jpa"],
            package_name=cls.package_name,
            file_path=cls.file_path
        )
        entities.append(entity)
    
    return entities


def parse_yaml_config(file_path: str) -> ConfigFile:
    """Parse YAML configuration file.
    
    Args:
        file_path: Path to the YAML file
        
    Returns:
        ConfigFile object
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = yaml.safe_load(f)
        
        if not content:
            content = {}
        
        # Extract file info
        file_name = os.path.basename(file_path)
        file_type = "yaml" if file_path.endswith('.yaml') else "yml"
        
        # Extract profiles
        profiles = []
        if 'spring' in content and 'profiles' in content['spring']:
            if 'active' in content['spring']['profiles']:
                profiles = content['spring']['profiles']['active']
                if isinstance(profiles, str):
                    profiles = [profiles]
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        # Extract sections
        sections = []
        for key, value in content.items():
            if isinstance(value, dict):
                sections.append({
                    "name": key,
                    "properties": value,
                    "type": "section"
                })
        
        return ConfigFile(
            name=file_name,
            file_path=file_path,
            file_type=file_type,
            properties=content,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing YAML file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="yaml",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def parse_properties_config(file_path: str) -> ConfigFile:
    """Parse Properties configuration file.
    
    Args:
        file_path: Path to the properties file
        
    Returns:
        ConfigFile object
    """
    try:
        properties = {}
        sections = []
        profiles = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                
                # Skip empty lines and comments
                if not line or line.startswith('#'):
                    continue
                
                # Parse key=value pairs
                if '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    
                    # Remove quotes if present
                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]
                    elif value.startswith("'") and value.endswith("'"):
                        value = value[1:-1]
                    
                    properties[key] = value
                    
                    # Check for profiles
                    if key == 'spring.profiles.active':
                        profiles = [p.strip() for p in value.split(',')]
        
        # Group properties by section
        section_map = {}
        for key, value in properties.items():
            if '.' in key:
                section = key.split('.')[0]
                if section not in section_map:
                    section_map[section] = {}
                section_map[section][key] = value
            else:
                if 'root' not in section_map:
                    section_map['root'] = {}
                section_map['root'][key] = value
        
        for section_name, section_props in section_map.items():
            sections.append({
                "name": section_name,
                "properties": section_props,
                "type": "section"
            })
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties=properties,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing Properties file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def extract_database_config(config_file: ConfigFile) -> DatabaseConfig:
    """Extract database configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        DatabaseConfig object
    """
    db_config = DatabaseConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        spring_config = config_file.properties.get('spring', {})
        datasource_config = spring_config.get('datasource', {})
        jpa_config = spring_config.get('jpa', {})
        
        db_config.driver = datasource_config.get('driver-class-name', '')
        db_config.url = datasource_config.get('url', '')
        db_config.username = datasource_config.get('username', '')
        db_config.password = datasource_config.get('password', '')
        db_config.dialect = jpa_config.get('database-platform', '')
        db_config.hibernate_ddl_auto = jpa_config.get('hibernate', {}).get('ddl-auto', '')
        db_config.show_sql = jpa_config.get('show-sql', False)
        db_config.format_sql = jpa_config.get('properties', {}).get('hibernate', {}).get('format_sql', False)
        
        # Store additional JPA properties
        if 'properties' in jpa_config:
            db_config.jpa_properties = jpa_config['properties']
    
    else:
        # Properties format
        props = config_file.properties
        
        db_config.driver = props.get('spring.datasource.driver-class-name', '')
        db_config.url = props.get('spring.datasource.url', '')
        db_config.username = props.get('spring.datasource.username', '')
        db_config.password = props.get('spring.datasource.password', '')
        db_config.dialect = props.get('spring.jpa.database-platform', '')
        db_config.hibernate_ddl_auto = props.get('spring.jpa.hibernate.ddl-auto', '')
        db_config.show_sql = props.get('spring.jpa.show-sql', 'false').lower() == 'true'
        db_config.format_sql = props.get('spring.jpa.properties.hibernate.format_sql', 'false').lower() == 'true'
        
        # Store additional JPA properties
        jpa_props = {}
        for key, value in props.items():
            if key.startswith('spring.jpa.properties.'):
                jpa_props[key] = value
        db_config.jpa_properties = jpa_props
    
    return db_config


def extract_server_config(config_file: ConfigFile) -> ServerConfig:
    """Extract server configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        ServerConfig object
    """
    server_config = ServerConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        server_props = config_file.properties.get('server', {})
        
        server_config.port = server_props.get('port', 8080)
        server_config.context_path = server_props.get('servlet', {}).get('context-path', '')
        server_config.servlet_path = server_props.get('servlet', {}).get('path', '')
        
        # SSL configuration
        ssl_config = server_props.get('ssl', {})
        server_config.ssl_enabled = bool(ssl_config)
        server_config.ssl_key_store = ssl_config.get('key-store', '')
        server_config.ssl_key_store_password = ssl_config.get('key-store-password', '')
        server_config.ssl_key_store_type = ssl_config.get('key-store-type', '')
    
    else:
        # Properties format
        props = config_file.properties
        
        server_config.port = int(props.get('server.port', '8080'))
        server_config.context_path = props.get('server.servlet.context-path', '')
        server_config.servlet_path = props.get('server.servlet.path', '')
        
        # SSL configuration
        server_config.ssl_enabled = any(key.startswith('server.ssl.') for key in props.keys())
        server_config.ssl_key_store = props.get('server.ssl.key-store', '')
        server_config.ssl_key_store_password = props.get('server.ssl.key-store-password', '')
        server_config.ssl_key_store_type = props.get('server.ssl.key-store-type', '')
    
    return server_config


def extract_security_config(config_file: ConfigFile) -> SecurityConfig:
    """Extract security configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        SecurityConfig object
    """
    security_config = SecurityConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        security_props = config_file.properties.get('security', {})
        jwt_props = security_props.get('jwt', {})
        cors_props = security_props.get('cors', {})
        
        security_config.enabled = bool(security_props)
        security_config.authentication_type = security_props.get('authentication-type', '')
        security_config.jwt_secret = jwt_props.get('secret', '')
        security_config.jwt_expiration = jwt_props.get('expiration', 0)
        security_config.cors_allowed_origins = cors_props.get('allowed-origins', [])
        security_config.cors_allowed_methods = cors_props.get('allowed-methods', [])
        security_config.cors_allowed_headers = cors_props.get('allowed-headers', [])
    
    else:
        # Properties format
        props = config_file.properties
        
        security_config.enabled = any(key.startswith('security.') for key in props.keys())
        security_config.authentication_type = props.get('security.authentication-type', '')
        security_config.jwt_secret = props.get('security.jwt.secret', '')
        security_config.jwt_expiration = int(props.get('security.jwt.expiration', '0'))
        
        # CORS configuration
        origins = props.get('security.cors.allowed-origins', '')
        if origins:
            security_config.cors_allowed_origins = [o.strip() for o in origins.split(',')]
        
        methods = props.get('security.cors.allowed-methods', '')
        if methods:
            security_config.cors_allowed_methods = [m.strip() for m in methods.split(',')]
        
        headers = props.get('security.cors.allowed-headers', '')
        if headers:
            security_config.cors_allowed_headers = [h.strip() for h in headers.split(',')]
    
    return security_config


def extract_logging_config(config_file: ConfigFile) -> LoggingConfig:
    """Extract logging configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        LoggingConfig object
    """
    logging_config = LoggingConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        logging_props = config_file.properties.get('logging', {})
        
        logging_config.level = logging_props.get('level', {}).get('root', 'INFO')
        logging_config.pattern = logging_props.get('pattern', {}).get('console', '')
        logging_config.file_path = logging_props.get('file', {}).get('name', '')
        logging_config.max_file_size = logging_props.get('file', {}).get('max-size', '')
        logging_config.max_history = logging_props.get('file', {}).get('max-history', 0)
        logging_config.console_output = logging_props.get('console', {}).get('enabled', True)
    
    else:
        # Properties format
        props = config_file.properties
        
        logging_config.level = props.get('logging.level.root', 'INFO')
        logging_config.pattern = props.get('logging.pattern.console', '')
        logging_config.file_path = props.get('logging.file.name', '')
        logging_config.max_file_size = props.get('logging.file.max-size', '')
        logging_config.max_history = int(props.get('logging.file.max-history', '0'))
        logging_config.console_output = props.get('logging.console.enabled', 'true').lower() == 'true'
    
    return logging_config


def extract_config_files(directory: str) -> list[ConfigFile]:
    """Extract configuration files from directory.
    
    Args:
        directory: Directory to search for config files
        
    Returns:
        List of ConfigFile objects
    """
    config_files = []
    
    # Common config file patterns
    config_patterns = [
        "application.yml",
        "application.yaml", 
        "application.properties",
        "application-*.properties",
        "bootstrap.yml",
        "bootstrap.yaml",
        "bootstrap.properties"
    ]
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            # Check if file matches any config pattern
            is_config_file = False
            for pattern in config_patterns:
                if pattern == file or (pattern.endswith('*') and file.startswith(pattern[:-1])):
                    is_config_file = True
                    break
            
            if is_config_file:
                file_path = os.path.join(root, file)
                
                if file.endswith(('.yml', '.yaml')):
                    config_file = parse_yaml_config(file_path)
                elif file.endswith('.properties'):
                    config_file = parse_properties_config(file_path)
                else:
                    continue
                
                config_files.append(config_file)
    
    return config_files


def extract_test_classes_from_classes(classes: list[Class]) -> list[TestClass]:
    """Extract test classes from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of TestClass objects
    """
    test_classes = []
    
    for cls in classes:
        # Check if class is a test class
        test_annotations = [ann for ann in cls.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
        
        if not test_annotations:
            continue
        
        # Determine test framework and type
        test_framework = "junit"  # default
        test_type = "unit"  # default
        
        for ann in test_annotations:
            if ann.name in ["SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest", "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest"]:
                test_framework = "spring_test"
                if ann.name == "SpringBootTest":
                    test_type = "integration"
                else:
                    test_type = "slice"
            elif ann.name in ["TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass"]:
                test_framework = "testng"
            elif ann.name in ["Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll"]:
                test_framework = "junit"
        
        # Extract test methods
        test_methods = []
        setup_methods = []
        
        for method in cls.methods:
            method_annotations = [ann.name for ann in method.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
            
            if method_annotations:
                # Check if it's a setup/teardown method
                if any(ann in method_annotations for ann in ["BeforeEach", "AfterEach", "BeforeAll", "AfterAll", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass", "BeforeSuite", "AfterSuite"]):
                    setup_methods.append({
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters]
                    })
                else:
                    # Regular test method
                    test_method_info = {
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                        "assertions": [],
                        "mock_calls": [],
                        "test_data": [],
                        "expected_exceptions": [],
                        "timeout": 0,
                        "display_name": ""
                    }
                    
                    # Extract display name
                    for ann in method.annotations:
                        if ann.name == "DisplayName" and "value" in ann.parameters:
                            test_method_info["display_name"] = ann.parameters["value"]
                        elif ann.name == "Timeout" and "value" in ann.parameters:
                            test_method_info["timeout"] = ann.parameters["value"]
                    
                    # Extract expected exceptions
                    for ann in method.annotations:
                        if ann.name == "ExpectedExceptions" and "value" in ann.parameters:
                            test_method_info["expected_exceptions"] = ann.parameters["value"] if isinstance(ann.parameters["value"], list) else [ann.parameters["value"]]
                    
                    test_methods.append(test_method_info)
        
        # Extract mock dependencies
        mock_dependencies = []
        for prop in cls.properties:
            prop_annotations = [ann.name for ann in prop.annotations if classify_test_annotation(ann.name) in ["mockito", "spring_test"]]
            if prop_annotations:
                mock_dependencies.append({
                    "name": prop.name,
                    "type": prop.type,
                    "annotations": prop_annotations,
                    "mock_type": "mock" if "Mock" in prop_annotations else "spy" if "Spy" in prop_annotations else "bean"
                })
        
        # Extract test configurations
        test_configurations = []
        for ann in cls.annotations:
            if ann.name in ["TestConfiguration", "ActiveProfiles", "TestPropertySource"]:
                config_info = {
                    "name": ann.name,
                    "type": "configuration" if ann.name == "TestConfiguration" else "profile" if ann.name == "ActiveProfiles" else "property",
                    "properties": ann.parameters,
                    "active_profiles": ann.parameters.get("value", []) if ann.name == "ActiveProfiles" else [],
                    "test_slices": [],
                    "mock_beans": [],
                    "spy_beans": []
                }
                test_configurations.append(config_info)
        
        # Create test class
        test_class = TestClass(
            name=cls.name,
            package_name=cls.package_name,
            test_framework=test_framework,
            test_type=test_type,
            annotations=[ann.name for ann in test_annotations],
            test_methods=test_methods,
            setup_methods=setup_methods,
            mock_dependencies=mock_dependencies,
            test_configurations=test_configurations,
            file_path=cls.file_path
        )
        test_classes.append(test_class)
    
    return test_classes


def analyze_test_methods(test_class: TestClass, class_obj: Class) -> list[TestMethod]:
    """Analyze test methods for assertions, mock calls, and test data.
    
    Args:
        test_class: TestClass object
        class_obj: Original Class object
        
    Returns:
        List of analyzed TestMethod objects
    """
    test_methods = []
    
    for method_info in test_class.test_methods:
        # Find the corresponding method in the class
        method_obj = None
        for method in class_obj.methods:
            if method.name == method_info["name"]:
                method_obj = method
                break
        
        if not method_obj:
            continue
        
        # Analyze method source code for assertions and mock calls
        assertions = []
        mock_calls = []
        test_data = []
        
        if method_obj.source:
            source_code = method_obj.source
            
            # Find assertions (JUnit, AssertJ, etc.)
            assertion_patterns = [
                r'assert\w+\(',  # JUnit assertions
                r'assertThat\(',  # AssertJ
                r'assertEquals\(',  # JUnit
                r'assertTrue\(',  # JUnit
                r'assertFalse\(',  # JUnit
                r'assertNotNull\(',  # JUnit
                r'assertNull\(',  # JUnit
                r'assertThrows\(',  # JUnit 5
                r'assertDoesNotThrow\(',  # JUnit 5
                r'verify\(',  # Mockito verify
                r'when\(',  # Mockito when
                r'then\(',  # Mockito then
                r'given\(',  # BDDMockito given
                r'willReturn\(',  # Mockito willReturn
                r'willThrow\(',  # Mockito willThrow
            ]
            
            for pattern in assertion_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    assertions.append({
                        "type": match,
                        "line": source_code.find(match) + 1
                    })
            
            # Find mock calls
            mock_call_patterns = [
                r'(\w+)\.(\w+)\(',  # Method calls on objects
                r'mock\(',  # Mockito mock creation
                r'spy\(',  # Mockito spy creation
                r'@Mock\s+(\w+)',  # @Mock annotation
                r'@Spy\s+(\w+)',  # @Spy annotation
                r'@InjectMocks\s+(\w+)',  # @InjectMocks annotation
            ]
            
            for pattern in mock_call_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        mock_calls.append({
                            "object": match[0],
                            "method": match[1],
                            "type": "method_call"
                        })
                    else:
                        mock_calls.append({
                            "type": match,
                            "line": source_code.find(match) + 1
                        })
            
            # Find test data setup
            test_data_patterns = [
                r'new\s+(\w+)\(',  # Object creation
                r'(\w+)\s*=\s*new\s+(\w+)\(',  # Variable assignment with new
                r'@ValueSource\(',  # JUnit 5 @ValueSource
                r'@CsvSource\(',  # JUnit 5 @CsvSource
                r'@MethodSource\(',  # JUnit 5 @MethodSource
            ]
            
            for pattern in test_data_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        test_data.append({
                            "variable": match[0],
                            "type": match[1],
                            "pattern": "object_creation"
                        })
                    else:
                        test_data.append({
                            "type": match,
                            "pattern": "annotation"
                        })
        
        # Create TestMethod object
        test_method = TestMethod(
            name=method_info["name"],
            return_type=method_info["return_type"],
            annotations=method_info["annotations"],
            assertions=assertions,
            mock_calls=mock_calls,
            test_data=test_data,
            expected_exceptions=method_info["expected_exceptions"],
            timeout=method_info["timeout"],
            display_name=method_info["display_name"]
        )
        test_methods.append(test_method)
    
    return test_methods


def generate_lombok_methods(properties: list[Field], class_name: str, package_name: str) -> list[Method]:
    """Generate Lombok @Data methods (getters, setters, equals, hashCode, toString) for properties."""
    methods = []
    
    # Generate getters and setters for each property
    for prop in properties:
        # Getter
        getter_name = f"get{prop.name[0].upper()}{prop.name[1:]}"
        if prop.type == "Boolean" and prop.name.startswith("is"):
            # For boolean fields starting with 'is', use the field name as getter
            getter_name = prop.name
        
        getter = Method(
            name=getter_name,
            logical_name=f"{package_name}.{class_name}.{getter_name}",
            return_type=prop.type,
            parameters=[],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[]
        )
        methods.append(getter)
        
        # Setter
        setter_name = f"set{prop.name[0].upper()}{prop.name[1:]}"
        setter_param = Field(
            name=prop.name,
            logical_name=f"{package_name}.{class_name}.{prop.name}",
            type=prop.type,
            package_name=package_name,
            class_name=class_name
        )
        
        setter = Method(
            name=setter_name,
            logical_name=f"{package_name}.{class_name}.{setter_name}",
            return_type="void",
            parameters=[setter_param],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[]
        )
        methods.append(setter)
    
    # Generate equals method
    equals_method = Method(
        name="equals",
        logical_name=f"{package_name}.{class_name}.equals",
        return_type="boolean",
        parameters=[Field(name="obj", logical_name=f"{package_name}.{class_name}.obj", type="Object", package_name=package_name, class_name=class_name)],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(equals_method)
    
    # Generate hashCode method
    hashcode_method = Method(
        name="hashCode",
        logical_name=f"{package_name}.{class_name}.hashCode",
        return_type="int",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(hashcode_method)
    
    # Generate toString method
    tostring_method = Method(
        name="toString",
        logical_name=f"{package_name}.{class_name}.toString",
        return_type="String",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(tostring_method)
    
    return methods


def parse_java_project(directory: str) -> tuple[list[Package], list[Class], dict[str, str], list[Bean], list[BeanDependency], list[Endpoint], list[MyBatisMapper], list[JpaEntity], list[ConfigFile], list[TestClass], list[SqlStatement], str]:
    """Parse Java project and return parsed entities."""
    logger = get_logger(__name__)
    """Parses all Java files in a directory and returns a tuple of (packages, classes, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name)."""
    
    # Extract project name from directory path
    project_name = extract_project_name(directory)
    packages = {}
    classes = {}
    class_to_package_map = {}  # Maps class_key to package_name

    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith(".java"):
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    file_content = f.read() # Read file content once
                try:
                    tree = javalang.parse.parse(file_content)
                    package_name = tree.package.name if tree.package else ""
                    
                    # Create or update package node
                    if package_name and package_name not in packages:
                        packages[package_name] = Package(
                            name=package_name
                        )
                    elif not package_name:
                        # Handle classes without package (default package)
                        package_name = "default"
                        if package_name not in packages:
                            packages[package_name] = Package(
                                name=package_name
                            )
                    
                    import_map = {}
                    for imp in tree.imports:
                        class_name = imp.path.split('.')[-1]
                        import_map[class_name] = imp.path

                    for _, class_declaration in tree.filter(
                        javalang.tree.ClassDeclaration
                    ):
                        class_name = class_declaration.name
                        class_key = f"{package_name}.{class_name}"
                        
                        # Debug: Check if this is the User class
                        if "User" in class_name:
                            logger.debug(f"Found User class - {class_key}")
                            logger.debug(f"Methods count: {len(class_declaration.methods)}")
                            logger.debug(f"Constructors count: {len(class_declaration.constructors)}")
                        
                        # Extract class source code - use the entire file content
                        class_source = file_content


                        if class_key not in classes:
                            # Parse class annotations
                            class_annotations = parse_annotations(class_declaration.annotations, "class") if hasattr(class_declaration, 'annotations') else []
                            
                            classes[class_key] = Class(
                                name=class_name,
                                logical_name=class_key,  # Add logical_name
                                file_path=file_path,
                                type="class", # Simplified for now
                                source=class_source, # Add class source
                                annotations=class_annotations,
                                package_name=package_name
                            )
                            class_to_package_map[class_key] = package_name
                        
                        # --- Start of new import logic ---
                        for imp in tree.imports:
                            classes[class_key].imports.append(imp.path)
                        # --- End of new import logic ---

                        # --- Start of new inheritance logic ---
                        # Handle 'extends'
                        if class_declaration.extends:
                            superclass_name = class_declaration.extends.name
                            # Try to resolve fully qualified name for superclass
                            if superclass_name in import_map:
                                classes[class_key].superclass = import_map[superclass_name]
                            else:
                                # Assume same package or fully qualified if not in import_map
                                classes[class_key].superclass = f"{package_name}.{superclass_name}" if package_name else superclass_name

                        # Handle 'implements'
                        if class_declaration.implements: # Add this check
                            for impl_ref in class_declaration.implements:
                                interface_name = impl_ref.name
                                # Try to resolve fully qualified name for interface
                                if interface_name in import_map:
                                    classes[class_key].interfaces.append(import_map[interface_name])
                                else:
                                    # Assume same package or fully qualified if not in import_map
                                    classes[class_key].interfaces.append(f"{package_name}.{interface_name}" if package_name else interface_name)
                        # --- End of new inheritance logic ---

                        field_map = {}
                        for field_declaration in class_declaration.fields:
                            for declarator in field_declaration.declarators:
                                field_map[declarator.name] = field_declaration.type.name
                                
                                # Parse field annotations
                                field_annotations = parse_annotations(field_declaration.annotations, "field") if hasattr(field_declaration, 'annotations') else []
                                
                                # Extract initial value if present
                                initial_value = ""
                                if hasattr(declarator, 'initializer') and declarator.initializer:
                                    # Convert the initializer to string representation
                                    if hasattr(declarator.initializer, 'value'):
                                        initial_value = str(declarator.initializer.value)
                                    elif hasattr(declarator.initializer, 'type'):
                                        initial_value = str(declarator.initializer.type)
                                    else:
                                        initial_value = str(declarator.initializer)
                                
                                prop = Field(
                                    name=declarator.name,
                                    logical_name=f"{package_name}.{class_name}.{declarator.name}",
                                    type=field_declaration.type.name,
                                    modifiers=list(field_declaration.modifiers), # Add modifiers
                                    package_name=package_name,
                                    class_name=class_name,
                                    annotations=field_annotations,
                                    initial_value=initial_value
                                )
                                classes[class_key].properties.append(prop)

                        all_declarations = class_declaration.methods + class_declaration.constructors
                        
                        # Debug: Check User class method processing
                        if "User" in class_name:
                            logger.debug(f"Processing User class methods - total declarations: {len(all_declarations)}")
                            for i, decl in enumerate(all_declarations):
                                logger.debug(f"Declaration {i}: {type(decl).__name__} - {decl.name}")
                        
                        for declaration in all_declarations:
                            local_var_map = field_map.copy()
                            params = []
                            for param in declaration.parameters:
                                param_type_name = 'Unknown'
                                if hasattr(param.type, 'name'):
                                    param_type_name = param.type.name
                                local_var_map[param.name] = param_type_name
                                params.append(Field(name=param.name, logical_name=f"{package_name}.{class_name}.{param.name}", type=param_type_name, package_name=package_name, class_name=class_name))

                            if declaration.body:
                                for _, var_decl in declaration.filter(javalang.tree.LocalVariableDeclaration):
                                    for declarator in var_decl.declarators:
                                        local_var_map[declarator.name] = var_decl.type.name
                            
                            if isinstance(declaration, javalang.tree.MethodDeclaration):
                                return_type = declaration.return_type.name if declaration.return_type else "void"
                            else: # ConstructorDeclaration
                                return_type = "constructor"

                            # Extract modifiers
                            modifiers = list(declaration.modifiers)
                            
                            # Parse method annotations
                            method_annotations = parse_annotations(declaration.annotations, "method") if hasattr(declaration, 'annotations') else []

                            # Extract method source code
                            method_source = ""
                            if declaration.position:
                                lines = file_content.splitlines(keepends=True) # Keep line endings
                                start_line = declaration.position.line - 1
                                
                                # Find the end of the method by matching braces
                                brace_count = 0
                                end_line = start_line
                                for i in range(start_line, len(lines)):
                                    line = lines[i]
                                    for char in line:
                                        if char == '{':
                                            brace_count += 1
                                        elif char == '}':
                                            brace_count -= 1
                                            if brace_count == 0:
                                                end_line = i
                                                break
                                    if brace_count == 0:
                                        break
                                
                                method_source = "".join(lines[start_line:end_line + 1])

                            method = Method(
                                name=declaration.name,
                                logical_name=f"{class_key}.{declaration.name}",  # Add logical_name
                                return_type=return_type,
                                parameters=params,
                                modifiers=modifiers,
                                source=method_source, # Add method source
                                package_name=package_name,
                                annotations=method_annotations
                            )
                            classes[class_key].methods.append(method)

                            # Extract method calls with order information
                            call_order = 0
                            for _, invocation in declaration.filter(javalang.tree.MethodInvocation):
                                target_class_name = None
                                resolved_target_package = ""
                                resolved_target_class_name = ""
                                
                                if invocation.qualifier:
                                    # External method call
                                    if invocation.qualifier in local_var_map:
                                        target_class_name = local_var_map[invocation.qualifier]
                                    else:
                                        target_class_name = invocation.qualifier
                                    
                                    if target_class_name:
                                        if target_class_name == "System.out":
                                            resolved_target_package = "java.io"
                                            resolved_target_class_name = "PrintStream"
                                        else:
                                            if target_class_name in import_map:
                                                resolved_target_package = ".".join(import_map[target_class_name].split(".")[:-1])
                                            else:
                                                resolved_target_package = package_name
                                                resolved_target_class_name = target_class_name
                                else:
                                    # Same class method call
                                    resolved_target_package = package_name
                                    resolved_target_class_name = class_name

                                if resolved_target_class_name:
                                    # Get line number from invocation position
                                    line_number = invocation.position.line if invocation.position else 0

                                    call = MethodCall(
                                        source_package=package_name,
                                        source_class=class_name,
                                        source_method=declaration.name,
                                        target_package=resolved_target_package,
                                        target_class=resolved_target_class_name,
                                        target_method=invocation.member,
                                        call_order=call_order,
                                        line_number=line_number,
                                        return_type="void"  # Default return type, can be enhanced later
                                    )
                                    classes[class_key].calls.append(call)
                                    call_order += 1
                        
                        # Check for Lombok @Data annotation and generate methods
                        has_data_annotation = any(ann.name == "Data" for ann in classes[class_key].annotations)
                        if has_data_annotation:
                            logger.debug(f"Found @Data annotation on {class_name}, generating Lombok methods")
                            lombok_methods = generate_lombok_methods(classes[class_key].properties, class_name, package_name)
                            classes[class_key].methods.extend(lombok_methods)
                            logger.debug(f"Generated {len(lombok_methods)} Lombok methods for {class_name}")
                except javalang.parser.JavaSyntaxError as e:
                    print(f"Syntax error in {file_path}: {e}")
                    continue
                except Exception as e:
                    print(f"Error parsing {file_path}: {e}")
                    continue
    
    # Extract beans, analyze dependencies, extract endpoints, extract MyBatis mappers, extract JPA entities, extract config files, and extract test classes
    classes_list = list(classes.values())
    beans = extract_beans_from_classes(classes_list)
    dependencies = analyze_bean_dependencies(classes_list, beans)
    endpoints = extract_endpoints_from_classes(classes_list)
    mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
    jpa_entities = extract_jpa_entities_from_classes(classes_list)
    config_files = extract_config_files(directory)
    test_classes = extract_test_classes_from_classes(classes_list)
    
    # Also extract XML mappers
    xml_mappers = extract_mybatis_xml_mappers(directory)
    mybatis_mappers.extend(xml_mappers)
    
    # Extract SQL statements from MyBatis mappers
    sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
    
    return list(packages.values()), classes_list, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name
```

이제 파서 서비스 변경이 완료되었습니다.


이제 데이터베이스 스키마에서 Property를 Field로 변경하겠습니다.


```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name"  # Add project_name
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name " # Add project_name
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, type: $prop_type}) "
                "SET p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.class_name = $class_name, " # Add class_name
                "p.project_name = $project_name " # Add project_name
                "MERGE (c)-[:HAS_PROPERTY]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

이제 관계 이름도 변경하겠습니다.


```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name"  # Add project_name
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name " # Add project_name
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, type: $prop_type}) "
                "SET p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.class_name = $class_name, " # Add class_name
                "p.project_name = $project_name " # Add project_name
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

이제 CLI에서도 Property를 Field로 변경하겠습니다.


```python
        OPTIONAL MATCH (c)-[:HAS_FIELD]->(p:Field)
```

```python
import click
import sys
import os
from dotenv import load_dotenv

# Add the project root to Python path
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from src.services.java_parser import parse_java_project
from src.services.graph_db import GraphDB
from src.services.sequence_diagram_generator import SequenceDiagramGenerator
from neo4j import GraphDatabase
import subprocess
import tempfile

load_dotenv()

def convert_to_image(diagram_content, output_file, image_format, width, height):
    """Convert Mermaid diagram to image using mermaid-cli"""
    # Try different possible locations for mmdc
    mmdc_commands = ['mmdc', 'mmdc.cmd', r'C:\Users\cjony\AppData\Roaming\npm\mmdc', r'C:\Users\cjony\AppData\Roaming\npm\mmdc.cmd']
    
    mmdc_cmd = None
    for cmd in mmdc_commands:
        try:
            subprocess.run([cmd, '--version'], capture_output=True, check=True, timeout=5)
            mmdc_cmd = cmd
            break
        except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired):
            continue
    
    if not mmdc_cmd:
        click.echo("Error: mermaid-cli is not installed or not found in PATH.")
        click.echo("Please install it with: npm install -g @mermaid-js/mermaid-cli")
        click.echo("Or check if it's installed at: C:\\Users\\cjony\\AppData\\Roaming\\npm\\")
        return
    
    try:
        # Create temporary file for mermaid content
        with tempfile.NamedTemporaryFile(mode='w', suffix='.md', delete=False, encoding='utf-8', newline='') as temp_file:
            temp_file.write(diagram_content)
            temp_file_path = temp_file.name
        
        # Determine format from output file extension
        file_extension = output_file.split('.')[-1].lower()
        actual_format = file_extension if file_extension in ['png', 'svg', 'pdf'] else image_format
        
        # Convert to image using mermaid-cli
        cmd = [
            mmdc_cmd,
            '-i', temp_file_path,
            '-o', output_file,
            '-e', actual_format,
            '-w', str(width),
            '-H', str(height)
        ]
        
        # Add PDF-specific options
        if image_format.lower() == 'pdf':
            # Set background color for PDF
            cmd.extend(['-b', 'white'])
            # Add PDF fit option
            cmd.append('-f')
        
        click.echo(f"Running command: {' '.join(cmd)}")
        
        # Set environment variables for UTF-8 encoding
        env = os.environ.copy()
        env['PYTHONIOENCODING'] = 'utf-8'
        env['LANG'] = 'en_US.UTF-8'
        env['LC_ALL'] = 'en_US.UTF-8'
        
        result = subprocess.run(cmd, capture_output=True, text=True, check=True, encoding='utf-8', errors='ignore', env=env)
        
        # Clean up temporary file
        os.unlink(temp_file_path)
        
        # Check if the expected output file was created
        if os.path.exists(output_file):
            actual_format = output_file.split('.')[-1].upper()
            click.echo(f"Image saved to: {output_file}")
            click.echo(f"Format: {actual_format}, Size: {width}x{height}")
        else:
            # Check for files with similar names (mermaid-cli sometimes adds numbers)
            import glob
            pattern = output_file.replace('.pdf', '-*.pdf').replace('.png', '-*.png').replace('.svg', '-*.svg')
            matching_files = glob.glob(pattern)
            if matching_files:
                actual_file = matching_files[0]
                actual_format = actual_file.split('.')[-1].upper()
                click.echo(f"Image saved to: {actual_file}")
                click.echo(f"Format: {actual_format}, Size: {width}x{height}")
                click.echo(f"Note: mermaid-cli created {actual_file} instead of {output_file}")
            else:
                click.echo(f"Warning: Expected file {output_file} not found")
        
        click.echo(f"Command output: {result.stdout}")
        
    except subprocess.CalledProcessError as e:
        click.echo(f"Error converting to image: {e}")
        click.echo(f"Error output: {e.stderr}")
        if os.path.exists(temp_file_path):
            os.unlink(temp_file_path)
    except Exception as e:
        click.echo(f"Unexpected error: {e}")
        if 'temp_file_path' in locals() and os.path.exists(temp_file_path):
            os.unlink(temp_file_path)

@click.group()
def cli():
    pass

@cli.command()
@click.option('--java-source-folder', default=os.getenv("JAVA_SOURCE_FOLDER"), help='Path to the Java source project folder.')
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--neo4j-password', default=os.getenv("NEO4J_PASSWORD"), help='Neo4j password')
@click.option('--clean', is_flag=True, help='Wipe the database before analysis.')
@click.option('--dry-run', is_flag=True, help='Parse Java files without connecting to database.')
def analyze(java_source_folder, neo4j_uri, neo4j_user, neo4j_password, clean, dry_run):
    """Analyzes a Java project and populates a Neo4j database."""
    if not java_source_folder:
        click.echo("Error: JAVA_SOURCE_FOLDER environment variable or --java-source-folder option is required.", err=True)
        exit(1)

    click.echo(f"Parsing Java project at: {java_source_folder}")
    packages_to_add, classes_to_add, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name = parse_java_project(java_source_folder)
    
    click.echo(f"Project name: {project_name}")
    
    click.echo(f"Found {len(packages_to_add)} packages and {len(classes_to_add)} classes.")
    
    if dry_run:
        click.echo("Dry run mode - not connecting to database.")
        click.echo(f"Found {len(packages_to_add)} packages and {len(classes_to_add)} classes.")
        click.echo(f"Found {len(beans)} Spring Beans and {len(dependencies)} dependencies.")
        click.echo(f"Found {len(endpoints)} REST API endpoints.")
        click.echo(f"Found {len(mybatis_mappers)} MyBatis mappers.")
        click.echo(f"Found {len(jpa_entities)} JPA entities.")
        click.echo(f"Found {len(config_files)} configuration files.")
        click.echo(f"Found {len(test_classes)} test classes.")
        click.echo(f"Found {len(sql_statements)} SQL statements.")
        
        for package_node in packages_to_add:
            click.echo(f"Package: {package_node.name}")
        for class_node in classes_to_add:
            click.echo(f"Class: {class_node.name}")
            click.echo(f"  Methods: {len(class_node.methods)}")
            click.echo(f"  Properties: {len(class_node.properties)}")
            click.echo(f"  Method calls: {len(class_node.calls)}")
        click.echo("Analysis complete (dry run).")
        return

    try:
        click.echo(f"Connecting to Neo4j at {neo4j_uri}...")
        db = GraphDB(uri=neo4j_uri, user=neo4j_user, password=neo4j_password)

        if clean:
            click.echo("Cleaning database...")
            with db._driver.session() as session:
                session.run("MATCH (n) DETACH DELETE n")

        click.echo("Adding packages to database...")
        for package_node in packages_to_add:
            db.add_package(package_node, project_name)
        
        click.echo("Adding classes to database...")
        for class_node in classes_to_add:
            # Find the package for this class using the mapping
            class_key = f"{class_to_package_map.get(class_node.name, '')}.{class_node.name}"
            package_name = class_to_package_map.get(class_key, None)
            
            if not package_name:
                # Fallback: try to find package by class name
                for key, pkg_name in class_to_package_map.items():
                    if key.endswith(f".{class_node.name}"):
                        package_name = pkg_name
                        break
            
            db.add_class(class_node, package_name, project_name)
        
        # Add Spring Boot analysis results
        if beans:
            click.echo(f"Adding {len(beans)} Spring Beans to database...")
            for bean in beans:
                db.add_bean(bean, project_name)
        
        if dependencies:
            click.echo(f"Adding {len(dependencies)} Bean dependencies to database...")
            for dependency in dependencies:
                db.add_bean_dependency(dependency, project_name)
        
        if endpoints:
            click.echo(f"Adding {len(endpoints)} REST API endpoints to database...")
            for endpoint in endpoints:
                db.add_endpoint(endpoint, project_name)
        
        if mybatis_mappers:
            click.echo(f"Adding {len(mybatis_mappers)} MyBatis mappers to database...")
            for mapper in mybatis_mappers:
                db.add_mybatis_mapper(mapper, project_name)
        
        if jpa_entities:
            click.echo(f"Adding {len(jpa_entities)} JPA entities to database...")
            for entity in jpa_entities:
                db.add_jpa_entity(entity, project_name)
        
        if config_files:
            click.echo(f"Adding {len(config_files)} configuration files to database...")
            for config_file in config_files:
                db.add_config_file(config_file, project_name)
        
        if test_classes:
            click.echo(f"Adding {len(test_classes)} test classes to database...")
            for test_class in test_classes:
                db.add_test_class(test_class, project_name)
        
        if sql_statements:
            click.echo(f"Adding {len(sql_statements)} SQL statements to database...")
            for sql_statement in sql_statements:
                db.add_sql_statement(sql_statement, project_name)
                # Create relationship between mapper and SQL statement
                with db._driver.session() as session:
                    session.execute_write(db._create_mapper_sql_relationship_tx, sql_statement.mapper_name, sql_statement.id, project_name)
        
        db.close()
        click.echo("Analysis complete.")
    except Exception as e:
        click.echo(f"Error connecting to database: {e}")
        click.echo("Use --dry-run flag to parse without database connection.")
        exit(1)

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--neo4j-password', default=os.getenv("NEO4J_PASSWORD"), help='Neo4j password')
@click.option('--query', help='Custom Cypher query to execute')
@click.option('--basic', is_flag=True, help='Run basic class query')
@click.option('--detailed', is_flag=True, help='Run detailed class query with methods and properties')
@click.option('--inheritance', is_flag=True, help='Run inheritance relationship query')
@click.option('--package', is_flag=True, help='Run package-based class query')
def query(neo4j_uri, neo4j_user, neo4j_password, query, basic, detailed, inheritance, package):
    """Execute queries against the Neo4j database."""
    
    # 미리 정의된 쿼리들
    queries = {
        'basic': """
        MATCH (c:Class)
        RETURN 
            c.name AS name,
            c.logical_name AS logical_name,
            c.file_path AS file_path,
            c.type AS type,
            c.source AS source
        ORDER BY c.name
        """,
        'detailed': """
        MATCH (c:Class)
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (c)-[:HAS_FIELD]->(p:Field)
        OPTIONAL MATCH (pkg:Package)-[:CONTAINS]->(c)
        RETURN 
            c.name AS class_name,
            c.logical_name AS class_logical_name,
            c.file_path AS file_path,
            c.type AS class_type,
            pkg.name AS package_name,
            collect(DISTINCT m.name) AS methods,
            collect(DISTINCT p.name) AS properties
        ORDER BY c.name
        """,
        'inheritance': """
        MATCH (c:Class)
        OPTIONAL MATCH (c)-[:EXTENDS]->(super:Class)
        OPTIONAL MATCH (c)-[:IMPLEMENTS]->(impl:Class)
        RETURN 
            c.name AS class_name,
            c.logical_name AS class_logical_name,
            c.type AS class_type,
            collect(DISTINCT super.name) AS extends,
            collect(DISTINCT impl.name) AS implements
        ORDER BY c.name
        """,
        'package': """
        MATCH (pkg:Package)-[:CONTAINS]->(c:Class)
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (c)-[:HAS_FIELD]->(p:Field)
        RETURN 
            pkg.name AS package_name,
            pkg.logical_name AS package_logical_name,
            collect(DISTINCT c.name) AS classes,
            count(DISTINCT m) AS total_methods,
            count(DISTINCT p) AS total_properties
        ORDER BY pkg.name
        """
    }
    
    # 실행할 쿼리 결정
    if query:
        cypher_query = query
        description = "Custom Query"
    elif basic:
        cypher_query = queries['basic']
        description = "Basic Class Query"
    elif detailed:
        cypher_query = queries['detailed']
        description = "Detailed Class Query"
    elif inheritance:
        cypher_query = queries['inheritance']
        description = "Inheritance Query"
    elif package:
        cypher_query = queries['package']
        description = "Package Query"
    else:
        click.echo("Error: Please specify a query type or provide a custom query.")
        click.echo("Available options: --basic, --detailed, --inheritance, --package, or --query")
        return
    
    try:
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        
        with driver.session() as session:
            click.echo(f"Executing: {description}")
            click.echo("=" * 50)
            
            result = session.run(cypher_query)
            records = list(result)
            
            if not records:
                click.echo("No results found.")
                return
            
            # 첫 번째 레코드의 키들을 헤더로 사용
            headers = list(records[0].keys())
            
            # 헤더 출력
            click.echo(" | ".join(f"{header:20}" for header in headers))
            click.echo("-" * (len(headers) * 23))
            
            # 데이터 출력
            for record in records:
                row = []
                for header in headers:
                    value = record[header]
                    if value is None:
                        row.append("None")
                    elif isinstance(value, (list, dict)):
                        row.append(str(value)[:50] + "..." if len(str(value)) > 50 else str(value))
                    else:
                        row.append(str(value)[:20])
                click.echo(" | ".join(f"{cell:20}" for cell in row))
            
            click.echo(f"\nTotal: {len(records)} results found.")
            
    except Exception as e:
        click.echo(f"Error executing query: {e}")
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--class-name', required=True, help='Name of the class to analyze')
@click.option('--method-name', help='Specific method to analyze (optional)')
@click.option('--max-depth', default=3, help='Maximum depth of call chain to follow (default: 3)')
@click.option('--include-external', is_flag=True, help='Include calls to external libraries')
@click.option('--method-focused', is_flag=True, help='Generate method-focused diagram (shows only the specified method and its direct calls)')
@click.option('--output-file', help='Output file to save the diagram (optional)')
@click.option('--output-image', help='Output image file (PNG/SVG/PDF) - requires mermaid-cli')
@click.option('--image-format', default='png', type=click.Choice(['png', 'svg', 'pdf']), help='Image format (default: png)')
@click.option('--image-width', default=1200, help='Image width in pixels (default: 1200)')
@click.option('--image-height', default=800, help='Image height in pixels (default: 800)')
def sequence(neo4j_uri, neo4j_user, class_name, method_name, max_depth, include_external, method_focused, output_file, output_image, image_format, image_width, image_height):
    """Generate sequence diagram for a specific class and optionally a method."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        click.echo(f"Connecting to Neo4j at {neo4j_uri}...")
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        generator = SequenceDiagramGenerator(driver)
        
        # Generate the sequence diagram
        click.echo(f"Generating sequence diagram for class: {class_name}")
        if method_name:
            click.echo(f"Focusing on method: {method_name}")
        if method_focused:
            click.echo("Method-focused mode: showing only direct calls from the specified method")
        
        diagram = generator.generate_sequence_diagram(
            class_name=class_name,
            method_name=method_name,
            max_depth=max_depth if not method_focused else 1,  # Method-focused uses depth 1
            include_external_calls=include_external,
            method_focused=method_focused
        )
        
        click.echo(f"Diagram generated (length: {len(diagram)})")
        
        # Check if diagram contains error message
        if diagram.startswith("Error:"):
            click.echo(f"Error: {diagram}")
            return
        
        # Output the diagram
        if output_file:
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(diagram)
            click.echo(f"Sequence diagram saved to: {output_file}")
        else:
            # Default: save to {class_name}.md
            default_filename = f"{class_name}.md"
            with open(default_filename, 'w', encoding='utf-8') as f:
                f.write(diagram)
            click.echo(f"Sequence diagram saved to: {default_filename}")
            
            click.echo("\n" + "="*50)
            click.echo("SEQUENCE DIAGRAM")
            click.echo("="*50)
            click.echo(diagram)
            click.echo("="*50)
        
        # Convert to image if requested
        if output_image:
            convert_to_image(diagram, output_image, image_format, image_width, image_height)
        
    except Exception as e:
        click.echo(f"Error generating sequence diagram: {e}")
        import traceback
        click.echo(f"Traceback: {traceback.format_exc()}")
        exit(1)
    finally:
        if 'driver' in locals():
            driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
def list_classes(neo4j_uri, neo4j_user):
    """List all available classes in the database."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        generator = SequenceDiagramGenerator(driver)
        
        classes = generator.get_available_classes()
        
        if not classes:
            click.echo("No classes found in the database.")
            return
        
        click.echo("Available classes:")
        click.echo("=" * 80)
        click.echo(f"{'Class Name':<30} {'Package':<30} {'Type':<10}")
        click.echo("-" * 80)
        
        for cls in classes:
            click.echo(f"{cls['name']:<30} {cls['package_name']:<30} {cls['type']:<10}")
        
        click.echo(f"\nTotal: {len(classes)} classes found.")
        
    except Exception as e:
        click.echo(f"Error listing classes: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--class-name', required=True, help='Name of the class to list methods for')
def list_methods(neo4j_uri, neo4j_user, class_name):
    """List all methods for a specific class."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        generator = SequenceDiagramGenerator(driver)
        
        methods = generator.get_class_methods(class_name)
        
        if not methods:
            click.echo(f"No methods found for class '{class_name}'.")
            return
        
        click.echo(f"Methods for class '{class_name}':")
        click.echo("=" * 80)
        click.echo(f"{'Method Name':<30} {'Return Type':<20} {'Logical Name':<30}")
        click.echo("-" * 80)
        
        for method in methods:
            click.echo(f"{method['name']:<30} {method['return_type']:<20} {method['logical_name']:<30}")
        
        click.echo(f"\nTotal: {len(methods)} methods found.")
        
    except Exception as e:
        click.echo(f"Error listing methods: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--project-name', help='Project name to filter by (optional)')
def crud_matrix(neo4j_uri, neo4j_user, project_name):
    """Show CRUD matrix for classes and tables."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        db = GraphDB(neo4j_uri, neo4j_user, neo4j_password)
        
        click.echo("CRUD Matrix - Class to Table Operations")
        click.echo("=" * 80)
        
        matrix = db.get_crud_matrix(project_name)
        
        if not matrix:
            click.echo("No CRUD operations found.")
            return
        
        click.echo(f"{'Class Name':<30} {'Package':<25} {'Tables':<20} {'Operations':<15}")
        click.echo("-" * 80)
        
        for row in matrix:
            class_name = row['class_name']
            package_name = row['package_name'] or 'N/A'
            tables = ', '.join(row['tables']) if row['tables'] else 'None'
            operations = ', '.join(row['operations']) if row['operations'] else 'None'
            
            click.echo(f"{class_name:<30} {package_name:<25} {tables:<20} {operations:<15}")
        
        click.echo(f"\nTotal: {len(matrix)} classes with CRUD operations.")
        
    except Exception as e:
        click.echo(f"Error getting CRUD matrix: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--project-name', help='Project name to filter by (optional)')
def table_summary(neo4j_uri, neo4j_user, project_name):
    """Show CRUD summary for each table."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        db = GraphDB(neo4j_uri, neo4j_user, neo4j_password)
        
        click.echo("Table CRUD Summary")
        click.echo("=" * 60)
        
        summary = db.get_table_crud_summary(project_name)
        
        if not summary:
            click.echo("No tables found.")
            return
        
        for row in summary:
            table_name = row['table_name']
            operations = row['operations']
            
            click.echo(f"\nTable: {table_name}")
            click.echo("-" * 40)
            
            for op in operations:
                operation = op['operation']
                count = op['count']
                click.echo(f"  {operation}: {count} statements")
        
        click.echo(f"\nTotal: {len(summary)} tables.")
        
    except Exception as e:
        click.echo(f"Error getting table summary: {e}")
        exit(1)
    finally:
        driver.close()

if __name__ == '__main__':
    cli()

```

이제 데이터베이스 스키마 변경이 완료되었습니다.


이제 테스트 코드에서 Property를 Field로 변경하겠습니다.


```python
import pytest
from unittest.mock import patch, mock_open
from src.services.java_parser import parse_java_project
from src.models.graph_entities import Class, Field, Method, MethodCall

@patch("os.walk")
@patch("builtins.open", new_callable=mock_open, read_data='''
package com.example;

import com.external.OtherClass;

class MyClass {
    private String myField;

    public MyClass() { 
        // constructor
    }

    public void myMethod(String name) {
        OtherClass other = new OtherClass();
        other.doSomething();
    }

    public int anotherMethod(int count) {
        return count * 2;
    }
}
''')
def test_parse_java_project(mock_file, mock_walk):
    # Given
    mock_walk.return_value = [("/fake/dir", [], ["MyClass.java"])]

    # When
    classes = parse_java_project("/fake/dir")

    # Then
    assert len(classes) == 1
    my_class = classes[0]

    assert my_class.name == "MyClass"
    assert my_class.package == "com.example"
    
    assert len(my_class.properties) == 1
    assert my_class.properties[0].name == "myField"
    assert my_class.properties[0].type == "String"
    assert sorted(my_class.properties[0].modifiers) == sorted(["private"])

    # Check method calls
    assert len(my_class.calls) == 1
    call = my_class.calls[0]
    assert isinstance(call, MethodCall)
    assert call.source_package == "com.example"
    assert call.source_class == "MyClass"
    assert call.source_method == "myMethod"
    assert call.target_package == "com.external"
    assert call.target_class == "OtherClass"
    assert call.target_method == "doSomething"

    assert len(my_class.methods) == 3

    # Check constructor
    constructor = next((m for m in my_class.methods if m.name == "MyClass"), None)
    assert constructor is not None
    assert constructor.return_type == "constructor"
    assert len(constructor.parameters) == 0

    # Check myMethod
    my_method = next((m for m in my_class.methods if m.name == "myMethod"), None)
    assert my_method is not None
    assert my_method.return_type == "void"
    assert len(my_method.parameters) == 1
    assert my_method.parameters[0].name == "name"
    assert my_method.parameters[0].type == "String"

    # Check anotherMethod
    another_method = next((m for m in my_class.methods if m.name == "anotherMethod"), None)
    assert another_method is not None
    assert another_method.return_type == "int"
    assert len(another_method.parameters) == 1
    assert another_method.parameters[0].name == "count"
    assert another_method.parameters[0].type == "int"


@patch("os.walk")
@patch("builtins.open", new_callable=mock_open, read_data='''
package com.example;

import com.test.Parent;

public class Greeter extends Parent{
    private String greeting = "Hello";
    public static final int MAX_VALUE = 100;

    public void sayHello() {
        System.out.println(greeting + ", World!");
    }
}
''')
def test_parse_java_project_with_greeter_fields(mock_file, mock_walk):
    # Given
    mock_walk.return_value = [("/fake/dir", [], ["Greeter.java"])]

    # When
    classes = parse_java_project("/fake/dir")

    # Then
    assert len(classes) == 1
    greeter_class = classes[0]

    assert greeter_class.name == "Greeter"
    assert greeter_class.package == "com.example"

    assert len(greeter_class.properties) == 2

    greeting_field = next((p for p in greeter_class.properties if p.name == "greeting"), None)
    assert greeting_field is not None
    assert greeting_field.type == "String"
    assert sorted(greeting_field.modifiers) == sorted(["private"])

    max_value_field = next((p for p in greeter_class.properties if p.name == "MAX_VALUE"), None)
    assert max_value_field is not None
    assert max_value_field.type == "int"
    assert sorted(max_value_field.modifiers) == sorted(["public", "static", "final"])

```

이제 test_graph_db.py에서도 Property를 Field로 변경하겠습니다.


```python
import pytest
from unittest.mock import MagicMock, patch
import json # Added import for json

from src.services.graph_db import GraphDB
from src.models.graph_entities import Class, Field, Method, MethodCall # Import Method and Field

@pytest.fixture
def mock_db():
    with patch('neo4j.GraphDatabase.driver') as mock_driver_constructor:
        mock_driver_instance = MagicMock()
        mock_driver_constructor.return_value = mock_driver_instance
        db_service = GraphDB("uri", "user", "pass")
        yield db_service, mock_driver_instance
        db_service.close()

def test_add_class(mock_db):
    # Given
    db_service, mock_driver = mock_db
    mock_session = MagicMock()
    mock_tx = MagicMock()
    mock_driver.session.return_value.__enter__.return_value = mock_session
    mock_session.write_transaction.side_effect = lambda func, *args: func(mock_tx, *args)

    test_class = Class(
        name="TestClass",
        package="com.test",
        file_path="/path/to/TestClass.java",
        type="class",
        properties=[Property(name="testProp", type="int")],
        calls=[
            MethodCall(
                source_package="com.test",
                source_class="TestClass",
                source_method="myCallingMethod",
                target_package="com.another",
                target_class="AnotherClass",
                target_method="someCalledMethod"
            )
        ]
    )

    # When
    db_service.add_class(test_class)

    # Then
    assert mock_session.write_transaction.called
    
    # Collect all executed queries
    executed_queries = [call[0][0] for call in mock_tx.run.call_args_list]
    executed_params = [call[1] for call in mock_tx.run.call_args_list]

    # Check the MERGE query for the class itself
    class_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (c:Class {name: $name, package: $package})" in query:
            assert executed_params[i]['name'] == "TestClass"
            assert executed_params[i]['package'] == "com.test"
            class_query_found = True
            break
    assert class_query_found

    # Check the MERGE query for the property
    prop_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (p:Property {name: $prop_name, type: $prop_type})" in query:
            assert executed_params[i]['prop_name'] == "testProp"
            prop_query_found = True
            break
    assert prop_query_found

    # Check the MERGE query for the call relationship
    call_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (sm)-[r:CALLS]->(tm)" in query: # Changed to match the actual query in graph_db.py
            assert executed_params[i]['source_package'] == "com.test"
            assert executed_params[i]['source_class'] == "TestClass"
            assert executed_params[i]['source_method'] == "myCallingMethod"
            assert executed_params[i]['target_package'] == "com.another"
            assert executed_params[i]['target_class'] == "AnotherClass"
            assert executed_params[i]['target_method'] == "someCalledMethod"
            call_query_found = True
            break
    assert call_query_found


def test_add_class_with_fields(mock_db):
    # Given
    db_service, mock_driver = mock_db
    mock_session = MagicMock()
    mock_tx = MagicMock()
    mock_driver.session.return_value.__enter__.return_value = mock_session
    mock_session.write_transaction.side_effect = lambda func, *args: func(mock_tx, *args)

    test_field_private = Property(
        name="greeting", type="String", modifiers=["private"]
    )
    test_field_public_static_final = Property(
        name="MAX_VALUE", type="int", modifiers=["public", "static", "final"]
    )
    test_class = Class(
        name="Greeter",
        package="com.example",
        file_path="/path/to/Greeter.java",
        source="class Greeter { private String greeting; }",
        properties=[test_field_private, test_field_public_static_final],
    )

    # When
    db_service.add_class(test_class)

    # Then
    # Check the MERGE query for the class itself
    class_merge_call = mock_tx.run.call_args_list[0]
    assert "MERGE (c:Class {name: $name, package: $package})" in class_merge_call[0][0]
    assert class_merge_call[1]['name'] == "Greeter"

    # Check the MERGE query for the first property (greeting)
    prop1_merge_call = mock_tx.run.call_args_list[1]
    assert (
        "MERGE (p:Property {name: $prop_name, type: $prop_type}) "
        "SET p.modifiers = $prop_modifiers "
        "MERGE (c)-[:HAS_FIELD]->(p)"
    ) in prop1_merge_call[0][0]
    assert prop1_merge_call[1]['prop_name'] == "greeting"
    assert prop1_merge_call[1]['prop_type'] == "String"
    assert prop1_merge_call[1]['prop_modifiers'] == ["private"]

    # Check the MERGE query for the second property (MAX_VALUE)
    prop2_merge_call = mock_tx.run.call_args_list[2]
    assert (
        "MERGE (p:Property {name: $prop_name, type: $prop_type}) "
        "SET p.modifiers = $prop_modifiers "
        "MERGE (c)-[:HAS_FIELD]->(p)"
    ) in prop2_merge_call[0][0]
    assert prop2_merge_call[1]['prop_name'] == "MAX_VALUE"
    assert prop2_merge_call[1]['prop_type'] == "int"
    assert prop2_merge_call[1]['prop_modifiers'] == ["public", "static", "final"]

```

이제 테스트 코드에서 Property 생성 부분들을 Field로 변경하겠습니다.


```python
import pytest
from unittest.mock import MagicMock, patch
import json # Added import for json

from src.services.graph_db import GraphDB
from src.models.graph_entities import Class, Field, Method, MethodCall # Import Method and Field

@pytest.fixture
def mock_db():
    with patch('neo4j.GraphDatabase.driver') as mock_driver_constructor:
        mock_driver_instance = MagicMock()
        mock_driver_constructor.return_value = mock_driver_instance
        db_service = GraphDB("uri", "user", "pass")
        yield db_service, mock_driver_instance
        db_service.close()

def test_add_class(mock_db):
    # Given
    db_service, mock_driver = mock_db
    mock_session = MagicMock()
    mock_tx = MagicMock()
    mock_driver.session.return_value.__enter__.return_value = mock_session
    mock_session.write_transaction.side_effect = lambda func, *args: func(mock_tx, *args)

    test_class = Class(
        name="TestClass",
        package="com.test",
        file_path="/path/to/TestClass.java",
        type="class",
        properties=[Field(name="testProp", type="int")],
        calls=[
            MethodCall(
                source_package="com.test",
                source_class="TestClass",
                source_method="myCallingMethod",
                target_package="com.another",
                target_class="AnotherClass",
                target_method="someCalledMethod"
            )
        ]
    )

    # When
    db_service.add_class(test_class)

    # Then
    assert mock_session.write_transaction.called
    
    # Collect all executed queries
    executed_queries = [call[0][0] for call in mock_tx.run.call_args_list]
    executed_params = [call[1] for call in mock_tx.run.call_args_list]

    # Check the MERGE query for the class itself
    class_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (c:Class {name: $name, package: $package})" in query:
            assert executed_params[i]['name'] == "TestClass"
            assert executed_params[i]['package'] == "com.test"
            class_query_found = True
            break
    assert class_query_found

    # Check the MERGE query for the property
    prop_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (p:Property {name: $prop_name, type: $prop_type})" in query:
            assert executed_params[i]['prop_name'] == "testProp"
            prop_query_found = True
            break
    assert prop_query_found

    # Check the MERGE query for the call relationship
    call_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (sm)-[r:CALLS]->(tm)" in query: # Changed to match the actual query in graph_db.py
            assert executed_params[i]['source_package'] == "com.test"
            assert executed_params[i]['source_class'] == "TestClass"
            assert executed_params[i]['source_method'] == "myCallingMethod"
            assert executed_params[i]['target_package'] == "com.another"
            assert executed_params[i]['target_class'] == "AnotherClass"
            assert executed_params[i]['target_method'] == "someCalledMethod"
            call_query_found = True
            break
    assert call_query_found


def test_add_class_with_fields(mock_db):
    # Given
    db_service, mock_driver = mock_db
    mock_session = MagicMock()
    mock_tx = MagicMock()
    mock_driver.session.return_value.__enter__.return_value = mock_session
    mock_session.write_transaction.side_effect = lambda func, *args: func(mock_tx, *args)

    test_field_private = Property(
        name="greeting", type="String", modifiers=["private"]
    )
    test_field_public_static_final = Property(
        name="MAX_VALUE", type="int", modifiers=["public", "static", "final"]
    )
    test_class = Class(
        name="Greeter",
        package="com.example",
        file_path="/path/to/Greeter.java",
        source="class Greeter { private String greeting; }",
        properties=[test_field_private, test_field_public_static_final],
    )

    # When
    db_service.add_class(test_class)

    # Then
    # Check the MERGE query for the class itself
    class_merge_call = mock_tx.run.call_args_list[0]
    assert "MERGE (c:Class {name: $name, package: $package})" in class_merge_call[0][0]
    assert class_merge_call[1]['name'] == "Greeter"

    # Check the MERGE query for the first property (greeting)
    prop1_merge_call = mock_tx.run.call_args_list[1]
    assert (
        "MERGE (p:Property {name: $prop_name, type: $prop_type}) "
        "SET p.modifiers = $prop_modifiers "
        "MERGE (c)-[:HAS_FIELD]->(p)"
    ) in prop1_merge_call[0][0]
    assert prop1_merge_call[1]['prop_name'] == "greeting"
    assert prop1_merge_call[1]['prop_type'] == "String"
    assert prop1_merge_call[1]['prop_modifiers'] == ["private"]

    # Check the MERGE query for the second property (MAX_VALUE)
    prop2_merge_call = mock_tx.run.call_args_list[2]
    assert (
        "MERGE (p:Property {name: $prop_name, type: $prop_type}) "
        "SET p.modifiers = $prop_modifiers "
        "MERGE (c)-[:HAS_FIELD]->(p)"
    ) in prop2_merge_call[0][0]
    assert prop2_merge_call[1]['prop_name'] == "MAX_VALUE"
    assert prop2_merge_call[1]['prop_type'] == "int"
    assert prop2_merge_call[1]['prop_modifiers'] == ["public", "static", "final"]

```

이제 테스트에서 Property 노드 검증 부분을 Field로 변경하겠습니다.


```python
import pytest
from unittest.mock import MagicMock, patch
import json # Added import for json

from src.services.graph_db import GraphDB
from src.models.graph_entities import Class, Field, Method, MethodCall # Import Method and Field

@pytest.fixture
def mock_db():
    with patch('neo4j.GraphDatabase.driver') as mock_driver_constructor:
        mock_driver_instance = MagicMock()
        mock_driver_constructor.return_value = mock_driver_instance
        db_service = GraphDB("uri", "user", "pass")
        yield db_service, mock_driver_instance
        db_service.close()

def test_add_class(mock_db):
    # Given
    db_service, mock_driver = mock_db
    mock_session = MagicMock()
    mock_tx = MagicMock()
    mock_driver.session.return_value.__enter__.return_value = mock_session
    mock_session.write_transaction.side_effect = lambda func, *args: func(mock_tx, *args)

    test_class = Class(
        name="TestClass",
        package="com.test",
        file_path="/path/to/TestClass.java",
        type="class",
        properties=[Field(name="testProp", type="int")],
        calls=[
            MethodCall(
                source_package="com.test",
                source_class="TestClass",
                source_method="myCallingMethod",
                target_package="com.another",
                target_class="AnotherClass",
                target_method="someCalledMethod"
            )
        ]
    )

    # When
    db_service.add_class(test_class)

    # Then
    assert mock_session.write_transaction.called
    
    # Collect all executed queries
    executed_queries = [call[0][0] for call in mock_tx.run.call_args_list]
    executed_params = [call[1] for call in mock_tx.run.call_args_list]

    # Check the MERGE query for the class itself
    class_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (c:Class {name: $name, package: $package})" in query:
            assert executed_params[i]['name'] == "TestClass"
            assert executed_params[i]['package'] == "com.test"
            class_query_found = True
            break
    assert class_query_found

    # Check the MERGE query for the property
    prop_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (p:Field {name: $prop_name, type: $prop_type})" in query:
            assert executed_params[i]['prop_name'] == "testProp"
            prop_query_found = True
            break
    assert prop_query_found

    # Check the MERGE query for the call relationship
    call_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (sm)-[r:CALLS]->(tm)" in query: # Changed to match the actual query in graph_db.py
            assert executed_params[i]['source_package'] == "com.test"
            assert executed_params[i]['source_class'] == "TestClass"
            assert executed_params[i]['source_method'] == "myCallingMethod"
            assert executed_params[i]['target_package'] == "com.another"
            assert executed_params[i]['target_class'] == "AnotherClass"
            assert executed_params[i]['target_method'] == "someCalledMethod"
            call_query_found = True
            break
    assert call_query_found


def test_add_class_with_fields(mock_db):
    # Given
    db_service, mock_driver = mock_db
    mock_session = MagicMock()
    mock_tx = MagicMock()
    mock_driver.session.return_value.__enter__.return_value = mock_session
    mock_session.write_transaction.side_effect = lambda func, *args: func(mock_tx, *args)

    test_field_private = Property(
        name="greeting", type="String", modifiers=["private"]
    )
    test_field_public_static_final = Property(
        name="MAX_VALUE", type="int", modifiers=["public", "static", "final"]
    )
    test_class = Class(
        name="Greeter",
        package="com.example",
        file_path="/path/to/Greeter.java",
        source="class Greeter { private String greeting; }",
        properties=[test_field_private, test_field_public_static_final],
    )

    # When
    db_service.add_class(test_class)

    # Then
    # Check the MERGE query for the class itself
    class_merge_call = mock_tx.run.call_args_list[0]
    assert "MERGE (c:Class {name: $name, package: $package})" in class_merge_call[0][0]
    assert class_merge_call[1]['name'] == "Greeter"

    # Check the MERGE query for the first property (greeting)
    prop1_merge_call = mock_tx.run.call_args_list[1]
    assert (
        "MERGE (p:Property {name: $prop_name, type: $prop_type}) "
        "SET p.modifiers = $prop_modifiers "
        "MERGE (c)-[:HAS_FIELD]->(p)"
    ) in prop1_merge_call[0][0]
    assert prop1_merge_call[1]['prop_name'] == "greeting"
    assert prop1_merge_call[1]['prop_type'] == "String"
    assert prop1_merge_call[1]['prop_modifiers'] == ["private"]

    # Check the MERGE query for the second property (MAX_VALUE)
    prop2_merge_call = mock_tx.run.call_args_list[2]
    assert (
        "MERGE (p:Property {name: $prop_name, type: $prop_type}) "
        "SET p.modifiers = $prop_modifiers "
        "MERGE (c)-[:HAS_FIELD]->(p)"
    ) in prop2_merge_call[0][0]
    assert prop2_merge_call[1]['prop_name'] == "MAX_VALUE"
    assert prop2_merge_call[1]['prop_type'] == "int"
    assert prop2_merge_call[1]['prop_modifiers'] == ["public", "static", "final"]

```

이제 다른 Property 생성 부분들을 Field로 변경하겠습니다.


```python
import pytest
from unittest.mock import MagicMock, patch
import json # Added import for json

from src.services.graph_db import GraphDB
from src.models.graph_entities import Class, Field, Method, MethodCall # Import Method and Field

@pytest.fixture
def mock_db():
    with patch('neo4j.GraphDatabase.driver') as mock_driver_constructor:
        mock_driver_instance = MagicMock()
        mock_driver_constructor.return_value = mock_driver_instance
        db_service = GraphDB("uri", "user", "pass")
        yield db_service, mock_driver_instance
        db_service.close()

def test_add_class(mock_db):
    # Given
    db_service, mock_driver = mock_db
    mock_session = MagicMock()
    mock_tx = MagicMock()
    mock_driver.session.return_value.__enter__.return_value = mock_session
    mock_session.write_transaction.side_effect = lambda func, *args: func(mock_tx, *args)

    test_class = Class(
        name="TestClass",
        package="com.test",
        file_path="/path/to/TestClass.java",
        type="class",
        properties=[Field(name="testProp", type="int")],
        calls=[
            MethodCall(
                source_package="com.test",
                source_class="TestClass",
                source_method="myCallingMethod",
                target_package="com.another",
                target_class="AnotherClass",
                target_method="someCalledMethod"
            )
        ]
    )

    # When
    db_service.add_class(test_class)

    # Then
    assert mock_session.write_transaction.called
    
    # Collect all executed queries
    executed_queries = [call[0][0] for call in mock_tx.run.call_args_list]
    executed_params = [call[1] for call in mock_tx.run.call_args_list]

    # Check the MERGE query for the class itself
    class_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (c:Class {name: $name, package: $package})" in query:
            assert executed_params[i]['name'] == "TestClass"
            assert executed_params[i]['package'] == "com.test"
            class_query_found = True
            break
    assert class_query_found

    # Check the MERGE query for the property
    prop_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (p:Field {name: $prop_name, type: $prop_type})" in query:
            assert executed_params[i]['prop_name'] == "testProp"
            prop_query_found = True
            break
    assert prop_query_found

    # Check the MERGE query for the call relationship
    call_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (sm)-[r:CALLS]->(tm)" in query: # Changed to match the actual query in graph_db.py
            assert executed_params[i]['source_package'] == "com.test"
            assert executed_params[i]['source_class'] == "TestClass"
            assert executed_params[i]['source_method'] == "myCallingMethod"
            assert executed_params[i]['target_package'] == "com.another"
            assert executed_params[i]['target_class'] == "AnotherClass"
            assert executed_params[i]['target_method'] == "someCalledMethod"
            call_query_found = True
            break
    assert call_query_found


def test_add_class_with_fields(mock_db):
    # Given
    db_service, mock_driver = mock_db
    mock_session = MagicMock()
    mock_tx = MagicMock()
    mock_driver.session.return_value.__enter__.return_value = mock_session
    mock_session.write_transaction.side_effect = lambda func, *args: func(mock_tx, *args)

    test_field_private = Field(
        name="greeting", type="String", modifiers=["private"]
    )
    test_field_public_static_final = Property(
        name="MAX_VALUE", type="int", modifiers=["public", "static", "final"]
    )
    test_class = Class(
        name="Greeter",
        package="com.example",
        file_path="/path/to/Greeter.java",
        source="class Greeter { private String greeting; }",
        properties=[test_field_private, test_field_public_static_final],
    )

    # When
    db_service.add_class(test_class)

    # Then
    # Check the MERGE query for the class itself
    class_merge_call = mock_tx.run.call_args_list[0]
    assert "MERGE (c:Class {name: $name, package: $package})" in class_merge_call[0][0]
    assert class_merge_call[1]['name'] == "Greeter"

    # Check the MERGE query for the first property (greeting)
    prop1_merge_call = mock_tx.run.call_args_list[1]
    assert (
        "MERGE (p:Property {name: $prop_name, type: $prop_type}) "
        "SET p.modifiers = $prop_modifiers "
        "MERGE (c)-[:HAS_FIELD]->(p)"
    ) in prop1_merge_call[0][0]
    assert prop1_merge_call[1]['prop_name'] == "greeting"
    assert prop1_merge_call[1]['prop_type'] == "String"
    assert prop1_merge_call[1]['prop_modifiers'] == ["private"]

    # Check the MERGE query for the second property (MAX_VALUE)
    prop2_merge_call = mock_tx.run.call_args_list[2]
    assert (
        "MERGE (p:Property {name: $prop_name, type: $prop_type}) "
        "SET p.modifiers = $prop_modifiers "
        "MERGE (c)-[:HAS_FIELD]->(p)"
    ) in prop2_merge_call[0][0]
    assert prop2_merge_call[1]['prop_name'] == "MAX_VALUE"
    assert prop2_merge_call[1]['prop_type'] == "int"
    assert prop2_merge_call[1]['prop_modifiers'] == ["public", "static", "final"]

```

```python
import pytest
from unittest.mock import MagicMock, patch
import json # Added import for json

from src.services.graph_db import GraphDB
from src.models.graph_entities import Class, Field, Method, MethodCall # Import Method and Field

@pytest.fixture
def mock_db():
    with patch('neo4j.GraphDatabase.driver') as mock_driver_constructor:
        mock_driver_instance = MagicMock()
        mock_driver_constructor.return_value = mock_driver_instance
        db_service = GraphDB("uri", "user", "pass")
        yield db_service, mock_driver_instance
        db_service.close()

def test_add_class(mock_db):
    # Given
    db_service, mock_driver = mock_db
    mock_session = MagicMock()
    mock_tx = MagicMock()
    mock_driver.session.return_value.__enter__.return_value = mock_session
    mock_session.write_transaction.side_effect = lambda func, *args: func(mock_tx, *args)

    test_class = Class(
        name="TestClass",
        package="com.test",
        file_path="/path/to/TestClass.java",
        type="class",
        properties=[Field(name="testProp", type="int")],
        calls=[
            MethodCall(
                source_package="com.test",
                source_class="TestClass",
                source_method="myCallingMethod",
                target_package="com.another",
                target_class="AnotherClass",
                target_method="someCalledMethod"
            )
        ]
    )

    # When
    db_service.add_class(test_class)

    # Then
    assert mock_session.write_transaction.called
    
    # Collect all executed queries
    executed_queries = [call[0][0] for call in mock_tx.run.call_args_list]
    executed_params = [call[1] for call in mock_tx.run.call_args_list]

    # Check the MERGE query for the class itself
    class_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (c:Class {name: $name, package: $package})" in query:
            assert executed_params[i]['name'] == "TestClass"
            assert executed_params[i]['package'] == "com.test"
            class_query_found = True
            break
    assert class_query_found

    # Check the MERGE query for the property
    prop_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (p:Field {name: $prop_name, type: $prop_type})" in query:
            assert executed_params[i]['prop_name'] == "testProp"
            prop_query_found = True
            break
    assert prop_query_found

    # Check the MERGE query for the call relationship
    call_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (sm)-[r:CALLS]->(tm)" in query: # Changed to match the actual query in graph_db.py
            assert executed_params[i]['source_package'] == "com.test"
            assert executed_params[i]['source_class'] == "TestClass"
            assert executed_params[i]['source_method'] == "myCallingMethod"
            assert executed_params[i]['target_package'] == "com.another"
            assert executed_params[i]['target_class'] == "AnotherClass"
            assert executed_params[i]['target_method'] == "someCalledMethod"
            call_query_found = True
            break
    assert call_query_found


def test_add_class_with_fields(mock_db):
    # Given
    db_service, mock_driver = mock_db
    mock_session = MagicMock()
    mock_tx = MagicMock()
    mock_driver.session.return_value.__enter__.return_value = mock_session
    mock_session.write_transaction.side_effect = lambda func, *args: func(mock_tx, *args)

    test_field_private = Field(
        name="greeting", type="String", modifiers=["private"]
    )
    test_field_public_static_final = Field(
        name="MAX_VALUE", type="int", modifiers=["public", "static", "final"]
    )
    test_class = Class(
        name="Greeter",
        package="com.example",
        file_path="/path/to/Greeter.java",
        source="class Greeter { private String greeting; }",
        properties=[test_field_private, test_field_public_static_final],
    )

    # When
    db_service.add_class(test_class)

    # Then
    # Check the MERGE query for the class itself
    class_merge_call = mock_tx.run.call_args_list[0]
    assert "MERGE (c:Class {name: $name, package: $package})" in class_merge_call[0][0]
    assert class_merge_call[1]['name'] == "Greeter"

    # Check the MERGE query for the first property (greeting)
    prop1_merge_call = mock_tx.run.call_args_list[1]
    assert (
        "MERGE (p:Property {name: $prop_name, type: $prop_type}) "
        "SET p.modifiers = $prop_modifiers "
        "MERGE (c)-[:HAS_FIELD]->(p)"
    ) in prop1_merge_call[0][0]
    assert prop1_merge_call[1]['prop_name'] == "greeting"
    assert prop1_merge_call[1]['prop_type'] == "String"
    assert prop1_merge_call[1]['prop_modifiers'] == ["private"]

    # Check the MERGE query for the second property (MAX_VALUE)
    prop2_merge_call = mock_tx.run.call_args_list[2]
    assert (
        "MERGE (p:Property {name: $prop_name, type: $prop_type}) "
        "SET p.modifiers = $prop_modifiers "
        "MERGE (c)-[:HAS_FIELD]->(p)"
    ) in prop2_merge_call[0][0]
    assert prop2_merge_call[1]['prop_name'] == "MAX_VALUE"
    assert prop2_merge_call[1]['prop_type'] == "int"
    assert prop2_merge_call[1]['prop_modifiers'] == ["public", "static", "final"]

```

이제 테스트에서 Property 노드 검증 부분들을 Field로 변경하겠습니다.


```python
        "MERGE (p:Field {name: $prop_name, type: $prop_type}) "
```

```python
import pytest
from unittest.mock import MagicMock, patch
import json # Added import for json

from src.services.graph_db import GraphDB
from src.models.graph_entities import Class, Field, Method, MethodCall # Import Method and Field

@pytest.fixture
def mock_db():
    with patch('neo4j.GraphDatabase.driver') as mock_driver_constructor:
        mock_driver_instance = MagicMock()
        mock_driver_constructor.return_value = mock_driver_instance
        db_service = GraphDB("uri", "user", "pass")
        yield db_service, mock_driver_instance
        db_service.close()

def test_add_class(mock_db):
    # Given
    db_service, mock_driver = mock_db
    mock_session = MagicMock()
    mock_tx = MagicMock()
    mock_driver.session.return_value.__enter__.return_value = mock_session
    mock_session.write_transaction.side_effect = lambda func, *args: func(mock_tx, *args)

    test_class = Class(
        name="TestClass",
        package="com.test",
        file_path="/path/to/TestClass.java",
        type="class",
        properties=[Field(name="testProp", type="int")],
        calls=[
            MethodCall(
                source_package="com.test",
                source_class="TestClass",
                source_method="myCallingMethod",
                target_package="com.another",
                target_class="AnotherClass",
                target_method="someCalledMethod"
            )
        ]
    )

    # When
    db_service.add_class(test_class)

    # Then
    assert mock_session.write_transaction.called
    
    # Collect all executed queries
    executed_queries = [call[0][0] for call in mock_tx.run.call_args_list]
    executed_params = [call[1] for call in mock_tx.run.call_args_list]

    # Check the MERGE query for the class itself
    class_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (c:Class {name: $name, package: $package})" in query:
            assert executed_params[i]['name'] == "TestClass"
            assert executed_params[i]['package'] == "com.test"
            class_query_found = True
            break
    assert class_query_found

    # Check the MERGE query for the property
    prop_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (p:Field {name: $prop_name, type: $prop_type})" in query:
            assert executed_params[i]['prop_name'] == "testProp"
            prop_query_found = True
            break
    assert prop_query_found

    # Check the MERGE query for the call relationship
    call_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (sm)-[r:CALLS]->(tm)" in query: # Changed to match the actual query in graph_db.py
            assert executed_params[i]['source_package'] == "com.test"
            assert executed_params[i]['source_class'] == "TestClass"
            assert executed_params[i]['source_method'] == "myCallingMethod"
            assert executed_params[i]['target_package'] == "com.another"
            assert executed_params[i]['target_class'] == "AnotherClass"
            assert executed_params[i]['target_method'] == "someCalledMethod"
            call_query_found = True
            break
    assert call_query_found


def test_add_class_with_fields(mock_db):
    # Given
    db_service, mock_driver = mock_db
    mock_session = MagicMock()
    mock_tx = MagicMock()
    mock_driver.session.return_value.__enter__.return_value = mock_session
    mock_session.write_transaction.side_effect = lambda func, *args: func(mock_tx, *args)

    test_field_private = Field(
        name="greeting", type="String", modifiers=["private"]
    )
    test_field_public_static_final = Field(
        name="MAX_VALUE", type="int", modifiers=["public", "static", "final"]
    )
    test_class = Class(
        name="Greeter",
        package="com.example",
        file_path="/path/to/Greeter.java",
        source="class Greeter { private String greeting; }",
        properties=[test_field_private, test_field_public_static_final],
    )

    # When
    db_service.add_class(test_class)

    # Then
    # Check the MERGE query for the class itself
    class_merge_call = mock_tx.run.call_args_list[0]
    assert "MERGE (c:Class {name: $name, package: $package})" in class_merge_call[0][0]
    assert class_merge_call[1]['name'] == "Greeter"

    # Check the MERGE query for the first property (greeting)
    prop1_merge_call = mock_tx.run.call_args_list[1]
    assert (
        "MERGE (p:Field {name: $prop_name, type: $prop_type}) "
        "SET p.modifiers = $prop_modifiers "
        "MERGE (c)-[:HAS_FIELD]->(p)"
    ) in prop1_merge_call[0][0]
    assert prop1_merge_call[1]['prop_name'] == "greeting"
    assert prop1_merge_call[1]['prop_type'] == "String"
    assert prop1_merge_call[1]['prop_modifiers'] == ["private"]

    # Check the MERGE query for the second property (MAX_VALUE)
    prop2_merge_call = mock_tx.run.call_args_list[2]
    assert (
        "MERGE (p:Field {name: $prop_name, type: $prop_type}) "
        "SET p.modifiers = $prop_modifiers "
        "MERGE (c)-[:HAS_FIELD]->(p)"
    ) in prop2_merge_call[0][0]
    assert prop2_merge_call[1]['prop_name'] == "MAX_VALUE"
    assert prop2_merge_call[1]['prop_type'] == "int"
    assert prop2_merge_call[1]['prop_modifiers'] == ["public", "static", "final"]

```

이제 테스트 코드 변경이 완료되었습니다.


이제 변경된 파일들에 대해 린터 오류가 있는지 확인하겠습니다.


완벽합니다! Property 노드를 Field 노드로 변경하는 작업이 모두 완료되었습니다. 

## 변경 사항 요약

다음과 같은 변경을 수행했습니다:

### 1. 모델 클래스 (`src/models/graph_entities.py`)
- `Property` 클래스를 `Field` 클래스로 변경
- `Method` 클래스의 `parameters` 필드 타입을 `list[Property]`에서 `list[Field]`로 변경
- `Class` 클래스의 `properties` 필드 타입을 `list[Property]`에서 `list[Field]`로 변경

### 2. 파서 서비스 (`src/services/java_parser.py`)
- import 문에서 `Property`를 `Field`로 변경
- `generate_lombok_methods` 함수의 매개변수 타입을 `list[Property]`에서 `list[Field]`로 변경
- 모든 `Property()` 생성자를 `Field()`로 변경

### 3. 데이터베이스 서비스 (`src/services/graph_db.py`)
- Neo4j 쿼리에서 `Property` 노드를 `Field` 노드로 변경
- 관계 이름을 `HAS_PROPERTY`에서 `HAS_FIELD`로 변경

### 4. CLI (`src/cli/main.py`)
- Cypher 쿼리에서 `Property` 노드를 `Field` 노드로 변경
- 관계 이름을 `HAS_PROPERTY`에서 `HAS_FIELD`로 변경

### 5. 테스트 코드
- `tests/unit/test_java_parser.py`: import 문에서 `Property`를 `Field`로 변경
- `tests/unit/test_graph_db.py`: import 문과 모든 `Property()` 생성자를 `Field()`로 변경, 테스트 검증 부분도 업데이트

모든 변경이 완료되었고 린터 오류도 없습니다. 이제 데이터베이스와 프로그램에서 Property 노드가 Field 노드로 완전히 변경되었습니다.

---

**User**

jwtUtil이란 Field가 두개의 class에서 같이 소유하는 것 처럼 관계가 나타나는데.. 잘못된 관계 아닌가?

---

**Cursor**

네, 맞습니다! 현재 그래프에서 `jwtUtil` Field가 두 개의 다른 클래스(`AuthService`와 `JwtAuthenticator`)에서 동시에 소유되는 것처럼 보이는 것은 잘못된 관계입니다. 

이는 데이터베이스 설계상의 문제로 보입니다. 각 Field는 하나의 클래스에만 속해야 하는데, 현재는 같은 이름의 Field가 여러 클래스에서 공유되고 있는 것 같습니다.

이 문제를 해결하기 위해 데이터베이스 스키마를 확인하고 수정해보겠습니다.


문제를 찾았습니다! 현재 Field 노드 생성 시 `MERGE`를 사용하고 있는데, 이는 같은 이름의 Field가 여러 클래스에서 공유될 수 있게 만듭니다. 

207번 라인을 보면:
```cypher
MERGE (p:Field {name: $prop_name, type: $prop_type})
```

이렇게 하면 `jwtUtil`이라는 이름의 Field가 여러 클래스에서 동일한 노드를 참조하게 됩니다. 이를 수정해야 합니다.


```cql
MERGE (p:Field {name: $prop_name, type: $prop_type})
```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name"  # Add project_name
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name " # Add project_name
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name " # Add project_name
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

이제 테스트 코드도 업데이트해야 합니다. 테스트에서 Field 노드의 고유성을 검증하는 부분을 수정하겠습니다.


```python
import pytest
from unittest.mock import MagicMock, patch
import json # Added import for json

from src.services.graph_db import GraphDB
from src.models.graph_entities import Class, Field, Method, MethodCall # Import Method and Field

@pytest.fixture
def mock_db():
    with patch('neo4j.GraphDatabase.driver') as mock_driver_constructor:
        mock_driver_instance = MagicMock()
        mock_driver_constructor.return_value = mock_driver_instance
        db_service = GraphDB("uri", "user", "pass")
        yield db_service, mock_driver_instance
        db_service.close()

def test_add_class(mock_db):
    # Given
    db_service, mock_driver = mock_db
    mock_session = MagicMock()
    mock_tx = MagicMock()
    mock_driver.session.return_value.__enter__.return_value = mock_session
    mock_session.write_transaction.side_effect = lambda func, *args: func(mock_tx, *args)

    test_class = Class(
        name="TestClass",
        package="com.test",
        file_path="/path/to/TestClass.java",
        type="class",
        properties=[Field(name="testProp", type="int")],
        calls=[
            MethodCall(
                source_package="com.test",
                source_class="TestClass",
                source_method="myCallingMethod",
                target_package="com.another",
                target_class="AnotherClass",
                target_method="someCalledMethod"
            )
        ]
    )

    # When
    db_service.add_class(test_class)

    # Then
    assert mock_session.write_transaction.called
    
    # Collect all executed queries
    executed_queries = [call[0][0] for call in mock_tx.run.call_args_list]
    executed_params = [call[1] for call in mock_tx.run.call_args_list]

    # Check the MERGE query for the class itself
    class_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (c:Class {name: $name, package: $package})" in query:
            assert executed_params[i]['name'] == "TestClass"
            assert executed_params[i]['package'] == "com.test"
            class_query_found = True
            break
    assert class_query_found

    # Check the MERGE query for the property
    prop_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name})" in query:
            assert executed_params[i]['prop_name'] == "testProp"
            prop_query_found = True
            break
    assert prop_query_found

    # Check the MERGE query for the call relationship
    call_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (sm)-[r:CALLS]->(tm)" in query: # Changed to match the actual query in graph_db.py
            assert executed_params[i]['source_package'] == "com.test"
            assert executed_params[i]['source_class'] == "TestClass"
            assert executed_params[i]['source_method'] == "myCallingMethod"
            assert executed_params[i]['target_package'] == "com.another"
            assert executed_params[i]['target_class'] == "AnotherClass"
            assert executed_params[i]['target_method'] == "someCalledMethod"
            call_query_found = True
            break
    assert call_query_found


def test_add_class_with_fields(mock_db):
    # Given
    db_service, mock_driver = mock_db
    mock_session = MagicMock()
    mock_tx = MagicMock()
    mock_driver.session.return_value.__enter__.return_value = mock_session
    mock_session.write_transaction.side_effect = lambda func, *args: func(mock_tx, *args)

    test_field_private = Field(
        name="greeting", type="String", modifiers=["private"]
    )
    test_field_public_static_final = Field(
        name="MAX_VALUE", type="int", modifiers=["public", "static", "final"]
    )
    test_class = Class(
        name="Greeter",
        package="com.example",
        file_path="/path/to/Greeter.java",
        source="class Greeter { private String greeting; }",
        properties=[test_field_private, test_field_public_static_final],
    )

    # When
    db_service.add_class(test_class)

    # Then
    # Check the MERGE query for the class itself
    class_merge_call = mock_tx.run.call_args_list[0]
    assert "MERGE (c:Class {name: $name, package: $package})" in class_merge_call[0][0]
    assert class_merge_call[1]['name'] == "Greeter"

    # Check the MERGE query for the first property (greeting)
    prop1_merge_call = mock_tx.run.call_args_list[1]
    assert (
        "MERGE (p:Field {name: $prop_name, type: $prop_type}) "
        "SET p.modifiers = $prop_modifiers "
        "MERGE (c)-[:HAS_FIELD]->(p)"
    ) in prop1_merge_call[0][0]
    assert prop1_merge_call[1]['prop_name'] == "greeting"
    assert prop1_merge_call[1]['prop_type'] == "String"
    assert prop1_merge_call[1]['prop_modifiers'] == ["private"]

    # Check the MERGE query for the second property (MAX_VALUE)
    prop2_merge_call = mock_tx.run.call_args_list[2]
    assert (
        "MERGE (p:Field {name: $prop_name, type: $prop_type}) "
        "SET p.modifiers = $prop_modifiers "
        "MERGE (c)-[:HAS_FIELD]->(p)"
    ) in prop2_merge_call[0][0]
    assert prop2_merge_call[1]['prop_name'] == "MAX_VALUE"
    assert prop2_merge_call[1]['prop_type'] == "int"
    assert prop2_merge_call[1]['prop_modifiers'] == ["public", "static", "final"]

```

```python
import pytest
from unittest.mock import MagicMock, patch
import json # Added import for json

from src.services.graph_db import GraphDB
from src.models.graph_entities import Class, Field, Method, MethodCall # Import Method and Field

@pytest.fixture
def mock_db():
    with patch('neo4j.GraphDatabase.driver') as mock_driver_constructor:
        mock_driver_instance = MagicMock()
        mock_driver_constructor.return_value = mock_driver_instance
        db_service = GraphDB("uri", "user", "pass")
        yield db_service, mock_driver_instance
        db_service.close()

def test_add_class(mock_db):
    # Given
    db_service, mock_driver = mock_db
    mock_session = MagicMock()
    mock_tx = MagicMock()
    mock_driver.session.return_value.__enter__.return_value = mock_session
    mock_session.write_transaction.side_effect = lambda func, *args: func(mock_tx, *args)

    test_class = Class(
        name="TestClass",
        package="com.test",
        file_path="/path/to/TestClass.java",
        type="class",
        properties=[Field(name="testProp", type="int")],
        calls=[
            MethodCall(
                source_package="com.test",
                source_class="TestClass",
                source_method="myCallingMethod",
                target_package="com.another",
                target_class="AnotherClass",
                target_method="someCalledMethod"
            )
        ]
    )

    # When
    db_service.add_class(test_class)

    # Then
    assert mock_session.write_transaction.called
    
    # Collect all executed queries
    executed_queries = [call[0][0] for call in mock_tx.run.call_args_list]
    executed_params = [call[1] for call in mock_tx.run.call_args_list]

    # Check the MERGE query for the class itself
    class_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (c:Class {name: $name, package: $package})" in query:
            assert executed_params[i]['name'] == "TestClass"
            assert executed_params[i]['package'] == "com.test"
            class_query_found = True
            break
    assert class_query_found

    # Check the MERGE query for the property
    prop_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name})" in query:
            assert executed_params[i]['prop_name'] == "testProp"
            prop_query_found = True
            break
    assert prop_query_found

    # Check the MERGE query for the call relationship
    call_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (sm)-[r:CALLS]->(tm)" in query: # Changed to match the actual query in graph_db.py
            assert executed_params[i]['source_package'] == "com.test"
            assert executed_params[i]['source_class'] == "TestClass"
            assert executed_params[i]['source_method'] == "myCallingMethod"
            assert executed_params[i]['target_package'] == "com.another"
            assert executed_params[i]['target_class'] == "AnotherClass"
            assert executed_params[i]['target_method'] == "someCalledMethod"
            call_query_found = True
            break
    assert call_query_found


def test_add_class_with_fields(mock_db):
    # Given
    db_service, mock_driver = mock_db
    mock_session = MagicMock()
    mock_tx = MagicMock()
    mock_driver.session.return_value.__enter__.return_value = mock_session
    mock_session.write_transaction.side_effect = lambda func, *args: func(mock_tx, *args)

    test_field_private = Field(
        name="greeting", type="String", modifiers=["private"]
    )
    test_field_public_static_final = Field(
        name="MAX_VALUE", type="int", modifiers=["public", "static", "final"]
    )
    test_class = Class(
        name="Greeter",
        package="com.example",
        file_path="/path/to/Greeter.java",
        source="class Greeter { private String greeting; }",
        properties=[test_field_private, test_field_public_static_final],
    )

    # When
    db_service.add_class(test_class)

    # Then
    # Check the MERGE query for the class itself
    class_merge_call = mock_tx.run.call_args_list[0]
    assert "MERGE (c:Class {name: $name, package: $package})" in class_merge_call[0][0]
    assert class_merge_call[1]['name'] == "Greeter"

    # Check the MERGE query for the first property (greeting)
    prop1_merge_call = mock_tx.run.call_args_list[1]
    assert (
        "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
        "SET p.modifiers = $prop_modifiers "
        "MERGE (c)-[:HAS_FIELD]->(p)"
    ) in prop1_merge_call[0][0]
    assert prop1_merge_call[1]['prop_name'] == "greeting"
    assert prop1_merge_call[1]['prop_type'] == "String"
    assert prop1_merge_call[1]['prop_modifiers'] == ["private"]

    # Check the MERGE query for the second property (MAX_VALUE)
    prop2_merge_call = mock_tx.run.call_args_list[2]
    assert (
        "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
        "SET p.modifiers = $prop_modifiers "
        "MERGE (c)-[:HAS_FIELD]->(p)"
    ) in prop2_merge_call[0][0]
    assert prop2_merge_call[1]['prop_name'] == "MAX_VALUE"
    assert prop2_merge_call[1]['prop_type'] == "int"
    assert prop2_merge_call[1]['prop_modifiers'] == ["public", "static", "final"]

```

이제 린터 오류를 확인해보겠습니다.


완벽합니다! 이제 문제가 해결되었습니다.

## 수정 내용

**문제**: `jwtUtil`과 같은 Field가 여러 클래스에서 동일한 노드를 공유하는 잘못된 관계가 발생했습니다.

**원인**: Field 노드 생성 시 `MERGE (p:Field {name: $prop_name, type: $prop_type})`를 사용하여 이름과 타입만으로 고유성을 판단했기 때문입니다.

**해결책**: Field 노드의 고유성을 `name`, `class_name`, `project_name`의 조합으로 판단하도록 변경했습니다:

```cypher
MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name})
```

이제 각 클래스는 자신만의 고유한 Field 노드를 가지게 되어, `AuthService`의 `jwtUtil`과 `JwtAuthenticator`의 `jwtUtil`은 서로 다른 노드로 생성됩니다. 이는 실제 Java 코드의 구조와 일치하며, 각 클래스가 독립적인 필드를 가지는 올바른 관계를 나타냅니다.

```cql
MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name})
```

```cql
MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name})
```

---

**User**

모든 노드에 description 속성을 추가해줘
용도는 추후 각 노드의 특징을 간략한 문장으로 표현해서 저장하거나 소스에서 특정 내용을 parsing해서 저장할 거야.. 

---

**Cursor**

모든 노드에 description 속성을 추가하겠습니다. 먼저 어떤 노드들이 있는지 확인하고 각각에 description 필드를 추가하겠습니다.


이제 모든 모델 클래스에 description 속성을 추가하겠습니다. 각 클래스의 마지막 필드 뒤에 description을 추가하겠습니다.


각 클래스를 개별적으로 수정하겠습니다. 먼저 Annotation 클래스부터 시작하겠습니다.


```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""


```

이제 나머지 클래스들도 계속 추가하겠습니다.


```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""


```

계속해서 나머지 클래스들에 description을 추가하겠습니다.


```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True
    description: str = ""  # Brief description of the logging config


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True
    description: str = ""  # Brief description of the logging config


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""
    description: str = ""  # Brief description of the test class


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True
    description: str = ""  # Brief description of the logging config


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""
    description: str = ""  # Brief description of the test class


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value
    description: str = ""  # Brief description of the test method


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True
    description: str = ""  # Brief description of the logging config


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""
    description: str = ""  # Brief description of the test class


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value
    description: str = ""  # Brief description of the test method


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions
    description: str = ""  # Brief description of the test configuration


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True
    description: str = ""  # Brief description of the logging config


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""
    description: str = ""  # Brief description of the test class


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value
    description: str = ""  # Brief description of the test method


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions
    description: str = ""  # Brief description of the test configuration


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""
    description: str = ""  # Brief description of the class


```

이제 모델 클래스에 description 속성 추가가 완료되었습니다.


이제 데이터베이스 스키마에 description 속성을 추가하겠습니다. 주요 노드들에 description 필드를 추가해야 합니다.


```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name"  # Add project_name
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name " # Add project_name
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name " # Add project_name
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name"  # Add project_name
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name " # Add project_name
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name " # Add project_name
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

이제 Class 노드에 description을 추가하겠습니다.


```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description"  # Add project_name and description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name " # Add project_name
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name " # Add project_name
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description"  # Add project_name and description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name " # Add project_name
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name " # Add project_name
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

이제 Method 노드에 description을 추가하겠습니다.


```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description"  # Add project_name and description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description " # Add description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name " # Add project_name
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description"  # Add project_name and description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description " # Add description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name " # Add project_name
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

이제 Field 노드에 description을 추가하겠습니다.


```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description"  # Add project_name and description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description " # Add description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description " # Add description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description"  # Add project_name and description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description " # Add description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description " # Add description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

이제 다른 주요 노드들에도 description을 추가하겠습니다. Bean 노드부터 시작하겠습니다.


```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description"  # Add project_name and description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description " # Add description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description " # Add description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description"  # Add project_name and description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description " # Add description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description " # Add description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

이제 Endpoint 노드에 description을 추가하겠습니다.


```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description"  # Add project_name and description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description " # Add description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description " # Add description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description"  # Add project_name and description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description " # Add description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description " # Add description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

이제 나머지 주요 노드들에도 description을 추가하겠습니다.


```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description"  # Add project_name and description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description " # Add description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description " # Add description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description"  # Add project_name and description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description " # Add description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description " # Add description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

이제 JpaEntity와 다른 노드들에도 description을 추가하겠습니다.


```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description"  # Add project_name and description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description " # Add description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description " # Add description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description"  # Add project_name and description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description " # Add description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description " # Add description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path,
            description=entity.description or ""
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

이제 ConfigFile과 TestClass, SqlStatement 노드에도 description을 추가하겠습니다.


```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description"  # Add project_name and description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description " # Add description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description " # Add description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path,
            description=entity.description or ""
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment, "
            "c.description = $description"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description"  # Add project_name and description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description " # Add description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description " # Add description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path,
            description=entity.description or ""
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment, "
            "c.description = $description"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment,
            description=config_file.description or ""
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description"  # Add project_name and description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description " # Add description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description " # Add description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path,
            description=entity.description or ""
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment, "
            "c.description = $description"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment,
            description=config_file.description or ""
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name, "
            "t.description = $description"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description"  # Add project_name and description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description " # Add description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description " # Add description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path,
            description=entity.description or ""
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment, "
            "c.description = $description"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment,
            description=config_file.description or ""
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name, "
            "t.description = $description"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name,
            description=test_class.description or ""
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description"  # Add project_name and description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description " # Add description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description " # Add description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path,
            description=entity.description or ""
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment, "
            "c.description = $description"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment,
            description=config_file.description or ""
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name, "
            "t.description = $description"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name,
            description=test_class.description or ""
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name, s.description = $description"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description"  # Add project_name and description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description " # Add description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description " # Add description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path,
            description=entity.description or ""
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment, "
            "c.description = $description"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment,
            description=config_file.description or ""
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name, "
            "t.description = $description"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name,
            description=test_class.description or ""
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name, s.description = $description"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name,
            description=sql_statement.description or ""
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

이제 데이터베이스 스키마에 description 속성 추가가 완료되었습니다.


이제 파서 서비스에서 description 처리 로직을 추가하겠습니다. 현재는 description이 빈 문자열로 설정되지만, 추후 소스 코드에서 특정 내용을 파싱해서 저장할 수 있도록 기본 구조를 만들어두겠습니다.


Field 생성 부분에 description을 추가하겠습니다.


```python
import os
import yaml
import re
from pathlib import Path

import javalang

from src.models.graph_entities import Class, Method, MethodCall, Field, Package, Annotation, Bean, BeanDependency, Endpoint, MyBatisMapper, MyBatisSqlStatement, MyBatisResultMap, SqlStatement, JpaEntity, JpaColumn, JpaRelationship, ConfigFile, DatabaseConfig, ServerConfig, SecurityConfig, LoggingConfig, TestClass, TestMethod, TestConfiguration
from src.utils.logger import get_logger
from typing import Optional, List, Literal


def extract_project_name(java_source_folder: str) -> str:
    """
    JAVA_SOURCE_FOLDER 경로에서 프로젝트 이름을 추출합니다.
    
    Args:
        java_source_folder: Java 소스 폴더 경로
        
    Returns:
        프로젝트 이름 (마지막 디렉토리명)
    """
    # 경로를 정규화하고 마지막 디렉토리명 추출
    path = Path(java_source_folder).resolve()
    return path.name


def extract_sql_statements_from_mappers(mybatis_mappers: list[MyBatisMapper], project_name: str) -> list[SqlStatement]:
    """
    MyBatis mappers에서 SQL statements를 추출합니다.
    
    Args:
        mybatis_mappers: MyBatis mapper 객체들의 리스트
        project_name: 프로젝트 이름
        
    Returns:
        SqlStatement 객체들의 리스트
    """
    sql_statements = []
    
    for mapper in mybatis_mappers:
        for sql_dict in mapper.sql_statements:
            # MyBatisSqlStatement를 SqlStatement로 변환
            sql_statement = SqlStatement(
                id=sql_dict.get('id', ''),
                sql_type=sql_dict.get('sql_type', ''),
                sql_content=sql_dict.get('sql_content', ''),
                parameter_type=sql_dict.get('parameter_type', ''),
                result_type=sql_dict.get('result_type', ''),
                result_map=sql_dict.get('result_map', ''),
                mapper_name=mapper.name,
                annotations=[],  # TODO: annotations를 파싱하여 추가
                project_name=project_name
            )
            sql_statements.append(sql_statement)
    
    return sql_statements


def parse_annotations(annotations, target_type: str = "class") -> list[Annotation]:
    """Parse Java annotations into Annotation objects.
    
    Args:
        annotations: List of annotation nodes from javalang
        target_type: Type of target ("class", "method", "field")
    """
    result = []
    for annotation in annotations:
        annotation_name = annotation.name
        parameters = {}
        
        # Parse annotation parameters if they exist
        if hasattr(annotation, 'element') and annotation.element:
            for element in annotation.element:
                if hasattr(element, 'name') and hasattr(element, 'value'):
                    parameters[element.name] = element.value.value if hasattr(element.value, 'value') else str(element.value)
        
        result.append(Annotation(
            name=annotation_name,
            parameters=parameters,
            target_type=target_type,
            category=classify_springboot_annotation(annotation_name)
        ))
    
    return result


def classify_springboot_annotation(annotation_name: str) -> str:
    """Classify SpringBoot annotations into categories.
    
    Args:
        annotation_name: Name of the annotation (e.g., "@Component", "@Service")
        
    Returns:
        Category of the annotation
    """
    # Component annotations
    component_annotations = {
        "Component", "Service", "Repository", "Controller", 
        "RestController", "Configuration", "Bean"
    }
    
    # Injection annotations
    injection_annotations = {
        "Autowired", "Resource", "Value", "Qualifier", "Primary"
    }
    
    # Web annotations
    web_annotations = {
        "RequestMapping", "GetMapping", "PostMapping", "PutMapping", 
        "DeleteMapping", "PatchMapping", "RequestParam", "PathVariable",
        "RequestBody", "ResponseBody", "ResponseStatus"
    }
    
    # JPA annotations
    jpa_annotations = {
        "Entity", "Table", "Id", "Column", "OneToMany", "ManyToOne",
        "OneToOne", "ManyToMany", "JoinColumn", "GeneratedValue"
    }
    
    # Test annotations
    test_annotations = {
        "Test", "SpringBootTest", "DataJpaTest", "WebMvcTest",
        "MockBean", "SpyBean", "TestPropertySource"
    }
    
    # Security annotations
    security_annotations = {
        "PreAuthorize", "PostAuthorize", "Secured", "RolesAllowed",
        "EnableWebSecurity", "EnableGlobalMethodSecurity"
    }
    
    # Validation annotations
    validation_annotations = {
        "Valid", "NotNull", "NotBlank", "NotEmpty", "Size", "Min", "Max",
        "Pattern", "Email", "AssertTrue", "AssertFalse"
    }
    
    # MyBatis annotations
    mybatis_annotations = {
        "Mapper", "Select", "Insert", "Update", "Delete", "SelectProvider",
        "InsertProvider", "UpdateProvider", "DeleteProvider", "Results",
        "Result", "One", "Many", "MapKey", "Options", "SelectKey"
    }
    
    if annotation_name in component_annotations:
        return "component"
    elif annotation_name in injection_annotations:
        return "injection"
    elif annotation_name in web_annotations:
        return "web"
    elif annotation_name in jpa_annotations:
        return "jpa"
    elif annotation_name in test_annotations:
        return "test"
    elif annotation_name in security_annotations:
        return "security"
    elif annotation_name in validation_annotations:
        return "validation"
    elif annotation_name in mybatis_annotations:
        return "mybatis"
    else:
        return "other"


def classify_test_annotation(annotation_name: str) -> str:
    """Classify test annotations into categories.
    
    Args:
        annotation_name: Name of the annotation
        
    Returns:
        Category of the test annotation
    """
    # JUnit annotations
    junit_annotations = {
        "Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll",
        "DisplayName", "ParameterizedTest", "ValueSource", "CsvSource",
        "MethodSource", "Timeout", "Disabled", "Nested", "RepeatedTest",
        "Order", "TestMethodOrder", "TestInstance", "TestClassOrder"
    }
    
    # Spring Boot Test annotations
    spring_test_annotations = {
        "SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest",
        "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest",
        "MockBean", "SpyBean", "TestConfiguration", "ActiveProfiles",
        "TestPropertySource", "DirtiesContext", "Transactional",
        "Rollback", "Commit", "Sql", "SqlGroup", "AutoConfigureTestDatabase",
        "AutoConfigureMockMvc", "AutoConfigureWebMvc", "AutoConfigureWebClient",
        "MockMvc", "TestEntityManager", "TestContainers", "DynamicPropertySource"
    }
    
    # TestNG annotations
    testng_annotations = {
        "TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass",
        "BeforeSuite", "AfterSuite", "BeforeGroups", "AfterGroups",
        "DataProvider", "Parameters", "Groups", "Priority", "DependsOnMethods",
        "DependsOnGroups", "ExpectedExceptions", "InvocationCount",
        "SuccessPercentage", "TimeOut"
    }
    
    # Mockito annotations
    mockito_annotations = {
        "Mock", "Spy", "InjectMocks", "Captor", "MockedStatic"
    }
    
    # AssertJ annotations
    assertj_annotations = {
        "AssertJ"
    }
    
    # Other test annotations
    other_test_annotations = {
        "Ignore", "Category", "RunWith", "ExtendWith", "ContextConfiguration"
    }
    
    if annotation_name in junit_annotations:
        return "junit"
    elif annotation_name in spring_test_annotations:
        return "spring_test"
    elif annotation_name in testng_annotations:
        return "testng"
    elif annotation_name in mockito_annotations:
        return "mockito"
    elif annotation_name in assertj_annotations:
        return "assertj"
    elif annotation_name in other_test_annotations:
        return "other_test"
    else:
        return "other"


def extract_beans_from_classes(classes: list[Class]) -> list[Bean]:
    """Extract Spring Beans from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Bean objects
    """
    beans = []
    
    for cls in classes:
        # Check if class has Spring component annotations
        component_annotations = [ann for ann in cls.annotations if ann.category == "component"]
        
        # Also check for @Repository on interfaces
        has_repository_annotation = any(ann.name == "Repository" for ann in cls.annotations)
        
        if component_annotations or has_repository_annotation:
            # Determine bean type based on annotations
            bean_type = "component"  # default
            if any(ann.name in ["Service", "Service"] for ann in cls.annotations):
                bean_type = "service"
            elif any(ann.name in ["Repository", "Repository"] for ann in cls.annotations):
                bean_type = "repository"
            elif any(ann.name in ["Controller", "RestController"] for ann in cls.annotations):
                bean_type = "controller"
            elif any(ann.name in ["Configuration", "Configuration"] for ann in cls.annotations):
                bean_type = "configuration"
            
            # Determine scope (default is singleton)
            scope = "singleton"
            for ann in cls.annotations:
                if ann.name == "Scope":
                    if "value" in ann.parameters:
                        scope = ann.parameters["value"]
                    elif "prototype" in str(ann.parameters):
                        scope = "prototype"
                    elif "request" in str(ann.parameters):
                        scope = "request"
                    elif "session" in str(ann.parameters):
                        scope = "session"
            
            # Create bean name (use class name with first letter lowercase)
            bean_name = cls.name[0].lower() + cls.name[1:] if cls.name else cls.name
            
            # Check for @Bean methods in configuration classes
            bean_methods = []
            if bean_type == "configuration":
                for method in cls.methods:
                    if any(ann.name == "Bean" for ann in method.annotations):
                        bean_methods.append(method)
            
            bean = Bean(
                name=bean_name,
                type=bean_type,
                scope=scope,
                class_name=cls.name,
                package_name=cls.package_name,
                annotation_names=[ann.name for ann in cls.annotations] if cls.annotations else [],
                method_count=len(bean_methods) if bean_type == "configuration" else len(cls.methods) if cls.methods else 0,
                property_count=len(cls.properties) if cls.properties else 0
            )
            beans.append(bean)
    
    return beans


def analyze_bean_dependencies(classes: list[Class], beans: list[Bean]) -> list[BeanDependency]:
    """Analyze dependencies between Spring Beans.
    
    Args:
        classes: List of parsed Class objects
        beans: List of Bean objects
        
    Returns:
        List of BeanDependency objects
    """
    dependencies = []
    
    # Create a mapping from class names to bean names
    class_to_bean = {}
    for bean in beans:
        class_to_bean[bean.class_name] = bean.name
    
    for cls in classes:
        # Check if this class is a bean
        if cls.name not in class_to_bean:
            continue
            
        source_bean = class_to_bean[cls.name]
        
        # Analyze field injections (@Autowired, @Resource, @Value)
        for prop in cls.properties:
            if any(ann.category == "injection" for ann in prop.annotations):
                # Try to determine target bean from field type
                target_bean = None
                field_type = prop.type
                
                # Look for exact class name match
                if field_type in class_to_bean:
                    target_bean = class_to_bean[field_type]
                else:
                    # Look for interface implementations (simplified - just check if type matches any bean class name)
                    for bean in beans:
                        if field_type == bean.class_name:
                            target_bean = bean.name
                            break
                
                if target_bean:
                    injection_type = "field"
                    for ann in prop.annotations:
                        if ann.name == "Autowired":
                            injection_type = "field"
                        elif ann.name == "Resource":
                            injection_type = "field"
                        elif ann.name == "Value":
                            injection_type = "field"
                    
                    dependency = BeanDependency(
                        source_bean=source_bean,
                        target_bean=target_bean,
                        injection_type=injection_type,
                        field_name=prop.name
                    )
                    dependencies.append(dependency)
        
        # Analyze constructor injections
        for method in cls.methods:
            if method.name == cls.name:  # Constructor
                for param in method.parameters:
                    if any(ann.category == "injection" for ann in param.annotations):
                        target_bean = None
                        param_type = param.type
                        
                        if param_type in class_to_bean:
                            target_bean = class_to_bean[param_type]
                        else:
                            # Look for interface implementations (simplified)
                            for bean in beans:
                                if param_type == bean.class_name:
                                    target_bean = bean.name
                                    break
                        
                        if target_bean:
                            dependency = BeanDependency(
                                source_bean=source_bean,
                                target_bean=target_bean,
                                injection_type="constructor",
                                parameter_name=param.name
                            )
                            dependencies.append(dependency)
        
        # Analyze setter injections
        for method in cls.methods:
            if method.name.startswith("set") and len(method.parameters) == 1:
                if any(ann.category == "injection" for ann in method.annotations):
                    param = method.parameters[0]
                    target_bean = None
                    param_type = param.type
                    
                    if param_type in class_to_bean:
                        target_bean = class_to_bean[param_type]
                    else:
                        # Look for interface implementations (simplified)
                        for bean in beans:
                            if param_type == bean.class_name:
                                target_bean = bean.name
                                break
                    
                    if target_bean:
                        dependency = BeanDependency(
                            source_bean=source_bean,
                            target_bean=target_bean,
                            injection_type="setter",
                            method_name=method.name,
                            parameter_name=param.name
                        )
                        dependencies.append(dependency)
    
    return dependencies


def extract_endpoints_from_classes(classes: list[Class]) -> list[Endpoint]:
    """Extract REST API endpoints from controller classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Endpoint objects
    """
    endpoints = []
    
    for cls in classes:
        # Check if class is a controller
        is_controller = any(ann.name in ["Controller", "RestController"] for ann in cls.annotations)
        
        if not is_controller:
            continue
            
        # Get class-level path mapping
        class_path = ""
        for ann in cls.annotations:
            if ann.name == "RequestMapping":
                if "value" in ann.parameters:
                    class_path = ann.parameters["value"]
                break
        
        # Process each method in the controller
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
                
            # Check if method has web mapping annotations
            web_annotations = [ann for ann in method.annotations if ann.category == "web"]
            
            if not web_annotations:
                continue
            
            # Extract endpoint information
            endpoint_path = ""
            http_method = "GET"  # default
            
            for ann in web_annotations:
                if ann.name in ["RequestMapping", "GetMapping", "PostMapping", "PutMapping", "DeleteMapping", "PatchMapping"]:
                    # Extract path
                    if "value" in ann.parameters:
                        endpoint_path = ann.parameters["value"]
                    elif "path" in ann.parameters:
                        endpoint_path = ann.parameters["path"]
                    
                    # Extract HTTP method
                    if ann.name == "GetMapping":
                        http_method = "GET"
                    elif ann.name == "PostMapping":
                        http_method = "POST"
                    elif ann.name == "PutMapping":
                        http_method = "PUT"
                    elif ann.name == "DeleteMapping":
                        http_method = "DELETE"
                    elif ann.name == "PatchMapping":
                        http_method = "PATCH"
                    elif ann.name == "RequestMapping":
                        if "method" in ann.parameters:
                            method_value = ann.parameters["method"]
                            if isinstance(method_value, list) and len(method_value) > 0:
                                http_method = method_value[0]
                            else:
                                http_method = str(method_value)
                        else:
                            http_method = "GET"  # default for RequestMapping
                    break
            
            # Build full path
            full_path = class_path
            if endpoint_path:
                if full_path and not full_path.endswith("/") and not endpoint_path.startswith("/"):
                    full_path += "/"
                full_path += endpoint_path
            elif not full_path:
                full_path = "/"
            
            # Extract method parameters
            parameters = []
            for param in method.parameters:
                param_info = {
                    "name": param.name,
                    "type": param.type,
                    "annotations": [ann.name for ann in param.annotations if ann.category == "web"]
                }
                parameters.append(param_info)
            
            # Extract return type
            return_type = method.return_type if method.return_type != "constructor" else "void"
            
            # Create endpoint
            endpoint = Endpoint(
                path=endpoint_path or "/",
                method=http_method,
                controller_class=cls.name,
                handler_method=method.name,
                parameters=parameters,
                return_type=return_type,
                annotations=[ann.name for ann in web_annotations],
                full_path=full_path
            )
            endpoints.append(endpoint)
    
    return endpoints


def extract_mybatis_mappers_from_classes(classes: list[Class]) -> list[MyBatisMapper]:
    """Extract MyBatis Mappers from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for cls in classes:
        # Check if class is a MyBatis Mapper interface
        is_mapper = any(ann.name == "Mapper" for ann in cls.annotations)
        
        if not is_mapper:
            continue
        
        # Extract mapper methods with MyBatis annotations
        mapper_methods = []
        sql_statements = []
        
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
            
            # Check if method has MyBatis annotations
            mybatis_annotations = [ann for ann in method.annotations if ann.category == "mybatis"]
            
            if not mybatis_annotations:
                continue
            
            # Extract SQL statement information
            sql_type = "SELECT"  # default
            sql_content = ""
            parameter_type = ""
            result_type = ""
            result_map = ""
            
            for ann in mybatis_annotations:
                if ann.name in ["Select", "SelectProvider"]:
                    sql_type = "SELECT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Insert", "InsertProvider"]:
                    sql_type = "INSERT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Update", "UpdateProvider"]:
                    sql_type = "UPDATE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Delete", "DeleteProvider"]:
                    sql_type = "DELETE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                
                # Extract parameter and result type information
                if "parameterType" in ann.parameters:
                    parameter_type = ann.parameters["parameterType"]
                if "resultType" in ann.parameters:
                    result_type = ann.parameters["resultType"]
                if "resultMap" in ann.parameters:
                    result_map = ann.parameters["resultMap"]
            
            # Create method info
            method_info = {
                "name": method.name,
                "return_type": method.return_type,
                "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            mapper_methods.append(method_info)
            
            # Create SQL statement info
            sql_statement = {
                "id": method.name,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            sql_statements.append(sql_statement)
        
        # Create mapper
        mapper = MyBatisMapper(
            name=cls.name,
            type="interface",
            namespace=f"{cls.package_name}.{cls.name}",
            methods=mapper_methods,
            sql_statements=sql_statements,
            file_path=cls.file_path,
            package_name=cls.package_name
        )
        mappers.append(mapper)
    
    return mappers


def parse_mybatis_xml_file(file_path: str) -> MyBatisMapper:
    """Parse MyBatis XML mapper file.
    
    Args:
        file_path: Path to the XML mapper file
        
    Returns:
        MyBatisMapper object
    """
    import xml.etree.ElementTree as ET
    
    try:
        tree = ET.parse(file_path)
        root = tree.getroot()
        
        # Extract namespace
        namespace = root.get("namespace", "")
        
        # Extract SQL statements
        sql_statements = []
        for statement in root.findall(".//*[@id]"):
            statement_id = statement.get("id")
            tag_name = statement.tag.lower()
            
            # Determine SQL type
            sql_type = "SELECT"
            if tag_name == "insert":
                sql_type = "INSERT"
            elif tag_name == "update":
                sql_type = "UPDATE"
            elif tag_name == "delete":
                sql_type = "DELETE"
            
            # Extract SQL content
            sql_content = statement.text.strip() if statement.text else ""
            
            # Extract parameter and result information
            parameter_type = statement.get("parameterType", "")
            result_type = statement.get("resultType", "")
            result_map = statement.get("resultMap", "")
            
            sql_statement = {
                "id": statement_id,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": []
            }
            sql_statements.append(sql_statement)
        
        # Extract ResultMaps
        result_maps = []
        for result_map in root.findall(".//resultMap"):
            result_map_id = result_map.get("id")
            result_map_type = result_map.get("type", "")
            
            properties = []
            for property_elem in result_map.findall(".//result"):
                prop = {
                    "property": property_elem.get("property", ""),
                    "column": property_elem.get("column", ""),
                    "jdbc_type": property_elem.get("jdbcType", "")
                }
                properties.append(prop)
            
            result_map_info = {
                "id": result_map_id,
                "type": result_map_type,
                "properties": properties,
                "associations": [],
                "collections": []
            }
            result_maps.append(result_map_info)
        
        # Create mapper
        mapper_name = namespace.split(".")[-1] if namespace else os.path.basename(file_path).replace(".xml", "")
        package_name = ".".join(namespace.split(".")[:-1]) if namespace else ""
        
        mapper = MyBatisMapper(
            name=mapper_name,
            type="xml",
            namespace=namespace,
            methods=[],  # XML mappers don't have Java methods
            sql_statements=sql_statements,
            file_path=file_path,
            package_name=package_name
        )
        
        return mapper
        
    except ET.ParseError as e:
        print(f"Error parsing XML file {file_path}: {e}")
        return None
    except Exception as e:
        print(f"Error reading XML file {file_path}: {e}")
        return None


def extract_mybatis_xml_mappers(directory: str) -> list[MyBatisMapper]:
    """Extract MyBatis XML mappers from directory.
    
    Args:
        directory: Directory to search for XML mapper files
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith("Mapper.xml") or file.endswith("Dao.xml"):
                file_path = os.path.join(root, file)
                mapper = parse_mybatis_xml_file(file_path)
                if mapper:
                    mappers.append(mapper)
    
    return mappers


def extract_jpa_entities_from_classes(classes: list[Class]) -> list[JpaEntity]:
    """Extract JPA Entities from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of JpaEntity objects
    """
    entities = []
    
    for cls in classes:
        # Check if class is a JPA Entity
        is_entity = any(ann.name == "Entity" for ann in cls.annotations)
        
        if not is_entity:
            continue
        
        # Extract table name
        table_name = cls.name.lower()  # default table name
        for ann in cls.annotations:
            if ann.name == "Table":
                if "name" in ann.parameters:
                    table_name = ann.parameters["name"]
                break
        
        # Extract columns from properties
        columns = []
        relationships = []
        
        for prop in cls.properties:
            # Check if property has JPA column annotations
            jpa_annotations = [ann for ann in prop.annotations if ann.category == "jpa"]
            
            if jpa_annotations:
                # Extract column information
                column_name = prop.name  # default column name
                nullable = True
                unique = False
                length = 0
                precision = 0
                scale = 0
                
                for ann in jpa_annotations:
                    if ann.name == "Column":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                        if "nullable" in ann.parameters:
                            nullable = ann.parameters["nullable"]
                        if "unique" in ann.parameters:
                            unique = ann.parameters["unique"]
                        if "length" in ann.parameters:
                            length = ann.parameters["length"]
                        if "precision" in ann.parameters:
                            precision = ann.parameters["precision"]
                        if "scale" in ann.parameters:
                            scale = ann.parameters["scale"]
                    elif ann.name == "Id":
                        column_name = "id"  # Primary key column
                        nullable = False
                        unique = True
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                
                # Check for relationship annotations
                relationship_type = None
                target_entity = ""
                mapped_by = ""
                join_column = ""
                join_table = ""
                cascade = []
                fetch = "LAZY"
                
                for ann in jpa_annotations:
                    if ann.name in ["OneToOne", "OneToMany", "ManyToOne", "ManyToMany"]:
                        relationship_type = ann.name
                        if "targetEntity" in ann.parameters:
                            target_entity = ann.parameters["targetEntity"]
                        if "mappedBy" in ann.parameters:
                            mapped_by = ann.parameters["mappedBy"]
                        if "cascade" in ann.parameters:
                            cascade = ann.parameters["cascade"] if isinstance(ann.parameters["cascade"], list) else [ann.parameters["cascade"]]
                        if "fetch" in ann.parameters:
                            fetch = ann.parameters["fetch"]
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            join_column = ann.parameters["name"]
                    elif ann.name == "JoinTable":
                        if "name" in ann.parameters:
                            join_table = ann.parameters["name"]
                
                # Create column info
                column_info = {
                    "property_name": prop.name,
                    "column_name": column_name,
                    "data_type": prop.type,
                    "nullable": nullable,
                    "unique": unique,
                    "length": length,
                    "precision": precision,
                    "scale": scale,
                    "annotations": [ann.name for ann in jpa_annotations]
                }
                columns.append(column_info)
                
                # Create relationship info if it's a relationship
                if relationship_type:
                    relationship_info = {
                        "type": relationship_type,
                        "target_entity": target_entity,
                        "mapped_by": mapped_by,
                        "join_column": join_column,
                        "join_table": join_table,
                        "cascade": cascade,
                        "fetch": fetch,
                        "annotations": [ann.name for ann in jpa_annotations]
                    }
                    relationships.append(relationship_info)
        
        # Create entity
        entity = JpaEntity(
            name=cls.name,
            table_name=table_name,
            columns=columns,
            relationships=relationships,
            annotations=[ann.name for ann in cls.annotations if ann.category == "jpa"],
            package_name=cls.package_name,
            file_path=cls.file_path
        )
        entities.append(entity)
    
    return entities


def parse_yaml_config(file_path: str) -> ConfigFile:
    """Parse YAML configuration file.
    
    Args:
        file_path: Path to the YAML file
        
    Returns:
        ConfigFile object
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = yaml.safe_load(f)
        
        if not content:
            content = {}
        
        # Extract file info
        file_name = os.path.basename(file_path)
        file_type = "yaml" if file_path.endswith('.yaml') else "yml"
        
        # Extract profiles
        profiles = []
        if 'spring' in content and 'profiles' in content['spring']:
            if 'active' in content['spring']['profiles']:
                profiles = content['spring']['profiles']['active']
                if isinstance(profiles, str):
                    profiles = [profiles]
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        # Extract sections
        sections = []
        for key, value in content.items():
            if isinstance(value, dict):
                sections.append({
                    "name": key,
                    "properties": value,
                    "type": "section"
                })
        
        return ConfigFile(
            name=file_name,
            file_path=file_path,
            file_type=file_type,
            properties=content,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing YAML file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="yaml",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def parse_properties_config(file_path: str) -> ConfigFile:
    """Parse Properties configuration file.
    
    Args:
        file_path: Path to the properties file
        
    Returns:
        ConfigFile object
    """
    try:
        properties = {}
        sections = []
        profiles = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                
                # Skip empty lines and comments
                if not line or line.startswith('#'):
                    continue
                
                # Parse key=value pairs
                if '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    
                    # Remove quotes if present
                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]
                    elif value.startswith("'") and value.endswith("'"):
                        value = value[1:-1]
                    
                    properties[key] = value
                    
                    # Check for profiles
                    if key == 'spring.profiles.active':
                        profiles = [p.strip() for p in value.split(',')]
        
        # Group properties by section
        section_map = {}
        for key, value in properties.items():
            if '.' in key:
                section = key.split('.')[0]
                if section not in section_map:
                    section_map[section] = {}
                section_map[section][key] = value
            else:
                if 'root' not in section_map:
                    section_map['root'] = {}
                section_map['root'][key] = value
        
        for section_name, section_props in section_map.items():
            sections.append({
                "name": section_name,
                "properties": section_props,
                "type": "section"
            })
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties=properties,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing Properties file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def extract_database_config(config_file: ConfigFile) -> DatabaseConfig:
    """Extract database configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        DatabaseConfig object
    """
    db_config = DatabaseConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        spring_config = config_file.properties.get('spring', {})
        datasource_config = spring_config.get('datasource', {})
        jpa_config = spring_config.get('jpa', {})
        
        db_config.driver = datasource_config.get('driver-class-name', '')
        db_config.url = datasource_config.get('url', '')
        db_config.username = datasource_config.get('username', '')
        db_config.password = datasource_config.get('password', '')
        db_config.dialect = jpa_config.get('database-platform', '')
        db_config.hibernate_ddl_auto = jpa_config.get('hibernate', {}).get('ddl-auto', '')
        db_config.show_sql = jpa_config.get('show-sql', False)
        db_config.format_sql = jpa_config.get('properties', {}).get('hibernate', {}).get('format_sql', False)
        
        # Store additional JPA properties
        if 'properties' in jpa_config:
            db_config.jpa_properties = jpa_config['properties']
    
    else:
        # Properties format
        props = config_file.properties
        
        db_config.driver = props.get('spring.datasource.driver-class-name', '')
        db_config.url = props.get('spring.datasource.url', '')
        db_config.username = props.get('spring.datasource.username', '')
        db_config.password = props.get('spring.datasource.password', '')
        db_config.dialect = props.get('spring.jpa.database-platform', '')
        db_config.hibernate_ddl_auto = props.get('spring.jpa.hibernate.ddl-auto', '')
        db_config.show_sql = props.get('spring.jpa.show-sql', 'false').lower() == 'true'
        db_config.format_sql = props.get('spring.jpa.properties.hibernate.format_sql', 'false').lower() == 'true'
        
        # Store additional JPA properties
        jpa_props = {}
        for key, value in props.items():
            if key.startswith('spring.jpa.properties.'):
                jpa_props[key] = value
        db_config.jpa_properties = jpa_props
    
    return db_config


def extract_server_config(config_file: ConfigFile) -> ServerConfig:
    """Extract server configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        ServerConfig object
    """
    server_config = ServerConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        server_props = config_file.properties.get('server', {})
        
        server_config.port = server_props.get('port', 8080)
        server_config.context_path = server_props.get('servlet', {}).get('context-path', '')
        server_config.servlet_path = server_props.get('servlet', {}).get('path', '')
        
        # SSL configuration
        ssl_config = server_props.get('ssl', {})
        server_config.ssl_enabled = bool(ssl_config)
        server_config.ssl_key_store = ssl_config.get('key-store', '')
        server_config.ssl_key_store_password = ssl_config.get('key-store-password', '')
        server_config.ssl_key_store_type = ssl_config.get('key-store-type', '')
    
    else:
        # Properties format
        props = config_file.properties
        
        server_config.port = int(props.get('server.port', '8080'))
        server_config.context_path = props.get('server.servlet.context-path', '')
        server_config.servlet_path = props.get('server.servlet.path', '')
        
        # SSL configuration
        server_config.ssl_enabled = any(key.startswith('server.ssl.') for key in props.keys())
        server_config.ssl_key_store = props.get('server.ssl.key-store', '')
        server_config.ssl_key_store_password = props.get('server.ssl.key-store-password', '')
        server_config.ssl_key_store_type = props.get('server.ssl.key-store-type', '')
    
    return server_config


def extract_security_config(config_file: ConfigFile) -> SecurityConfig:
    """Extract security configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        SecurityConfig object
    """
    security_config = SecurityConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        security_props = config_file.properties.get('security', {})
        jwt_props = security_props.get('jwt', {})
        cors_props = security_props.get('cors', {})
        
        security_config.enabled = bool(security_props)
        security_config.authentication_type = security_props.get('authentication-type', '')
        security_config.jwt_secret = jwt_props.get('secret', '')
        security_config.jwt_expiration = jwt_props.get('expiration', 0)
        security_config.cors_allowed_origins = cors_props.get('allowed-origins', [])
        security_config.cors_allowed_methods = cors_props.get('allowed-methods', [])
        security_config.cors_allowed_headers = cors_props.get('allowed-headers', [])
    
    else:
        # Properties format
        props = config_file.properties
        
        security_config.enabled = any(key.startswith('security.') for key in props.keys())
        security_config.authentication_type = props.get('security.authentication-type', '')
        security_config.jwt_secret = props.get('security.jwt.secret', '')
        security_config.jwt_expiration = int(props.get('security.jwt.expiration', '0'))
        
        # CORS configuration
        origins = props.get('security.cors.allowed-origins', '')
        if origins:
            security_config.cors_allowed_origins = [o.strip() for o in origins.split(',')]
        
        methods = props.get('security.cors.allowed-methods', '')
        if methods:
            security_config.cors_allowed_methods = [m.strip() for m in methods.split(',')]
        
        headers = props.get('security.cors.allowed-headers', '')
        if headers:
            security_config.cors_allowed_headers = [h.strip() for h in headers.split(',')]
    
    return security_config


def extract_logging_config(config_file: ConfigFile) -> LoggingConfig:
    """Extract logging configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        LoggingConfig object
    """
    logging_config = LoggingConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        logging_props = config_file.properties.get('logging', {})
        
        logging_config.level = logging_props.get('level', {}).get('root', 'INFO')
        logging_config.pattern = logging_props.get('pattern', {}).get('console', '')
        logging_config.file_path = logging_props.get('file', {}).get('name', '')
        logging_config.max_file_size = logging_props.get('file', {}).get('max-size', '')
        logging_config.max_history = logging_props.get('file', {}).get('max-history', 0)
        logging_config.console_output = logging_props.get('console', {}).get('enabled', True)
    
    else:
        # Properties format
        props = config_file.properties
        
        logging_config.level = props.get('logging.level.root', 'INFO')
        logging_config.pattern = props.get('logging.pattern.console', '')
        logging_config.file_path = props.get('logging.file.name', '')
        logging_config.max_file_size = props.get('logging.file.max-size', '')
        logging_config.max_history = int(props.get('logging.file.max-history', '0'))
        logging_config.console_output = props.get('logging.console.enabled', 'true').lower() == 'true'
    
    return logging_config


def extract_config_files(directory: str) -> list[ConfigFile]:
    """Extract configuration files from directory.
    
    Args:
        directory: Directory to search for config files
        
    Returns:
        List of ConfigFile objects
    """
    config_files = []
    
    # Common config file patterns
    config_patterns = [
        "application.yml",
        "application.yaml", 
        "application.properties",
        "application-*.properties",
        "bootstrap.yml",
        "bootstrap.yaml",
        "bootstrap.properties"
    ]
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            # Check if file matches any config pattern
            is_config_file = False
            for pattern in config_patterns:
                if pattern == file or (pattern.endswith('*') and file.startswith(pattern[:-1])):
                    is_config_file = True
                    break
            
            if is_config_file:
                file_path = os.path.join(root, file)
                
                if file.endswith(('.yml', '.yaml')):
                    config_file = parse_yaml_config(file_path)
                elif file.endswith('.properties'):
                    config_file = parse_properties_config(file_path)
                else:
                    continue
                
                config_files.append(config_file)
    
    return config_files


def extract_test_classes_from_classes(classes: list[Class]) -> list[TestClass]:
    """Extract test classes from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of TestClass objects
    """
    test_classes = []
    
    for cls in classes:
        # Check if class is a test class
        test_annotations = [ann for ann in cls.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
        
        if not test_annotations:
            continue
        
        # Determine test framework and type
        test_framework = "junit"  # default
        test_type = "unit"  # default
        
        for ann in test_annotations:
            if ann.name in ["SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest", "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest"]:
                test_framework = "spring_test"
                if ann.name == "SpringBootTest":
                    test_type = "integration"
                else:
                    test_type = "slice"
            elif ann.name in ["TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass"]:
                test_framework = "testng"
            elif ann.name in ["Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll"]:
                test_framework = "junit"
        
        # Extract test methods
        test_methods = []
        setup_methods = []
        
        for method in cls.methods:
            method_annotations = [ann.name for ann in method.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
            
            if method_annotations:
                # Check if it's a setup/teardown method
                if any(ann in method_annotations for ann in ["BeforeEach", "AfterEach", "BeforeAll", "AfterAll", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass", "BeforeSuite", "AfterSuite"]):
                    setup_methods.append({
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters]
                    })
                else:
                    # Regular test method
                    test_method_info = {
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                        "assertions": [],
                        "mock_calls": [],
                        "test_data": [],
                        "expected_exceptions": [],
                        "timeout": 0,
                        "display_name": ""
                    }
                    
                    # Extract display name
                    for ann in method.annotations:
                        if ann.name == "DisplayName" and "value" in ann.parameters:
                            test_method_info["display_name"] = ann.parameters["value"]
                        elif ann.name == "Timeout" and "value" in ann.parameters:
                            test_method_info["timeout"] = ann.parameters["value"]
                    
                    # Extract expected exceptions
                    for ann in method.annotations:
                        if ann.name == "ExpectedExceptions" and "value" in ann.parameters:
                            test_method_info["expected_exceptions"] = ann.parameters["value"] if isinstance(ann.parameters["value"], list) else [ann.parameters["value"]]
                    
                    test_methods.append(test_method_info)
        
        # Extract mock dependencies
        mock_dependencies = []
        for prop in cls.properties:
            prop_annotations = [ann.name for ann in prop.annotations if classify_test_annotation(ann.name) in ["mockito", "spring_test"]]
            if prop_annotations:
                mock_dependencies.append({
                    "name": prop.name,
                    "type": prop.type,
                    "annotations": prop_annotations,
                    "mock_type": "mock" if "Mock" in prop_annotations else "spy" if "Spy" in prop_annotations else "bean"
                })
        
        # Extract test configurations
        test_configurations = []
        for ann in cls.annotations:
            if ann.name in ["TestConfiguration", "ActiveProfiles", "TestPropertySource"]:
                config_info = {
                    "name": ann.name,
                    "type": "configuration" if ann.name == "TestConfiguration" else "profile" if ann.name == "ActiveProfiles" else "property",
                    "properties": ann.parameters,
                    "active_profiles": ann.parameters.get("value", []) if ann.name == "ActiveProfiles" else [],
                    "test_slices": [],
                    "mock_beans": [],
                    "spy_beans": []
                }
                test_configurations.append(config_info)
        
        # Create test class
        test_class = TestClass(
            name=cls.name,
            package_name=cls.package_name,
            test_framework=test_framework,
            test_type=test_type,
            annotations=[ann.name for ann in test_annotations],
            test_methods=test_methods,
            setup_methods=setup_methods,
            mock_dependencies=mock_dependencies,
            test_configurations=test_configurations,
            file_path=cls.file_path
        )
        test_classes.append(test_class)
    
    return test_classes


def analyze_test_methods(test_class: TestClass, class_obj: Class) -> list[TestMethod]:
    """Analyze test methods for assertions, mock calls, and test data.
    
    Args:
        test_class: TestClass object
        class_obj: Original Class object
        
    Returns:
        List of analyzed TestMethod objects
    """
    test_methods = []
    
    for method_info in test_class.test_methods:
        # Find the corresponding method in the class
        method_obj = None
        for method in class_obj.methods:
            if method.name == method_info["name"]:
                method_obj = method
                break
        
        if not method_obj:
            continue
        
        # Analyze method source code for assertions and mock calls
        assertions = []
        mock_calls = []
        test_data = []
        
        if method_obj.source:
            source_code = method_obj.source
            
            # Find assertions (JUnit, AssertJ, etc.)
            assertion_patterns = [
                r'assert\w+\(',  # JUnit assertions
                r'assertThat\(',  # AssertJ
                r'assertEquals\(',  # JUnit
                r'assertTrue\(',  # JUnit
                r'assertFalse\(',  # JUnit
                r'assertNotNull\(',  # JUnit
                r'assertNull\(',  # JUnit
                r'assertThrows\(',  # JUnit 5
                r'assertDoesNotThrow\(',  # JUnit 5
                r'verify\(',  # Mockito verify
                r'when\(',  # Mockito when
                r'then\(',  # Mockito then
                r'given\(',  # BDDMockito given
                r'willReturn\(',  # Mockito willReturn
                r'willThrow\(',  # Mockito willThrow
            ]
            
            for pattern in assertion_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    assertions.append({
                        "type": match,
                        "line": source_code.find(match) + 1
                    })
            
            # Find mock calls
            mock_call_patterns = [
                r'(\w+)\.(\w+)\(',  # Method calls on objects
                r'mock\(',  # Mockito mock creation
                r'spy\(',  # Mockito spy creation
                r'@Mock\s+(\w+)',  # @Mock annotation
                r'@Spy\s+(\w+)',  # @Spy annotation
                r'@InjectMocks\s+(\w+)',  # @InjectMocks annotation
            ]
            
            for pattern in mock_call_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        mock_calls.append({
                            "object": match[0],
                            "method": match[1],
                            "type": "method_call"
                        })
                    else:
                        mock_calls.append({
                            "type": match,
                            "line": source_code.find(match) + 1
                        })
            
            # Find test data setup
            test_data_patterns = [
                r'new\s+(\w+)\(',  # Object creation
                r'(\w+)\s*=\s*new\s+(\w+)\(',  # Variable assignment with new
                r'@ValueSource\(',  # JUnit 5 @ValueSource
                r'@CsvSource\(',  # JUnit 5 @CsvSource
                r'@MethodSource\(',  # JUnit 5 @MethodSource
            ]
            
            for pattern in test_data_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        test_data.append({
                            "variable": match[0],
                            "type": match[1],
                            "pattern": "object_creation"
                        })
                    else:
                        test_data.append({
                            "type": match,
                            "pattern": "annotation"
                        })
        
        # Create TestMethod object
        test_method = TestMethod(
            name=method_info["name"],
            return_type=method_info["return_type"],
            annotations=method_info["annotations"],
            assertions=assertions,
            mock_calls=mock_calls,
            test_data=test_data,
            expected_exceptions=method_info["expected_exceptions"],
            timeout=method_info["timeout"],
            display_name=method_info["display_name"]
        )
        test_methods.append(test_method)
    
    return test_methods


def generate_lombok_methods(properties: list[Field], class_name: str, package_name: str) -> list[Method]:
    """Generate Lombok @Data methods (getters, setters, equals, hashCode, toString) for properties."""
    methods = []
    
    # Generate getters and setters for each property
    for prop in properties:
        # Getter
        getter_name = f"get{prop.name[0].upper()}{prop.name[1:]}"
        if prop.type == "Boolean" and prop.name.startswith("is"):
            # For boolean fields starting with 'is', use the field name as getter
            getter_name = prop.name
        
        getter = Method(
            name=getter_name,
            logical_name=f"{package_name}.{class_name}.{getter_name}",
            return_type=prop.type,
            parameters=[],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[]
        )
        methods.append(getter)
        
        # Setter
        setter_name = f"set{prop.name[0].upper()}{prop.name[1:]}"
        setter_param = Field(
            name=prop.name,
            logical_name=f"{package_name}.{class_name}.{prop.name}",
            type=prop.type,
            package_name=package_name,
            class_name=class_name
        )
        
        setter = Method(
            name=setter_name,
            logical_name=f"{package_name}.{class_name}.{setter_name}",
            return_type="void",
            parameters=[setter_param],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[]
        )
        methods.append(setter)
    
    # Generate equals method
    equals_method = Method(
        name="equals",
        logical_name=f"{package_name}.{class_name}.equals",
        return_type="boolean",
        parameters=[Field(name="obj", logical_name=f"{package_name}.{class_name}.obj", type="Object", package_name=package_name, class_name=class_name)],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(equals_method)
    
    # Generate hashCode method
    hashcode_method = Method(
        name="hashCode",
        logical_name=f"{package_name}.{class_name}.hashCode",
        return_type="int",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(hashcode_method)
    
    # Generate toString method
    tostring_method = Method(
        name="toString",
        logical_name=f"{package_name}.{class_name}.toString",
        return_type="String",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(tostring_method)
    
    return methods


def parse_java_project(directory: str) -> tuple[list[Package], list[Class], dict[str, str], list[Bean], list[BeanDependency], list[Endpoint], list[MyBatisMapper], list[JpaEntity], list[ConfigFile], list[TestClass], list[SqlStatement], str]:
    """Parse Java project and return parsed entities."""
    logger = get_logger(__name__)
    """Parses all Java files in a directory and returns a tuple of (packages, classes, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name)."""
    
    # Extract project name from directory path
    project_name = extract_project_name(directory)
    packages = {}
    classes = {}
    class_to_package_map = {}  # Maps class_key to package_name

    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith(".java"):
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    file_content = f.read() # Read file content once
                try:
                    tree = javalang.parse.parse(file_content)
                    package_name = tree.package.name if tree.package else ""
                    
                    # Create or update package node
                    if package_name and package_name not in packages:
                        packages[package_name] = Package(
                            name=package_name
                        )
                    elif not package_name:
                        # Handle classes without package (default package)
                        package_name = "default"
                        if package_name not in packages:
                            packages[package_name] = Package(
                                name=package_name
                            )
                    
                    import_map = {}
                    for imp in tree.imports:
                        class_name = imp.path.split('.')[-1]
                        import_map[class_name] = imp.path

                    for _, class_declaration in tree.filter(
                        javalang.tree.ClassDeclaration
                    ):
                        class_name = class_declaration.name
                        class_key = f"{package_name}.{class_name}"
                        
                        # Debug: Check if this is the User class
                        if "User" in class_name:
                            logger.debug(f"Found User class - {class_key}")
                            logger.debug(f"Methods count: {len(class_declaration.methods)}")
                            logger.debug(f"Constructors count: {len(class_declaration.constructors)}")
                        
                        # Extract class source code - use the entire file content
                        class_source = file_content


                        if class_key not in classes:
                            # Parse class annotations
                            class_annotations = parse_annotations(class_declaration.annotations, "class") if hasattr(class_declaration, 'annotations') else []
                            
                            classes[class_key] = Class(
                                name=class_name,
                                logical_name=class_key,  # Add logical_name
                                file_path=file_path,
                                type="class", # Simplified for now
                                source=class_source, # Add class source
                                annotations=class_annotations,
                                package_name=package_name
                            )
                            class_to_package_map[class_key] = package_name
                        
                        # --- Start of new import logic ---
                        for imp in tree.imports:
                            classes[class_key].imports.append(imp.path)
                        # --- End of new import logic ---

                        # --- Start of new inheritance logic ---
                        # Handle 'extends'
                        if class_declaration.extends:
                            superclass_name = class_declaration.extends.name
                            # Try to resolve fully qualified name for superclass
                            if superclass_name in import_map:
                                classes[class_key].superclass = import_map[superclass_name]
                            else:
                                # Assume same package or fully qualified if not in import_map
                                classes[class_key].superclass = f"{package_name}.{superclass_name}" if package_name else superclass_name

                        # Handle 'implements'
                        if class_declaration.implements: # Add this check
                            for impl_ref in class_declaration.implements:
                                interface_name = impl_ref.name
                                # Try to resolve fully qualified name for interface
                                if interface_name in import_map:
                                    classes[class_key].interfaces.append(import_map[interface_name])
                                else:
                                    # Assume same package or fully qualified if not in import_map
                                    classes[class_key].interfaces.append(f"{package_name}.{interface_name}" if package_name else interface_name)
                        # --- End of new inheritance logic ---

                        field_map = {}
                        for field_declaration in class_declaration.fields:
                            for declarator in field_declaration.declarators:
                                field_map[declarator.name] = field_declaration.type.name
                                
                                # Parse field annotations
                                field_annotations = parse_annotations(field_declaration.annotations, "field") if hasattr(field_declaration, 'annotations') else []
                                
                                # Extract initial value if present
                                initial_value = ""
                                if hasattr(declarator, 'initializer') and declarator.initializer:
                                    # Convert the initializer to string representation
                                    if hasattr(declarator.initializer, 'value'):
                                        initial_value = str(declarator.initializer.value)
                                    elif hasattr(declarator.initializer, 'type'):
                                        initial_value = str(declarator.initializer.type)
                                    else:
                                        initial_value = str(declarator.initializer)
                                
                                prop = Field(
                                    name=declarator.name,
                                    logical_name=f"{package_name}.{class_name}.{declarator.name}",
                                    type=field_declaration.type.name,
                                    modifiers=list(field_declaration.modifiers), # Add modifiers
                                    package_name=package_name,
                                    class_name=class_name,
                                    annotations=field_annotations,
                                    initial_value=initial_value,
                                    description=""  # TODO: Extract description from comments or annotations
                                )
                                classes[class_key].properties.append(prop)

                        all_declarations = class_declaration.methods + class_declaration.constructors
                        
                        # Debug: Check User class method processing
                        if "User" in class_name:
                            logger.debug(f"Processing User class methods - total declarations: {len(all_declarations)}")
                            for i, decl in enumerate(all_declarations):
                                logger.debug(f"Declaration {i}: {type(decl).__name__} - {decl.name}")
                        
                        for declaration in all_declarations:
                            local_var_map = field_map.copy()
                            params = []
                            for param in declaration.parameters:
                                param_type_name = 'Unknown'
                                if hasattr(param.type, 'name'):
                                    param_type_name = param.type.name
                                local_var_map[param.name] = param_type_name
                                params.append(Field(name=param.name, logical_name=f"{package_name}.{class_name}.{param.name}", type=param_type_name, package_name=package_name, class_name=class_name))

                            if declaration.body:
                                for _, var_decl in declaration.filter(javalang.tree.LocalVariableDeclaration):
                                    for declarator in var_decl.declarators:
                                        local_var_map[declarator.name] = var_decl.type.name
                            
                            if isinstance(declaration, javalang.tree.MethodDeclaration):
                                return_type = declaration.return_type.name if declaration.return_type else "void"
                            else: # ConstructorDeclaration
                                return_type = "constructor"

                            # Extract modifiers
                            modifiers = list(declaration.modifiers)
                            
                            # Parse method annotations
                            method_annotations = parse_annotations(declaration.annotations, "method") if hasattr(declaration, 'annotations') else []

                            # Extract method source code
                            method_source = ""
                            if declaration.position:
                                lines = file_content.splitlines(keepends=True) # Keep line endings
                                start_line = declaration.position.line - 1
                                
                                # Find the end of the method by matching braces
                                brace_count = 0
                                end_line = start_line
                                for i in range(start_line, len(lines)):
                                    line = lines[i]
                                    for char in line:
                                        if char == '{':
                                            brace_count += 1
                                        elif char == '}':
                                            brace_count -= 1
                                            if brace_count == 0:
                                                end_line = i
                                                break
                                    if brace_count == 0:
                                        break
                                
                                method_source = "".join(lines[start_line:end_line + 1])

                            method = Method(
                                name=declaration.name,
                                logical_name=f"{class_key}.{declaration.name}",  # Add logical_name
                                return_type=return_type,
                                parameters=params,
                                modifiers=modifiers,
                                source=method_source, # Add method source
                                package_name=package_name,
                                annotations=method_annotations
                            )
                            classes[class_key].methods.append(method)

                            # Extract method calls with order information
                            call_order = 0
                            for _, invocation in declaration.filter(javalang.tree.MethodInvocation):
                                target_class_name = None
                                resolved_target_package = ""
                                resolved_target_class_name = ""
                                
                                if invocation.qualifier:
                                    # External method call
                                    if invocation.qualifier in local_var_map:
                                        target_class_name = local_var_map[invocation.qualifier]
                                    else:
                                        target_class_name = invocation.qualifier
                                    
                                    if target_class_name:
                                        if target_class_name == "System.out":
                                            resolved_target_package = "java.io"
                                            resolved_target_class_name = "PrintStream"
                                        else:
                                            if target_class_name in import_map:
                                                resolved_target_package = ".".join(import_map[target_class_name].split(".")[:-1])
                                            else:
                                                resolved_target_package = package_name
                                                resolved_target_class_name = target_class_name
                                else:
                                    # Same class method call
                                    resolved_target_package = package_name
                                    resolved_target_class_name = class_name

                                if resolved_target_class_name:
                                    # Get line number from invocation position
                                    line_number = invocation.position.line if invocation.position else 0

                                    call = MethodCall(
                                        source_package=package_name,
                                        source_class=class_name,
                                        source_method=declaration.name,
                                        target_package=resolved_target_package,
                                        target_class=resolved_target_class_name,
                                        target_method=invocation.member,
                                        call_order=call_order,
                                        line_number=line_number,
                                        return_type="void"  # Default return type, can be enhanced later
                                    )
                                    classes[class_key].calls.append(call)
                                    call_order += 1
                        
                        # Check for Lombok @Data annotation and generate methods
                        has_data_annotation = any(ann.name == "Data" for ann in classes[class_key].annotations)
                        if has_data_annotation:
                            logger.debug(f"Found @Data annotation on {class_name}, generating Lombok methods")
                            lombok_methods = generate_lombok_methods(classes[class_key].properties, class_name, package_name)
                            classes[class_key].methods.extend(lombok_methods)
                            logger.debug(f"Generated {len(lombok_methods)} Lombok methods for {class_name}")
                except javalang.parser.JavaSyntaxError as e:
                    print(f"Syntax error in {file_path}: {e}")
                    continue
                except Exception as e:
                    print(f"Error parsing {file_path}: {e}")
                    continue
    
    # Extract beans, analyze dependencies, extract endpoints, extract MyBatis mappers, extract JPA entities, extract config files, and extract test classes
    classes_list = list(classes.values())
    beans = extract_beans_from_classes(classes_list)
    dependencies = analyze_bean_dependencies(classes_list, beans)
    endpoints = extract_endpoints_from_classes(classes_list)
    mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
    jpa_entities = extract_jpa_entities_from_classes(classes_list)
    config_files = extract_config_files(directory)
    test_classes = extract_test_classes_from_classes(classes_list)
    
    # Also extract XML mappers
    xml_mappers = extract_mybatis_xml_mappers(directory)
    mybatis_mappers.extend(xml_mappers)
    
    # Extract SQL statements from MyBatis mappers
    sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
    
    return list(packages.values()), classes_list, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name
```

이제 Method 생성 부분에서도 description을 추가하겠습니다. Method 생성 부분을 찾아보겠습니다.


주요 Method 생성 부분들을 찾았습니다. 이제 각각에 description을 추가하겠습니다.


```python
import os
import yaml
import re
from pathlib import Path

import javalang

from src.models.graph_entities import Class, Method, MethodCall, Field, Package, Annotation, Bean, BeanDependency, Endpoint, MyBatisMapper, MyBatisSqlStatement, MyBatisResultMap, SqlStatement, JpaEntity, JpaColumn, JpaRelationship, ConfigFile, DatabaseConfig, ServerConfig, SecurityConfig, LoggingConfig, TestClass, TestMethod, TestConfiguration
from src.utils.logger import get_logger
from typing import Optional, List, Literal


def extract_project_name(java_source_folder: str) -> str:
    """
    JAVA_SOURCE_FOLDER 경로에서 프로젝트 이름을 추출합니다.
    
    Args:
        java_source_folder: Java 소스 폴더 경로
        
    Returns:
        프로젝트 이름 (마지막 디렉토리명)
    """
    # 경로를 정규화하고 마지막 디렉토리명 추출
    path = Path(java_source_folder).resolve()
    return path.name


def extract_sql_statements_from_mappers(mybatis_mappers: list[MyBatisMapper], project_name: str) -> list[SqlStatement]:
    """
    MyBatis mappers에서 SQL statements를 추출합니다.
    
    Args:
        mybatis_mappers: MyBatis mapper 객체들의 리스트
        project_name: 프로젝트 이름
        
    Returns:
        SqlStatement 객체들의 리스트
    """
    sql_statements = []
    
    for mapper in mybatis_mappers:
        for sql_dict in mapper.sql_statements:
            # MyBatisSqlStatement를 SqlStatement로 변환
            sql_statement = SqlStatement(
                id=sql_dict.get('id', ''),
                sql_type=sql_dict.get('sql_type', ''),
                sql_content=sql_dict.get('sql_content', ''),
                parameter_type=sql_dict.get('parameter_type', ''),
                result_type=sql_dict.get('result_type', ''),
                result_map=sql_dict.get('result_map', ''),
                mapper_name=mapper.name,
                annotations=[],  # TODO: annotations를 파싱하여 추가
                project_name=project_name
            )
            sql_statements.append(sql_statement)
    
    return sql_statements


def parse_annotations(annotations, target_type: str = "class") -> list[Annotation]:
    """Parse Java annotations into Annotation objects.
    
    Args:
        annotations: List of annotation nodes from javalang
        target_type: Type of target ("class", "method", "field")
    """
    result = []
    for annotation in annotations:
        annotation_name = annotation.name
        parameters = {}
        
        # Parse annotation parameters if they exist
        if hasattr(annotation, 'element') and annotation.element:
            for element in annotation.element:
                if hasattr(element, 'name') and hasattr(element, 'value'):
                    parameters[element.name] = element.value.value if hasattr(element.value, 'value') else str(element.value)
        
        result.append(Annotation(
            name=annotation_name,
            parameters=parameters,
            target_type=target_type,
            category=classify_springboot_annotation(annotation_name)
        ))
    
    return result


def classify_springboot_annotation(annotation_name: str) -> str:
    """Classify SpringBoot annotations into categories.
    
    Args:
        annotation_name: Name of the annotation (e.g., "@Component", "@Service")
        
    Returns:
        Category of the annotation
    """
    # Component annotations
    component_annotations = {
        "Component", "Service", "Repository", "Controller", 
        "RestController", "Configuration", "Bean"
    }
    
    # Injection annotations
    injection_annotations = {
        "Autowired", "Resource", "Value", "Qualifier", "Primary"
    }
    
    # Web annotations
    web_annotations = {
        "RequestMapping", "GetMapping", "PostMapping", "PutMapping", 
        "DeleteMapping", "PatchMapping", "RequestParam", "PathVariable",
        "RequestBody", "ResponseBody", "ResponseStatus"
    }
    
    # JPA annotations
    jpa_annotations = {
        "Entity", "Table", "Id", "Column", "OneToMany", "ManyToOne",
        "OneToOne", "ManyToMany", "JoinColumn", "GeneratedValue"
    }
    
    # Test annotations
    test_annotations = {
        "Test", "SpringBootTest", "DataJpaTest", "WebMvcTest",
        "MockBean", "SpyBean", "TestPropertySource"
    }
    
    # Security annotations
    security_annotations = {
        "PreAuthorize", "PostAuthorize", "Secured", "RolesAllowed",
        "EnableWebSecurity", "EnableGlobalMethodSecurity"
    }
    
    # Validation annotations
    validation_annotations = {
        "Valid", "NotNull", "NotBlank", "NotEmpty", "Size", "Min", "Max",
        "Pattern", "Email", "AssertTrue", "AssertFalse"
    }
    
    # MyBatis annotations
    mybatis_annotations = {
        "Mapper", "Select", "Insert", "Update", "Delete", "SelectProvider",
        "InsertProvider", "UpdateProvider", "DeleteProvider", "Results",
        "Result", "One", "Many", "MapKey", "Options", "SelectKey"
    }
    
    if annotation_name in component_annotations:
        return "component"
    elif annotation_name in injection_annotations:
        return "injection"
    elif annotation_name in web_annotations:
        return "web"
    elif annotation_name in jpa_annotations:
        return "jpa"
    elif annotation_name in test_annotations:
        return "test"
    elif annotation_name in security_annotations:
        return "security"
    elif annotation_name in validation_annotations:
        return "validation"
    elif annotation_name in mybatis_annotations:
        return "mybatis"
    else:
        return "other"


def classify_test_annotation(annotation_name: str) -> str:
    """Classify test annotations into categories.
    
    Args:
        annotation_name: Name of the annotation
        
    Returns:
        Category of the test annotation
    """
    # JUnit annotations
    junit_annotations = {
        "Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll",
        "DisplayName", "ParameterizedTest", "ValueSource", "CsvSource",
        "MethodSource", "Timeout", "Disabled", "Nested", "RepeatedTest",
        "Order", "TestMethodOrder", "TestInstance", "TestClassOrder"
    }
    
    # Spring Boot Test annotations
    spring_test_annotations = {
        "SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest",
        "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest",
        "MockBean", "SpyBean", "TestConfiguration", "ActiveProfiles",
        "TestPropertySource", "DirtiesContext", "Transactional",
        "Rollback", "Commit", "Sql", "SqlGroup", "AutoConfigureTestDatabase",
        "AutoConfigureMockMvc", "AutoConfigureWebMvc", "AutoConfigureWebClient",
        "MockMvc", "TestEntityManager", "TestContainers", "DynamicPropertySource"
    }
    
    # TestNG annotations
    testng_annotations = {
        "TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass",
        "BeforeSuite", "AfterSuite", "BeforeGroups", "AfterGroups",
        "DataProvider", "Parameters", "Groups", "Priority", "DependsOnMethods",
        "DependsOnGroups", "ExpectedExceptions", "InvocationCount",
        "SuccessPercentage", "TimeOut"
    }
    
    # Mockito annotations
    mockito_annotations = {
        "Mock", "Spy", "InjectMocks", "Captor", "MockedStatic"
    }
    
    # AssertJ annotations
    assertj_annotations = {
        "AssertJ"
    }
    
    # Other test annotations
    other_test_annotations = {
        "Ignore", "Category", "RunWith", "ExtendWith", "ContextConfiguration"
    }
    
    if annotation_name in junit_annotations:
        return "junit"
    elif annotation_name in spring_test_annotations:
        return "spring_test"
    elif annotation_name in testng_annotations:
        return "testng"
    elif annotation_name in mockito_annotations:
        return "mockito"
    elif annotation_name in assertj_annotations:
        return "assertj"
    elif annotation_name in other_test_annotations:
        return "other_test"
    else:
        return "other"


def extract_beans_from_classes(classes: list[Class]) -> list[Bean]:
    """Extract Spring Beans from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Bean objects
    """
    beans = []
    
    for cls in classes:
        # Check if class has Spring component annotations
        component_annotations = [ann for ann in cls.annotations if ann.category == "component"]
        
        # Also check for @Repository on interfaces
        has_repository_annotation = any(ann.name == "Repository" for ann in cls.annotations)
        
        if component_annotations or has_repository_annotation:
            # Determine bean type based on annotations
            bean_type = "component"  # default
            if any(ann.name in ["Service", "Service"] for ann in cls.annotations):
                bean_type = "service"
            elif any(ann.name in ["Repository", "Repository"] for ann in cls.annotations):
                bean_type = "repository"
            elif any(ann.name in ["Controller", "RestController"] for ann in cls.annotations):
                bean_type = "controller"
            elif any(ann.name in ["Configuration", "Configuration"] for ann in cls.annotations):
                bean_type = "configuration"
            
            # Determine scope (default is singleton)
            scope = "singleton"
            for ann in cls.annotations:
                if ann.name == "Scope":
                    if "value" in ann.parameters:
                        scope = ann.parameters["value"]
                    elif "prototype" in str(ann.parameters):
                        scope = "prototype"
                    elif "request" in str(ann.parameters):
                        scope = "request"
                    elif "session" in str(ann.parameters):
                        scope = "session"
            
            # Create bean name (use class name with first letter lowercase)
            bean_name = cls.name[0].lower() + cls.name[1:] if cls.name else cls.name
            
            # Check for @Bean methods in configuration classes
            bean_methods = []
            if bean_type == "configuration":
                for method in cls.methods:
                    if any(ann.name == "Bean" for ann in method.annotations):
                        bean_methods.append(method)
            
            bean = Bean(
                name=bean_name,
                type=bean_type,
                scope=scope,
                class_name=cls.name,
                package_name=cls.package_name,
                annotation_names=[ann.name for ann in cls.annotations] if cls.annotations else [],
                method_count=len(bean_methods) if bean_type == "configuration" else len(cls.methods) if cls.methods else 0,
                property_count=len(cls.properties) if cls.properties else 0
            )
            beans.append(bean)
    
    return beans


def analyze_bean_dependencies(classes: list[Class], beans: list[Bean]) -> list[BeanDependency]:
    """Analyze dependencies between Spring Beans.
    
    Args:
        classes: List of parsed Class objects
        beans: List of Bean objects
        
    Returns:
        List of BeanDependency objects
    """
    dependencies = []
    
    # Create a mapping from class names to bean names
    class_to_bean = {}
    for bean in beans:
        class_to_bean[bean.class_name] = bean.name
    
    for cls in classes:
        # Check if this class is a bean
        if cls.name not in class_to_bean:
            continue
            
        source_bean = class_to_bean[cls.name]
        
        # Analyze field injections (@Autowired, @Resource, @Value)
        for prop in cls.properties:
            if any(ann.category == "injection" for ann in prop.annotations):
                # Try to determine target bean from field type
                target_bean = None
                field_type = prop.type
                
                # Look for exact class name match
                if field_type in class_to_bean:
                    target_bean = class_to_bean[field_type]
                else:
                    # Look for interface implementations (simplified - just check if type matches any bean class name)
                    for bean in beans:
                        if field_type == bean.class_name:
                            target_bean = bean.name
                            break
                
                if target_bean:
                    injection_type = "field"
                    for ann in prop.annotations:
                        if ann.name == "Autowired":
                            injection_type = "field"
                        elif ann.name == "Resource":
                            injection_type = "field"
                        elif ann.name == "Value":
                            injection_type = "field"
                    
                    dependency = BeanDependency(
                        source_bean=source_bean,
                        target_bean=target_bean,
                        injection_type=injection_type,
                        field_name=prop.name
                    )
                    dependencies.append(dependency)
        
        # Analyze constructor injections
        for method in cls.methods:
            if method.name == cls.name:  # Constructor
                for param in method.parameters:
                    if any(ann.category == "injection" for ann in param.annotations):
                        target_bean = None
                        param_type = param.type
                        
                        if param_type in class_to_bean:
                            target_bean = class_to_bean[param_type]
                        else:
                            # Look for interface implementations (simplified)
                            for bean in beans:
                                if param_type == bean.class_name:
                                    target_bean = bean.name
                                    break
                        
                        if target_bean:
                            dependency = BeanDependency(
                                source_bean=source_bean,
                                target_bean=target_bean,
                                injection_type="constructor",
                                parameter_name=param.name
                            )
                            dependencies.append(dependency)
        
        # Analyze setter injections
        for method in cls.methods:
            if method.name.startswith("set") and len(method.parameters) == 1:
                if any(ann.category == "injection" for ann in method.annotations):
                    param = method.parameters[0]
                    target_bean = None
                    param_type = param.type
                    
                    if param_type in class_to_bean:
                        target_bean = class_to_bean[param_type]
                    else:
                        # Look for interface implementations (simplified)
                        for bean in beans:
                            if param_type == bean.class_name:
                                target_bean = bean.name
                                break
                    
                    if target_bean:
                        dependency = BeanDependency(
                            source_bean=source_bean,
                            target_bean=target_bean,
                            injection_type="setter",
                            method_name=method.name,
                            parameter_name=param.name
                        )
                        dependencies.append(dependency)
    
    return dependencies


def extract_endpoints_from_classes(classes: list[Class]) -> list[Endpoint]:
    """Extract REST API endpoints from controller classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Endpoint objects
    """
    endpoints = []
    
    for cls in classes:
        # Check if class is a controller
        is_controller = any(ann.name in ["Controller", "RestController"] for ann in cls.annotations)
        
        if not is_controller:
            continue
            
        # Get class-level path mapping
        class_path = ""
        for ann in cls.annotations:
            if ann.name == "RequestMapping":
                if "value" in ann.parameters:
                    class_path = ann.parameters["value"]
                break
        
        # Process each method in the controller
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
                
            # Check if method has web mapping annotations
            web_annotations = [ann for ann in method.annotations if ann.category == "web"]
            
            if not web_annotations:
                continue
            
            # Extract endpoint information
            endpoint_path = ""
            http_method = "GET"  # default
            
            for ann in web_annotations:
                if ann.name in ["RequestMapping", "GetMapping", "PostMapping", "PutMapping", "DeleteMapping", "PatchMapping"]:
                    # Extract path
                    if "value" in ann.parameters:
                        endpoint_path = ann.parameters["value"]
                    elif "path" in ann.parameters:
                        endpoint_path = ann.parameters["path"]
                    
                    # Extract HTTP method
                    if ann.name == "GetMapping":
                        http_method = "GET"
                    elif ann.name == "PostMapping":
                        http_method = "POST"
                    elif ann.name == "PutMapping":
                        http_method = "PUT"
                    elif ann.name == "DeleteMapping":
                        http_method = "DELETE"
                    elif ann.name == "PatchMapping":
                        http_method = "PATCH"
                    elif ann.name == "RequestMapping":
                        if "method" in ann.parameters:
                            method_value = ann.parameters["method"]
                            if isinstance(method_value, list) and len(method_value) > 0:
                                http_method = method_value[0]
                            else:
                                http_method = str(method_value)
                        else:
                            http_method = "GET"  # default for RequestMapping
                    break
            
            # Build full path
            full_path = class_path
            if endpoint_path:
                if full_path and not full_path.endswith("/") and not endpoint_path.startswith("/"):
                    full_path += "/"
                full_path += endpoint_path
            elif not full_path:
                full_path = "/"
            
            # Extract method parameters
            parameters = []
            for param in method.parameters:
                param_info = {
                    "name": param.name,
                    "type": param.type,
                    "annotations": [ann.name for ann in param.annotations if ann.category == "web"]
                }
                parameters.append(param_info)
            
            # Extract return type
            return_type = method.return_type if method.return_type != "constructor" else "void"
            
            # Create endpoint
            endpoint = Endpoint(
                path=endpoint_path or "/",
                method=http_method,
                controller_class=cls.name,
                handler_method=method.name,
                parameters=parameters,
                return_type=return_type,
                annotations=[ann.name for ann in web_annotations],
                full_path=full_path
            )
            endpoints.append(endpoint)
    
    return endpoints


def extract_mybatis_mappers_from_classes(classes: list[Class]) -> list[MyBatisMapper]:
    """Extract MyBatis Mappers from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for cls in classes:
        # Check if class is a MyBatis Mapper interface
        is_mapper = any(ann.name == "Mapper" for ann in cls.annotations)
        
        if not is_mapper:
            continue
        
        # Extract mapper methods with MyBatis annotations
        mapper_methods = []
        sql_statements = []
        
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
            
            # Check if method has MyBatis annotations
            mybatis_annotations = [ann for ann in method.annotations if ann.category == "mybatis"]
            
            if not mybatis_annotations:
                continue
            
            # Extract SQL statement information
            sql_type = "SELECT"  # default
            sql_content = ""
            parameter_type = ""
            result_type = ""
            result_map = ""
            
            for ann in mybatis_annotations:
                if ann.name in ["Select", "SelectProvider"]:
                    sql_type = "SELECT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Insert", "InsertProvider"]:
                    sql_type = "INSERT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Update", "UpdateProvider"]:
                    sql_type = "UPDATE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Delete", "DeleteProvider"]:
                    sql_type = "DELETE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                
                # Extract parameter and result type information
                if "parameterType" in ann.parameters:
                    parameter_type = ann.parameters["parameterType"]
                if "resultType" in ann.parameters:
                    result_type = ann.parameters["resultType"]
                if "resultMap" in ann.parameters:
                    result_map = ann.parameters["resultMap"]
            
            # Create method info
            method_info = {
                "name": method.name,
                "return_type": method.return_type,
                "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            mapper_methods.append(method_info)
            
            # Create SQL statement info
            sql_statement = {
                "id": method.name,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            sql_statements.append(sql_statement)
        
        # Create mapper
        mapper = MyBatisMapper(
            name=cls.name,
            type="interface",
            namespace=f"{cls.package_name}.{cls.name}",
            methods=mapper_methods,
            sql_statements=sql_statements,
            file_path=cls.file_path,
            package_name=cls.package_name
        )
        mappers.append(mapper)
    
    return mappers


def parse_mybatis_xml_file(file_path: str) -> MyBatisMapper:
    """Parse MyBatis XML mapper file.
    
    Args:
        file_path: Path to the XML mapper file
        
    Returns:
        MyBatisMapper object
    """
    import xml.etree.ElementTree as ET
    
    try:
        tree = ET.parse(file_path)
        root = tree.getroot()
        
        # Extract namespace
        namespace = root.get("namespace", "")
        
        # Extract SQL statements
        sql_statements = []
        for statement in root.findall(".//*[@id]"):
            statement_id = statement.get("id")
            tag_name = statement.tag.lower()
            
            # Determine SQL type
            sql_type = "SELECT"
            if tag_name == "insert":
                sql_type = "INSERT"
            elif tag_name == "update":
                sql_type = "UPDATE"
            elif tag_name == "delete":
                sql_type = "DELETE"
            
            # Extract SQL content
            sql_content = statement.text.strip() if statement.text else ""
            
            # Extract parameter and result information
            parameter_type = statement.get("parameterType", "")
            result_type = statement.get("resultType", "")
            result_map = statement.get("resultMap", "")
            
            sql_statement = {
                "id": statement_id,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": []
            }
            sql_statements.append(sql_statement)
        
        # Extract ResultMaps
        result_maps = []
        for result_map in root.findall(".//resultMap"):
            result_map_id = result_map.get("id")
            result_map_type = result_map.get("type", "")
            
            properties = []
            for property_elem in result_map.findall(".//result"):
                prop = {
                    "property": property_elem.get("property", ""),
                    "column": property_elem.get("column", ""),
                    "jdbc_type": property_elem.get("jdbcType", "")
                }
                properties.append(prop)
            
            result_map_info = {
                "id": result_map_id,
                "type": result_map_type,
                "properties": properties,
                "associations": [],
                "collections": []
            }
            result_maps.append(result_map_info)
        
        # Create mapper
        mapper_name = namespace.split(".")[-1] if namespace else os.path.basename(file_path).replace(".xml", "")
        package_name = ".".join(namespace.split(".")[:-1]) if namespace else ""
        
        mapper = MyBatisMapper(
            name=mapper_name,
            type="xml",
            namespace=namespace,
            methods=[],  # XML mappers don't have Java methods
            sql_statements=sql_statements,
            file_path=file_path,
            package_name=package_name
        )
        
        return mapper
        
    except ET.ParseError as e:
        print(f"Error parsing XML file {file_path}: {e}")
        return None
    except Exception as e:
        print(f"Error reading XML file {file_path}: {e}")
        return None


def extract_mybatis_xml_mappers(directory: str) -> list[MyBatisMapper]:
    """Extract MyBatis XML mappers from directory.
    
    Args:
        directory: Directory to search for XML mapper files
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith("Mapper.xml") or file.endswith("Dao.xml"):
                file_path = os.path.join(root, file)
                mapper = parse_mybatis_xml_file(file_path)
                if mapper:
                    mappers.append(mapper)
    
    return mappers


def extract_jpa_entities_from_classes(classes: list[Class]) -> list[JpaEntity]:
    """Extract JPA Entities from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of JpaEntity objects
    """
    entities = []
    
    for cls in classes:
        # Check if class is a JPA Entity
        is_entity = any(ann.name == "Entity" for ann in cls.annotations)
        
        if not is_entity:
            continue
        
        # Extract table name
        table_name = cls.name.lower()  # default table name
        for ann in cls.annotations:
            if ann.name == "Table":
                if "name" in ann.parameters:
                    table_name = ann.parameters["name"]
                break
        
        # Extract columns from properties
        columns = []
        relationships = []
        
        for prop in cls.properties:
            # Check if property has JPA column annotations
            jpa_annotations = [ann for ann in prop.annotations if ann.category == "jpa"]
            
            if jpa_annotations:
                # Extract column information
                column_name = prop.name  # default column name
                nullable = True
                unique = False
                length = 0
                precision = 0
                scale = 0
                
                for ann in jpa_annotations:
                    if ann.name == "Column":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                        if "nullable" in ann.parameters:
                            nullable = ann.parameters["nullable"]
                        if "unique" in ann.parameters:
                            unique = ann.parameters["unique"]
                        if "length" in ann.parameters:
                            length = ann.parameters["length"]
                        if "precision" in ann.parameters:
                            precision = ann.parameters["precision"]
                        if "scale" in ann.parameters:
                            scale = ann.parameters["scale"]
                    elif ann.name == "Id":
                        column_name = "id"  # Primary key column
                        nullable = False
                        unique = True
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                
                # Check for relationship annotations
                relationship_type = None
                target_entity = ""
                mapped_by = ""
                join_column = ""
                join_table = ""
                cascade = []
                fetch = "LAZY"
                
                for ann in jpa_annotations:
                    if ann.name in ["OneToOne", "OneToMany", "ManyToOne", "ManyToMany"]:
                        relationship_type = ann.name
                        if "targetEntity" in ann.parameters:
                            target_entity = ann.parameters["targetEntity"]
                        if "mappedBy" in ann.parameters:
                            mapped_by = ann.parameters["mappedBy"]
                        if "cascade" in ann.parameters:
                            cascade = ann.parameters["cascade"] if isinstance(ann.parameters["cascade"], list) else [ann.parameters["cascade"]]
                        if "fetch" in ann.parameters:
                            fetch = ann.parameters["fetch"]
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            join_column = ann.parameters["name"]
                    elif ann.name == "JoinTable":
                        if "name" in ann.parameters:
                            join_table = ann.parameters["name"]
                
                # Create column info
                column_info = {
                    "property_name": prop.name,
                    "column_name": column_name,
                    "data_type": prop.type,
                    "nullable": nullable,
                    "unique": unique,
                    "length": length,
                    "precision": precision,
                    "scale": scale,
                    "annotations": [ann.name for ann in jpa_annotations]
                }
                columns.append(column_info)
                
                # Create relationship info if it's a relationship
                if relationship_type:
                    relationship_info = {
                        "type": relationship_type,
                        "target_entity": target_entity,
                        "mapped_by": mapped_by,
                        "join_column": join_column,
                        "join_table": join_table,
                        "cascade": cascade,
                        "fetch": fetch,
                        "annotations": [ann.name for ann in jpa_annotations]
                    }
                    relationships.append(relationship_info)
        
        # Create entity
        entity = JpaEntity(
            name=cls.name,
            table_name=table_name,
            columns=columns,
            relationships=relationships,
            annotations=[ann.name for ann in cls.annotations if ann.category == "jpa"],
            package_name=cls.package_name,
            file_path=cls.file_path
        )
        entities.append(entity)
    
    return entities


def parse_yaml_config(file_path: str) -> ConfigFile:
    """Parse YAML configuration file.
    
    Args:
        file_path: Path to the YAML file
        
    Returns:
        ConfigFile object
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = yaml.safe_load(f)
        
        if not content:
            content = {}
        
        # Extract file info
        file_name = os.path.basename(file_path)
        file_type = "yaml" if file_path.endswith('.yaml') else "yml"
        
        # Extract profiles
        profiles = []
        if 'spring' in content and 'profiles' in content['spring']:
            if 'active' in content['spring']['profiles']:
                profiles = content['spring']['profiles']['active']
                if isinstance(profiles, str):
                    profiles = [profiles]
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        # Extract sections
        sections = []
        for key, value in content.items():
            if isinstance(value, dict):
                sections.append({
                    "name": key,
                    "properties": value,
                    "type": "section"
                })
        
        return ConfigFile(
            name=file_name,
            file_path=file_path,
            file_type=file_type,
            properties=content,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing YAML file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="yaml",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def parse_properties_config(file_path: str) -> ConfigFile:
    """Parse Properties configuration file.
    
    Args:
        file_path: Path to the properties file
        
    Returns:
        ConfigFile object
    """
    try:
        properties = {}
        sections = []
        profiles = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                
                # Skip empty lines and comments
                if not line or line.startswith('#'):
                    continue
                
                # Parse key=value pairs
                if '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    
                    # Remove quotes if present
                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]
                    elif value.startswith("'") and value.endswith("'"):
                        value = value[1:-1]
                    
                    properties[key] = value
                    
                    # Check for profiles
                    if key == 'spring.profiles.active':
                        profiles = [p.strip() for p in value.split(',')]
        
        # Group properties by section
        section_map = {}
        for key, value in properties.items():
            if '.' in key:
                section = key.split('.')[0]
                if section not in section_map:
                    section_map[section] = {}
                section_map[section][key] = value
            else:
                if 'root' not in section_map:
                    section_map['root'] = {}
                section_map['root'][key] = value
        
        for section_name, section_props in section_map.items():
            sections.append({
                "name": section_name,
                "properties": section_props,
                "type": "section"
            })
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties=properties,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing Properties file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def extract_database_config(config_file: ConfigFile) -> DatabaseConfig:
    """Extract database configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        DatabaseConfig object
    """
    db_config = DatabaseConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        spring_config = config_file.properties.get('spring', {})
        datasource_config = spring_config.get('datasource', {})
        jpa_config = spring_config.get('jpa', {})
        
        db_config.driver = datasource_config.get('driver-class-name', '')
        db_config.url = datasource_config.get('url', '')
        db_config.username = datasource_config.get('username', '')
        db_config.password = datasource_config.get('password', '')
        db_config.dialect = jpa_config.get('database-platform', '')
        db_config.hibernate_ddl_auto = jpa_config.get('hibernate', {}).get('ddl-auto', '')
        db_config.show_sql = jpa_config.get('show-sql', False)
        db_config.format_sql = jpa_config.get('properties', {}).get('hibernate', {}).get('format_sql', False)
        
        # Store additional JPA properties
        if 'properties' in jpa_config:
            db_config.jpa_properties = jpa_config['properties']
    
    else:
        # Properties format
        props = config_file.properties
        
        db_config.driver = props.get('spring.datasource.driver-class-name', '')
        db_config.url = props.get('spring.datasource.url', '')
        db_config.username = props.get('spring.datasource.username', '')
        db_config.password = props.get('spring.datasource.password', '')
        db_config.dialect = props.get('spring.jpa.database-platform', '')
        db_config.hibernate_ddl_auto = props.get('spring.jpa.hibernate.ddl-auto', '')
        db_config.show_sql = props.get('spring.jpa.show-sql', 'false').lower() == 'true'
        db_config.format_sql = props.get('spring.jpa.properties.hibernate.format_sql', 'false').lower() == 'true'
        
        # Store additional JPA properties
        jpa_props = {}
        for key, value in props.items():
            if key.startswith('spring.jpa.properties.'):
                jpa_props[key] = value
        db_config.jpa_properties = jpa_props
    
    return db_config


def extract_server_config(config_file: ConfigFile) -> ServerConfig:
    """Extract server configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        ServerConfig object
    """
    server_config = ServerConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        server_props = config_file.properties.get('server', {})
        
        server_config.port = server_props.get('port', 8080)
        server_config.context_path = server_props.get('servlet', {}).get('context-path', '')
        server_config.servlet_path = server_props.get('servlet', {}).get('path', '')
        
        # SSL configuration
        ssl_config = server_props.get('ssl', {})
        server_config.ssl_enabled = bool(ssl_config)
        server_config.ssl_key_store = ssl_config.get('key-store', '')
        server_config.ssl_key_store_password = ssl_config.get('key-store-password', '')
        server_config.ssl_key_store_type = ssl_config.get('key-store-type', '')
    
    else:
        # Properties format
        props = config_file.properties
        
        server_config.port = int(props.get('server.port', '8080'))
        server_config.context_path = props.get('server.servlet.context-path', '')
        server_config.servlet_path = props.get('server.servlet.path', '')
        
        # SSL configuration
        server_config.ssl_enabled = any(key.startswith('server.ssl.') for key in props.keys())
        server_config.ssl_key_store = props.get('server.ssl.key-store', '')
        server_config.ssl_key_store_password = props.get('server.ssl.key-store-password', '')
        server_config.ssl_key_store_type = props.get('server.ssl.key-store-type', '')
    
    return server_config


def extract_security_config(config_file: ConfigFile) -> SecurityConfig:
    """Extract security configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        SecurityConfig object
    """
    security_config = SecurityConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        security_props = config_file.properties.get('security', {})
        jwt_props = security_props.get('jwt', {})
        cors_props = security_props.get('cors', {})
        
        security_config.enabled = bool(security_props)
        security_config.authentication_type = security_props.get('authentication-type', '')
        security_config.jwt_secret = jwt_props.get('secret', '')
        security_config.jwt_expiration = jwt_props.get('expiration', 0)
        security_config.cors_allowed_origins = cors_props.get('allowed-origins', [])
        security_config.cors_allowed_methods = cors_props.get('allowed-methods', [])
        security_config.cors_allowed_headers = cors_props.get('allowed-headers', [])
    
    else:
        # Properties format
        props = config_file.properties
        
        security_config.enabled = any(key.startswith('security.') for key in props.keys())
        security_config.authentication_type = props.get('security.authentication-type', '')
        security_config.jwt_secret = props.get('security.jwt.secret', '')
        security_config.jwt_expiration = int(props.get('security.jwt.expiration', '0'))
        
        # CORS configuration
        origins = props.get('security.cors.allowed-origins', '')
        if origins:
            security_config.cors_allowed_origins = [o.strip() for o in origins.split(',')]
        
        methods = props.get('security.cors.allowed-methods', '')
        if methods:
            security_config.cors_allowed_methods = [m.strip() for m in methods.split(',')]
        
        headers = props.get('security.cors.allowed-headers', '')
        if headers:
            security_config.cors_allowed_headers = [h.strip() for h in headers.split(',')]
    
    return security_config


def extract_logging_config(config_file: ConfigFile) -> LoggingConfig:
    """Extract logging configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        LoggingConfig object
    """
    logging_config = LoggingConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        logging_props = config_file.properties.get('logging', {})
        
        logging_config.level = logging_props.get('level', {}).get('root', 'INFO')
        logging_config.pattern = logging_props.get('pattern', {}).get('console', '')
        logging_config.file_path = logging_props.get('file', {}).get('name', '')
        logging_config.max_file_size = logging_props.get('file', {}).get('max-size', '')
        logging_config.max_history = logging_props.get('file', {}).get('max-history', 0)
        logging_config.console_output = logging_props.get('console', {}).get('enabled', True)
    
    else:
        # Properties format
        props = config_file.properties
        
        logging_config.level = props.get('logging.level.root', 'INFO')
        logging_config.pattern = props.get('logging.pattern.console', '')
        logging_config.file_path = props.get('logging.file.name', '')
        logging_config.max_file_size = props.get('logging.file.max-size', '')
        logging_config.max_history = int(props.get('logging.file.max-history', '0'))
        logging_config.console_output = props.get('logging.console.enabled', 'true').lower() == 'true'
    
    return logging_config


def extract_config_files(directory: str) -> list[ConfigFile]:
    """Extract configuration files from directory.
    
    Args:
        directory: Directory to search for config files
        
    Returns:
        List of ConfigFile objects
    """
    config_files = []
    
    # Common config file patterns
    config_patterns = [
        "application.yml",
        "application.yaml", 
        "application.properties",
        "application-*.properties",
        "bootstrap.yml",
        "bootstrap.yaml",
        "bootstrap.properties"
    ]
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            # Check if file matches any config pattern
            is_config_file = False
            for pattern in config_patterns:
                if pattern == file or (pattern.endswith('*') and file.startswith(pattern[:-1])):
                    is_config_file = True
                    break
            
            if is_config_file:
                file_path = os.path.join(root, file)
                
                if file.endswith(('.yml', '.yaml')):
                    config_file = parse_yaml_config(file_path)
                elif file.endswith('.properties'):
                    config_file = parse_properties_config(file_path)
                else:
                    continue
                
                config_files.append(config_file)
    
    return config_files


def extract_test_classes_from_classes(classes: list[Class]) -> list[TestClass]:
    """Extract test classes from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of TestClass objects
    """
    test_classes = []
    
    for cls in classes:
        # Check if class is a test class
        test_annotations = [ann for ann in cls.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
        
        if not test_annotations:
            continue
        
        # Determine test framework and type
        test_framework = "junit"  # default
        test_type = "unit"  # default
        
        for ann in test_annotations:
            if ann.name in ["SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest", "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest"]:
                test_framework = "spring_test"
                if ann.name == "SpringBootTest":
                    test_type = "integration"
                else:
                    test_type = "slice"
            elif ann.name in ["TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass"]:
                test_framework = "testng"
            elif ann.name in ["Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll"]:
                test_framework = "junit"
        
        # Extract test methods
        test_methods = []
        setup_methods = []
        
        for method in cls.methods:
            method_annotations = [ann.name for ann in method.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
            
            if method_annotations:
                # Check if it's a setup/teardown method
                if any(ann in method_annotations for ann in ["BeforeEach", "AfterEach", "BeforeAll", "AfterAll", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass", "BeforeSuite", "AfterSuite"]):
                    setup_methods.append({
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters]
                    })
                else:
                    # Regular test method
                    test_method_info = {
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                        "assertions": [],
                        "mock_calls": [],
                        "test_data": [],
                        "expected_exceptions": [],
                        "timeout": 0,
                        "display_name": ""
                    }
                    
                    # Extract display name
                    for ann in method.annotations:
                        if ann.name == "DisplayName" and "value" in ann.parameters:
                            test_method_info["display_name"] = ann.parameters["value"]
                        elif ann.name == "Timeout" and "value" in ann.parameters:
                            test_method_info["timeout"] = ann.parameters["value"]
                    
                    # Extract expected exceptions
                    for ann in method.annotations:
                        if ann.name == "ExpectedExceptions" and "value" in ann.parameters:
                            test_method_info["expected_exceptions"] = ann.parameters["value"] if isinstance(ann.parameters["value"], list) else [ann.parameters["value"]]
                    
                    test_methods.append(test_method_info)
        
        # Extract mock dependencies
        mock_dependencies = []
        for prop in cls.properties:
            prop_annotations = [ann.name for ann in prop.annotations if classify_test_annotation(ann.name) in ["mockito", "spring_test"]]
            if prop_annotations:
                mock_dependencies.append({
                    "name": prop.name,
                    "type": prop.type,
                    "annotations": prop_annotations,
                    "mock_type": "mock" if "Mock" in prop_annotations else "spy" if "Spy" in prop_annotations else "bean"
                })
        
        # Extract test configurations
        test_configurations = []
        for ann in cls.annotations:
            if ann.name in ["TestConfiguration", "ActiveProfiles", "TestPropertySource"]:
                config_info = {
                    "name": ann.name,
                    "type": "configuration" if ann.name == "TestConfiguration" else "profile" if ann.name == "ActiveProfiles" else "property",
                    "properties": ann.parameters,
                    "active_profiles": ann.parameters.get("value", []) if ann.name == "ActiveProfiles" else [],
                    "test_slices": [],
                    "mock_beans": [],
                    "spy_beans": []
                }
                test_configurations.append(config_info)
        
        # Create test class
        test_class = TestClass(
            name=cls.name,
            package_name=cls.package_name,
            test_framework=test_framework,
            test_type=test_type,
            annotations=[ann.name for ann in test_annotations],
            test_methods=test_methods,
            setup_methods=setup_methods,
            mock_dependencies=mock_dependencies,
            test_configurations=test_configurations,
            file_path=cls.file_path
        )
        test_classes.append(test_class)
    
    return test_classes


def analyze_test_methods(test_class: TestClass, class_obj: Class) -> list[TestMethod]:
    """Analyze test methods for assertions, mock calls, and test data.
    
    Args:
        test_class: TestClass object
        class_obj: Original Class object
        
    Returns:
        List of analyzed TestMethod objects
    """
    test_methods = []
    
    for method_info in test_class.test_methods:
        # Find the corresponding method in the class
        method_obj = None
        for method in class_obj.methods:
            if method.name == method_info["name"]:
                method_obj = method
                break
        
        if not method_obj:
            continue
        
        # Analyze method source code for assertions and mock calls
        assertions = []
        mock_calls = []
        test_data = []
        
        if method_obj.source:
            source_code = method_obj.source
            
            # Find assertions (JUnit, AssertJ, etc.)
            assertion_patterns = [
                r'assert\w+\(',  # JUnit assertions
                r'assertThat\(',  # AssertJ
                r'assertEquals\(',  # JUnit
                r'assertTrue\(',  # JUnit
                r'assertFalse\(',  # JUnit
                r'assertNotNull\(',  # JUnit
                r'assertNull\(',  # JUnit
                r'assertThrows\(',  # JUnit 5
                r'assertDoesNotThrow\(',  # JUnit 5
                r'verify\(',  # Mockito verify
                r'when\(',  # Mockito when
                r'then\(',  # Mockito then
                r'given\(',  # BDDMockito given
                r'willReturn\(',  # Mockito willReturn
                r'willThrow\(',  # Mockito willThrow
            ]
            
            for pattern in assertion_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    assertions.append({
                        "type": match,
                        "line": source_code.find(match) + 1
                    })
            
            # Find mock calls
            mock_call_patterns = [
                r'(\w+)\.(\w+)\(',  # Method calls on objects
                r'mock\(',  # Mockito mock creation
                r'spy\(',  # Mockito spy creation
                r'@Mock\s+(\w+)',  # @Mock annotation
                r'@Spy\s+(\w+)',  # @Spy annotation
                r'@InjectMocks\s+(\w+)',  # @InjectMocks annotation
            ]
            
            for pattern in mock_call_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        mock_calls.append({
                            "object": match[0],
                            "method": match[1],
                            "type": "method_call"
                        })
                    else:
                        mock_calls.append({
                            "type": match,
                            "line": source_code.find(match) + 1
                        })
            
            # Find test data setup
            test_data_patterns = [
                r'new\s+(\w+)\(',  # Object creation
                r'(\w+)\s*=\s*new\s+(\w+)\(',  # Variable assignment with new
                r'@ValueSource\(',  # JUnit 5 @ValueSource
                r'@CsvSource\(',  # JUnit 5 @CsvSource
                r'@MethodSource\(',  # JUnit 5 @MethodSource
            ]
            
            for pattern in test_data_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        test_data.append({
                            "variable": match[0],
                            "type": match[1],
                            "pattern": "object_creation"
                        })
                    else:
                        test_data.append({
                            "type": match,
                            "pattern": "annotation"
                        })
        
        # Create TestMethod object
        test_method = TestMethod(
            name=method_info["name"],
            return_type=method_info["return_type"],
            annotations=method_info["annotations"],
            assertions=assertions,
            mock_calls=mock_calls,
            test_data=test_data,
            expected_exceptions=method_info["expected_exceptions"],
            timeout=method_info["timeout"],
            display_name=method_info["display_name"]
        )
        test_methods.append(test_method)
    
    return test_methods


def generate_lombok_methods(properties: list[Field], class_name: str, package_name: str) -> list[Method]:
    """Generate Lombok @Data methods (getters, setters, equals, hashCode, toString) for properties."""
    methods = []
    
    # Generate getters and setters for each property
    for prop in properties:
        # Getter
        getter_name = f"get{prop.name[0].upper()}{prop.name[1:]}"
        if prop.type == "Boolean" and prop.name.startswith("is"):
            # For boolean fields starting with 'is', use the field name as getter
            getter_name = prop.name
        
        getter = Method(
            name=getter_name,
            logical_name=f"{package_name}.{class_name}.{getter_name}",
            return_type=prop.type,
            parameters=[],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[],
            description=f"Generated getter for {prop.name} field"  # Generated method description
        )
        methods.append(getter)
        
        # Setter
        setter_name = f"set{prop.name[0].upper()}{prop.name[1:]}"
        setter_param = Field(
            name=prop.name,
            logical_name=f"{package_name}.{class_name}.{prop.name}",
            type=prop.type,
            package_name=package_name,
            class_name=class_name
        )
        
        setter = Method(
            name=setter_name,
            logical_name=f"{package_name}.{class_name}.{setter_name}",
            return_type="void",
            parameters=[setter_param],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[]
        )
        methods.append(setter)
    
    # Generate equals method
    equals_method = Method(
        name="equals",
        logical_name=f"{package_name}.{class_name}.equals",
        return_type="boolean",
        parameters=[Field(name="obj", logical_name=f"{package_name}.{class_name}.obj", type="Object", package_name=package_name, class_name=class_name)],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(equals_method)
    
    # Generate hashCode method
    hashcode_method = Method(
        name="hashCode",
        logical_name=f"{package_name}.{class_name}.hashCode",
        return_type="int",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(hashcode_method)
    
    # Generate toString method
    tostring_method = Method(
        name="toString",
        logical_name=f"{package_name}.{class_name}.toString",
        return_type="String",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(tostring_method)
    
    return methods


def parse_java_project(directory: str) -> tuple[list[Package], list[Class], dict[str, str], list[Bean], list[BeanDependency], list[Endpoint], list[MyBatisMapper], list[JpaEntity], list[ConfigFile], list[TestClass], list[SqlStatement], str]:
    """Parse Java project and return parsed entities."""
    logger = get_logger(__name__)
    """Parses all Java files in a directory and returns a tuple of (packages, classes, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name)."""
    
    # Extract project name from directory path
    project_name = extract_project_name(directory)
    packages = {}
    classes = {}
    class_to_package_map = {}  # Maps class_key to package_name

    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith(".java"):
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    file_content = f.read() # Read file content once
                try:
                    tree = javalang.parse.parse(file_content)
                    package_name = tree.package.name if tree.package else ""
                    
                    # Create or update package node
                    if package_name and package_name not in packages:
                        packages[package_name] = Package(
                            name=package_name
                        )
                    elif not package_name:
                        # Handle classes without package (default package)
                        package_name = "default"
                        if package_name not in packages:
                            packages[package_name] = Package(
                                name=package_name
                            )
                    
                    import_map = {}
                    for imp in tree.imports:
                        class_name = imp.path.split('.')[-1]
                        import_map[class_name] = imp.path

                    for _, class_declaration in tree.filter(
                        javalang.tree.ClassDeclaration
                    ):
                        class_name = class_declaration.name
                        class_key = f"{package_name}.{class_name}"
                        
                        # Debug: Check if this is the User class
                        if "User" in class_name:
                            logger.debug(f"Found User class - {class_key}")
                            logger.debug(f"Methods count: {len(class_declaration.methods)}")
                            logger.debug(f"Constructors count: {len(class_declaration.constructors)}")
                        
                        # Extract class source code - use the entire file content
                        class_source = file_content


                        if class_key not in classes:
                            # Parse class annotations
                            class_annotations = parse_annotations(class_declaration.annotations, "class") if hasattr(class_declaration, 'annotations') else []
                            
                            classes[class_key] = Class(
                                name=class_name,
                                logical_name=class_key,  # Add logical_name
                                file_path=file_path,
                                type="class", # Simplified for now
                                source=class_source, # Add class source
                                annotations=class_annotations,
                                package_name=package_name
                            )
                            class_to_package_map[class_key] = package_name
                        
                        # --- Start of new import logic ---
                        for imp in tree.imports:
                            classes[class_key].imports.append(imp.path)
                        # --- End of new import logic ---

                        # --- Start of new inheritance logic ---
                        # Handle 'extends'
                        if class_declaration.extends:
                            superclass_name = class_declaration.extends.name
                            # Try to resolve fully qualified name for superclass
                            if superclass_name in import_map:
                                classes[class_key].superclass = import_map[superclass_name]
                            else:
                                # Assume same package or fully qualified if not in import_map
                                classes[class_key].superclass = f"{package_name}.{superclass_name}" if package_name else superclass_name

                        # Handle 'implements'
                        if class_declaration.implements: # Add this check
                            for impl_ref in class_declaration.implements:
                                interface_name = impl_ref.name
                                # Try to resolve fully qualified name for interface
                                if interface_name in import_map:
                                    classes[class_key].interfaces.append(import_map[interface_name])
                                else:
                                    # Assume same package or fully qualified if not in import_map
                                    classes[class_key].interfaces.append(f"{package_name}.{interface_name}" if package_name else interface_name)
                        # --- End of new inheritance logic ---

                        field_map = {}
                        for field_declaration in class_declaration.fields:
                            for declarator in field_declaration.declarators:
                                field_map[declarator.name] = field_declaration.type.name
                                
                                # Parse field annotations
                                field_annotations = parse_annotations(field_declaration.annotations, "field") if hasattr(field_declaration, 'annotations') else []
                                
                                # Extract initial value if present
                                initial_value = ""
                                if hasattr(declarator, 'initializer') and declarator.initializer:
                                    # Convert the initializer to string representation
                                    if hasattr(declarator.initializer, 'value'):
                                        initial_value = str(declarator.initializer.value)
                                    elif hasattr(declarator.initializer, 'type'):
                                        initial_value = str(declarator.initializer.type)
                                    else:
                                        initial_value = str(declarator.initializer)
                                
                                prop = Field(
                                    name=declarator.name,
                                    logical_name=f"{package_name}.{class_name}.{declarator.name}",
                                    type=field_declaration.type.name,
                                    modifiers=list(field_declaration.modifiers), # Add modifiers
                                    package_name=package_name,
                                    class_name=class_name,
                                    annotations=field_annotations,
                                    initial_value=initial_value,
                                    description=""  # TODO: Extract description from comments or annotations
                                )
                                classes[class_key].properties.append(prop)

                        all_declarations = class_declaration.methods + class_declaration.constructors
                        
                        # Debug: Check User class method processing
                        if "User" in class_name:
                            logger.debug(f"Processing User class methods - total declarations: {len(all_declarations)}")
                            for i, decl in enumerate(all_declarations):
                                logger.debug(f"Declaration {i}: {type(decl).__name__} - {decl.name}")
                        
                        for declaration in all_declarations:
                            local_var_map = field_map.copy()
                            params = []
                            for param in declaration.parameters:
                                param_type_name = 'Unknown'
                                if hasattr(param.type, 'name'):
                                    param_type_name = param.type.name
                                local_var_map[param.name] = param_type_name
                                params.append(Field(name=param.name, logical_name=f"{package_name}.{class_name}.{param.name}", type=param_type_name, package_name=package_name, class_name=class_name))

                            if declaration.body:
                                for _, var_decl in declaration.filter(javalang.tree.LocalVariableDeclaration):
                                    for declarator in var_decl.declarators:
                                        local_var_map[declarator.name] = var_decl.type.name
                            
                            if isinstance(declaration, javalang.tree.MethodDeclaration):
                                return_type = declaration.return_type.name if declaration.return_type else "void"
                            else: # ConstructorDeclaration
                                return_type = "constructor"

                            # Extract modifiers
                            modifiers = list(declaration.modifiers)
                            
                            # Parse method annotations
                            method_annotations = parse_annotations(declaration.annotations, "method") if hasattr(declaration, 'annotations') else []

                            # Extract method source code
                            method_source = ""
                            if declaration.position:
                                lines = file_content.splitlines(keepends=True) # Keep line endings
                                start_line = declaration.position.line - 1
                                
                                # Find the end of the method by matching braces
                                brace_count = 0
                                end_line = start_line
                                for i in range(start_line, len(lines)):
                                    line = lines[i]
                                    for char in line:
                                        if char == '{':
                                            brace_count += 1
                                        elif char == '}':
                                            brace_count -= 1
                                            if brace_count == 0:
                                                end_line = i
                                                break
                                    if brace_count == 0:
                                        break
                                
                                method_source = "".join(lines[start_line:end_line + 1])

                            method = Method(
                                name=declaration.name,
                                logical_name=f"{class_key}.{declaration.name}",  # Add logical_name
                                return_type=return_type,
                                parameters=params,
                                modifiers=modifiers,
                                source=method_source, # Add method source
                                package_name=package_name,
                                annotations=method_annotations
                            )
                            classes[class_key].methods.append(method)

                            # Extract method calls with order information
                            call_order = 0
                            for _, invocation in declaration.filter(javalang.tree.MethodInvocation):
                                target_class_name = None
                                resolved_target_package = ""
                                resolved_target_class_name = ""
                                
                                if invocation.qualifier:
                                    # External method call
                                    if invocation.qualifier in local_var_map:
                                        target_class_name = local_var_map[invocation.qualifier]
                                    else:
                                        target_class_name = invocation.qualifier
                                    
                                    if target_class_name:
                                        if target_class_name == "System.out":
                                            resolved_target_package = "java.io"
                                            resolved_target_class_name = "PrintStream"
                                        else:
                                            if target_class_name in import_map:
                                                resolved_target_package = ".".join(import_map[target_class_name].split(".")[:-1])
                                            else:
                                                resolved_target_package = package_name
                                                resolved_target_class_name = target_class_name
                                else:
                                    # Same class method call
                                    resolved_target_package = package_name
                                    resolved_target_class_name = class_name

                                if resolved_target_class_name:
                                    # Get line number from invocation position
                                    line_number = invocation.position.line if invocation.position else 0

                                    call = MethodCall(
                                        source_package=package_name,
                                        source_class=class_name,
                                        source_method=declaration.name,
                                        target_package=resolved_target_package,
                                        target_class=resolved_target_class_name,
                                        target_method=invocation.member,
                                        call_order=call_order,
                                        line_number=line_number,
                                        return_type="void"  # Default return type, can be enhanced later
                                    )
                                    classes[class_key].calls.append(call)
                                    call_order += 1
                        
                        # Check for Lombok @Data annotation and generate methods
                        has_data_annotation = any(ann.name == "Data" for ann in classes[class_key].annotations)
                        if has_data_annotation:
                            logger.debug(f"Found @Data annotation on {class_name}, generating Lombok methods")
                            lombok_methods = generate_lombok_methods(classes[class_key].properties, class_name, package_name)
                            classes[class_key].methods.extend(lombok_methods)
                            logger.debug(f"Generated {len(lombok_methods)} Lombok methods for {class_name}")
                except javalang.parser.JavaSyntaxError as e:
                    print(f"Syntax error in {file_path}: {e}")
                    continue
                except Exception as e:
                    print(f"Error parsing {file_path}: {e}")
                    continue
    
    # Extract beans, analyze dependencies, extract endpoints, extract MyBatis mappers, extract JPA entities, extract config files, and extract test classes
    classes_list = list(classes.values())
    beans = extract_beans_from_classes(classes_list)
    dependencies = analyze_bean_dependencies(classes_list, beans)
    endpoints = extract_endpoints_from_classes(classes_list)
    mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
    jpa_entities = extract_jpa_entities_from_classes(classes_list)
    config_files = extract_config_files(directory)
    test_classes = extract_test_classes_from_classes(classes_list)
    
    # Also extract XML mappers
    xml_mappers = extract_mybatis_xml_mappers(directory)
    mybatis_mappers.extend(xml_mappers)
    
    # Extract SQL statements from MyBatis mappers
    sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
    
    return list(packages.values()), classes_list, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name
```

```python
import os
import yaml
import re
from pathlib import Path

import javalang

from src.models.graph_entities import Class, Method, MethodCall, Field, Package, Annotation, Bean, BeanDependency, Endpoint, MyBatisMapper, MyBatisSqlStatement, MyBatisResultMap, SqlStatement, JpaEntity, JpaColumn, JpaRelationship, ConfigFile, DatabaseConfig, ServerConfig, SecurityConfig, LoggingConfig, TestClass, TestMethod, TestConfiguration
from src.utils.logger import get_logger
from typing import Optional, List, Literal


def extract_project_name(java_source_folder: str) -> str:
    """
    JAVA_SOURCE_FOLDER 경로에서 프로젝트 이름을 추출합니다.
    
    Args:
        java_source_folder: Java 소스 폴더 경로
        
    Returns:
        프로젝트 이름 (마지막 디렉토리명)
    """
    # 경로를 정규화하고 마지막 디렉토리명 추출
    path = Path(java_source_folder).resolve()
    return path.name


def extract_sql_statements_from_mappers(mybatis_mappers: list[MyBatisMapper], project_name: str) -> list[SqlStatement]:
    """
    MyBatis mappers에서 SQL statements를 추출합니다.
    
    Args:
        mybatis_mappers: MyBatis mapper 객체들의 리스트
        project_name: 프로젝트 이름
        
    Returns:
        SqlStatement 객체들의 리스트
    """
    sql_statements = []
    
    for mapper in mybatis_mappers:
        for sql_dict in mapper.sql_statements:
            # MyBatisSqlStatement를 SqlStatement로 변환
            sql_statement = SqlStatement(
                id=sql_dict.get('id', ''),
                sql_type=sql_dict.get('sql_type', ''),
                sql_content=sql_dict.get('sql_content', ''),
                parameter_type=sql_dict.get('parameter_type', ''),
                result_type=sql_dict.get('result_type', ''),
                result_map=sql_dict.get('result_map', ''),
                mapper_name=mapper.name,
                annotations=[],  # TODO: annotations를 파싱하여 추가
                project_name=project_name
            )
            sql_statements.append(sql_statement)
    
    return sql_statements


def parse_annotations(annotations, target_type: str = "class") -> list[Annotation]:
    """Parse Java annotations into Annotation objects.
    
    Args:
        annotations: List of annotation nodes from javalang
        target_type: Type of target ("class", "method", "field")
    """
    result = []
    for annotation in annotations:
        annotation_name = annotation.name
        parameters = {}
        
        # Parse annotation parameters if they exist
        if hasattr(annotation, 'element') and annotation.element:
            for element in annotation.element:
                if hasattr(element, 'name') and hasattr(element, 'value'):
                    parameters[element.name] = element.value.value if hasattr(element.value, 'value') else str(element.value)
        
        result.append(Annotation(
            name=annotation_name,
            parameters=parameters,
            target_type=target_type,
            category=classify_springboot_annotation(annotation_name)
        ))
    
    return result


def classify_springboot_annotation(annotation_name: str) -> str:
    """Classify SpringBoot annotations into categories.
    
    Args:
        annotation_name: Name of the annotation (e.g., "@Component", "@Service")
        
    Returns:
        Category of the annotation
    """
    # Component annotations
    component_annotations = {
        "Component", "Service", "Repository", "Controller", 
        "RestController", "Configuration", "Bean"
    }
    
    # Injection annotations
    injection_annotations = {
        "Autowired", "Resource", "Value", "Qualifier", "Primary"
    }
    
    # Web annotations
    web_annotations = {
        "RequestMapping", "GetMapping", "PostMapping", "PutMapping", 
        "DeleteMapping", "PatchMapping", "RequestParam", "PathVariable",
        "RequestBody", "ResponseBody", "ResponseStatus"
    }
    
    # JPA annotations
    jpa_annotations = {
        "Entity", "Table", "Id", "Column", "OneToMany", "ManyToOne",
        "OneToOne", "ManyToMany", "JoinColumn", "GeneratedValue"
    }
    
    # Test annotations
    test_annotations = {
        "Test", "SpringBootTest", "DataJpaTest", "WebMvcTest",
        "MockBean", "SpyBean", "TestPropertySource"
    }
    
    # Security annotations
    security_annotations = {
        "PreAuthorize", "PostAuthorize", "Secured", "RolesAllowed",
        "EnableWebSecurity", "EnableGlobalMethodSecurity"
    }
    
    # Validation annotations
    validation_annotations = {
        "Valid", "NotNull", "NotBlank", "NotEmpty", "Size", "Min", "Max",
        "Pattern", "Email", "AssertTrue", "AssertFalse"
    }
    
    # MyBatis annotations
    mybatis_annotations = {
        "Mapper", "Select", "Insert", "Update", "Delete", "SelectProvider",
        "InsertProvider", "UpdateProvider", "DeleteProvider", "Results",
        "Result", "One", "Many", "MapKey", "Options", "SelectKey"
    }
    
    if annotation_name in component_annotations:
        return "component"
    elif annotation_name in injection_annotations:
        return "injection"
    elif annotation_name in web_annotations:
        return "web"
    elif annotation_name in jpa_annotations:
        return "jpa"
    elif annotation_name in test_annotations:
        return "test"
    elif annotation_name in security_annotations:
        return "security"
    elif annotation_name in validation_annotations:
        return "validation"
    elif annotation_name in mybatis_annotations:
        return "mybatis"
    else:
        return "other"


def classify_test_annotation(annotation_name: str) -> str:
    """Classify test annotations into categories.
    
    Args:
        annotation_name: Name of the annotation
        
    Returns:
        Category of the test annotation
    """
    # JUnit annotations
    junit_annotations = {
        "Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll",
        "DisplayName", "ParameterizedTest", "ValueSource", "CsvSource",
        "MethodSource", "Timeout", "Disabled", "Nested", "RepeatedTest",
        "Order", "TestMethodOrder", "TestInstance", "TestClassOrder"
    }
    
    # Spring Boot Test annotations
    spring_test_annotations = {
        "SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest",
        "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest",
        "MockBean", "SpyBean", "TestConfiguration", "ActiveProfiles",
        "TestPropertySource", "DirtiesContext", "Transactional",
        "Rollback", "Commit", "Sql", "SqlGroup", "AutoConfigureTestDatabase",
        "AutoConfigureMockMvc", "AutoConfigureWebMvc", "AutoConfigureWebClient",
        "MockMvc", "TestEntityManager", "TestContainers", "DynamicPropertySource"
    }
    
    # TestNG annotations
    testng_annotations = {
        "TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass",
        "BeforeSuite", "AfterSuite", "BeforeGroups", "AfterGroups",
        "DataProvider", "Parameters", "Groups", "Priority", "DependsOnMethods",
        "DependsOnGroups", "ExpectedExceptions", "InvocationCount",
        "SuccessPercentage", "TimeOut"
    }
    
    # Mockito annotations
    mockito_annotations = {
        "Mock", "Spy", "InjectMocks", "Captor", "MockedStatic"
    }
    
    # AssertJ annotations
    assertj_annotations = {
        "AssertJ"
    }
    
    # Other test annotations
    other_test_annotations = {
        "Ignore", "Category", "RunWith", "ExtendWith", "ContextConfiguration"
    }
    
    if annotation_name in junit_annotations:
        return "junit"
    elif annotation_name in spring_test_annotations:
        return "spring_test"
    elif annotation_name in testng_annotations:
        return "testng"
    elif annotation_name in mockito_annotations:
        return "mockito"
    elif annotation_name in assertj_annotations:
        return "assertj"
    elif annotation_name in other_test_annotations:
        return "other_test"
    else:
        return "other"


def extract_beans_from_classes(classes: list[Class]) -> list[Bean]:
    """Extract Spring Beans from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Bean objects
    """
    beans = []
    
    for cls in classes:
        # Check if class has Spring component annotations
        component_annotations = [ann for ann in cls.annotations if ann.category == "component"]
        
        # Also check for @Repository on interfaces
        has_repository_annotation = any(ann.name == "Repository" for ann in cls.annotations)
        
        if component_annotations or has_repository_annotation:
            # Determine bean type based on annotations
            bean_type = "component"  # default
            if any(ann.name in ["Service", "Service"] for ann in cls.annotations):
                bean_type = "service"
            elif any(ann.name in ["Repository", "Repository"] for ann in cls.annotations):
                bean_type = "repository"
            elif any(ann.name in ["Controller", "RestController"] for ann in cls.annotations):
                bean_type = "controller"
            elif any(ann.name in ["Configuration", "Configuration"] for ann in cls.annotations):
                bean_type = "configuration"
            
            # Determine scope (default is singleton)
            scope = "singleton"
            for ann in cls.annotations:
                if ann.name == "Scope":
                    if "value" in ann.parameters:
                        scope = ann.parameters["value"]
                    elif "prototype" in str(ann.parameters):
                        scope = "prototype"
                    elif "request" in str(ann.parameters):
                        scope = "request"
                    elif "session" in str(ann.parameters):
                        scope = "session"
            
            # Create bean name (use class name with first letter lowercase)
            bean_name = cls.name[0].lower() + cls.name[1:] if cls.name else cls.name
            
            # Check for @Bean methods in configuration classes
            bean_methods = []
            if bean_type == "configuration":
                for method in cls.methods:
                    if any(ann.name == "Bean" for ann in method.annotations):
                        bean_methods.append(method)
            
            bean = Bean(
                name=bean_name,
                type=bean_type,
                scope=scope,
                class_name=cls.name,
                package_name=cls.package_name,
                annotation_names=[ann.name for ann in cls.annotations] if cls.annotations else [],
                method_count=len(bean_methods) if bean_type == "configuration" else len(cls.methods) if cls.methods else 0,
                property_count=len(cls.properties) if cls.properties else 0
            )
            beans.append(bean)
    
    return beans


def analyze_bean_dependencies(classes: list[Class], beans: list[Bean]) -> list[BeanDependency]:
    """Analyze dependencies between Spring Beans.
    
    Args:
        classes: List of parsed Class objects
        beans: List of Bean objects
        
    Returns:
        List of BeanDependency objects
    """
    dependencies = []
    
    # Create a mapping from class names to bean names
    class_to_bean = {}
    for bean in beans:
        class_to_bean[bean.class_name] = bean.name
    
    for cls in classes:
        # Check if this class is a bean
        if cls.name not in class_to_bean:
            continue
            
        source_bean = class_to_bean[cls.name]
        
        # Analyze field injections (@Autowired, @Resource, @Value)
        for prop in cls.properties:
            if any(ann.category == "injection" for ann in prop.annotations):
                # Try to determine target bean from field type
                target_bean = None
                field_type = prop.type
                
                # Look for exact class name match
                if field_type in class_to_bean:
                    target_bean = class_to_bean[field_type]
                else:
                    # Look for interface implementations (simplified - just check if type matches any bean class name)
                    for bean in beans:
                        if field_type == bean.class_name:
                            target_bean = bean.name
                            break
                
                if target_bean:
                    injection_type = "field"
                    for ann in prop.annotations:
                        if ann.name == "Autowired":
                            injection_type = "field"
                        elif ann.name == "Resource":
                            injection_type = "field"
                        elif ann.name == "Value":
                            injection_type = "field"
                    
                    dependency = BeanDependency(
                        source_bean=source_bean,
                        target_bean=target_bean,
                        injection_type=injection_type,
                        field_name=prop.name
                    )
                    dependencies.append(dependency)
        
        # Analyze constructor injections
        for method in cls.methods:
            if method.name == cls.name:  # Constructor
                for param in method.parameters:
                    if any(ann.category == "injection" for ann in param.annotations):
                        target_bean = None
                        param_type = param.type
                        
                        if param_type in class_to_bean:
                            target_bean = class_to_bean[param_type]
                        else:
                            # Look for interface implementations (simplified)
                            for bean in beans:
                                if param_type == bean.class_name:
                                    target_bean = bean.name
                                    break
                        
                        if target_bean:
                            dependency = BeanDependency(
                                source_bean=source_bean,
                                target_bean=target_bean,
                                injection_type="constructor",
                                parameter_name=param.name
                            )
                            dependencies.append(dependency)
        
        # Analyze setter injections
        for method in cls.methods:
            if method.name.startswith("set") and len(method.parameters) == 1:
                if any(ann.category == "injection" for ann in method.annotations):
                    param = method.parameters[0]
                    target_bean = None
                    param_type = param.type
                    
                    if param_type in class_to_bean:
                        target_bean = class_to_bean[param_type]
                    else:
                        # Look for interface implementations (simplified)
                        for bean in beans:
                            if param_type == bean.class_name:
                                target_bean = bean.name
                                break
                    
                    if target_bean:
                        dependency = BeanDependency(
                            source_bean=source_bean,
                            target_bean=target_bean,
                            injection_type="setter",
                            method_name=method.name,
                            parameter_name=param.name
                        )
                        dependencies.append(dependency)
    
    return dependencies


def extract_endpoints_from_classes(classes: list[Class]) -> list[Endpoint]:
    """Extract REST API endpoints from controller classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Endpoint objects
    """
    endpoints = []
    
    for cls in classes:
        # Check if class is a controller
        is_controller = any(ann.name in ["Controller", "RestController"] for ann in cls.annotations)
        
        if not is_controller:
            continue
            
        # Get class-level path mapping
        class_path = ""
        for ann in cls.annotations:
            if ann.name == "RequestMapping":
                if "value" in ann.parameters:
                    class_path = ann.parameters["value"]
                break
        
        # Process each method in the controller
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
                
            # Check if method has web mapping annotations
            web_annotations = [ann for ann in method.annotations if ann.category == "web"]
            
            if not web_annotations:
                continue
            
            # Extract endpoint information
            endpoint_path = ""
            http_method = "GET"  # default
            
            for ann in web_annotations:
                if ann.name in ["RequestMapping", "GetMapping", "PostMapping", "PutMapping", "DeleteMapping", "PatchMapping"]:
                    # Extract path
                    if "value" in ann.parameters:
                        endpoint_path = ann.parameters["value"]
                    elif "path" in ann.parameters:
                        endpoint_path = ann.parameters["path"]
                    
                    # Extract HTTP method
                    if ann.name == "GetMapping":
                        http_method = "GET"
                    elif ann.name == "PostMapping":
                        http_method = "POST"
                    elif ann.name == "PutMapping":
                        http_method = "PUT"
                    elif ann.name == "DeleteMapping":
                        http_method = "DELETE"
                    elif ann.name == "PatchMapping":
                        http_method = "PATCH"
                    elif ann.name == "RequestMapping":
                        if "method" in ann.parameters:
                            method_value = ann.parameters["method"]
                            if isinstance(method_value, list) and len(method_value) > 0:
                                http_method = method_value[0]
                            else:
                                http_method = str(method_value)
                        else:
                            http_method = "GET"  # default for RequestMapping
                    break
            
            # Build full path
            full_path = class_path
            if endpoint_path:
                if full_path and not full_path.endswith("/") and not endpoint_path.startswith("/"):
                    full_path += "/"
                full_path += endpoint_path
            elif not full_path:
                full_path = "/"
            
            # Extract method parameters
            parameters = []
            for param in method.parameters:
                param_info = {
                    "name": param.name,
                    "type": param.type,
                    "annotations": [ann.name for ann in param.annotations if ann.category == "web"]
                }
                parameters.append(param_info)
            
            # Extract return type
            return_type = method.return_type if method.return_type != "constructor" else "void"
            
            # Create endpoint
            endpoint = Endpoint(
                path=endpoint_path or "/",
                method=http_method,
                controller_class=cls.name,
                handler_method=method.name,
                parameters=parameters,
                return_type=return_type,
                annotations=[ann.name for ann in web_annotations],
                full_path=full_path
            )
            endpoints.append(endpoint)
    
    return endpoints


def extract_mybatis_mappers_from_classes(classes: list[Class]) -> list[MyBatisMapper]:
    """Extract MyBatis Mappers from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for cls in classes:
        # Check if class is a MyBatis Mapper interface
        is_mapper = any(ann.name == "Mapper" for ann in cls.annotations)
        
        if not is_mapper:
            continue
        
        # Extract mapper methods with MyBatis annotations
        mapper_methods = []
        sql_statements = []
        
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
            
            # Check if method has MyBatis annotations
            mybatis_annotations = [ann for ann in method.annotations if ann.category == "mybatis"]
            
            if not mybatis_annotations:
                continue
            
            # Extract SQL statement information
            sql_type = "SELECT"  # default
            sql_content = ""
            parameter_type = ""
            result_type = ""
            result_map = ""
            
            for ann in mybatis_annotations:
                if ann.name in ["Select", "SelectProvider"]:
                    sql_type = "SELECT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Insert", "InsertProvider"]:
                    sql_type = "INSERT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Update", "UpdateProvider"]:
                    sql_type = "UPDATE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Delete", "DeleteProvider"]:
                    sql_type = "DELETE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                
                # Extract parameter and result type information
                if "parameterType" in ann.parameters:
                    parameter_type = ann.parameters["parameterType"]
                if "resultType" in ann.parameters:
                    result_type = ann.parameters["resultType"]
                if "resultMap" in ann.parameters:
                    result_map = ann.parameters["resultMap"]
            
            # Create method info
            method_info = {
                "name": method.name,
                "return_type": method.return_type,
                "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            mapper_methods.append(method_info)
            
            # Create SQL statement info
            sql_statement = {
                "id": method.name,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            sql_statements.append(sql_statement)
        
        # Create mapper
        mapper = MyBatisMapper(
            name=cls.name,
            type="interface",
            namespace=f"{cls.package_name}.{cls.name}",
            methods=mapper_methods,
            sql_statements=sql_statements,
            file_path=cls.file_path,
            package_name=cls.package_name
        )
        mappers.append(mapper)
    
    return mappers


def parse_mybatis_xml_file(file_path: str) -> MyBatisMapper:
    """Parse MyBatis XML mapper file.
    
    Args:
        file_path: Path to the XML mapper file
        
    Returns:
        MyBatisMapper object
    """
    import xml.etree.ElementTree as ET
    
    try:
        tree = ET.parse(file_path)
        root = tree.getroot()
        
        # Extract namespace
        namespace = root.get("namespace", "")
        
        # Extract SQL statements
        sql_statements = []
        for statement in root.findall(".//*[@id]"):
            statement_id = statement.get("id")
            tag_name = statement.tag.lower()
            
            # Determine SQL type
            sql_type = "SELECT"
            if tag_name == "insert":
                sql_type = "INSERT"
            elif tag_name == "update":
                sql_type = "UPDATE"
            elif tag_name == "delete":
                sql_type = "DELETE"
            
            # Extract SQL content
            sql_content = statement.text.strip() if statement.text else ""
            
            # Extract parameter and result information
            parameter_type = statement.get("parameterType", "")
            result_type = statement.get("resultType", "")
            result_map = statement.get("resultMap", "")
            
            sql_statement = {
                "id": statement_id,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": []
            }
            sql_statements.append(sql_statement)
        
        # Extract ResultMaps
        result_maps = []
        for result_map in root.findall(".//resultMap"):
            result_map_id = result_map.get("id")
            result_map_type = result_map.get("type", "")
            
            properties = []
            for property_elem in result_map.findall(".//result"):
                prop = {
                    "property": property_elem.get("property", ""),
                    "column": property_elem.get("column", ""),
                    "jdbc_type": property_elem.get("jdbcType", "")
                }
                properties.append(prop)
            
            result_map_info = {
                "id": result_map_id,
                "type": result_map_type,
                "properties": properties,
                "associations": [],
                "collections": []
            }
            result_maps.append(result_map_info)
        
        # Create mapper
        mapper_name = namespace.split(".")[-1] if namespace else os.path.basename(file_path).replace(".xml", "")
        package_name = ".".join(namespace.split(".")[:-1]) if namespace else ""
        
        mapper = MyBatisMapper(
            name=mapper_name,
            type="xml",
            namespace=namespace,
            methods=[],  # XML mappers don't have Java methods
            sql_statements=sql_statements,
            file_path=file_path,
            package_name=package_name
        )
        
        return mapper
        
    except ET.ParseError as e:
        print(f"Error parsing XML file {file_path}: {e}")
        return None
    except Exception as e:
        print(f"Error reading XML file {file_path}: {e}")
        return None


def extract_mybatis_xml_mappers(directory: str) -> list[MyBatisMapper]:
    """Extract MyBatis XML mappers from directory.
    
    Args:
        directory: Directory to search for XML mapper files
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith("Mapper.xml") or file.endswith("Dao.xml"):
                file_path = os.path.join(root, file)
                mapper = parse_mybatis_xml_file(file_path)
                if mapper:
                    mappers.append(mapper)
    
    return mappers


def extract_jpa_entities_from_classes(classes: list[Class]) -> list[JpaEntity]:
    """Extract JPA Entities from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of JpaEntity objects
    """
    entities = []
    
    for cls in classes:
        # Check if class is a JPA Entity
        is_entity = any(ann.name == "Entity" for ann in cls.annotations)
        
        if not is_entity:
            continue
        
        # Extract table name
        table_name = cls.name.lower()  # default table name
        for ann in cls.annotations:
            if ann.name == "Table":
                if "name" in ann.parameters:
                    table_name = ann.parameters["name"]
                break
        
        # Extract columns from properties
        columns = []
        relationships = []
        
        for prop in cls.properties:
            # Check if property has JPA column annotations
            jpa_annotations = [ann for ann in prop.annotations if ann.category == "jpa"]
            
            if jpa_annotations:
                # Extract column information
                column_name = prop.name  # default column name
                nullable = True
                unique = False
                length = 0
                precision = 0
                scale = 0
                
                for ann in jpa_annotations:
                    if ann.name == "Column":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                        if "nullable" in ann.parameters:
                            nullable = ann.parameters["nullable"]
                        if "unique" in ann.parameters:
                            unique = ann.parameters["unique"]
                        if "length" in ann.parameters:
                            length = ann.parameters["length"]
                        if "precision" in ann.parameters:
                            precision = ann.parameters["precision"]
                        if "scale" in ann.parameters:
                            scale = ann.parameters["scale"]
                    elif ann.name == "Id":
                        column_name = "id"  # Primary key column
                        nullable = False
                        unique = True
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                
                # Check for relationship annotations
                relationship_type = None
                target_entity = ""
                mapped_by = ""
                join_column = ""
                join_table = ""
                cascade = []
                fetch = "LAZY"
                
                for ann in jpa_annotations:
                    if ann.name in ["OneToOne", "OneToMany", "ManyToOne", "ManyToMany"]:
                        relationship_type = ann.name
                        if "targetEntity" in ann.parameters:
                            target_entity = ann.parameters["targetEntity"]
                        if "mappedBy" in ann.parameters:
                            mapped_by = ann.parameters["mappedBy"]
                        if "cascade" in ann.parameters:
                            cascade = ann.parameters["cascade"] if isinstance(ann.parameters["cascade"], list) else [ann.parameters["cascade"]]
                        if "fetch" in ann.parameters:
                            fetch = ann.parameters["fetch"]
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            join_column = ann.parameters["name"]
                    elif ann.name == "JoinTable":
                        if "name" in ann.parameters:
                            join_table = ann.parameters["name"]
                
                # Create column info
                column_info = {
                    "property_name": prop.name,
                    "column_name": column_name,
                    "data_type": prop.type,
                    "nullable": nullable,
                    "unique": unique,
                    "length": length,
                    "precision": precision,
                    "scale": scale,
                    "annotations": [ann.name for ann in jpa_annotations]
                }
                columns.append(column_info)
                
                # Create relationship info if it's a relationship
                if relationship_type:
                    relationship_info = {
                        "type": relationship_type,
                        "target_entity": target_entity,
                        "mapped_by": mapped_by,
                        "join_column": join_column,
                        "join_table": join_table,
                        "cascade": cascade,
                        "fetch": fetch,
                        "annotations": [ann.name for ann in jpa_annotations]
                    }
                    relationships.append(relationship_info)
        
        # Create entity
        entity = JpaEntity(
            name=cls.name,
            table_name=table_name,
            columns=columns,
            relationships=relationships,
            annotations=[ann.name for ann in cls.annotations if ann.category == "jpa"],
            package_name=cls.package_name,
            file_path=cls.file_path
        )
        entities.append(entity)
    
    return entities


def parse_yaml_config(file_path: str) -> ConfigFile:
    """Parse YAML configuration file.
    
    Args:
        file_path: Path to the YAML file
        
    Returns:
        ConfigFile object
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = yaml.safe_load(f)
        
        if not content:
            content = {}
        
        # Extract file info
        file_name = os.path.basename(file_path)
        file_type = "yaml" if file_path.endswith('.yaml') else "yml"
        
        # Extract profiles
        profiles = []
        if 'spring' in content and 'profiles' in content['spring']:
            if 'active' in content['spring']['profiles']:
                profiles = content['spring']['profiles']['active']
                if isinstance(profiles, str):
                    profiles = [profiles]
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        # Extract sections
        sections = []
        for key, value in content.items():
            if isinstance(value, dict):
                sections.append({
                    "name": key,
                    "properties": value,
                    "type": "section"
                })
        
        return ConfigFile(
            name=file_name,
            file_path=file_path,
            file_type=file_type,
            properties=content,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing YAML file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="yaml",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def parse_properties_config(file_path: str) -> ConfigFile:
    """Parse Properties configuration file.
    
    Args:
        file_path: Path to the properties file
        
    Returns:
        ConfigFile object
    """
    try:
        properties = {}
        sections = []
        profiles = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                
                # Skip empty lines and comments
                if not line or line.startswith('#'):
                    continue
                
                # Parse key=value pairs
                if '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    
                    # Remove quotes if present
                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]
                    elif value.startswith("'") and value.endswith("'"):
                        value = value[1:-1]
                    
                    properties[key] = value
                    
                    # Check for profiles
                    if key == 'spring.profiles.active':
                        profiles = [p.strip() for p in value.split(',')]
        
        # Group properties by section
        section_map = {}
        for key, value in properties.items():
            if '.' in key:
                section = key.split('.')[0]
                if section not in section_map:
                    section_map[section] = {}
                section_map[section][key] = value
            else:
                if 'root' not in section_map:
                    section_map['root'] = {}
                section_map['root'][key] = value
        
        for section_name, section_props in section_map.items():
            sections.append({
                "name": section_name,
                "properties": section_props,
                "type": "section"
            })
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties=properties,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing Properties file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def extract_database_config(config_file: ConfigFile) -> DatabaseConfig:
    """Extract database configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        DatabaseConfig object
    """
    db_config = DatabaseConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        spring_config = config_file.properties.get('spring', {})
        datasource_config = spring_config.get('datasource', {})
        jpa_config = spring_config.get('jpa', {})
        
        db_config.driver = datasource_config.get('driver-class-name', '')
        db_config.url = datasource_config.get('url', '')
        db_config.username = datasource_config.get('username', '')
        db_config.password = datasource_config.get('password', '')
        db_config.dialect = jpa_config.get('database-platform', '')
        db_config.hibernate_ddl_auto = jpa_config.get('hibernate', {}).get('ddl-auto', '')
        db_config.show_sql = jpa_config.get('show-sql', False)
        db_config.format_sql = jpa_config.get('properties', {}).get('hibernate', {}).get('format_sql', False)
        
        # Store additional JPA properties
        if 'properties' in jpa_config:
            db_config.jpa_properties = jpa_config['properties']
    
    else:
        # Properties format
        props = config_file.properties
        
        db_config.driver = props.get('spring.datasource.driver-class-name', '')
        db_config.url = props.get('spring.datasource.url', '')
        db_config.username = props.get('spring.datasource.username', '')
        db_config.password = props.get('spring.datasource.password', '')
        db_config.dialect = props.get('spring.jpa.database-platform', '')
        db_config.hibernate_ddl_auto = props.get('spring.jpa.hibernate.ddl-auto', '')
        db_config.show_sql = props.get('spring.jpa.show-sql', 'false').lower() == 'true'
        db_config.format_sql = props.get('spring.jpa.properties.hibernate.format_sql', 'false').lower() == 'true'
        
        # Store additional JPA properties
        jpa_props = {}
        for key, value in props.items():
            if key.startswith('spring.jpa.properties.'):
                jpa_props[key] = value
        db_config.jpa_properties = jpa_props
    
    return db_config


def extract_server_config(config_file: ConfigFile) -> ServerConfig:
    """Extract server configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        ServerConfig object
    """
    server_config = ServerConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        server_props = config_file.properties.get('server', {})
        
        server_config.port = server_props.get('port', 8080)
        server_config.context_path = server_props.get('servlet', {}).get('context-path', '')
        server_config.servlet_path = server_props.get('servlet', {}).get('path', '')
        
        # SSL configuration
        ssl_config = server_props.get('ssl', {})
        server_config.ssl_enabled = bool(ssl_config)
        server_config.ssl_key_store = ssl_config.get('key-store', '')
        server_config.ssl_key_store_password = ssl_config.get('key-store-password', '')
        server_config.ssl_key_store_type = ssl_config.get('key-store-type', '')
    
    else:
        # Properties format
        props = config_file.properties
        
        server_config.port = int(props.get('server.port', '8080'))
        server_config.context_path = props.get('server.servlet.context-path', '')
        server_config.servlet_path = props.get('server.servlet.path', '')
        
        # SSL configuration
        server_config.ssl_enabled = any(key.startswith('server.ssl.') for key in props.keys())
        server_config.ssl_key_store = props.get('server.ssl.key-store', '')
        server_config.ssl_key_store_password = props.get('server.ssl.key-store-password', '')
        server_config.ssl_key_store_type = props.get('server.ssl.key-store-type', '')
    
    return server_config


def extract_security_config(config_file: ConfigFile) -> SecurityConfig:
    """Extract security configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        SecurityConfig object
    """
    security_config = SecurityConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        security_props = config_file.properties.get('security', {})
        jwt_props = security_props.get('jwt', {})
        cors_props = security_props.get('cors', {})
        
        security_config.enabled = bool(security_props)
        security_config.authentication_type = security_props.get('authentication-type', '')
        security_config.jwt_secret = jwt_props.get('secret', '')
        security_config.jwt_expiration = jwt_props.get('expiration', 0)
        security_config.cors_allowed_origins = cors_props.get('allowed-origins', [])
        security_config.cors_allowed_methods = cors_props.get('allowed-methods', [])
        security_config.cors_allowed_headers = cors_props.get('allowed-headers', [])
    
    else:
        # Properties format
        props = config_file.properties
        
        security_config.enabled = any(key.startswith('security.') for key in props.keys())
        security_config.authentication_type = props.get('security.authentication-type', '')
        security_config.jwt_secret = props.get('security.jwt.secret', '')
        security_config.jwt_expiration = int(props.get('security.jwt.expiration', '0'))
        
        # CORS configuration
        origins = props.get('security.cors.allowed-origins', '')
        if origins:
            security_config.cors_allowed_origins = [o.strip() for o in origins.split(',')]
        
        methods = props.get('security.cors.allowed-methods', '')
        if methods:
            security_config.cors_allowed_methods = [m.strip() for m in methods.split(',')]
        
        headers = props.get('security.cors.allowed-headers', '')
        if headers:
            security_config.cors_allowed_headers = [h.strip() for h in headers.split(',')]
    
    return security_config


def extract_logging_config(config_file: ConfigFile) -> LoggingConfig:
    """Extract logging configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        LoggingConfig object
    """
    logging_config = LoggingConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        logging_props = config_file.properties.get('logging', {})
        
        logging_config.level = logging_props.get('level', {}).get('root', 'INFO')
        logging_config.pattern = logging_props.get('pattern', {}).get('console', '')
        logging_config.file_path = logging_props.get('file', {}).get('name', '')
        logging_config.max_file_size = logging_props.get('file', {}).get('max-size', '')
        logging_config.max_history = logging_props.get('file', {}).get('max-history', 0)
        logging_config.console_output = logging_props.get('console', {}).get('enabled', True)
    
    else:
        # Properties format
        props = config_file.properties
        
        logging_config.level = props.get('logging.level.root', 'INFO')
        logging_config.pattern = props.get('logging.pattern.console', '')
        logging_config.file_path = props.get('logging.file.name', '')
        logging_config.max_file_size = props.get('logging.file.max-size', '')
        logging_config.max_history = int(props.get('logging.file.max-history', '0'))
        logging_config.console_output = props.get('logging.console.enabled', 'true').lower() == 'true'
    
    return logging_config


def extract_config_files(directory: str) -> list[ConfigFile]:
    """Extract configuration files from directory.
    
    Args:
        directory: Directory to search for config files
        
    Returns:
        List of ConfigFile objects
    """
    config_files = []
    
    # Common config file patterns
    config_patterns = [
        "application.yml",
        "application.yaml", 
        "application.properties",
        "application-*.properties",
        "bootstrap.yml",
        "bootstrap.yaml",
        "bootstrap.properties"
    ]
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            # Check if file matches any config pattern
            is_config_file = False
            for pattern in config_patterns:
                if pattern == file or (pattern.endswith('*') and file.startswith(pattern[:-1])):
                    is_config_file = True
                    break
            
            if is_config_file:
                file_path = os.path.join(root, file)
                
                if file.endswith(('.yml', '.yaml')):
                    config_file = parse_yaml_config(file_path)
                elif file.endswith('.properties'):
                    config_file = parse_properties_config(file_path)
                else:
                    continue
                
                config_files.append(config_file)
    
    return config_files


def extract_test_classes_from_classes(classes: list[Class]) -> list[TestClass]:
    """Extract test classes from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of TestClass objects
    """
    test_classes = []
    
    for cls in classes:
        # Check if class is a test class
        test_annotations = [ann for ann in cls.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
        
        if not test_annotations:
            continue
        
        # Determine test framework and type
        test_framework = "junit"  # default
        test_type = "unit"  # default
        
        for ann in test_annotations:
            if ann.name in ["SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest", "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest"]:
                test_framework = "spring_test"
                if ann.name == "SpringBootTest":
                    test_type = "integration"
                else:
                    test_type = "slice"
            elif ann.name in ["TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass"]:
                test_framework = "testng"
            elif ann.name in ["Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll"]:
                test_framework = "junit"
        
        # Extract test methods
        test_methods = []
        setup_methods = []
        
        for method in cls.methods:
            method_annotations = [ann.name for ann in method.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
            
            if method_annotations:
                # Check if it's a setup/teardown method
                if any(ann in method_annotations for ann in ["BeforeEach", "AfterEach", "BeforeAll", "AfterAll", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass", "BeforeSuite", "AfterSuite"]):
                    setup_methods.append({
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters]
                    })
                else:
                    # Regular test method
                    test_method_info = {
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                        "assertions": [],
                        "mock_calls": [],
                        "test_data": [],
                        "expected_exceptions": [],
                        "timeout": 0,
                        "display_name": ""
                    }
                    
                    # Extract display name
                    for ann in method.annotations:
                        if ann.name == "DisplayName" and "value" in ann.parameters:
                            test_method_info["display_name"] = ann.parameters["value"]
                        elif ann.name == "Timeout" and "value" in ann.parameters:
                            test_method_info["timeout"] = ann.parameters["value"]
                    
                    # Extract expected exceptions
                    for ann in method.annotations:
                        if ann.name == "ExpectedExceptions" and "value" in ann.parameters:
                            test_method_info["expected_exceptions"] = ann.parameters["value"] if isinstance(ann.parameters["value"], list) else [ann.parameters["value"]]
                    
                    test_methods.append(test_method_info)
        
        # Extract mock dependencies
        mock_dependencies = []
        for prop in cls.properties:
            prop_annotations = [ann.name for ann in prop.annotations if classify_test_annotation(ann.name) in ["mockito", "spring_test"]]
            if prop_annotations:
                mock_dependencies.append({
                    "name": prop.name,
                    "type": prop.type,
                    "annotations": prop_annotations,
                    "mock_type": "mock" if "Mock" in prop_annotations else "spy" if "Spy" in prop_annotations else "bean"
                })
        
        # Extract test configurations
        test_configurations = []
        for ann in cls.annotations:
            if ann.name in ["TestConfiguration", "ActiveProfiles", "TestPropertySource"]:
                config_info = {
                    "name": ann.name,
                    "type": "configuration" if ann.name == "TestConfiguration" else "profile" if ann.name == "ActiveProfiles" else "property",
                    "properties": ann.parameters,
                    "active_profiles": ann.parameters.get("value", []) if ann.name == "ActiveProfiles" else [],
                    "test_slices": [],
                    "mock_beans": [],
                    "spy_beans": []
                }
                test_configurations.append(config_info)
        
        # Create test class
        test_class = TestClass(
            name=cls.name,
            package_name=cls.package_name,
            test_framework=test_framework,
            test_type=test_type,
            annotations=[ann.name for ann in test_annotations],
            test_methods=test_methods,
            setup_methods=setup_methods,
            mock_dependencies=mock_dependencies,
            test_configurations=test_configurations,
            file_path=cls.file_path
        )
        test_classes.append(test_class)
    
    return test_classes


def analyze_test_methods(test_class: TestClass, class_obj: Class) -> list[TestMethod]:
    """Analyze test methods for assertions, mock calls, and test data.
    
    Args:
        test_class: TestClass object
        class_obj: Original Class object
        
    Returns:
        List of analyzed TestMethod objects
    """
    test_methods = []
    
    for method_info in test_class.test_methods:
        # Find the corresponding method in the class
        method_obj = None
        for method in class_obj.methods:
            if method.name == method_info["name"]:
                method_obj = method
                break
        
        if not method_obj:
            continue
        
        # Analyze method source code for assertions and mock calls
        assertions = []
        mock_calls = []
        test_data = []
        
        if method_obj.source:
            source_code = method_obj.source
            
            # Find assertions (JUnit, AssertJ, etc.)
            assertion_patterns = [
                r'assert\w+\(',  # JUnit assertions
                r'assertThat\(',  # AssertJ
                r'assertEquals\(',  # JUnit
                r'assertTrue\(',  # JUnit
                r'assertFalse\(',  # JUnit
                r'assertNotNull\(',  # JUnit
                r'assertNull\(',  # JUnit
                r'assertThrows\(',  # JUnit 5
                r'assertDoesNotThrow\(',  # JUnit 5
                r'verify\(',  # Mockito verify
                r'when\(',  # Mockito when
                r'then\(',  # Mockito then
                r'given\(',  # BDDMockito given
                r'willReturn\(',  # Mockito willReturn
                r'willThrow\(',  # Mockito willThrow
            ]
            
            for pattern in assertion_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    assertions.append({
                        "type": match,
                        "line": source_code.find(match) + 1
                    })
            
            # Find mock calls
            mock_call_patterns = [
                r'(\w+)\.(\w+)\(',  # Method calls on objects
                r'mock\(',  # Mockito mock creation
                r'spy\(',  # Mockito spy creation
                r'@Mock\s+(\w+)',  # @Mock annotation
                r'@Spy\s+(\w+)',  # @Spy annotation
                r'@InjectMocks\s+(\w+)',  # @InjectMocks annotation
            ]
            
            for pattern in mock_call_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        mock_calls.append({
                            "object": match[0],
                            "method": match[1],
                            "type": "method_call"
                        })
                    else:
                        mock_calls.append({
                            "type": match,
                            "line": source_code.find(match) + 1
                        })
            
            # Find test data setup
            test_data_patterns = [
                r'new\s+(\w+)\(',  # Object creation
                r'(\w+)\s*=\s*new\s+(\w+)\(',  # Variable assignment with new
                r'@ValueSource\(',  # JUnit 5 @ValueSource
                r'@CsvSource\(',  # JUnit 5 @CsvSource
                r'@MethodSource\(',  # JUnit 5 @MethodSource
            ]
            
            for pattern in test_data_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        test_data.append({
                            "variable": match[0],
                            "type": match[1],
                            "pattern": "object_creation"
                        })
                    else:
                        test_data.append({
                            "type": match,
                            "pattern": "annotation"
                        })
        
        # Create TestMethod object
        test_method = TestMethod(
            name=method_info["name"],
            return_type=method_info["return_type"],
            annotations=method_info["annotations"],
            assertions=assertions,
            mock_calls=mock_calls,
            test_data=test_data,
            expected_exceptions=method_info["expected_exceptions"],
            timeout=method_info["timeout"],
            display_name=method_info["display_name"]
        )
        test_methods.append(test_method)
    
    return test_methods


def generate_lombok_methods(properties: list[Field], class_name: str, package_name: str) -> list[Method]:
    """Generate Lombok @Data methods (getters, setters, equals, hashCode, toString) for properties."""
    methods = []
    
    # Generate getters and setters for each property
    for prop in properties:
        # Getter
        getter_name = f"get{prop.name[0].upper()}{prop.name[1:]}"
        if prop.type == "Boolean" and prop.name.startswith("is"):
            # For boolean fields starting with 'is', use the field name as getter
            getter_name = prop.name
        
        getter = Method(
            name=getter_name,
            logical_name=f"{package_name}.{class_name}.{getter_name}",
            return_type=prop.type,
            parameters=[],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[],
            description=f"Generated getter for {prop.name} field"  # Generated method description
        )
        methods.append(getter)
        
        # Setter
        setter_name = f"set{prop.name[0].upper()}{prop.name[1:]}"
        setter_param = Field(
            name=prop.name,
            logical_name=f"{package_name}.{class_name}.{prop.name}",
            type=prop.type,
            package_name=package_name,
            class_name=class_name
        )
        
        setter = Method(
            name=setter_name,
            logical_name=f"{package_name}.{class_name}.{setter_name}",
            return_type="void",
            parameters=[setter_param],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[],
            description=f"Generated setter for {prop.name} field"  # Generated method description
        )
        methods.append(setter)
    
    # Generate equals method
    equals_method = Method(
        name="equals",
        logical_name=f"{package_name}.{class_name}.equals",
        return_type="boolean",
        parameters=[Field(name="obj", logical_name=f"{package_name}.{class_name}.obj", type="Object", package_name=package_name, class_name=class_name)],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(equals_method)
    
    # Generate hashCode method
    hashcode_method = Method(
        name="hashCode",
        logical_name=f"{package_name}.{class_name}.hashCode",
        return_type="int",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(hashcode_method)
    
    # Generate toString method
    tostring_method = Method(
        name="toString",
        logical_name=f"{package_name}.{class_name}.toString",
        return_type="String",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(tostring_method)
    
    return methods


def parse_java_project(directory: str) -> tuple[list[Package], list[Class], dict[str, str], list[Bean], list[BeanDependency], list[Endpoint], list[MyBatisMapper], list[JpaEntity], list[ConfigFile], list[TestClass], list[SqlStatement], str]:
    """Parse Java project and return parsed entities."""
    logger = get_logger(__name__)
    """Parses all Java files in a directory and returns a tuple of (packages, classes, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name)."""
    
    # Extract project name from directory path
    project_name = extract_project_name(directory)
    packages = {}
    classes = {}
    class_to_package_map = {}  # Maps class_key to package_name

    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith(".java"):
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    file_content = f.read() # Read file content once
                try:
                    tree = javalang.parse.parse(file_content)
                    package_name = tree.package.name if tree.package else ""
                    
                    # Create or update package node
                    if package_name and package_name not in packages:
                        packages[package_name] = Package(
                            name=package_name
                        )
                    elif not package_name:
                        # Handle classes without package (default package)
                        package_name = "default"
                        if package_name not in packages:
                            packages[package_name] = Package(
                                name=package_name
                            )
                    
                    import_map = {}
                    for imp in tree.imports:
                        class_name = imp.path.split('.')[-1]
                        import_map[class_name] = imp.path

                    for _, class_declaration in tree.filter(
                        javalang.tree.ClassDeclaration
                    ):
                        class_name = class_declaration.name
                        class_key = f"{package_name}.{class_name}"
                        
                        # Debug: Check if this is the User class
                        if "User" in class_name:
                            logger.debug(f"Found User class - {class_key}")
                            logger.debug(f"Methods count: {len(class_declaration.methods)}")
                            logger.debug(f"Constructors count: {len(class_declaration.constructors)}")
                        
                        # Extract class source code - use the entire file content
                        class_source = file_content


                        if class_key not in classes:
                            # Parse class annotations
                            class_annotations = parse_annotations(class_declaration.annotations, "class") if hasattr(class_declaration, 'annotations') else []
                            
                            classes[class_key] = Class(
                                name=class_name,
                                logical_name=class_key,  # Add logical_name
                                file_path=file_path,
                                type="class", # Simplified for now
                                source=class_source, # Add class source
                                annotations=class_annotations,
                                package_name=package_name
                            )
                            class_to_package_map[class_key] = package_name
                        
                        # --- Start of new import logic ---
                        for imp in tree.imports:
                            classes[class_key].imports.append(imp.path)
                        # --- End of new import logic ---

                        # --- Start of new inheritance logic ---
                        # Handle 'extends'
                        if class_declaration.extends:
                            superclass_name = class_declaration.extends.name
                            # Try to resolve fully qualified name for superclass
                            if superclass_name in import_map:
                                classes[class_key].superclass = import_map[superclass_name]
                            else:
                                # Assume same package or fully qualified if not in import_map
                                classes[class_key].superclass = f"{package_name}.{superclass_name}" if package_name else superclass_name

                        # Handle 'implements'
                        if class_declaration.implements: # Add this check
                            for impl_ref in class_declaration.implements:
                                interface_name = impl_ref.name
                                # Try to resolve fully qualified name for interface
                                if interface_name in import_map:
                                    classes[class_key].interfaces.append(import_map[interface_name])
                                else:
                                    # Assume same package or fully qualified if not in import_map
                                    classes[class_key].interfaces.append(f"{package_name}.{interface_name}" if package_name else interface_name)
                        # --- End of new inheritance logic ---

                        field_map = {}
                        for field_declaration in class_declaration.fields:
                            for declarator in field_declaration.declarators:
                                field_map[declarator.name] = field_declaration.type.name
                                
                                # Parse field annotations
                                field_annotations = parse_annotations(field_declaration.annotations, "field") if hasattr(field_declaration, 'annotations') else []
                                
                                # Extract initial value if present
                                initial_value = ""
                                if hasattr(declarator, 'initializer') and declarator.initializer:
                                    # Convert the initializer to string representation
                                    if hasattr(declarator.initializer, 'value'):
                                        initial_value = str(declarator.initializer.value)
                                    elif hasattr(declarator.initializer, 'type'):
                                        initial_value = str(declarator.initializer.type)
                                    else:
                                        initial_value = str(declarator.initializer)
                                
                                prop = Field(
                                    name=declarator.name,
                                    logical_name=f"{package_name}.{class_name}.{declarator.name}",
                                    type=field_declaration.type.name,
                                    modifiers=list(field_declaration.modifiers), # Add modifiers
                                    package_name=package_name,
                                    class_name=class_name,
                                    annotations=field_annotations,
                                    initial_value=initial_value,
                                    description=""  # TODO: Extract description from comments or annotations
                                )
                                classes[class_key].properties.append(prop)

                        all_declarations = class_declaration.methods + class_declaration.constructors
                        
                        # Debug: Check User class method processing
                        if "User" in class_name:
                            logger.debug(f"Processing User class methods - total declarations: {len(all_declarations)}")
                            for i, decl in enumerate(all_declarations):
                                logger.debug(f"Declaration {i}: {type(decl).__name__} - {decl.name}")
                        
                        for declaration in all_declarations:
                            local_var_map = field_map.copy()
                            params = []
                            for param in declaration.parameters:
                                param_type_name = 'Unknown'
                                if hasattr(param.type, 'name'):
                                    param_type_name = param.type.name
                                local_var_map[param.name] = param_type_name
                                params.append(Field(name=param.name, logical_name=f"{package_name}.{class_name}.{param.name}", type=param_type_name, package_name=package_name, class_name=class_name))

                            if declaration.body:
                                for _, var_decl in declaration.filter(javalang.tree.LocalVariableDeclaration):
                                    for declarator in var_decl.declarators:
                                        local_var_map[declarator.name] = var_decl.type.name
                            
                            if isinstance(declaration, javalang.tree.MethodDeclaration):
                                return_type = declaration.return_type.name if declaration.return_type else "void"
                            else: # ConstructorDeclaration
                                return_type = "constructor"

                            # Extract modifiers
                            modifiers = list(declaration.modifiers)
                            
                            # Parse method annotations
                            method_annotations = parse_annotations(declaration.annotations, "method") if hasattr(declaration, 'annotations') else []

                            # Extract method source code
                            method_source = ""
                            if declaration.position:
                                lines = file_content.splitlines(keepends=True) # Keep line endings
                                start_line = declaration.position.line - 1
                                
                                # Find the end of the method by matching braces
                                brace_count = 0
                                end_line = start_line
                                for i in range(start_line, len(lines)):
                                    line = lines[i]
                                    for char in line:
                                        if char == '{':
                                            brace_count += 1
                                        elif char == '}':
                                            brace_count -= 1
                                            if brace_count == 0:
                                                end_line = i
                                                break
                                    if brace_count == 0:
                                        break
                                
                                method_source = "".join(lines[start_line:end_line + 1])

                            method = Method(
                                name=declaration.name,
                                logical_name=f"{class_key}.{declaration.name}",  # Add logical_name
                                return_type=return_type,
                                parameters=params,
                                modifiers=modifiers,
                                source=method_source, # Add method source
                                package_name=package_name,
                                annotations=method_annotations
                            )
                            classes[class_key].methods.append(method)

                            # Extract method calls with order information
                            call_order = 0
                            for _, invocation in declaration.filter(javalang.tree.MethodInvocation):
                                target_class_name = None
                                resolved_target_package = ""
                                resolved_target_class_name = ""
                                
                                if invocation.qualifier:
                                    # External method call
                                    if invocation.qualifier in local_var_map:
                                        target_class_name = local_var_map[invocation.qualifier]
                                    else:
                                        target_class_name = invocation.qualifier
                                    
                                    if target_class_name:
                                        if target_class_name == "System.out":
                                            resolved_target_package = "java.io"
                                            resolved_target_class_name = "PrintStream"
                                        else:
                                            if target_class_name in import_map:
                                                resolved_target_package = ".".join(import_map[target_class_name].split(".")[:-1])
                                            else:
                                                resolved_target_package = package_name
                                                resolved_target_class_name = target_class_name
                                else:
                                    # Same class method call
                                    resolved_target_package = package_name
                                    resolved_target_class_name = class_name

                                if resolved_target_class_name:
                                    # Get line number from invocation position
                                    line_number = invocation.position.line if invocation.position else 0

                                    call = MethodCall(
                                        source_package=package_name,
                                        source_class=class_name,
                                        source_method=declaration.name,
                                        target_package=resolved_target_package,
                                        target_class=resolved_target_class_name,
                                        target_method=invocation.member,
                                        call_order=call_order,
                                        line_number=line_number,
                                        return_type="void"  # Default return type, can be enhanced later
                                    )
                                    classes[class_key].calls.append(call)
                                    call_order += 1
                        
                        # Check for Lombok @Data annotation and generate methods
                        has_data_annotation = any(ann.name == "Data" for ann in classes[class_key].annotations)
                        if has_data_annotation:
                            logger.debug(f"Found @Data annotation on {class_name}, generating Lombok methods")
                            lombok_methods = generate_lombok_methods(classes[class_key].properties, class_name, package_name)
                            classes[class_key].methods.extend(lombok_methods)
                            logger.debug(f"Generated {len(lombok_methods)} Lombok methods for {class_name}")
                except javalang.parser.JavaSyntaxError as e:
                    print(f"Syntax error in {file_path}: {e}")
                    continue
                except Exception as e:
                    print(f"Error parsing {file_path}: {e}")
                    continue
    
    # Extract beans, analyze dependencies, extract endpoints, extract MyBatis mappers, extract JPA entities, extract config files, and extract test classes
    classes_list = list(classes.values())
    beans = extract_beans_from_classes(classes_list)
    dependencies = analyze_bean_dependencies(classes_list, beans)
    endpoints = extract_endpoints_from_classes(classes_list)
    mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
    jpa_entities = extract_jpa_entities_from_classes(classes_list)
    config_files = extract_config_files(directory)
    test_classes = extract_test_classes_from_classes(classes_list)
    
    # Also extract XML mappers
    xml_mappers = extract_mybatis_xml_mappers(directory)
    mybatis_mappers.extend(xml_mappers)
    
    # Extract SQL statements from MyBatis mappers
    sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
    
    return list(packages.values()), classes_list, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name
```

```python
import os
import yaml
import re
from pathlib import Path

import javalang

from src.models.graph_entities import Class, Method, MethodCall, Field, Package, Annotation, Bean, BeanDependency, Endpoint, MyBatisMapper, MyBatisSqlStatement, MyBatisResultMap, SqlStatement, JpaEntity, JpaColumn, JpaRelationship, ConfigFile, DatabaseConfig, ServerConfig, SecurityConfig, LoggingConfig, TestClass, TestMethod, TestConfiguration
from src.utils.logger import get_logger
from typing import Optional, List, Literal


def extract_project_name(java_source_folder: str) -> str:
    """
    JAVA_SOURCE_FOLDER 경로에서 프로젝트 이름을 추출합니다.
    
    Args:
        java_source_folder: Java 소스 폴더 경로
        
    Returns:
        프로젝트 이름 (마지막 디렉토리명)
    """
    # 경로를 정규화하고 마지막 디렉토리명 추출
    path = Path(java_source_folder).resolve()
    return path.name


def extract_sql_statements_from_mappers(mybatis_mappers: list[MyBatisMapper], project_name: str) -> list[SqlStatement]:
    """
    MyBatis mappers에서 SQL statements를 추출합니다.
    
    Args:
        mybatis_mappers: MyBatis mapper 객체들의 리스트
        project_name: 프로젝트 이름
        
    Returns:
        SqlStatement 객체들의 리스트
    """
    sql_statements = []
    
    for mapper in mybatis_mappers:
        for sql_dict in mapper.sql_statements:
            # MyBatisSqlStatement를 SqlStatement로 변환
            sql_statement = SqlStatement(
                id=sql_dict.get('id', ''),
                sql_type=sql_dict.get('sql_type', ''),
                sql_content=sql_dict.get('sql_content', ''),
                parameter_type=sql_dict.get('parameter_type', ''),
                result_type=sql_dict.get('result_type', ''),
                result_map=sql_dict.get('result_map', ''),
                mapper_name=mapper.name,
                annotations=[],  # TODO: annotations를 파싱하여 추가
                project_name=project_name
            )
            sql_statements.append(sql_statement)
    
    return sql_statements


def parse_annotations(annotations, target_type: str = "class") -> list[Annotation]:
    """Parse Java annotations into Annotation objects.
    
    Args:
        annotations: List of annotation nodes from javalang
        target_type: Type of target ("class", "method", "field")
    """
    result = []
    for annotation in annotations:
        annotation_name = annotation.name
        parameters = {}
        
        # Parse annotation parameters if they exist
        if hasattr(annotation, 'element') and annotation.element:
            for element in annotation.element:
                if hasattr(element, 'name') and hasattr(element, 'value'):
                    parameters[element.name] = element.value.value if hasattr(element.value, 'value') else str(element.value)
        
        result.append(Annotation(
            name=annotation_name,
            parameters=parameters,
            target_type=target_type,
            category=classify_springboot_annotation(annotation_name)
        ))
    
    return result


def classify_springboot_annotation(annotation_name: str) -> str:
    """Classify SpringBoot annotations into categories.
    
    Args:
        annotation_name: Name of the annotation (e.g., "@Component", "@Service")
        
    Returns:
        Category of the annotation
    """
    # Component annotations
    component_annotations = {
        "Component", "Service", "Repository", "Controller", 
        "RestController", "Configuration", "Bean"
    }
    
    # Injection annotations
    injection_annotations = {
        "Autowired", "Resource", "Value", "Qualifier", "Primary"
    }
    
    # Web annotations
    web_annotations = {
        "RequestMapping", "GetMapping", "PostMapping", "PutMapping", 
        "DeleteMapping", "PatchMapping", "RequestParam", "PathVariable",
        "RequestBody", "ResponseBody", "ResponseStatus"
    }
    
    # JPA annotations
    jpa_annotations = {
        "Entity", "Table", "Id", "Column", "OneToMany", "ManyToOne",
        "OneToOne", "ManyToMany", "JoinColumn", "GeneratedValue"
    }
    
    # Test annotations
    test_annotations = {
        "Test", "SpringBootTest", "DataJpaTest", "WebMvcTest",
        "MockBean", "SpyBean", "TestPropertySource"
    }
    
    # Security annotations
    security_annotations = {
        "PreAuthorize", "PostAuthorize", "Secured", "RolesAllowed",
        "EnableWebSecurity", "EnableGlobalMethodSecurity"
    }
    
    # Validation annotations
    validation_annotations = {
        "Valid", "NotNull", "NotBlank", "NotEmpty", "Size", "Min", "Max",
        "Pattern", "Email", "AssertTrue", "AssertFalse"
    }
    
    # MyBatis annotations
    mybatis_annotations = {
        "Mapper", "Select", "Insert", "Update", "Delete", "SelectProvider",
        "InsertProvider", "UpdateProvider", "DeleteProvider", "Results",
        "Result", "One", "Many", "MapKey", "Options", "SelectKey"
    }
    
    if annotation_name in component_annotations:
        return "component"
    elif annotation_name in injection_annotations:
        return "injection"
    elif annotation_name in web_annotations:
        return "web"
    elif annotation_name in jpa_annotations:
        return "jpa"
    elif annotation_name in test_annotations:
        return "test"
    elif annotation_name in security_annotations:
        return "security"
    elif annotation_name in validation_annotations:
        return "validation"
    elif annotation_name in mybatis_annotations:
        return "mybatis"
    else:
        return "other"


def classify_test_annotation(annotation_name: str) -> str:
    """Classify test annotations into categories.
    
    Args:
        annotation_name: Name of the annotation
        
    Returns:
        Category of the test annotation
    """
    # JUnit annotations
    junit_annotations = {
        "Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll",
        "DisplayName", "ParameterizedTest", "ValueSource", "CsvSource",
        "MethodSource", "Timeout", "Disabled", "Nested", "RepeatedTest",
        "Order", "TestMethodOrder", "TestInstance", "TestClassOrder"
    }
    
    # Spring Boot Test annotations
    spring_test_annotations = {
        "SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest",
        "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest",
        "MockBean", "SpyBean", "TestConfiguration", "ActiveProfiles",
        "TestPropertySource", "DirtiesContext", "Transactional",
        "Rollback", "Commit", "Sql", "SqlGroup", "AutoConfigureTestDatabase",
        "AutoConfigureMockMvc", "AutoConfigureWebMvc", "AutoConfigureWebClient",
        "MockMvc", "TestEntityManager", "TestContainers", "DynamicPropertySource"
    }
    
    # TestNG annotations
    testng_annotations = {
        "TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass",
        "BeforeSuite", "AfterSuite", "BeforeGroups", "AfterGroups",
        "DataProvider", "Parameters", "Groups", "Priority", "DependsOnMethods",
        "DependsOnGroups", "ExpectedExceptions", "InvocationCount",
        "SuccessPercentage", "TimeOut"
    }
    
    # Mockito annotations
    mockito_annotations = {
        "Mock", "Spy", "InjectMocks", "Captor", "MockedStatic"
    }
    
    # AssertJ annotations
    assertj_annotations = {
        "AssertJ"
    }
    
    # Other test annotations
    other_test_annotations = {
        "Ignore", "Category", "RunWith", "ExtendWith", "ContextConfiguration"
    }
    
    if annotation_name in junit_annotations:
        return "junit"
    elif annotation_name in spring_test_annotations:
        return "spring_test"
    elif annotation_name in testng_annotations:
        return "testng"
    elif annotation_name in mockito_annotations:
        return "mockito"
    elif annotation_name in assertj_annotations:
        return "assertj"
    elif annotation_name in other_test_annotations:
        return "other_test"
    else:
        return "other"


def extract_beans_from_classes(classes: list[Class]) -> list[Bean]:
    """Extract Spring Beans from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Bean objects
    """
    beans = []
    
    for cls in classes:
        # Check if class has Spring component annotations
        component_annotations = [ann for ann in cls.annotations if ann.category == "component"]
        
        # Also check for @Repository on interfaces
        has_repository_annotation = any(ann.name == "Repository" for ann in cls.annotations)
        
        if component_annotations or has_repository_annotation:
            # Determine bean type based on annotations
            bean_type = "component"  # default
            if any(ann.name in ["Service", "Service"] for ann in cls.annotations):
                bean_type = "service"
            elif any(ann.name in ["Repository", "Repository"] for ann in cls.annotations):
                bean_type = "repository"
            elif any(ann.name in ["Controller", "RestController"] for ann in cls.annotations):
                bean_type = "controller"
            elif any(ann.name in ["Configuration", "Configuration"] for ann in cls.annotations):
                bean_type = "configuration"
            
            # Determine scope (default is singleton)
            scope = "singleton"
            for ann in cls.annotations:
                if ann.name == "Scope":
                    if "value" in ann.parameters:
                        scope = ann.parameters["value"]
                    elif "prototype" in str(ann.parameters):
                        scope = "prototype"
                    elif "request" in str(ann.parameters):
                        scope = "request"
                    elif "session" in str(ann.parameters):
                        scope = "session"
            
            # Create bean name (use class name with first letter lowercase)
            bean_name = cls.name[0].lower() + cls.name[1:] if cls.name else cls.name
            
            # Check for @Bean methods in configuration classes
            bean_methods = []
            if bean_type == "configuration":
                for method in cls.methods:
                    if any(ann.name == "Bean" for ann in method.annotations):
                        bean_methods.append(method)
            
            bean = Bean(
                name=bean_name,
                type=bean_type,
                scope=scope,
                class_name=cls.name,
                package_name=cls.package_name,
                annotation_names=[ann.name for ann in cls.annotations] if cls.annotations else [],
                method_count=len(bean_methods) if bean_type == "configuration" else len(cls.methods) if cls.methods else 0,
                property_count=len(cls.properties) if cls.properties else 0
            )
            beans.append(bean)
    
    return beans


def analyze_bean_dependencies(classes: list[Class], beans: list[Bean]) -> list[BeanDependency]:
    """Analyze dependencies between Spring Beans.
    
    Args:
        classes: List of parsed Class objects
        beans: List of Bean objects
        
    Returns:
        List of BeanDependency objects
    """
    dependencies = []
    
    # Create a mapping from class names to bean names
    class_to_bean = {}
    for bean in beans:
        class_to_bean[bean.class_name] = bean.name
    
    for cls in classes:
        # Check if this class is a bean
        if cls.name not in class_to_bean:
            continue
            
        source_bean = class_to_bean[cls.name]
        
        # Analyze field injections (@Autowired, @Resource, @Value)
        for prop in cls.properties:
            if any(ann.category == "injection" for ann in prop.annotations):
                # Try to determine target bean from field type
                target_bean = None
                field_type = prop.type
                
                # Look for exact class name match
                if field_type in class_to_bean:
                    target_bean = class_to_bean[field_type]
                else:
                    # Look for interface implementations (simplified - just check if type matches any bean class name)
                    for bean in beans:
                        if field_type == bean.class_name:
                            target_bean = bean.name
                            break
                
                if target_bean:
                    injection_type = "field"
                    for ann in prop.annotations:
                        if ann.name == "Autowired":
                            injection_type = "field"
                        elif ann.name == "Resource":
                            injection_type = "field"
                        elif ann.name == "Value":
                            injection_type = "field"
                    
                    dependency = BeanDependency(
                        source_bean=source_bean,
                        target_bean=target_bean,
                        injection_type=injection_type,
                        field_name=prop.name
                    )
                    dependencies.append(dependency)
        
        # Analyze constructor injections
        for method in cls.methods:
            if method.name == cls.name:  # Constructor
                for param in method.parameters:
                    if any(ann.category == "injection" for ann in param.annotations):
                        target_bean = None
                        param_type = param.type
                        
                        if param_type in class_to_bean:
                            target_bean = class_to_bean[param_type]
                        else:
                            # Look for interface implementations (simplified)
                            for bean in beans:
                                if param_type == bean.class_name:
                                    target_bean = bean.name
                                    break
                        
                        if target_bean:
                            dependency = BeanDependency(
                                source_bean=source_bean,
                                target_bean=target_bean,
                                injection_type="constructor",
                                parameter_name=param.name
                            )
                            dependencies.append(dependency)
        
        # Analyze setter injections
        for method in cls.methods:
            if method.name.startswith("set") and len(method.parameters) == 1:
                if any(ann.category == "injection" for ann in method.annotations):
                    param = method.parameters[0]
                    target_bean = None
                    param_type = param.type
                    
                    if param_type in class_to_bean:
                        target_bean = class_to_bean[param_type]
                    else:
                        # Look for interface implementations (simplified)
                        for bean in beans:
                            if param_type == bean.class_name:
                                target_bean = bean.name
                                break
                    
                    if target_bean:
                        dependency = BeanDependency(
                            source_bean=source_bean,
                            target_bean=target_bean,
                            injection_type="setter",
                            method_name=method.name,
                            parameter_name=param.name
                        )
                        dependencies.append(dependency)
    
    return dependencies


def extract_endpoints_from_classes(classes: list[Class]) -> list[Endpoint]:
    """Extract REST API endpoints from controller classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Endpoint objects
    """
    endpoints = []
    
    for cls in classes:
        # Check if class is a controller
        is_controller = any(ann.name in ["Controller", "RestController"] for ann in cls.annotations)
        
        if not is_controller:
            continue
            
        # Get class-level path mapping
        class_path = ""
        for ann in cls.annotations:
            if ann.name == "RequestMapping":
                if "value" in ann.parameters:
                    class_path = ann.parameters["value"]
                break
        
        # Process each method in the controller
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
                
            # Check if method has web mapping annotations
            web_annotations = [ann for ann in method.annotations if ann.category == "web"]
            
            if not web_annotations:
                continue
            
            # Extract endpoint information
            endpoint_path = ""
            http_method = "GET"  # default
            
            for ann in web_annotations:
                if ann.name in ["RequestMapping", "GetMapping", "PostMapping", "PutMapping", "DeleteMapping", "PatchMapping"]:
                    # Extract path
                    if "value" in ann.parameters:
                        endpoint_path = ann.parameters["value"]
                    elif "path" in ann.parameters:
                        endpoint_path = ann.parameters["path"]
                    
                    # Extract HTTP method
                    if ann.name == "GetMapping":
                        http_method = "GET"
                    elif ann.name == "PostMapping":
                        http_method = "POST"
                    elif ann.name == "PutMapping":
                        http_method = "PUT"
                    elif ann.name == "DeleteMapping":
                        http_method = "DELETE"
                    elif ann.name == "PatchMapping":
                        http_method = "PATCH"
                    elif ann.name == "RequestMapping":
                        if "method" in ann.parameters:
                            method_value = ann.parameters["method"]
                            if isinstance(method_value, list) and len(method_value) > 0:
                                http_method = method_value[0]
                            else:
                                http_method = str(method_value)
                        else:
                            http_method = "GET"  # default for RequestMapping
                    break
            
            # Build full path
            full_path = class_path
            if endpoint_path:
                if full_path and not full_path.endswith("/") and not endpoint_path.startswith("/"):
                    full_path += "/"
                full_path += endpoint_path
            elif not full_path:
                full_path = "/"
            
            # Extract method parameters
            parameters = []
            for param in method.parameters:
                param_info = {
                    "name": param.name,
                    "type": param.type,
                    "annotations": [ann.name for ann in param.annotations if ann.category == "web"]
                }
                parameters.append(param_info)
            
            # Extract return type
            return_type = method.return_type if method.return_type != "constructor" else "void"
            
            # Create endpoint
            endpoint = Endpoint(
                path=endpoint_path or "/",
                method=http_method,
                controller_class=cls.name,
                handler_method=method.name,
                parameters=parameters,
                return_type=return_type,
                annotations=[ann.name for ann in web_annotations],
                full_path=full_path
            )
            endpoints.append(endpoint)
    
    return endpoints


def extract_mybatis_mappers_from_classes(classes: list[Class]) -> list[MyBatisMapper]:
    """Extract MyBatis Mappers from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for cls in classes:
        # Check if class is a MyBatis Mapper interface
        is_mapper = any(ann.name == "Mapper" for ann in cls.annotations)
        
        if not is_mapper:
            continue
        
        # Extract mapper methods with MyBatis annotations
        mapper_methods = []
        sql_statements = []
        
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
            
            # Check if method has MyBatis annotations
            mybatis_annotations = [ann for ann in method.annotations if ann.category == "mybatis"]
            
            if not mybatis_annotations:
                continue
            
            # Extract SQL statement information
            sql_type = "SELECT"  # default
            sql_content = ""
            parameter_type = ""
            result_type = ""
            result_map = ""
            
            for ann in mybatis_annotations:
                if ann.name in ["Select", "SelectProvider"]:
                    sql_type = "SELECT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Insert", "InsertProvider"]:
                    sql_type = "INSERT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Update", "UpdateProvider"]:
                    sql_type = "UPDATE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Delete", "DeleteProvider"]:
                    sql_type = "DELETE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                
                # Extract parameter and result type information
                if "parameterType" in ann.parameters:
                    parameter_type = ann.parameters["parameterType"]
                if "resultType" in ann.parameters:
                    result_type = ann.parameters["resultType"]
                if "resultMap" in ann.parameters:
                    result_map = ann.parameters["resultMap"]
            
            # Create method info
            method_info = {
                "name": method.name,
                "return_type": method.return_type,
                "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            mapper_methods.append(method_info)
            
            # Create SQL statement info
            sql_statement = {
                "id": method.name,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            sql_statements.append(sql_statement)
        
        # Create mapper
        mapper = MyBatisMapper(
            name=cls.name,
            type="interface",
            namespace=f"{cls.package_name}.{cls.name}",
            methods=mapper_methods,
            sql_statements=sql_statements,
            file_path=cls.file_path,
            package_name=cls.package_name
        )
        mappers.append(mapper)
    
    return mappers


def parse_mybatis_xml_file(file_path: str) -> MyBatisMapper:
    """Parse MyBatis XML mapper file.
    
    Args:
        file_path: Path to the XML mapper file
        
    Returns:
        MyBatisMapper object
    """
    import xml.etree.ElementTree as ET
    
    try:
        tree = ET.parse(file_path)
        root = tree.getroot()
        
        # Extract namespace
        namespace = root.get("namespace", "")
        
        # Extract SQL statements
        sql_statements = []
        for statement in root.findall(".//*[@id]"):
            statement_id = statement.get("id")
            tag_name = statement.tag.lower()
            
            # Determine SQL type
            sql_type = "SELECT"
            if tag_name == "insert":
                sql_type = "INSERT"
            elif tag_name == "update":
                sql_type = "UPDATE"
            elif tag_name == "delete":
                sql_type = "DELETE"
            
            # Extract SQL content
            sql_content = statement.text.strip() if statement.text else ""
            
            # Extract parameter and result information
            parameter_type = statement.get("parameterType", "")
            result_type = statement.get("resultType", "")
            result_map = statement.get("resultMap", "")
            
            sql_statement = {
                "id": statement_id,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": []
            }
            sql_statements.append(sql_statement)
        
        # Extract ResultMaps
        result_maps = []
        for result_map in root.findall(".//resultMap"):
            result_map_id = result_map.get("id")
            result_map_type = result_map.get("type", "")
            
            properties = []
            for property_elem in result_map.findall(".//result"):
                prop = {
                    "property": property_elem.get("property", ""),
                    "column": property_elem.get("column", ""),
                    "jdbc_type": property_elem.get("jdbcType", "")
                }
                properties.append(prop)
            
            result_map_info = {
                "id": result_map_id,
                "type": result_map_type,
                "properties": properties,
                "associations": [],
                "collections": []
            }
            result_maps.append(result_map_info)
        
        # Create mapper
        mapper_name = namespace.split(".")[-1] if namespace else os.path.basename(file_path).replace(".xml", "")
        package_name = ".".join(namespace.split(".")[:-1]) if namespace else ""
        
        mapper = MyBatisMapper(
            name=mapper_name,
            type="xml",
            namespace=namespace,
            methods=[],  # XML mappers don't have Java methods
            sql_statements=sql_statements,
            file_path=file_path,
            package_name=package_name
        )
        
        return mapper
        
    except ET.ParseError as e:
        print(f"Error parsing XML file {file_path}: {e}")
        return None
    except Exception as e:
        print(f"Error reading XML file {file_path}: {e}")
        return None


def extract_mybatis_xml_mappers(directory: str) -> list[MyBatisMapper]:
    """Extract MyBatis XML mappers from directory.
    
    Args:
        directory: Directory to search for XML mapper files
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith("Mapper.xml") or file.endswith("Dao.xml"):
                file_path = os.path.join(root, file)
                mapper = parse_mybatis_xml_file(file_path)
                if mapper:
                    mappers.append(mapper)
    
    return mappers


def extract_jpa_entities_from_classes(classes: list[Class]) -> list[JpaEntity]:
    """Extract JPA Entities from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of JpaEntity objects
    """
    entities = []
    
    for cls in classes:
        # Check if class is a JPA Entity
        is_entity = any(ann.name == "Entity" for ann in cls.annotations)
        
        if not is_entity:
            continue
        
        # Extract table name
        table_name = cls.name.lower()  # default table name
        for ann in cls.annotations:
            if ann.name == "Table":
                if "name" in ann.parameters:
                    table_name = ann.parameters["name"]
                break
        
        # Extract columns from properties
        columns = []
        relationships = []
        
        for prop in cls.properties:
            # Check if property has JPA column annotations
            jpa_annotations = [ann for ann in prop.annotations if ann.category == "jpa"]
            
            if jpa_annotations:
                # Extract column information
                column_name = prop.name  # default column name
                nullable = True
                unique = False
                length = 0
                precision = 0
                scale = 0
                
                for ann in jpa_annotations:
                    if ann.name == "Column":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                        if "nullable" in ann.parameters:
                            nullable = ann.parameters["nullable"]
                        if "unique" in ann.parameters:
                            unique = ann.parameters["unique"]
                        if "length" in ann.parameters:
                            length = ann.parameters["length"]
                        if "precision" in ann.parameters:
                            precision = ann.parameters["precision"]
                        if "scale" in ann.parameters:
                            scale = ann.parameters["scale"]
                    elif ann.name == "Id":
                        column_name = "id"  # Primary key column
                        nullable = False
                        unique = True
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                
                # Check for relationship annotations
                relationship_type = None
                target_entity = ""
                mapped_by = ""
                join_column = ""
                join_table = ""
                cascade = []
                fetch = "LAZY"
                
                for ann in jpa_annotations:
                    if ann.name in ["OneToOne", "OneToMany", "ManyToOne", "ManyToMany"]:
                        relationship_type = ann.name
                        if "targetEntity" in ann.parameters:
                            target_entity = ann.parameters["targetEntity"]
                        if "mappedBy" in ann.parameters:
                            mapped_by = ann.parameters["mappedBy"]
                        if "cascade" in ann.parameters:
                            cascade = ann.parameters["cascade"] if isinstance(ann.parameters["cascade"], list) else [ann.parameters["cascade"]]
                        if "fetch" in ann.parameters:
                            fetch = ann.parameters["fetch"]
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            join_column = ann.parameters["name"]
                    elif ann.name == "JoinTable":
                        if "name" in ann.parameters:
                            join_table = ann.parameters["name"]
                
                # Create column info
                column_info = {
                    "property_name": prop.name,
                    "column_name": column_name,
                    "data_type": prop.type,
                    "nullable": nullable,
                    "unique": unique,
                    "length": length,
                    "precision": precision,
                    "scale": scale,
                    "annotations": [ann.name for ann in jpa_annotations]
                }
                columns.append(column_info)
                
                # Create relationship info if it's a relationship
                if relationship_type:
                    relationship_info = {
                        "type": relationship_type,
                        "target_entity": target_entity,
                        "mapped_by": mapped_by,
                        "join_column": join_column,
                        "join_table": join_table,
                        "cascade": cascade,
                        "fetch": fetch,
                        "annotations": [ann.name for ann in jpa_annotations]
                    }
                    relationships.append(relationship_info)
        
        # Create entity
        entity = JpaEntity(
            name=cls.name,
            table_name=table_name,
            columns=columns,
            relationships=relationships,
            annotations=[ann.name for ann in cls.annotations if ann.category == "jpa"],
            package_name=cls.package_name,
            file_path=cls.file_path
        )
        entities.append(entity)
    
    return entities


def parse_yaml_config(file_path: str) -> ConfigFile:
    """Parse YAML configuration file.
    
    Args:
        file_path: Path to the YAML file
        
    Returns:
        ConfigFile object
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = yaml.safe_load(f)
        
        if not content:
            content = {}
        
        # Extract file info
        file_name = os.path.basename(file_path)
        file_type = "yaml" if file_path.endswith('.yaml') else "yml"
        
        # Extract profiles
        profiles = []
        if 'spring' in content and 'profiles' in content['spring']:
            if 'active' in content['spring']['profiles']:
                profiles = content['spring']['profiles']['active']
                if isinstance(profiles, str):
                    profiles = [profiles]
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        # Extract sections
        sections = []
        for key, value in content.items():
            if isinstance(value, dict):
                sections.append({
                    "name": key,
                    "properties": value,
                    "type": "section"
                })
        
        return ConfigFile(
            name=file_name,
            file_path=file_path,
            file_type=file_type,
            properties=content,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing YAML file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="yaml",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def parse_properties_config(file_path: str) -> ConfigFile:
    """Parse Properties configuration file.
    
    Args:
        file_path: Path to the properties file
        
    Returns:
        ConfigFile object
    """
    try:
        properties = {}
        sections = []
        profiles = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                
                # Skip empty lines and comments
                if not line or line.startswith('#'):
                    continue
                
                # Parse key=value pairs
                if '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    
                    # Remove quotes if present
                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]
                    elif value.startswith("'") and value.endswith("'"):
                        value = value[1:-1]
                    
                    properties[key] = value
                    
                    # Check for profiles
                    if key == 'spring.profiles.active':
                        profiles = [p.strip() for p in value.split(',')]
        
        # Group properties by section
        section_map = {}
        for key, value in properties.items():
            if '.' in key:
                section = key.split('.')[0]
                if section not in section_map:
                    section_map[section] = {}
                section_map[section][key] = value
            else:
                if 'root' not in section_map:
                    section_map['root'] = {}
                section_map['root'][key] = value
        
        for section_name, section_props in section_map.items():
            sections.append({
                "name": section_name,
                "properties": section_props,
                "type": "section"
            })
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties=properties,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing Properties file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def extract_database_config(config_file: ConfigFile) -> DatabaseConfig:
    """Extract database configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        DatabaseConfig object
    """
    db_config = DatabaseConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        spring_config = config_file.properties.get('spring', {})
        datasource_config = spring_config.get('datasource', {})
        jpa_config = spring_config.get('jpa', {})
        
        db_config.driver = datasource_config.get('driver-class-name', '')
        db_config.url = datasource_config.get('url', '')
        db_config.username = datasource_config.get('username', '')
        db_config.password = datasource_config.get('password', '')
        db_config.dialect = jpa_config.get('database-platform', '')
        db_config.hibernate_ddl_auto = jpa_config.get('hibernate', {}).get('ddl-auto', '')
        db_config.show_sql = jpa_config.get('show-sql', False)
        db_config.format_sql = jpa_config.get('properties', {}).get('hibernate', {}).get('format_sql', False)
        
        # Store additional JPA properties
        if 'properties' in jpa_config:
            db_config.jpa_properties = jpa_config['properties']
    
    else:
        # Properties format
        props = config_file.properties
        
        db_config.driver = props.get('spring.datasource.driver-class-name', '')
        db_config.url = props.get('spring.datasource.url', '')
        db_config.username = props.get('spring.datasource.username', '')
        db_config.password = props.get('spring.datasource.password', '')
        db_config.dialect = props.get('spring.jpa.database-platform', '')
        db_config.hibernate_ddl_auto = props.get('spring.jpa.hibernate.ddl-auto', '')
        db_config.show_sql = props.get('spring.jpa.show-sql', 'false').lower() == 'true'
        db_config.format_sql = props.get('spring.jpa.properties.hibernate.format_sql', 'false').lower() == 'true'
        
        # Store additional JPA properties
        jpa_props = {}
        for key, value in props.items():
            if key.startswith('spring.jpa.properties.'):
                jpa_props[key] = value
        db_config.jpa_properties = jpa_props
    
    return db_config


def extract_server_config(config_file: ConfigFile) -> ServerConfig:
    """Extract server configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        ServerConfig object
    """
    server_config = ServerConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        server_props = config_file.properties.get('server', {})
        
        server_config.port = server_props.get('port', 8080)
        server_config.context_path = server_props.get('servlet', {}).get('context-path', '')
        server_config.servlet_path = server_props.get('servlet', {}).get('path', '')
        
        # SSL configuration
        ssl_config = server_props.get('ssl', {})
        server_config.ssl_enabled = bool(ssl_config)
        server_config.ssl_key_store = ssl_config.get('key-store', '')
        server_config.ssl_key_store_password = ssl_config.get('key-store-password', '')
        server_config.ssl_key_store_type = ssl_config.get('key-store-type', '')
    
    else:
        # Properties format
        props = config_file.properties
        
        server_config.port = int(props.get('server.port', '8080'))
        server_config.context_path = props.get('server.servlet.context-path', '')
        server_config.servlet_path = props.get('server.servlet.path', '')
        
        # SSL configuration
        server_config.ssl_enabled = any(key.startswith('server.ssl.') for key in props.keys())
        server_config.ssl_key_store = props.get('server.ssl.key-store', '')
        server_config.ssl_key_store_password = props.get('server.ssl.key-store-password', '')
        server_config.ssl_key_store_type = props.get('server.ssl.key-store-type', '')
    
    return server_config


def extract_security_config(config_file: ConfigFile) -> SecurityConfig:
    """Extract security configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        SecurityConfig object
    """
    security_config = SecurityConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        security_props = config_file.properties.get('security', {})
        jwt_props = security_props.get('jwt', {})
        cors_props = security_props.get('cors', {})
        
        security_config.enabled = bool(security_props)
        security_config.authentication_type = security_props.get('authentication-type', '')
        security_config.jwt_secret = jwt_props.get('secret', '')
        security_config.jwt_expiration = jwt_props.get('expiration', 0)
        security_config.cors_allowed_origins = cors_props.get('allowed-origins', [])
        security_config.cors_allowed_methods = cors_props.get('allowed-methods', [])
        security_config.cors_allowed_headers = cors_props.get('allowed-headers', [])
    
    else:
        # Properties format
        props = config_file.properties
        
        security_config.enabled = any(key.startswith('security.') for key in props.keys())
        security_config.authentication_type = props.get('security.authentication-type', '')
        security_config.jwt_secret = props.get('security.jwt.secret', '')
        security_config.jwt_expiration = int(props.get('security.jwt.expiration', '0'))
        
        # CORS configuration
        origins = props.get('security.cors.allowed-origins', '')
        if origins:
            security_config.cors_allowed_origins = [o.strip() for o in origins.split(',')]
        
        methods = props.get('security.cors.allowed-methods', '')
        if methods:
            security_config.cors_allowed_methods = [m.strip() for m in methods.split(',')]
        
        headers = props.get('security.cors.allowed-headers', '')
        if headers:
            security_config.cors_allowed_headers = [h.strip() for h in headers.split(',')]
    
    return security_config


def extract_logging_config(config_file: ConfigFile) -> LoggingConfig:
    """Extract logging configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        LoggingConfig object
    """
    logging_config = LoggingConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        logging_props = config_file.properties.get('logging', {})
        
        logging_config.level = logging_props.get('level', {}).get('root', 'INFO')
        logging_config.pattern = logging_props.get('pattern', {}).get('console', '')
        logging_config.file_path = logging_props.get('file', {}).get('name', '')
        logging_config.max_file_size = logging_props.get('file', {}).get('max-size', '')
        logging_config.max_history = logging_props.get('file', {}).get('max-history', 0)
        logging_config.console_output = logging_props.get('console', {}).get('enabled', True)
    
    else:
        # Properties format
        props = config_file.properties
        
        logging_config.level = props.get('logging.level.root', 'INFO')
        logging_config.pattern = props.get('logging.pattern.console', '')
        logging_config.file_path = props.get('logging.file.name', '')
        logging_config.max_file_size = props.get('logging.file.max-size', '')
        logging_config.max_history = int(props.get('logging.file.max-history', '0'))
        logging_config.console_output = props.get('logging.console.enabled', 'true').lower() == 'true'
    
    return logging_config


def extract_config_files(directory: str) -> list[ConfigFile]:
    """Extract configuration files from directory.
    
    Args:
        directory: Directory to search for config files
        
    Returns:
        List of ConfigFile objects
    """
    config_files = []
    
    # Common config file patterns
    config_patterns = [
        "application.yml",
        "application.yaml", 
        "application.properties",
        "application-*.properties",
        "bootstrap.yml",
        "bootstrap.yaml",
        "bootstrap.properties"
    ]
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            # Check if file matches any config pattern
            is_config_file = False
            for pattern in config_patterns:
                if pattern == file or (pattern.endswith('*') and file.startswith(pattern[:-1])):
                    is_config_file = True
                    break
            
            if is_config_file:
                file_path = os.path.join(root, file)
                
                if file.endswith(('.yml', '.yaml')):
                    config_file = parse_yaml_config(file_path)
                elif file.endswith('.properties'):
                    config_file = parse_properties_config(file_path)
                else:
                    continue
                
                config_files.append(config_file)
    
    return config_files


def extract_test_classes_from_classes(classes: list[Class]) -> list[TestClass]:
    """Extract test classes from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of TestClass objects
    """
    test_classes = []
    
    for cls in classes:
        # Check if class is a test class
        test_annotations = [ann for ann in cls.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
        
        if not test_annotations:
            continue
        
        # Determine test framework and type
        test_framework = "junit"  # default
        test_type = "unit"  # default
        
        for ann in test_annotations:
            if ann.name in ["SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest", "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest"]:
                test_framework = "spring_test"
                if ann.name == "SpringBootTest":
                    test_type = "integration"
                else:
                    test_type = "slice"
            elif ann.name in ["TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass"]:
                test_framework = "testng"
            elif ann.name in ["Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll"]:
                test_framework = "junit"
        
        # Extract test methods
        test_methods = []
        setup_methods = []
        
        for method in cls.methods:
            method_annotations = [ann.name for ann in method.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
            
            if method_annotations:
                # Check if it's a setup/teardown method
                if any(ann in method_annotations for ann in ["BeforeEach", "AfterEach", "BeforeAll", "AfterAll", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass", "BeforeSuite", "AfterSuite"]):
                    setup_methods.append({
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters]
                    })
                else:
                    # Regular test method
                    test_method_info = {
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                        "assertions": [],
                        "mock_calls": [],
                        "test_data": [],
                        "expected_exceptions": [],
                        "timeout": 0,
                        "display_name": ""
                    }
                    
                    # Extract display name
                    for ann in method.annotations:
                        if ann.name == "DisplayName" and "value" in ann.parameters:
                            test_method_info["display_name"] = ann.parameters["value"]
                        elif ann.name == "Timeout" and "value" in ann.parameters:
                            test_method_info["timeout"] = ann.parameters["value"]
                    
                    # Extract expected exceptions
                    for ann in method.annotations:
                        if ann.name == "ExpectedExceptions" and "value" in ann.parameters:
                            test_method_info["expected_exceptions"] = ann.parameters["value"] if isinstance(ann.parameters["value"], list) else [ann.parameters["value"]]
                    
                    test_methods.append(test_method_info)
        
        # Extract mock dependencies
        mock_dependencies = []
        for prop in cls.properties:
            prop_annotations = [ann.name for ann in prop.annotations if classify_test_annotation(ann.name) in ["mockito", "spring_test"]]
            if prop_annotations:
                mock_dependencies.append({
                    "name": prop.name,
                    "type": prop.type,
                    "annotations": prop_annotations,
                    "mock_type": "mock" if "Mock" in prop_annotations else "spy" if "Spy" in prop_annotations else "bean"
                })
        
        # Extract test configurations
        test_configurations = []
        for ann in cls.annotations:
            if ann.name in ["TestConfiguration", "ActiveProfiles", "TestPropertySource"]:
                config_info = {
                    "name": ann.name,
                    "type": "configuration" if ann.name == "TestConfiguration" else "profile" if ann.name == "ActiveProfiles" else "property",
                    "properties": ann.parameters,
                    "active_profiles": ann.parameters.get("value", []) if ann.name == "ActiveProfiles" else [],
                    "test_slices": [],
                    "mock_beans": [],
                    "spy_beans": []
                }
                test_configurations.append(config_info)
        
        # Create test class
        test_class = TestClass(
            name=cls.name,
            package_name=cls.package_name,
            test_framework=test_framework,
            test_type=test_type,
            annotations=[ann.name for ann in test_annotations],
            test_methods=test_methods,
            setup_methods=setup_methods,
            mock_dependencies=mock_dependencies,
            test_configurations=test_configurations,
            file_path=cls.file_path
        )
        test_classes.append(test_class)
    
    return test_classes


def analyze_test_methods(test_class: TestClass, class_obj: Class) -> list[TestMethod]:
    """Analyze test methods for assertions, mock calls, and test data.
    
    Args:
        test_class: TestClass object
        class_obj: Original Class object
        
    Returns:
        List of analyzed TestMethod objects
    """
    test_methods = []
    
    for method_info in test_class.test_methods:
        # Find the corresponding method in the class
        method_obj = None
        for method in class_obj.methods:
            if method.name == method_info["name"]:
                method_obj = method
                break
        
        if not method_obj:
            continue
        
        # Analyze method source code for assertions and mock calls
        assertions = []
        mock_calls = []
        test_data = []
        
        if method_obj.source:
            source_code = method_obj.source
            
            # Find assertions (JUnit, AssertJ, etc.)
            assertion_patterns = [
                r'assert\w+\(',  # JUnit assertions
                r'assertThat\(',  # AssertJ
                r'assertEquals\(',  # JUnit
                r'assertTrue\(',  # JUnit
                r'assertFalse\(',  # JUnit
                r'assertNotNull\(',  # JUnit
                r'assertNull\(',  # JUnit
                r'assertThrows\(',  # JUnit 5
                r'assertDoesNotThrow\(',  # JUnit 5
                r'verify\(',  # Mockito verify
                r'when\(',  # Mockito when
                r'then\(',  # Mockito then
                r'given\(',  # BDDMockito given
                r'willReturn\(',  # Mockito willReturn
                r'willThrow\(',  # Mockito willThrow
            ]
            
            for pattern in assertion_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    assertions.append({
                        "type": match,
                        "line": source_code.find(match) + 1
                    })
            
            # Find mock calls
            mock_call_patterns = [
                r'(\w+)\.(\w+)\(',  # Method calls on objects
                r'mock\(',  # Mockito mock creation
                r'spy\(',  # Mockito spy creation
                r'@Mock\s+(\w+)',  # @Mock annotation
                r'@Spy\s+(\w+)',  # @Spy annotation
                r'@InjectMocks\s+(\w+)',  # @InjectMocks annotation
            ]
            
            for pattern in mock_call_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        mock_calls.append({
                            "object": match[0],
                            "method": match[1],
                            "type": "method_call"
                        })
                    else:
                        mock_calls.append({
                            "type": match,
                            "line": source_code.find(match) + 1
                        })
            
            # Find test data setup
            test_data_patterns = [
                r'new\s+(\w+)\(',  # Object creation
                r'(\w+)\s*=\s*new\s+(\w+)\(',  # Variable assignment with new
                r'@ValueSource\(',  # JUnit 5 @ValueSource
                r'@CsvSource\(',  # JUnit 5 @CsvSource
                r'@MethodSource\(',  # JUnit 5 @MethodSource
            ]
            
            for pattern in test_data_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        test_data.append({
                            "variable": match[0],
                            "type": match[1],
                            "pattern": "object_creation"
                        })
                    else:
                        test_data.append({
                            "type": match,
                            "pattern": "annotation"
                        })
        
        # Create TestMethod object
        test_method = TestMethod(
            name=method_info["name"],
            return_type=method_info["return_type"],
            annotations=method_info["annotations"],
            assertions=assertions,
            mock_calls=mock_calls,
            test_data=test_data,
            expected_exceptions=method_info["expected_exceptions"],
            timeout=method_info["timeout"],
            display_name=method_info["display_name"]
        )
        test_methods.append(test_method)
    
    return test_methods


def generate_lombok_methods(properties: list[Field], class_name: str, package_name: str) -> list[Method]:
    """Generate Lombok @Data methods (getters, setters, equals, hashCode, toString) for properties."""
    methods = []
    
    # Generate getters and setters for each property
    for prop in properties:
        # Getter
        getter_name = f"get{prop.name[0].upper()}{prop.name[1:]}"
        if prop.type == "Boolean" and prop.name.startswith("is"):
            # For boolean fields starting with 'is', use the field name as getter
            getter_name = prop.name
        
        getter = Method(
            name=getter_name,
            logical_name=f"{package_name}.{class_name}.{getter_name}",
            return_type=prop.type,
            parameters=[],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[],
            description=f"Generated getter for {prop.name} field"  # Generated method description
        )
        methods.append(getter)
        
        # Setter
        setter_name = f"set{prop.name[0].upper()}{prop.name[1:]}"
        setter_param = Field(
            name=prop.name,
            logical_name=f"{package_name}.{class_name}.{prop.name}",
            type=prop.type,
            package_name=package_name,
            class_name=class_name
        )
        
        setter = Method(
            name=setter_name,
            logical_name=f"{package_name}.{class_name}.{setter_name}",
            return_type="void",
            parameters=[setter_param],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[],
            description=f"Generated setter for {prop.name} field"  # Generated method description
        )
        methods.append(setter)
    
    # Generate equals method
    equals_method = Method(
        name="equals",
        logical_name=f"{package_name}.{class_name}.equals",
        return_type="boolean",
        parameters=[Field(name="obj", logical_name=f"{package_name}.{class_name}.obj", type="Object", package_name=package_name, class_name=class_name)],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated equals method for object comparison"  # Generated method description
    )
    methods.append(equals_method)
    
    # Generate hashCode method
    hashcode_method = Method(
        name="hashCode",
        logical_name=f"{package_name}.{class_name}.hashCode",
        return_type="int",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(hashcode_method)
    
    # Generate toString method
    tostring_method = Method(
        name="toString",
        logical_name=f"{package_name}.{class_name}.toString",
        return_type="String",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(tostring_method)
    
    return methods


def parse_java_project(directory: str) -> tuple[list[Package], list[Class], dict[str, str], list[Bean], list[BeanDependency], list[Endpoint], list[MyBatisMapper], list[JpaEntity], list[ConfigFile], list[TestClass], list[SqlStatement], str]:
    """Parse Java project and return parsed entities."""
    logger = get_logger(__name__)
    """Parses all Java files in a directory and returns a tuple of (packages, classes, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name)."""
    
    # Extract project name from directory path
    project_name = extract_project_name(directory)
    packages = {}
    classes = {}
    class_to_package_map = {}  # Maps class_key to package_name

    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith(".java"):
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    file_content = f.read() # Read file content once
                try:
                    tree = javalang.parse.parse(file_content)
                    package_name = tree.package.name if tree.package else ""
                    
                    # Create or update package node
                    if package_name and package_name not in packages:
                        packages[package_name] = Package(
                            name=package_name
                        )
                    elif not package_name:
                        # Handle classes without package (default package)
                        package_name = "default"
                        if package_name not in packages:
                            packages[package_name] = Package(
                                name=package_name
                            )
                    
                    import_map = {}
                    for imp in tree.imports:
                        class_name = imp.path.split('.')[-1]
                        import_map[class_name] = imp.path

                    for _, class_declaration in tree.filter(
                        javalang.tree.ClassDeclaration
                    ):
                        class_name = class_declaration.name
                        class_key = f"{package_name}.{class_name}"
                        
                        # Debug: Check if this is the User class
                        if "User" in class_name:
                            logger.debug(f"Found User class - {class_key}")
                            logger.debug(f"Methods count: {len(class_declaration.methods)}")
                            logger.debug(f"Constructors count: {len(class_declaration.constructors)}")
                        
                        # Extract class source code - use the entire file content
                        class_source = file_content


                        if class_key not in classes:
                            # Parse class annotations
                            class_annotations = parse_annotations(class_declaration.annotations, "class") if hasattr(class_declaration, 'annotations') else []
                            
                            classes[class_key] = Class(
                                name=class_name,
                                logical_name=class_key,  # Add logical_name
                                file_path=file_path,
                                type="class", # Simplified for now
                                source=class_source, # Add class source
                                annotations=class_annotations,
                                package_name=package_name
                            )
                            class_to_package_map[class_key] = package_name
                        
                        # --- Start of new import logic ---
                        for imp in tree.imports:
                            classes[class_key].imports.append(imp.path)
                        # --- End of new import logic ---

                        # --- Start of new inheritance logic ---
                        # Handle 'extends'
                        if class_declaration.extends:
                            superclass_name = class_declaration.extends.name
                            # Try to resolve fully qualified name for superclass
                            if superclass_name in import_map:
                                classes[class_key].superclass = import_map[superclass_name]
                            else:
                                # Assume same package or fully qualified if not in import_map
                                classes[class_key].superclass = f"{package_name}.{superclass_name}" if package_name else superclass_name

                        # Handle 'implements'
                        if class_declaration.implements: # Add this check
                            for impl_ref in class_declaration.implements:
                                interface_name = impl_ref.name
                                # Try to resolve fully qualified name for interface
                                if interface_name in import_map:
                                    classes[class_key].interfaces.append(import_map[interface_name])
                                else:
                                    # Assume same package or fully qualified if not in import_map
                                    classes[class_key].interfaces.append(f"{package_name}.{interface_name}" if package_name else interface_name)
                        # --- End of new inheritance logic ---

                        field_map = {}
                        for field_declaration in class_declaration.fields:
                            for declarator in field_declaration.declarators:
                                field_map[declarator.name] = field_declaration.type.name
                                
                                # Parse field annotations
                                field_annotations = parse_annotations(field_declaration.annotations, "field") if hasattr(field_declaration, 'annotations') else []
                                
                                # Extract initial value if present
                                initial_value = ""
                                if hasattr(declarator, 'initializer') and declarator.initializer:
                                    # Convert the initializer to string representation
                                    if hasattr(declarator.initializer, 'value'):
                                        initial_value = str(declarator.initializer.value)
                                    elif hasattr(declarator.initializer, 'type'):
                                        initial_value = str(declarator.initializer.type)
                                    else:
                                        initial_value = str(declarator.initializer)
                                
                                prop = Field(
                                    name=declarator.name,
                                    logical_name=f"{package_name}.{class_name}.{declarator.name}",
                                    type=field_declaration.type.name,
                                    modifiers=list(field_declaration.modifiers), # Add modifiers
                                    package_name=package_name,
                                    class_name=class_name,
                                    annotations=field_annotations,
                                    initial_value=initial_value,
                                    description=""  # TODO: Extract description from comments or annotations
                                )
                                classes[class_key].properties.append(prop)

                        all_declarations = class_declaration.methods + class_declaration.constructors
                        
                        # Debug: Check User class method processing
                        if "User" in class_name:
                            logger.debug(f"Processing User class methods - total declarations: {len(all_declarations)}")
                            for i, decl in enumerate(all_declarations):
                                logger.debug(f"Declaration {i}: {type(decl).__name__} - {decl.name}")
                        
                        for declaration in all_declarations:
                            local_var_map = field_map.copy()
                            params = []
                            for param in declaration.parameters:
                                param_type_name = 'Unknown'
                                if hasattr(param.type, 'name'):
                                    param_type_name = param.type.name
                                local_var_map[param.name] = param_type_name
                                params.append(Field(name=param.name, logical_name=f"{package_name}.{class_name}.{param.name}", type=param_type_name, package_name=package_name, class_name=class_name))

                            if declaration.body:
                                for _, var_decl in declaration.filter(javalang.tree.LocalVariableDeclaration):
                                    for declarator in var_decl.declarators:
                                        local_var_map[declarator.name] = var_decl.type.name
                            
                            if isinstance(declaration, javalang.tree.MethodDeclaration):
                                return_type = declaration.return_type.name if declaration.return_type else "void"
                            else: # ConstructorDeclaration
                                return_type = "constructor"

                            # Extract modifiers
                            modifiers = list(declaration.modifiers)
                            
                            # Parse method annotations
                            method_annotations = parse_annotations(declaration.annotations, "method") if hasattr(declaration, 'annotations') else []

                            # Extract method source code
                            method_source = ""
                            if declaration.position:
                                lines = file_content.splitlines(keepends=True) # Keep line endings
                                start_line = declaration.position.line - 1
                                
                                # Find the end of the method by matching braces
                                brace_count = 0
                                end_line = start_line
                                for i in range(start_line, len(lines)):
                                    line = lines[i]
                                    for char in line:
                                        if char == '{':
                                            brace_count += 1
                                        elif char == '}':
                                            brace_count -= 1
                                            if brace_count == 0:
                                                end_line = i
                                                break
                                    if brace_count == 0:
                                        break
                                
                                method_source = "".join(lines[start_line:end_line + 1])

                            method = Method(
                                name=declaration.name,
                                logical_name=f"{class_key}.{declaration.name}",  # Add logical_name
                                return_type=return_type,
                                parameters=params,
                                modifiers=modifiers,
                                source=method_source, # Add method source
                                package_name=package_name,
                                annotations=method_annotations
                            )
                            classes[class_key].methods.append(method)

                            # Extract method calls with order information
                            call_order = 0
                            for _, invocation in declaration.filter(javalang.tree.MethodInvocation):
                                target_class_name = None
                                resolved_target_package = ""
                                resolved_target_class_name = ""
                                
                                if invocation.qualifier:
                                    # External method call
                                    if invocation.qualifier in local_var_map:
                                        target_class_name = local_var_map[invocation.qualifier]
                                    else:
                                        target_class_name = invocation.qualifier
                                    
                                    if target_class_name:
                                        if target_class_name == "System.out":
                                            resolved_target_package = "java.io"
                                            resolved_target_class_name = "PrintStream"
                                        else:
                                            if target_class_name in import_map:
                                                resolved_target_package = ".".join(import_map[target_class_name].split(".")[:-1])
                                            else:
                                                resolved_target_package = package_name
                                                resolved_target_class_name = target_class_name
                                else:
                                    # Same class method call
                                    resolved_target_package = package_name
                                    resolved_target_class_name = class_name

                                if resolved_target_class_name:
                                    # Get line number from invocation position
                                    line_number = invocation.position.line if invocation.position else 0

                                    call = MethodCall(
                                        source_package=package_name,
                                        source_class=class_name,
                                        source_method=declaration.name,
                                        target_package=resolved_target_package,
                                        target_class=resolved_target_class_name,
                                        target_method=invocation.member,
                                        call_order=call_order,
                                        line_number=line_number,
                                        return_type="void"  # Default return type, can be enhanced later
                                    )
                                    classes[class_key].calls.append(call)
                                    call_order += 1
                        
                        # Check for Lombok @Data annotation and generate methods
                        has_data_annotation = any(ann.name == "Data" for ann in classes[class_key].annotations)
                        if has_data_annotation:
                            logger.debug(f"Found @Data annotation on {class_name}, generating Lombok methods")
                            lombok_methods = generate_lombok_methods(classes[class_key].properties, class_name, package_name)
                            classes[class_key].methods.extend(lombok_methods)
                            logger.debug(f"Generated {len(lombok_methods)} Lombok methods for {class_name}")
                except javalang.parser.JavaSyntaxError as e:
                    print(f"Syntax error in {file_path}: {e}")
                    continue
                except Exception as e:
                    print(f"Error parsing {file_path}: {e}")
                    continue
    
    # Extract beans, analyze dependencies, extract endpoints, extract MyBatis mappers, extract JPA entities, extract config files, and extract test classes
    classes_list = list(classes.values())
    beans = extract_beans_from_classes(classes_list)
    dependencies = analyze_bean_dependencies(classes_list, beans)
    endpoints = extract_endpoints_from_classes(classes_list)
    mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
    jpa_entities = extract_jpa_entities_from_classes(classes_list)
    config_files = extract_config_files(directory)
    test_classes = extract_test_classes_from_classes(classes_list)
    
    # Also extract XML mappers
    xml_mappers = extract_mybatis_xml_mappers(directory)
    mybatis_mappers.extend(xml_mappers)
    
    # Extract SQL statements from MyBatis mappers
    sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
    
    return list(packages.values()), classes_list, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name
```

```python
import os
import yaml
import re
from pathlib import Path

import javalang

from src.models.graph_entities import Class, Method, MethodCall, Field, Package, Annotation, Bean, BeanDependency, Endpoint, MyBatisMapper, MyBatisSqlStatement, MyBatisResultMap, SqlStatement, JpaEntity, JpaColumn, JpaRelationship, ConfigFile, DatabaseConfig, ServerConfig, SecurityConfig, LoggingConfig, TestClass, TestMethod, TestConfiguration
from src.utils.logger import get_logger
from typing import Optional, List, Literal


def extract_project_name(java_source_folder: str) -> str:
    """
    JAVA_SOURCE_FOLDER 경로에서 프로젝트 이름을 추출합니다.
    
    Args:
        java_source_folder: Java 소스 폴더 경로
        
    Returns:
        프로젝트 이름 (마지막 디렉토리명)
    """
    # 경로를 정규화하고 마지막 디렉토리명 추출
    path = Path(java_source_folder).resolve()
    return path.name


def extract_sql_statements_from_mappers(mybatis_mappers: list[MyBatisMapper], project_name: str) -> list[SqlStatement]:
    """
    MyBatis mappers에서 SQL statements를 추출합니다.
    
    Args:
        mybatis_mappers: MyBatis mapper 객체들의 리스트
        project_name: 프로젝트 이름
        
    Returns:
        SqlStatement 객체들의 리스트
    """
    sql_statements = []
    
    for mapper in mybatis_mappers:
        for sql_dict in mapper.sql_statements:
            # MyBatisSqlStatement를 SqlStatement로 변환
            sql_statement = SqlStatement(
                id=sql_dict.get('id', ''),
                sql_type=sql_dict.get('sql_type', ''),
                sql_content=sql_dict.get('sql_content', ''),
                parameter_type=sql_dict.get('parameter_type', ''),
                result_type=sql_dict.get('result_type', ''),
                result_map=sql_dict.get('result_map', ''),
                mapper_name=mapper.name,
                annotations=[],  # TODO: annotations를 파싱하여 추가
                project_name=project_name
            )
            sql_statements.append(sql_statement)
    
    return sql_statements


def parse_annotations(annotations, target_type: str = "class") -> list[Annotation]:
    """Parse Java annotations into Annotation objects.
    
    Args:
        annotations: List of annotation nodes from javalang
        target_type: Type of target ("class", "method", "field")
    """
    result = []
    for annotation in annotations:
        annotation_name = annotation.name
        parameters = {}
        
        # Parse annotation parameters if they exist
        if hasattr(annotation, 'element') and annotation.element:
            for element in annotation.element:
                if hasattr(element, 'name') and hasattr(element, 'value'):
                    parameters[element.name] = element.value.value if hasattr(element.value, 'value') else str(element.value)
        
        result.append(Annotation(
            name=annotation_name,
            parameters=parameters,
            target_type=target_type,
            category=classify_springboot_annotation(annotation_name)
        ))
    
    return result


def classify_springboot_annotation(annotation_name: str) -> str:
    """Classify SpringBoot annotations into categories.
    
    Args:
        annotation_name: Name of the annotation (e.g., "@Component", "@Service")
        
    Returns:
        Category of the annotation
    """
    # Component annotations
    component_annotations = {
        "Component", "Service", "Repository", "Controller", 
        "RestController", "Configuration", "Bean"
    }
    
    # Injection annotations
    injection_annotations = {
        "Autowired", "Resource", "Value", "Qualifier", "Primary"
    }
    
    # Web annotations
    web_annotations = {
        "RequestMapping", "GetMapping", "PostMapping", "PutMapping", 
        "DeleteMapping", "PatchMapping", "RequestParam", "PathVariable",
        "RequestBody", "ResponseBody", "ResponseStatus"
    }
    
    # JPA annotations
    jpa_annotations = {
        "Entity", "Table", "Id", "Column", "OneToMany", "ManyToOne",
        "OneToOne", "ManyToMany", "JoinColumn", "GeneratedValue"
    }
    
    # Test annotations
    test_annotations = {
        "Test", "SpringBootTest", "DataJpaTest", "WebMvcTest",
        "MockBean", "SpyBean", "TestPropertySource"
    }
    
    # Security annotations
    security_annotations = {
        "PreAuthorize", "PostAuthorize", "Secured", "RolesAllowed",
        "EnableWebSecurity", "EnableGlobalMethodSecurity"
    }
    
    # Validation annotations
    validation_annotations = {
        "Valid", "NotNull", "NotBlank", "NotEmpty", "Size", "Min", "Max",
        "Pattern", "Email", "AssertTrue", "AssertFalse"
    }
    
    # MyBatis annotations
    mybatis_annotations = {
        "Mapper", "Select", "Insert", "Update", "Delete", "SelectProvider",
        "InsertProvider", "UpdateProvider", "DeleteProvider", "Results",
        "Result", "One", "Many", "MapKey", "Options", "SelectKey"
    }
    
    if annotation_name in component_annotations:
        return "component"
    elif annotation_name in injection_annotations:
        return "injection"
    elif annotation_name in web_annotations:
        return "web"
    elif annotation_name in jpa_annotations:
        return "jpa"
    elif annotation_name in test_annotations:
        return "test"
    elif annotation_name in security_annotations:
        return "security"
    elif annotation_name in validation_annotations:
        return "validation"
    elif annotation_name in mybatis_annotations:
        return "mybatis"
    else:
        return "other"


def classify_test_annotation(annotation_name: str) -> str:
    """Classify test annotations into categories.
    
    Args:
        annotation_name: Name of the annotation
        
    Returns:
        Category of the test annotation
    """
    # JUnit annotations
    junit_annotations = {
        "Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll",
        "DisplayName", "ParameterizedTest", "ValueSource", "CsvSource",
        "MethodSource", "Timeout", "Disabled", "Nested", "RepeatedTest",
        "Order", "TestMethodOrder", "TestInstance", "TestClassOrder"
    }
    
    # Spring Boot Test annotations
    spring_test_annotations = {
        "SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest",
        "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest",
        "MockBean", "SpyBean", "TestConfiguration", "ActiveProfiles",
        "TestPropertySource", "DirtiesContext", "Transactional",
        "Rollback", "Commit", "Sql", "SqlGroup", "AutoConfigureTestDatabase",
        "AutoConfigureMockMvc", "AutoConfigureWebMvc", "AutoConfigureWebClient",
        "MockMvc", "TestEntityManager", "TestContainers", "DynamicPropertySource"
    }
    
    # TestNG annotations
    testng_annotations = {
        "TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass",
        "BeforeSuite", "AfterSuite", "BeforeGroups", "AfterGroups",
        "DataProvider", "Parameters", "Groups", "Priority", "DependsOnMethods",
        "DependsOnGroups", "ExpectedExceptions", "InvocationCount",
        "SuccessPercentage", "TimeOut"
    }
    
    # Mockito annotations
    mockito_annotations = {
        "Mock", "Spy", "InjectMocks", "Captor", "MockedStatic"
    }
    
    # AssertJ annotations
    assertj_annotations = {
        "AssertJ"
    }
    
    # Other test annotations
    other_test_annotations = {
        "Ignore", "Category", "RunWith", "ExtendWith", "ContextConfiguration"
    }
    
    if annotation_name in junit_annotations:
        return "junit"
    elif annotation_name in spring_test_annotations:
        return "spring_test"
    elif annotation_name in testng_annotations:
        return "testng"
    elif annotation_name in mockito_annotations:
        return "mockito"
    elif annotation_name in assertj_annotations:
        return "assertj"
    elif annotation_name in other_test_annotations:
        return "other_test"
    else:
        return "other"


def extract_beans_from_classes(classes: list[Class]) -> list[Bean]:
    """Extract Spring Beans from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Bean objects
    """
    beans = []
    
    for cls in classes:
        # Check if class has Spring component annotations
        component_annotations = [ann for ann in cls.annotations if ann.category == "component"]
        
        # Also check for @Repository on interfaces
        has_repository_annotation = any(ann.name == "Repository" for ann in cls.annotations)
        
        if component_annotations or has_repository_annotation:
            # Determine bean type based on annotations
            bean_type = "component"  # default
            if any(ann.name in ["Service", "Service"] for ann in cls.annotations):
                bean_type = "service"
            elif any(ann.name in ["Repository", "Repository"] for ann in cls.annotations):
                bean_type = "repository"
            elif any(ann.name in ["Controller", "RestController"] for ann in cls.annotations):
                bean_type = "controller"
            elif any(ann.name in ["Configuration", "Configuration"] for ann in cls.annotations):
                bean_type = "configuration"
            
            # Determine scope (default is singleton)
            scope = "singleton"
            for ann in cls.annotations:
                if ann.name == "Scope":
                    if "value" in ann.parameters:
                        scope = ann.parameters["value"]
                    elif "prototype" in str(ann.parameters):
                        scope = "prototype"
                    elif "request" in str(ann.parameters):
                        scope = "request"
                    elif "session" in str(ann.parameters):
                        scope = "session"
            
            # Create bean name (use class name with first letter lowercase)
            bean_name = cls.name[0].lower() + cls.name[1:] if cls.name else cls.name
            
            # Check for @Bean methods in configuration classes
            bean_methods = []
            if bean_type == "configuration":
                for method in cls.methods:
                    if any(ann.name == "Bean" for ann in method.annotations):
                        bean_methods.append(method)
            
            bean = Bean(
                name=bean_name,
                type=bean_type,
                scope=scope,
                class_name=cls.name,
                package_name=cls.package_name,
                annotation_names=[ann.name for ann in cls.annotations] if cls.annotations else [],
                method_count=len(bean_methods) if bean_type == "configuration" else len(cls.methods) if cls.methods else 0,
                property_count=len(cls.properties) if cls.properties else 0
            )
            beans.append(bean)
    
    return beans


def analyze_bean_dependencies(classes: list[Class], beans: list[Bean]) -> list[BeanDependency]:
    """Analyze dependencies between Spring Beans.
    
    Args:
        classes: List of parsed Class objects
        beans: List of Bean objects
        
    Returns:
        List of BeanDependency objects
    """
    dependencies = []
    
    # Create a mapping from class names to bean names
    class_to_bean = {}
    for bean in beans:
        class_to_bean[bean.class_name] = bean.name
    
    for cls in classes:
        # Check if this class is a bean
        if cls.name not in class_to_bean:
            continue
            
        source_bean = class_to_bean[cls.name]
        
        # Analyze field injections (@Autowired, @Resource, @Value)
        for prop in cls.properties:
            if any(ann.category == "injection" for ann in prop.annotations):
                # Try to determine target bean from field type
                target_bean = None
                field_type = prop.type
                
                # Look for exact class name match
                if field_type in class_to_bean:
                    target_bean = class_to_bean[field_type]
                else:
                    # Look for interface implementations (simplified - just check if type matches any bean class name)
                    for bean in beans:
                        if field_type == bean.class_name:
                            target_bean = bean.name
                            break
                
                if target_bean:
                    injection_type = "field"
                    for ann in prop.annotations:
                        if ann.name == "Autowired":
                            injection_type = "field"
                        elif ann.name == "Resource":
                            injection_type = "field"
                        elif ann.name == "Value":
                            injection_type = "field"
                    
                    dependency = BeanDependency(
                        source_bean=source_bean,
                        target_bean=target_bean,
                        injection_type=injection_type,
                        field_name=prop.name
                    )
                    dependencies.append(dependency)
        
        # Analyze constructor injections
        for method in cls.methods:
            if method.name == cls.name:  # Constructor
                for param in method.parameters:
                    if any(ann.category == "injection" for ann in param.annotations):
                        target_bean = None
                        param_type = param.type
                        
                        if param_type in class_to_bean:
                            target_bean = class_to_bean[param_type]
                        else:
                            # Look for interface implementations (simplified)
                            for bean in beans:
                                if param_type == bean.class_name:
                                    target_bean = bean.name
                                    break
                        
                        if target_bean:
                            dependency = BeanDependency(
                                source_bean=source_bean,
                                target_bean=target_bean,
                                injection_type="constructor",
                                parameter_name=param.name
                            )
                            dependencies.append(dependency)
        
        # Analyze setter injections
        for method in cls.methods:
            if method.name.startswith("set") and len(method.parameters) == 1:
                if any(ann.category == "injection" for ann in method.annotations):
                    param = method.parameters[0]
                    target_bean = None
                    param_type = param.type
                    
                    if param_type in class_to_bean:
                        target_bean = class_to_bean[param_type]
                    else:
                        # Look for interface implementations (simplified)
                        for bean in beans:
                            if param_type == bean.class_name:
                                target_bean = bean.name
                                break
                    
                    if target_bean:
                        dependency = BeanDependency(
                            source_bean=source_bean,
                            target_bean=target_bean,
                            injection_type="setter",
                            method_name=method.name,
                            parameter_name=param.name
                        )
                        dependencies.append(dependency)
    
    return dependencies


def extract_endpoints_from_classes(classes: list[Class]) -> list[Endpoint]:
    """Extract REST API endpoints from controller classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Endpoint objects
    """
    endpoints = []
    
    for cls in classes:
        # Check if class is a controller
        is_controller = any(ann.name in ["Controller", "RestController"] for ann in cls.annotations)
        
        if not is_controller:
            continue
            
        # Get class-level path mapping
        class_path = ""
        for ann in cls.annotations:
            if ann.name == "RequestMapping":
                if "value" in ann.parameters:
                    class_path = ann.parameters["value"]
                break
        
        # Process each method in the controller
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
                
            # Check if method has web mapping annotations
            web_annotations = [ann for ann in method.annotations if ann.category == "web"]
            
            if not web_annotations:
                continue
            
            # Extract endpoint information
            endpoint_path = ""
            http_method = "GET"  # default
            
            for ann in web_annotations:
                if ann.name in ["RequestMapping", "GetMapping", "PostMapping", "PutMapping", "DeleteMapping", "PatchMapping"]:
                    # Extract path
                    if "value" in ann.parameters:
                        endpoint_path = ann.parameters["value"]
                    elif "path" in ann.parameters:
                        endpoint_path = ann.parameters["path"]
                    
                    # Extract HTTP method
                    if ann.name == "GetMapping":
                        http_method = "GET"
                    elif ann.name == "PostMapping":
                        http_method = "POST"
                    elif ann.name == "PutMapping":
                        http_method = "PUT"
                    elif ann.name == "DeleteMapping":
                        http_method = "DELETE"
                    elif ann.name == "PatchMapping":
                        http_method = "PATCH"
                    elif ann.name == "RequestMapping":
                        if "method" in ann.parameters:
                            method_value = ann.parameters["method"]
                            if isinstance(method_value, list) and len(method_value) > 0:
                                http_method = method_value[0]
                            else:
                                http_method = str(method_value)
                        else:
                            http_method = "GET"  # default for RequestMapping
                    break
            
            # Build full path
            full_path = class_path
            if endpoint_path:
                if full_path and not full_path.endswith("/") and not endpoint_path.startswith("/"):
                    full_path += "/"
                full_path += endpoint_path
            elif not full_path:
                full_path = "/"
            
            # Extract method parameters
            parameters = []
            for param in method.parameters:
                param_info = {
                    "name": param.name,
                    "type": param.type,
                    "annotations": [ann.name for ann in param.annotations if ann.category == "web"]
                }
                parameters.append(param_info)
            
            # Extract return type
            return_type = method.return_type if method.return_type != "constructor" else "void"
            
            # Create endpoint
            endpoint = Endpoint(
                path=endpoint_path or "/",
                method=http_method,
                controller_class=cls.name,
                handler_method=method.name,
                parameters=parameters,
                return_type=return_type,
                annotations=[ann.name for ann in web_annotations],
                full_path=full_path
            )
            endpoints.append(endpoint)
    
    return endpoints


def extract_mybatis_mappers_from_classes(classes: list[Class]) -> list[MyBatisMapper]:
    """Extract MyBatis Mappers from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for cls in classes:
        # Check if class is a MyBatis Mapper interface
        is_mapper = any(ann.name == "Mapper" for ann in cls.annotations)
        
        if not is_mapper:
            continue
        
        # Extract mapper methods with MyBatis annotations
        mapper_methods = []
        sql_statements = []
        
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
            
            # Check if method has MyBatis annotations
            mybatis_annotations = [ann for ann in method.annotations if ann.category == "mybatis"]
            
            if not mybatis_annotations:
                continue
            
            # Extract SQL statement information
            sql_type = "SELECT"  # default
            sql_content = ""
            parameter_type = ""
            result_type = ""
            result_map = ""
            
            for ann in mybatis_annotations:
                if ann.name in ["Select", "SelectProvider"]:
                    sql_type = "SELECT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Insert", "InsertProvider"]:
                    sql_type = "INSERT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Update", "UpdateProvider"]:
                    sql_type = "UPDATE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Delete", "DeleteProvider"]:
                    sql_type = "DELETE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                
                # Extract parameter and result type information
                if "parameterType" in ann.parameters:
                    parameter_type = ann.parameters["parameterType"]
                if "resultType" in ann.parameters:
                    result_type = ann.parameters["resultType"]
                if "resultMap" in ann.parameters:
                    result_map = ann.parameters["resultMap"]
            
            # Create method info
            method_info = {
                "name": method.name,
                "return_type": method.return_type,
                "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            mapper_methods.append(method_info)
            
            # Create SQL statement info
            sql_statement = {
                "id": method.name,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            sql_statements.append(sql_statement)
        
        # Create mapper
        mapper = MyBatisMapper(
            name=cls.name,
            type="interface",
            namespace=f"{cls.package_name}.{cls.name}",
            methods=mapper_methods,
            sql_statements=sql_statements,
            file_path=cls.file_path,
            package_name=cls.package_name
        )
        mappers.append(mapper)
    
    return mappers


def parse_mybatis_xml_file(file_path: str) -> MyBatisMapper:
    """Parse MyBatis XML mapper file.
    
    Args:
        file_path: Path to the XML mapper file
        
    Returns:
        MyBatisMapper object
    """
    import xml.etree.ElementTree as ET
    
    try:
        tree = ET.parse(file_path)
        root = tree.getroot()
        
        # Extract namespace
        namespace = root.get("namespace", "")
        
        # Extract SQL statements
        sql_statements = []
        for statement in root.findall(".//*[@id]"):
            statement_id = statement.get("id")
            tag_name = statement.tag.lower()
            
            # Determine SQL type
            sql_type = "SELECT"
            if tag_name == "insert":
                sql_type = "INSERT"
            elif tag_name == "update":
                sql_type = "UPDATE"
            elif tag_name == "delete":
                sql_type = "DELETE"
            
            # Extract SQL content
            sql_content = statement.text.strip() if statement.text else ""
            
            # Extract parameter and result information
            parameter_type = statement.get("parameterType", "")
            result_type = statement.get("resultType", "")
            result_map = statement.get("resultMap", "")
            
            sql_statement = {
                "id": statement_id,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": []
            }
            sql_statements.append(sql_statement)
        
        # Extract ResultMaps
        result_maps = []
        for result_map in root.findall(".//resultMap"):
            result_map_id = result_map.get("id")
            result_map_type = result_map.get("type", "")
            
            properties = []
            for property_elem in result_map.findall(".//result"):
                prop = {
                    "property": property_elem.get("property", ""),
                    "column": property_elem.get("column", ""),
                    "jdbc_type": property_elem.get("jdbcType", "")
                }
                properties.append(prop)
            
            result_map_info = {
                "id": result_map_id,
                "type": result_map_type,
                "properties": properties,
                "associations": [],
                "collections": []
            }
            result_maps.append(result_map_info)
        
        # Create mapper
        mapper_name = namespace.split(".")[-1] if namespace else os.path.basename(file_path).replace(".xml", "")
        package_name = ".".join(namespace.split(".")[:-1]) if namespace else ""
        
        mapper = MyBatisMapper(
            name=mapper_name,
            type="xml",
            namespace=namespace,
            methods=[],  # XML mappers don't have Java methods
            sql_statements=sql_statements,
            file_path=file_path,
            package_name=package_name
        )
        
        return mapper
        
    except ET.ParseError as e:
        print(f"Error parsing XML file {file_path}: {e}")
        return None
    except Exception as e:
        print(f"Error reading XML file {file_path}: {e}")
        return None


def extract_mybatis_xml_mappers(directory: str) -> list[MyBatisMapper]:
    """Extract MyBatis XML mappers from directory.
    
    Args:
        directory: Directory to search for XML mapper files
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith("Mapper.xml") or file.endswith("Dao.xml"):
                file_path = os.path.join(root, file)
                mapper = parse_mybatis_xml_file(file_path)
                if mapper:
                    mappers.append(mapper)
    
    return mappers


def extract_jpa_entities_from_classes(classes: list[Class]) -> list[JpaEntity]:
    """Extract JPA Entities from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of JpaEntity objects
    """
    entities = []
    
    for cls in classes:
        # Check if class is a JPA Entity
        is_entity = any(ann.name == "Entity" for ann in cls.annotations)
        
        if not is_entity:
            continue
        
        # Extract table name
        table_name = cls.name.lower()  # default table name
        for ann in cls.annotations:
            if ann.name == "Table":
                if "name" in ann.parameters:
                    table_name = ann.parameters["name"]
                break
        
        # Extract columns from properties
        columns = []
        relationships = []
        
        for prop in cls.properties:
            # Check if property has JPA column annotations
            jpa_annotations = [ann for ann in prop.annotations if ann.category == "jpa"]
            
            if jpa_annotations:
                # Extract column information
                column_name = prop.name  # default column name
                nullable = True
                unique = False
                length = 0
                precision = 0
                scale = 0
                
                for ann in jpa_annotations:
                    if ann.name == "Column":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                        if "nullable" in ann.parameters:
                            nullable = ann.parameters["nullable"]
                        if "unique" in ann.parameters:
                            unique = ann.parameters["unique"]
                        if "length" in ann.parameters:
                            length = ann.parameters["length"]
                        if "precision" in ann.parameters:
                            precision = ann.parameters["precision"]
                        if "scale" in ann.parameters:
                            scale = ann.parameters["scale"]
                    elif ann.name == "Id":
                        column_name = "id"  # Primary key column
                        nullable = False
                        unique = True
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                
                # Check for relationship annotations
                relationship_type = None
                target_entity = ""
                mapped_by = ""
                join_column = ""
                join_table = ""
                cascade = []
                fetch = "LAZY"
                
                for ann in jpa_annotations:
                    if ann.name in ["OneToOne", "OneToMany", "ManyToOne", "ManyToMany"]:
                        relationship_type = ann.name
                        if "targetEntity" in ann.parameters:
                            target_entity = ann.parameters["targetEntity"]
                        if "mappedBy" in ann.parameters:
                            mapped_by = ann.parameters["mappedBy"]
                        if "cascade" in ann.parameters:
                            cascade = ann.parameters["cascade"] if isinstance(ann.parameters["cascade"], list) else [ann.parameters["cascade"]]
                        if "fetch" in ann.parameters:
                            fetch = ann.parameters["fetch"]
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            join_column = ann.parameters["name"]
                    elif ann.name == "JoinTable":
                        if "name" in ann.parameters:
                            join_table = ann.parameters["name"]
                
                # Create column info
                column_info = {
                    "property_name": prop.name,
                    "column_name": column_name,
                    "data_type": prop.type,
                    "nullable": nullable,
                    "unique": unique,
                    "length": length,
                    "precision": precision,
                    "scale": scale,
                    "annotations": [ann.name for ann in jpa_annotations]
                }
                columns.append(column_info)
                
                # Create relationship info if it's a relationship
                if relationship_type:
                    relationship_info = {
                        "type": relationship_type,
                        "target_entity": target_entity,
                        "mapped_by": mapped_by,
                        "join_column": join_column,
                        "join_table": join_table,
                        "cascade": cascade,
                        "fetch": fetch,
                        "annotations": [ann.name for ann in jpa_annotations]
                    }
                    relationships.append(relationship_info)
        
        # Create entity
        entity = JpaEntity(
            name=cls.name,
            table_name=table_name,
            columns=columns,
            relationships=relationships,
            annotations=[ann.name for ann in cls.annotations if ann.category == "jpa"],
            package_name=cls.package_name,
            file_path=cls.file_path
        )
        entities.append(entity)
    
    return entities


def parse_yaml_config(file_path: str) -> ConfigFile:
    """Parse YAML configuration file.
    
    Args:
        file_path: Path to the YAML file
        
    Returns:
        ConfigFile object
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = yaml.safe_load(f)
        
        if not content:
            content = {}
        
        # Extract file info
        file_name = os.path.basename(file_path)
        file_type = "yaml" if file_path.endswith('.yaml') else "yml"
        
        # Extract profiles
        profiles = []
        if 'spring' in content and 'profiles' in content['spring']:
            if 'active' in content['spring']['profiles']:
                profiles = content['spring']['profiles']['active']
                if isinstance(profiles, str):
                    profiles = [profiles]
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        # Extract sections
        sections = []
        for key, value in content.items():
            if isinstance(value, dict):
                sections.append({
                    "name": key,
                    "properties": value,
                    "type": "section"
                })
        
        return ConfigFile(
            name=file_name,
            file_path=file_path,
            file_type=file_type,
            properties=content,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing YAML file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="yaml",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def parse_properties_config(file_path: str) -> ConfigFile:
    """Parse Properties configuration file.
    
    Args:
        file_path: Path to the properties file
        
    Returns:
        ConfigFile object
    """
    try:
        properties = {}
        sections = []
        profiles = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                
                # Skip empty lines and comments
                if not line or line.startswith('#'):
                    continue
                
                # Parse key=value pairs
                if '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    
                    # Remove quotes if present
                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]
                    elif value.startswith("'") and value.endswith("'"):
                        value = value[1:-1]
                    
                    properties[key] = value
                    
                    # Check for profiles
                    if key == 'spring.profiles.active':
                        profiles = [p.strip() for p in value.split(',')]
        
        # Group properties by section
        section_map = {}
        for key, value in properties.items():
            if '.' in key:
                section = key.split('.')[0]
                if section not in section_map:
                    section_map[section] = {}
                section_map[section][key] = value
            else:
                if 'root' not in section_map:
                    section_map['root'] = {}
                section_map['root'][key] = value
        
        for section_name, section_props in section_map.items():
            sections.append({
                "name": section_name,
                "properties": section_props,
                "type": "section"
            })
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties=properties,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing Properties file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def extract_database_config(config_file: ConfigFile) -> DatabaseConfig:
    """Extract database configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        DatabaseConfig object
    """
    db_config = DatabaseConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        spring_config = config_file.properties.get('spring', {})
        datasource_config = spring_config.get('datasource', {})
        jpa_config = spring_config.get('jpa', {})
        
        db_config.driver = datasource_config.get('driver-class-name', '')
        db_config.url = datasource_config.get('url', '')
        db_config.username = datasource_config.get('username', '')
        db_config.password = datasource_config.get('password', '')
        db_config.dialect = jpa_config.get('database-platform', '')
        db_config.hibernate_ddl_auto = jpa_config.get('hibernate', {}).get('ddl-auto', '')
        db_config.show_sql = jpa_config.get('show-sql', False)
        db_config.format_sql = jpa_config.get('properties', {}).get('hibernate', {}).get('format_sql', False)
        
        # Store additional JPA properties
        if 'properties' in jpa_config:
            db_config.jpa_properties = jpa_config['properties']
    
    else:
        # Properties format
        props = config_file.properties
        
        db_config.driver = props.get('spring.datasource.driver-class-name', '')
        db_config.url = props.get('spring.datasource.url', '')
        db_config.username = props.get('spring.datasource.username', '')
        db_config.password = props.get('spring.datasource.password', '')
        db_config.dialect = props.get('spring.jpa.database-platform', '')
        db_config.hibernate_ddl_auto = props.get('spring.jpa.hibernate.ddl-auto', '')
        db_config.show_sql = props.get('spring.jpa.show-sql', 'false').lower() == 'true'
        db_config.format_sql = props.get('spring.jpa.properties.hibernate.format_sql', 'false').lower() == 'true'
        
        # Store additional JPA properties
        jpa_props = {}
        for key, value in props.items():
            if key.startswith('spring.jpa.properties.'):
                jpa_props[key] = value
        db_config.jpa_properties = jpa_props
    
    return db_config


def extract_server_config(config_file: ConfigFile) -> ServerConfig:
    """Extract server configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        ServerConfig object
    """
    server_config = ServerConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        server_props = config_file.properties.get('server', {})
        
        server_config.port = server_props.get('port', 8080)
        server_config.context_path = server_props.get('servlet', {}).get('context-path', '')
        server_config.servlet_path = server_props.get('servlet', {}).get('path', '')
        
        # SSL configuration
        ssl_config = server_props.get('ssl', {})
        server_config.ssl_enabled = bool(ssl_config)
        server_config.ssl_key_store = ssl_config.get('key-store', '')
        server_config.ssl_key_store_password = ssl_config.get('key-store-password', '')
        server_config.ssl_key_store_type = ssl_config.get('key-store-type', '')
    
    else:
        # Properties format
        props = config_file.properties
        
        server_config.port = int(props.get('server.port', '8080'))
        server_config.context_path = props.get('server.servlet.context-path', '')
        server_config.servlet_path = props.get('server.servlet.path', '')
        
        # SSL configuration
        server_config.ssl_enabled = any(key.startswith('server.ssl.') for key in props.keys())
        server_config.ssl_key_store = props.get('server.ssl.key-store', '')
        server_config.ssl_key_store_password = props.get('server.ssl.key-store-password', '')
        server_config.ssl_key_store_type = props.get('server.ssl.key-store-type', '')
    
    return server_config


def extract_security_config(config_file: ConfigFile) -> SecurityConfig:
    """Extract security configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        SecurityConfig object
    """
    security_config = SecurityConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        security_props = config_file.properties.get('security', {})
        jwt_props = security_props.get('jwt', {})
        cors_props = security_props.get('cors', {})
        
        security_config.enabled = bool(security_props)
        security_config.authentication_type = security_props.get('authentication-type', '')
        security_config.jwt_secret = jwt_props.get('secret', '')
        security_config.jwt_expiration = jwt_props.get('expiration', 0)
        security_config.cors_allowed_origins = cors_props.get('allowed-origins', [])
        security_config.cors_allowed_methods = cors_props.get('allowed-methods', [])
        security_config.cors_allowed_headers = cors_props.get('allowed-headers', [])
    
    else:
        # Properties format
        props = config_file.properties
        
        security_config.enabled = any(key.startswith('security.') for key in props.keys())
        security_config.authentication_type = props.get('security.authentication-type', '')
        security_config.jwt_secret = props.get('security.jwt.secret', '')
        security_config.jwt_expiration = int(props.get('security.jwt.expiration', '0'))
        
        # CORS configuration
        origins = props.get('security.cors.allowed-origins', '')
        if origins:
            security_config.cors_allowed_origins = [o.strip() for o in origins.split(',')]
        
        methods = props.get('security.cors.allowed-methods', '')
        if methods:
            security_config.cors_allowed_methods = [m.strip() for m in methods.split(',')]
        
        headers = props.get('security.cors.allowed-headers', '')
        if headers:
            security_config.cors_allowed_headers = [h.strip() for h in headers.split(',')]
    
    return security_config


def extract_logging_config(config_file: ConfigFile) -> LoggingConfig:
    """Extract logging configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        LoggingConfig object
    """
    logging_config = LoggingConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        logging_props = config_file.properties.get('logging', {})
        
        logging_config.level = logging_props.get('level', {}).get('root', 'INFO')
        logging_config.pattern = logging_props.get('pattern', {}).get('console', '')
        logging_config.file_path = logging_props.get('file', {}).get('name', '')
        logging_config.max_file_size = logging_props.get('file', {}).get('max-size', '')
        logging_config.max_history = logging_props.get('file', {}).get('max-history', 0)
        logging_config.console_output = logging_props.get('console', {}).get('enabled', True)
    
    else:
        # Properties format
        props = config_file.properties
        
        logging_config.level = props.get('logging.level.root', 'INFO')
        logging_config.pattern = props.get('logging.pattern.console', '')
        logging_config.file_path = props.get('logging.file.name', '')
        logging_config.max_file_size = props.get('logging.file.max-size', '')
        logging_config.max_history = int(props.get('logging.file.max-history', '0'))
        logging_config.console_output = props.get('logging.console.enabled', 'true').lower() == 'true'
    
    return logging_config


def extract_config_files(directory: str) -> list[ConfigFile]:
    """Extract configuration files from directory.
    
    Args:
        directory: Directory to search for config files
        
    Returns:
        List of ConfigFile objects
    """
    config_files = []
    
    # Common config file patterns
    config_patterns = [
        "application.yml",
        "application.yaml", 
        "application.properties",
        "application-*.properties",
        "bootstrap.yml",
        "bootstrap.yaml",
        "bootstrap.properties"
    ]
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            # Check if file matches any config pattern
            is_config_file = False
            for pattern in config_patterns:
                if pattern == file or (pattern.endswith('*') and file.startswith(pattern[:-1])):
                    is_config_file = True
                    break
            
            if is_config_file:
                file_path = os.path.join(root, file)
                
                if file.endswith(('.yml', '.yaml')):
                    config_file = parse_yaml_config(file_path)
                elif file.endswith('.properties'):
                    config_file = parse_properties_config(file_path)
                else:
                    continue
                
                config_files.append(config_file)
    
    return config_files


def extract_test_classes_from_classes(classes: list[Class]) -> list[TestClass]:
    """Extract test classes from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of TestClass objects
    """
    test_classes = []
    
    for cls in classes:
        # Check if class is a test class
        test_annotations = [ann for ann in cls.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
        
        if not test_annotations:
            continue
        
        # Determine test framework and type
        test_framework = "junit"  # default
        test_type = "unit"  # default
        
        for ann in test_annotations:
            if ann.name in ["SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest", "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest"]:
                test_framework = "spring_test"
                if ann.name == "SpringBootTest":
                    test_type = "integration"
                else:
                    test_type = "slice"
            elif ann.name in ["TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass"]:
                test_framework = "testng"
            elif ann.name in ["Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll"]:
                test_framework = "junit"
        
        # Extract test methods
        test_methods = []
        setup_methods = []
        
        for method in cls.methods:
            method_annotations = [ann.name for ann in method.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
            
            if method_annotations:
                # Check if it's a setup/teardown method
                if any(ann in method_annotations for ann in ["BeforeEach", "AfterEach", "BeforeAll", "AfterAll", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass", "BeforeSuite", "AfterSuite"]):
                    setup_methods.append({
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters]
                    })
                else:
                    # Regular test method
                    test_method_info = {
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                        "assertions": [],
                        "mock_calls": [],
                        "test_data": [],
                        "expected_exceptions": [],
                        "timeout": 0,
                        "display_name": ""
                    }
                    
                    # Extract display name
                    for ann in method.annotations:
                        if ann.name == "DisplayName" and "value" in ann.parameters:
                            test_method_info["display_name"] = ann.parameters["value"]
                        elif ann.name == "Timeout" and "value" in ann.parameters:
                            test_method_info["timeout"] = ann.parameters["value"]
                    
                    # Extract expected exceptions
                    for ann in method.annotations:
                        if ann.name == "ExpectedExceptions" and "value" in ann.parameters:
                            test_method_info["expected_exceptions"] = ann.parameters["value"] if isinstance(ann.parameters["value"], list) else [ann.parameters["value"]]
                    
                    test_methods.append(test_method_info)
        
        # Extract mock dependencies
        mock_dependencies = []
        for prop in cls.properties:
            prop_annotations = [ann.name for ann in prop.annotations if classify_test_annotation(ann.name) in ["mockito", "spring_test"]]
            if prop_annotations:
                mock_dependencies.append({
                    "name": prop.name,
                    "type": prop.type,
                    "annotations": prop_annotations,
                    "mock_type": "mock" if "Mock" in prop_annotations else "spy" if "Spy" in prop_annotations else "bean"
                })
        
        # Extract test configurations
        test_configurations = []
        for ann in cls.annotations:
            if ann.name in ["TestConfiguration", "ActiveProfiles", "TestPropertySource"]:
                config_info = {
                    "name": ann.name,
                    "type": "configuration" if ann.name == "TestConfiguration" else "profile" if ann.name == "ActiveProfiles" else "property",
                    "properties": ann.parameters,
                    "active_profiles": ann.parameters.get("value", []) if ann.name == "ActiveProfiles" else [],
                    "test_slices": [],
                    "mock_beans": [],
                    "spy_beans": []
                }
                test_configurations.append(config_info)
        
        # Create test class
        test_class = TestClass(
            name=cls.name,
            package_name=cls.package_name,
            test_framework=test_framework,
            test_type=test_type,
            annotations=[ann.name for ann in test_annotations],
            test_methods=test_methods,
            setup_methods=setup_methods,
            mock_dependencies=mock_dependencies,
            test_configurations=test_configurations,
            file_path=cls.file_path
        )
        test_classes.append(test_class)
    
    return test_classes


def analyze_test_methods(test_class: TestClass, class_obj: Class) -> list[TestMethod]:
    """Analyze test methods for assertions, mock calls, and test data.
    
    Args:
        test_class: TestClass object
        class_obj: Original Class object
        
    Returns:
        List of analyzed TestMethod objects
    """
    test_methods = []
    
    for method_info in test_class.test_methods:
        # Find the corresponding method in the class
        method_obj = None
        for method in class_obj.methods:
            if method.name == method_info["name"]:
                method_obj = method
                break
        
        if not method_obj:
            continue
        
        # Analyze method source code for assertions and mock calls
        assertions = []
        mock_calls = []
        test_data = []
        
        if method_obj.source:
            source_code = method_obj.source
            
            # Find assertions (JUnit, AssertJ, etc.)
            assertion_patterns = [
                r'assert\w+\(',  # JUnit assertions
                r'assertThat\(',  # AssertJ
                r'assertEquals\(',  # JUnit
                r'assertTrue\(',  # JUnit
                r'assertFalse\(',  # JUnit
                r'assertNotNull\(',  # JUnit
                r'assertNull\(',  # JUnit
                r'assertThrows\(',  # JUnit 5
                r'assertDoesNotThrow\(',  # JUnit 5
                r'verify\(',  # Mockito verify
                r'when\(',  # Mockito when
                r'then\(',  # Mockito then
                r'given\(',  # BDDMockito given
                r'willReturn\(',  # Mockito willReturn
                r'willThrow\(',  # Mockito willThrow
            ]
            
            for pattern in assertion_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    assertions.append({
                        "type": match,
                        "line": source_code.find(match) + 1
                    })
            
            # Find mock calls
            mock_call_patterns = [
                r'(\w+)\.(\w+)\(',  # Method calls on objects
                r'mock\(',  # Mockito mock creation
                r'spy\(',  # Mockito spy creation
                r'@Mock\s+(\w+)',  # @Mock annotation
                r'@Spy\s+(\w+)',  # @Spy annotation
                r'@InjectMocks\s+(\w+)',  # @InjectMocks annotation
            ]
            
            for pattern in mock_call_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        mock_calls.append({
                            "object": match[0],
                            "method": match[1],
                            "type": "method_call"
                        })
                    else:
                        mock_calls.append({
                            "type": match,
                            "line": source_code.find(match) + 1
                        })
            
            # Find test data setup
            test_data_patterns = [
                r'new\s+(\w+)\(',  # Object creation
                r'(\w+)\s*=\s*new\s+(\w+)\(',  # Variable assignment with new
                r'@ValueSource\(',  # JUnit 5 @ValueSource
                r'@CsvSource\(',  # JUnit 5 @CsvSource
                r'@MethodSource\(',  # JUnit 5 @MethodSource
            ]
            
            for pattern in test_data_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        test_data.append({
                            "variable": match[0],
                            "type": match[1],
                            "pattern": "object_creation"
                        })
                    else:
                        test_data.append({
                            "type": match,
                            "pattern": "annotation"
                        })
        
        # Create TestMethod object
        test_method = TestMethod(
            name=method_info["name"],
            return_type=method_info["return_type"],
            annotations=method_info["annotations"],
            assertions=assertions,
            mock_calls=mock_calls,
            test_data=test_data,
            expected_exceptions=method_info["expected_exceptions"],
            timeout=method_info["timeout"],
            display_name=method_info["display_name"]
        )
        test_methods.append(test_method)
    
    return test_methods


def generate_lombok_methods(properties: list[Field], class_name: str, package_name: str) -> list[Method]:
    """Generate Lombok @Data methods (getters, setters, equals, hashCode, toString) for properties."""
    methods = []
    
    # Generate getters and setters for each property
    for prop in properties:
        # Getter
        getter_name = f"get{prop.name[0].upper()}{prop.name[1:]}"
        if prop.type == "Boolean" and prop.name.startswith("is"):
            # For boolean fields starting with 'is', use the field name as getter
            getter_name = prop.name
        
        getter = Method(
            name=getter_name,
            logical_name=f"{package_name}.{class_name}.{getter_name}",
            return_type=prop.type,
            parameters=[],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[],
            description=f"Generated getter for {prop.name} field"  # Generated method description
        )
        methods.append(getter)
        
        # Setter
        setter_name = f"set{prop.name[0].upper()}{prop.name[1:]}"
        setter_param = Field(
            name=prop.name,
            logical_name=f"{package_name}.{class_name}.{prop.name}",
            type=prop.type,
            package_name=package_name,
            class_name=class_name
        )
        
        setter = Method(
            name=setter_name,
            logical_name=f"{package_name}.{class_name}.{setter_name}",
            return_type="void",
            parameters=[setter_param],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[],
            description=f"Generated setter for {prop.name} field"  # Generated method description
        )
        methods.append(setter)
    
    # Generate equals method
    equals_method = Method(
        name="equals",
        logical_name=f"{package_name}.{class_name}.equals",
        return_type="boolean",
        parameters=[Field(name="obj", logical_name=f"{package_name}.{class_name}.obj", type="Object", package_name=package_name, class_name=class_name)],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated equals method for object comparison"  # Generated method description
    )
    methods.append(equals_method)
    
    # Generate hashCode method
    hashcode_method = Method(
        name="hashCode",
        logical_name=f"{package_name}.{class_name}.hashCode",
        return_type="int",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated hashCode method for object hashing"  # Generated method description
    )
    methods.append(hashcode_method)
    
    # Generate toString method
    tostring_method = Method(
        name="toString",
        logical_name=f"{package_name}.{class_name}.toString",
        return_type="String",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[]
    )
    methods.append(tostring_method)
    
    return methods


def parse_java_project(directory: str) -> tuple[list[Package], list[Class], dict[str, str], list[Bean], list[BeanDependency], list[Endpoint], list[MyBatisMapper], list[JpaEntity], list[ConfigFile], list[TestClass], list[SqlStatement], str]:
    """Parse Java project and return parsed entities."""
    logger = get_logger(__name__)
    """Parses all Java files in a directory and returns a tuple of (packages, classes, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name)."""
    
    # Extract project name from directory path
    project_name = extract_project_name(directory)
    packages = {}
    classes = {}
    class_to_package_map = {}  # Maps class_key to package_name

    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith(".java"):
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    file_content = f.read() # Read file content once
                try:
                    tree = javalang.parse.parse(file_content)
                    package_name = tree.package.name if tree.package else ""
                    
                    # Create or update package node
                    if package_name and package_name not in packages:
                        packages[package_name] = Package(
                            name=package_name
                        )
                    elif not package_name:
                        # Handle classes without package (default package)
                        package_name = "default"
                        if package_name not in packages:
                            packages[package_name] = Package(
                                name=package_name
                            )
                    
                    import_map = {}
                    for imp in tree.imports:
                        class_name = imp.path.split('.')[-1]
                        import_map[class_name] = imp.path

                    for _, class_declaration in tree.filter(
                        javalang.tree.ClassDeclaration
                    ):
                        class_name = class_declaration.name
                        class_key = f"{package_name}.{class_name}"
                        
                        # Debug: Check if this is the User class
                        if "User" in class_name:
                            logger.debug(f"Found User class - {class_key}")
                            logger.debug(f"Methods count: {len(class_declaration.methods)}")
                            logger.debug(f"Constructors count: {len(class_declaration.constructors)}")
                        
                        # Extract class source code - use the entire file content
                        class_source = file_content


                        if class_key not in classes:
                            # Parse class annotations
                            class_annotations = parse_annotations(class_declaration.annotations, "class") if hasattr(class_declaration, 'annotations') else []
                            
                            classes[class_key] = Class(
                                name=class_name,
                                logical_name=class_key,  # Add logical_name
                                file_path=file_path,
                                type="class", # Simplified for now
                                source=class_source, # Add class source
                                annotations=class_annotations,
                                package_name=package_name
                            )
                            class_to_package_map[class_key] = package_name
                        
                        # --- Start of new import logic ---
                        for imp in tree.imports:
                            classes[class_key].imports.append(imp.path)
                        # --- End of new import logic ---

                        # --- Start of new inheritance logic ---
                        # Handle 'extends'
                        if class_declaration.extends:
                            superclass_name = class_declaration.extends.name
                            # Try to resolve fully qualified name for superclass
                            if superclass_name in import_map:
                                classes[class_key].superclass = import_map[superclass_name]
                            else:
                                # Assume same package or fully qualified if not in import_map
                                classes[class_key].superclass = f"{package_name}.{superclass_name}" if package_name else superclass_name

                        # Handle 'implements'
                        if class_declaration.implements: # Add this check
                            for impl_ref in class_declaration.implements:
                                interface_name = impl_ref.name
                                # Try to resolve fully qualified name for interface
                                if interface_name in import_map:
                                    classes[class_key].interfaces.append(import_map[interface_name])
                                else:
                                    # Assume same package or fully qualified if not in import_map
                                    classes[class_key].interfaces.append(f"{package_name}.{interface_name}" if package_name else interface_name)
                        # --- End of new inheritance logic ---

                        field_map = {}
                        for field_declaration in class_declaration.fields:
                            for declarator in field_declaration.declarators:
                                field_map[declarator.name] = field_declaration.type.name
                                
                                # Parse field annotations
                                field_annotations = parse_annotations(field_declaration.annotations, "field") if hasattr(field_declaration, 'annotations') else []
                                
                                # Extract initial value if present
                                initial_value = ""
                                if hasattr(declarator, 'initializer') and declarator.initializer:
                                    # Convert the initializer to string representation
                                    if hasattr(declarator.initializer, 'value'):
                                        initial_value = str(declarator.initializer.value)
                                    elif hasattr(declarator.initializer, 'type'):
                                        initial_value = str(declarator.initializer.type)
                                    else:
                                        initial_value = str(declarator.initializer)
                                
                                prop = Field(
                                    name=declarator.name,
                                    logical_name=f"{package_name}.{class_name}.{declarator.name}",
                                    type=field_declaration.type.name,
                                    modifiers=list(field_declaration.modifiers), # Add modifiers
                                    package_name=package_name,
                                    class_name=class_name,
                                    annotations=field_annotations,
                                    initial_value=initial_value,
                                    description=""  # TODO: Extract description from comments or annotations
                                )
                                classes[class_key].properties.append(prop)

                        all_declarations = class_declaration.methods + class_declaration.constructors
                        
                        # Debug: Check User class method processing
                        if "User" in class_name:
                            logger.debug(f"Processing User class methods - total declarations: {len(all_declarations)}")
                            for i, decl in enumerate(all_declarations):
                                logger.debug(f"Declaration {i}: {type(decl).__name__} - {decl.name}")
                        
                        for declaration in all_declarations:
                            local_var_map = field_map.copy()
                            params = []
                            for param in declaration.parameters:
                                param_type_name = 'Unknown'
                                if hasattr(param.type, 'name'):
                                    param_type_name = param.type.name
                                local_var_map[param.name] = param_type_name
                                params.append(Field(name=param.name, logical_name=f"{package_name}.{class_name}.{param.name}", type=param_type_name, package_name=package_name, class_name=class_name))

                            if declaration.body:
                                for _, var_decl in declaration.filter(javalang.tree.LocalVariableDeclaration):
                                    for declarator in var_decl.declarators:
                                        local_var_map[declarator.name] = var_decl.type.name
                            
                            if isinstance(declaration, javalang.tree.MethodDeclaration):
                                return_type = declaration.return_type.name if declaration.return_type else "void"
                            else: # ConstructorDeclaration
                                return_type = "constructor"

                            # Extract modifiers
                            modifiers = list(declaration.modifiers)
                            
                            # Parse method annotations
                            method_annotations = parse_annotations(declaration.annotations, "method") if hasattr(declaration, 'annotations') else []

                            # Extract method source code
                            method_source = ""
                            if declaration.position:
                                lines = file_content.splitlines(keepends=True) # Keep line endings
                                start_line = declaration.position.line - 1
                                
                                # Find the end of the method by matching braces
                                brace_count = 0
                                end_line = start_line
                                for i in range(start_line, len(lines)):
                                    line = lines[i]
                                    for char in line:
                                        if char == '{':
                                            brace_count += 1
                                        elif char == '}':
                                            brace_count -= 1
                                            if brace_count == 0:
                                                end_line = i
                                                break
                                    if brace_count == 0:
                                        break
                                
                                method_source = "".join(lines[start_line:end_line + 1])

                            method = Method(
                                name=declaration.name,
                                logical_name=f"{class_key}.{declaration.name}",  # Add logical_name
                                return_type=return_type,
                                parameters=params,
                                modifiers=modifiers,
                                source=method_source, # Add method source
                                package_name=package_name,
                                annotations=method_annotations
                            )
                            classes[class_key].methods.append(method)

                            # Extract method calls with order information
                            call_order = 0
                            for _, invocation in declaration.filter(javalang.tree.MethodInvocation):
                                target_class_name = None
                                resolved_target_package = ""
                                resolved_target_class_name = ""
                                
                                if invocation.qualifier:
                                    # External method call
                                    if invocation.qualifier in local_var_map:
                                        target_class_name = local_var_map[invocation.qualifier]
                                    else:
                                        target_class_name = invocation.qualifier
                                    
                                    if target_class_name:
                                        if target_class_name == "System.out":
                                            resolved_target_package = "java.io"
                                            resolved_target_class_name = "PrintStream"
                                        else:
                                            if target_class_name in import_map:
                                                resolved_target_package = ".".join(import_map[target_class_name].split(".")[:-1])
                                            else:
                                                resolved_target_package = package_name
                                                resolved_target_class_name = target_class_name
                                else:
                                    # Same class method call
                                    resolved_target_package = package_name
                                    resolved_target_class_name = class_name

                                if resolved_target_class_name:
                                    # Get line number from invocation position
                                    line_number = invocation.position.line if invocation.position else 0

                                    call = MethodCall(
                                        source_package=package_name,
                                        source_class=class_name,
                                        source_method=declaration.name,
                                        target_package=resolved_target_package,
                                        target_class=resolved_target_class_name,
                                        target_method=invocation.member,
                                        call_order=call_order,
                                        line_number=line_number,
                                        return_type="void"  # Default return type, can be enhanced later
                                    )
                                    classes[class_key].calls.append(call)
                                    call_order += 1
                        
                        # Check for Lombok @Data annotation and generate methods
                        has_data_annotation = any(ann.name == "Data" for ann in classes[class_key].annotations)
                        if has_data_annotation:
                            logger.debug(f"Found @Data annotation on {class_name}, generating Lombok methods")
                            lombok_methods = generate_lombok_methods(classes[class_key].properties, class_name, package_name)
                            classes[class_key].methods.extend(lombok_methods)
                            logger.debug(f"Generated {len(lombok_methods)} Lombok methods for {class_name}")
                except javalang.parser.JavaSyntaxError as e:
                    print(f"Syntax error in {file_path}: {e}")
                    continue
                except Exception as e:
                    print(f"Error parsing {file_path}: {e}")
                    continue
    
    # Extract beans, analyze dependencies, extract endpoints, extract MyBatis mappers, extract JPA entities, extract config files, and extract test classes
    classes_list = list(classes.values())
    beans = extract_beans_from_classes(classes_list)
    dependencies = analyze_bean_dependencies(classes_list, beans)
    endpoints = extract_endpoints_from_classes(classes_list)
    mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
    jpa_entities = extract_jpa_entities_from_classes(classes_list)
    config_files = extract_config_files(directory)
    test_classes = extract_test_classes_from_classes(classes_list)
    
    # Also extract XML mappers
    xml_mappers = extract_mybatis_xml_mappers(directory)
    mybatis_mappers.extend(xml_mappers)
    
    # Extract SQL statements from MyBatis mappers
    sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
    
    return list(packages.values()), classes_list, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name
```

```python
import os
import yaml
import re
from pathlib import Path

import javalang

from src.models.graph_entities import Class, Method, MethodCall, Field, Package, Annotation, Bean, BeanDependency, Endpoint, MyBatisMapper, MyBatisSqlStatement, MyBatisResultMap, SqlStatement, JpaEntity, JpaColumn, JpaRelationship, ConfigFile, DatabaseConfig, ServerConfig, SecurityConfig, LoggingConfig, TestClass, TestMethod, TestConfiguration
from src.utils.logger import get_logger
from typing import Optional, List, Literal


def extract_project_name(java_source_folder: str) -> str:
    """
    JAVA_SOURCE_FOLDER 경로에서 프로젝트 이름을 추출합니다.
    
    Args:
        java_source_folder: Java 소스 폴더 경로
        
    Returns:
        프로젝트 이름 (마지막 디렉토리명)
    """
    # 경로를 정규화하고 마지막 디렉토리명 추출
    path = Path(java_source_folder).resolve()
    return path.name


def extract_sql_statements_from_mappers(mybatis_mappers: list[MyBatisMapper], project_name: str) -> list[SqlStatement]:
    """
    MyBatis mappers에서 SQL statements를 추출합니다.
    
    Args:
        mybatis_mappers: MyBatis mapper 객체들의 리스트
        project_name: 프로젝트 이름
        
    Returns:
        SqlStatement 객체들의 리스트
    """
    sql_statements = []
    
    for mapper in mybatis_mappers:
        for sql_dict in mapper.sql_statements:
            # MyBatisSqlStatement를 SqlStatement로 변환
            sql_statement = SqlStatement(
                id=sql_dict.get('id', ''),
                sql_type=sql_dict.get('sql_type', ''),
                sql_content=sql_dict.get('sql_content', ''),
                parameter_type=sql_dict.get('parameter_type', ''),
                result_type=sql_dict.get('result_type', ''),
                result_map=sql_dict.get('result_map', ''),
                mapper_name=mapper.name,
                annotations=[],  # TODO: annotations를 파싱하여 추가
                project_name=project_name
            )
            sql_statements.append(sql_statement)
    
    return sql_statements


def parse_annotations(annotations, target_type: str = "class") -> list[Annotation]:
    """Parse Java annotations into Annotation objects.
    
    Args:
        annotations: List of annotation nodes from javalang
        target_type: Type of target ("class", "method", "field")
    """
    result = []
    for annotation in annotations:
        annotation_name = annotation.name
        parameters = {}
        
        # Parse annotation parameters if they exist
        if hasattr(annotation, 'element') and annotation.element:
            for element in annotation.element:
                if hasattr(element, 'name') and hasattr(element, 'value'):
                    parameters[element.name] = element.value.value if hasattr(element.value, 'value') else str(element.value)
        
        result.append(Annotation(
            name=annotation_name,
            parameters=parameters,
            target_type=target_type,
            category=classify_springboot_annotation(annotation_name)
        ))
    
    return result


def classify_springboot_annotation(annotation_name: str) -> str:
    """Classify SpringBoot annotations into categories.
    
    Args:
        annotation_name: Name of the annotation (e.g., "@Component", "@Service")
        
    Returns:
        Category of the annotation
    """
    # Component annotations
    component_annotations = {
        "Component", "Service", "Repository", "Controller", 
        "RestController", "Configuration", "Bean"
    }
    
    # Injection annotations
    injection_annotations = {
        "Autowired", "Resource", "Value", "Qualifier", "Primary"
    }
    
    # Web annotations
    web_annotations = {
        "RequestMapping", "GetMapping", "PostMapping", "PutMapping", 
        "DeleteMapping", "PatchMapping", "RequestParam", "PathVariable",
        "RequestBody", "ResponseBody", "ResponseStatus"
    }
    
    # JPA annotations
    jpa_annotations = {
        "Entity", "Table", "Id", "Column", "OneToMany", "ManyToOne",
        "OneToOne", "ManyToMany", "JoinColumn", "GeneratedValue"
    }
    
    # Test annotations
    test_annotations = {
        "Test", "SpringBootTest", "DataJpaTest", "WebMvcTest",
        "MockBean", "SpyBean", "TestPropertySource"
    }
    
    # Security annotations
    security_annotations = {
        "PreAuthorize", "PostAuthorize", "Secured", "RolesAllowed",
        "EnableWebSecurity", "EnableGlobalMethodSecurity"
    }
    
    # Validation annotations
    validation_annotations = {
        "Valid", "NotNull", "NotBlank", "NotEmpty", "Size", "Min", "Max",
        "Pattern", "Email", "AssertTrue", "AssertFalse"
    }
    
    # MyBatis annotations
    mybatis_annotations = {
        "Mapper", "Select", "Insert", "Update", "Delete", "SelectProvider",
        "InsertProvider", "UpdateProvider", "DeleteProvider", "Results",
        "Result", "One", "Many", "MapKey", "Options", "SelectKey"
    }
    
    if annotation_name in component_annotations:
        return "component"
    elif annotation_name in injection_annotations:
        return "injection"
    elif annotation_name in web_annotations:
        return "web"
    elif annotation_name in jpa_annotations:
        return "jpa"
    elif annotation_name in test_annotations:
        return "test"
    elif annotation_name in security_annotations:
        return "security"
    elif annotation_name in validation_annotations:
        return "validation"
    elif annotation_name in mybatis_annotations:
        return "mybatis"
    else:
        return "other"


def classify_test_annotation(annotation_name: str) -> str:
    """Classify test annotations into categories.
    
    Args:
        annotation_name: Name of the annotation
        
    Returns:
        Category of the test annotation
    """
    # JUnit annotations
    junit_annotations = {
        "Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll",
        "DisplayName", "ParameterizedTest", "ValueSource", "CsvSource",
        "MethodSource", "Timeout", "Disabled", "Nested", "RepeatedTest",
        "Order", "TestMethodOrder", "TestInstance", "TestClassOrder"
    }
    
    # Spring Boot Test annotations
    spring_test_annotations = {
        "SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest",
        "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest",
        "MockBean", "SpyBean", "TestConfiguration", "ActiveProfiles",
        "TestPropertySource", "DirtiesContext", "Transactional",
        "Rollback", "Commit", "Sql", "SqlGroup", "AutoConfigureTestDatabase",
        "AutoConfigureMockMvc", "AutoConfigureWebMvc", "AutoConfigureWebClient",
        "MockMvc", "TestEntityManager", "TestContainers", "DynamicPropertySource"
    }
    
    # TestNG annotations
    testng_annotations = {
        "TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass",
        "BeforeSuite", "AfterSuite", "BeforeGroups", "AfterGroups",
        "DataProvider", "Parameters", "Groups", "Priority", "DependsOnMethods",
        "DependsOnGroups", "ExpectedExceptions", "InvocationCount",
        "SuccessPercentage", "TimeOut"
    }
    
    # Mockito annotations
    mockito_annotations = {
        "Mock", "Spy", "InjectMocks", "Captor", "MockedStatic"
    }
    
    # AssertJ annotations
    assertj_annotations = {
        "AssertJ"
    }
    
    # Other test annotations
    other_test_annotations = {
        "Ignore", "Category", "RunWith", "ExtendWith", "ContextConfiguration"
    }
    
    if annotation_name in junit_annotations:
        return "junit"
    elif annotation_name in spring_test_annotations:
        return "spring_test"
    elif annotation_name in testng_annotations:
        return "testng"
    elif annotation_name in mockito_annotations:
        return "mockito"
    elif annotation_name in assertj_annotations:
        return "assertj"
    elif annotation_name in other_test_annotations:
        return "other_test"
    else:
        return "other"


def extract_beans_from_classes(classes: list[Class]) -> list[Bean]:
    """Extract Spring Beans from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Bean objects
    """
    beans = []
    
    for cls in classes:
        # Check if class has Spring component annotations
        component_annotations = [ann for ann in cls.annotations if ann.category == "component"]
        
        # Also check for @Repository on interfaces
        has_repository_annotation = any(ann.name == "Repository" for ann in cls.annotations)
        
        if component_annotations or has_repository_annotation:
            # Determine bean type based on annotations
            bean_type = "component"  # default
            if any(ann.name in ["Service", "Service"] for ann in cls.annotations):
                bean_type = "service"
            elif any(ann.name in ["Repository", "Repository"] for ann in cls.annotations):
                bean_type = "repository"
            elif any(ann.name in ["Controller", "RestController"] for ann in cls.annotations):
                bean_type = "controller"
            elif any(ann.name in ["Configuration", "Configuration"] for ann in cls.annotations):
                bean_type = "configuration"
            
            # Determine scope (default is singleton)
            scope = "singleton"
            for ann in cls.annotations:
                if ann.name == "Scope":
                    if "value" in ann.parameters:
                        scope = ann.parameters["value"]
                    elif "prototype" in str(ann.parameters):
                        scope = "prototype"
                    elif "request" in str(ann.parameters):
                        scope = "request"
                    elif "session" in str(ann.parameters):
                        scope = "session"
            
            # Create bean name (use class name with first letter lowercase)
            bean_name = cls.name[0].lower() + cls.name[1:] if cls.name else cls.name
            
            # Check for @Bean methods in configuration classes
            bean_methods = []
            if bean_type == "configuration":
                for method in cls.methods:
                    if any(ann.name == "Bean" for ann in method.annotations):
                        bean_methods.append(method)
            
            bean = Bean(
                name=bean_name,
                type=bean_type,
                scope=scope,
                class_name=cls.name,
                package_name=cls.package_name,
                annotation_names=[ann.name for ann in cls.annotations] if cls.annotations else [],
                method_count=len(bean_methods) if bean_type == "configuration" else len(cls.methods) if cls.methods else 0,
                property_count=len(cls.properties) if cls.properties else 0
            )
            beans.append(bean)
    
    return beans


def analyze_bean_dependencies(classes: list[Class], beans: list[Bean]) -> list[BeanDependency]:
    """Analyze dependencies between Spring Beans.
    
    Args:
        classes: List of parsed Class objects
        beans: List of Bean objects
        
    Returns:
        List of BeanDependency objects
    """
    dependencies = []
    
    # Create a mapping from class names to bean names
    class_to_bean = {}
    for bean in beans:
        class_to_bean[bean.class_name] = bean.name
    
    for cls in classes:
        # Check if this class is a bean
        if cls.name not in class_to_bean:
            continue
            
        source_bean = class_to_bean[cls.name]
        
        # Analyze field injections (@Autowired, @Resource, @Value)
        for prop in cls.properties:
            if any(ann.category == "injection" for ann in prop.annotations):
                # Try to determine target bean from field type
                target_bean = None
                field_type = prop.type
                
                # Look for exact class name match
                if field_type in class_to_bean:
                    target_bean = class_to_bean[field_type]
                else:
                    # Look for interface implementations (simplified - just check if type matches any bean class name)
                    for bean in beans:
                        if field_type == bean.class_name:
                            target_bean = bean.name
                            break
                
                if target_bean:
                    injection_type = "field"
                    for ann in prop.annotations:
                        if ann.name == "Autowired":
                            injection_type = "field"
                        elif ann.name == "Resource":
                            injection_type = "field"
                        elif ann.name == "Value":
                            injection_type = "field"
                    
                    dependency = BeanDependency(
                        source_bean=source_bean,
                        target_bean=target_bean,
                        injection_type=injection_type,
                        field_name=prop.name
                    )
                    dependencies.append(dependency)
        
        # Analyze constructor injections
        for method in cls.methods:
            if method.name == cls.name:  # Constructor
                for param in method.parameters:
                    if any(ann.category == "injection" for ann in param.annotations):
                        target_bean = None
                        param_type = param.type
                        
                        if param_type in class_to_bean:
                            target_bean = class_to_bean[param_type]
                        else:
                            # Look for interface implementations (simplified)
                            for bean in beans:
                                if param_type == bean.class_name:
                                    target_bean = bean.name
                                    break
                        
                        if target_bean:
                            dependency = BeanDependency(
                                source_bean=source_bean,
                                target_bean=target_bean,
                                injection_type="constructor",
                                parameter_name=param.name
                            )
                            dependencies.append(dependency)
        
        # Analyze setter injections
        for method in cls.methods:
            if method.name.startswith("set") and len(method.parameters) == 1:
                if any(ann.category == "injection" for ann in method.annotations):
                    param = method.parameters[0]
                    target_bean = None
                    param_type = param.type
                    
                    if param_type in class_to_bean:
                        target_bean = class_to_bean[param_type]
                    else:
                        # Look for interface implementations (simplified)
                        for bean in beans:
                            if param_type == bean.class_name:
                                target_bean = bean.name
                                break
                    
                    if target_bean:
                        dependency = BeanDependency(
                            source_bean=source_bean,
                            target_bean=target_bean,
                            injection_type="setter",
                            method_name=method.name,
                            parameter_name=param.name
                        )
                        dependencies.append(dependency)
    
    return dependencies


def extract_endpoints_from_classes(classes: list[Class]) -> list[Endpoint]:
    """Extract REST API endpoints from controller classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Endpoint objects
    """
    endpoints = []
    
    for cls in classes:
        # Check if class is a controller
        is_controller = any(ann.name in ["Controller", "RestController"] for ann in cls.annotations)
        
        if not is_controller:
            continue
            
        # Get class-level path mapping
        class_path = ""
        for ann in cls.annotations:
            if ann.name == "RequestMapping":
                if "value" in ann.parameters:
                    class_path = ann.parameters["value"]
                break
        
        # Process each method in the controller
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
                
            # Check if method has web mapping annotations
            web_annotations = [ann for ann in method.annotations if ann.category == "web"]
            
            if not web_annotations:
                continue
            
            # Extract endpoint information
            endpoint_path = ""
            http_method = "GET"  # default
            
            for ann in web_annotations:
                if ann.name in ["RequestMapping", "GetMapping", "PostMapping", "PutMapping", "DeleteMapping", "PatchMapping"]:
                    # Extract path
                    if "value" in ann.parameters:
                        endpoint_path = ann.parameters["value"]
                    elif "path" in ann.parameters:
                        endpoint_path = ann.parameters["path"]
                    
                    # Extract HTTP method
                    if ann.name == "GetMapping":
                        http_method = "GET"
                    elif ann.name == "PostMapping":
                        http_method = "POST"
                    elif ann.name == "PutMapping":
                        http_method = "PUT"
                    elif ann.name == "DeleteMapping":
                        http_method = "DELETE"
                    elif ann.name == "PatchMapping":
                        http_method = "PATCH"
                    elif ann.name == "RequestMapping":
                        if "method" in ann.parameters:
                            method_value = ann.parameters["method"]
                            if isinstance(method_value, list) and len(method_value) > 0:
                                http_method = method_value[0]
                            else:
                                http_method = str(method_value)
                        else:
                            http_method = "GET"  # default for RequestMapping
                    break
            
            # Build full path
            full_path = class_path
            if endpoint_path:
                if full_path and not full_path.endswith("/") and not endpoint_path.startswith("/"):
                    full_path += "/"
                full_path += endpoint_path
            elif not full_path:
                full_path = "/"
            
            # Extract method parameters
            parameters = []
            for param in method.parameters:
                param_info = {
                    "name": param.name,
                    "type": param.type,
                    "annotations": [ann.name for ann in param.annotations if ann.category == "web"]
                }
                parameters.append(param_info)
            
            # Extract return type
            return_type = method.return_type if method.return_type != "constructor" else "void"
            
            # Create endpoint
            endpoint = Endpoint(
                path=endpoint_path or "/",
                method=http_method,
                controller_class=cls.name,
                handler_method=method.name,
                parameters=parameters,
                return_type=return_type,
                annotations=[ann.name for ann in web_annotations],
                full_path=full_path
            )
            endpoints.append(endpoint)
    
    return endpoints


def extract_mybatis_mappers_from_classes(classes: list[Class]) -> list[MyBatisMapper]:
    """Extract MyBatis Mappers from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for cls in classes:
        # Check if class is a MyBatis Mapper interface
        is_mapper = any(ann.name == "Mapper" for ann in cls.annotations)
        
        if not is_mapper:
            continue
        
        # Extract mapper methods with MyBatis annotations
        mapper_methods = []
        sql_statements = []
        
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
            
            # Check if method has MyBatis annotations
            mybatis_annotations = [ann for ann in method.annotations if ann.category == "mybatis"]
            
            if not mybatis_annotations:
                continue
            
            # Extract SQL statement information
            sql_type = "SELECT"  # default
            sql_content = ""
            parameter_type = ""
            result_type = ""
            result_map = ""
            
            for ann in mybatis_annotations:
                if ann.name in ["Select", "SelectProvider"]:
                    sql_type = "SELECT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Insert", "InsertProvider"]:
                    sql_type = "INSERT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Update", "UpdateProvider"]:
                    sql_type = "UPDATE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Delete", "DeleteProvider"]:
                    sql_type = "DELETE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                
                # Extract parameter and result type information
                if "parameterType" in ann.parameters:
                    parameter_type = ann.parameters["parameterType"]
                if "resultType" in ann.parameters:
                    result_type = ann.parameters["resultType"]
                if "resultMap" in ann.parameters:
                    result_map = ann.parameters["resultMap"]
            
            # Create method info
            method_info = {
                "name": method.name,
                "return_type": method.return_type,
                "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            mapper_methods.append(method_info)
            
            # Create SQL statement info
            sql_statement = {
                "id": method.name,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            sql_statements.append(sql_statement)
        
        # Create mapper
        mapper = MyBatisMapper(
            name=cls.name,
            type="interface",
            namespace=f"{cls.package_name}.{cls.name}",
            methods=mapper_methods,
            sql_statements=sql_statements,
            file_path=cls.file_path,
            package_name=cls.package_name
        )
        mappers.append(mapper)
    
    return mappers


def parse_mybatis_xml_file(file_path: str) -> MyBatisMapper:
    """Parse MyBatis XML mapper file.
    
    Args:
        file_path: Path to the XML mapper file
        
    Returns:
        MyBatisMapper object
    """
    import xml.etree.ElementTree as ET
    
    try:
        tree = ET.parse(file_path)
        root = tree.getroot()
        
        # Extract namespace
        namespace = root.get("namespace", "")
        
        # Extract SQL statements
        sql_statements = []
        for statement in root.findall(".//*[@id]"):
            statement_id = statement.get("id")
            tag_name = statement.tag.lower()
            
            # Determine SQL type
            sql_type = "SELECT"
            if tag_name == "insert":
                sql_type = "INSERT"
            elif tag_name == "update":
                sql_type = "UPDATE"
            elif tag_name == "delete":
                sql_type = "DELETE"
            
            # Extract SQL content
            sql_content = statement.text.strip() if statement.text else ""
            
            # Extract parameter and result information
            parameter_type = statement.get("parameterType", "")
            result_type = statement.get("resultType", "")
            result_map = statement.get("resultMap", "")
            
            sql_statement = {
                "id": statement_id,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": []
            }
            sql_statements.append(sql_statement)
        
        # Extract ResultMaps
        result_maps = []
        for result_map in root.findall(".//resultMap"):
            result_map_id = result_map.get("id")
            result_map_type = result_map.get("type", "")
            
            properties = []
            for property_elem in result_map.findall(".//result"):
                prop = {
                    "property": property_elem.get("property", ""),
                    "column": property_elem.get("column", ""),
                    "jdbc_type": property_elem.get("jdbcType", "")
                }
                properties.append(prop)
            
            result_map_info = {
                "id": result_map_id,
                "type": result_map_type,
                "properties": properties,
                "associations": [],
                "collections": []
            }
            result_maps.append(result_map_info)
        
        # Create mapper
        mapper_name = namespace.split(".")[-1] if namespace else os.path.basename(file_path).replace(".xml", "")
        package_name = ".".join(namespace.split(".")[:-1]) if namespace else ""
        
        mapper = MyBatisMapper(
            name=mapper_name,
            type="xml",
            namespace=namespace,
            methods=[],  # XML mappers don't have Java methods
            sql_statements=sql_statements,
            file_path=file_path,
            package_name=package_name
        )
        
        return mapper
        
    except ET.ParseError as e:
        print(f"Error parsing XML file {file_path}: {e}")
        return None
    except Exception as e:
        print(f"Error reading XML file {file_path}: {e}")
        return None


def extract_mybatis_xml_mappers(directory: str) -> list[MyBatisMapper]:
    """Extract MyBatis XML mappers from directory.
    
    Args:
        directory: Directory to search for XML mapper files
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith("Mapper.xml") or file.endswith("Dao.xml"):
                file_path = os.path.join(root, file)
                mapper = parse_mybatis_xml_file(file_path)
                if mapper:
                    mappers.append(mapper)
    
    return mappers


def extract_jpa_entities_from_classes(classes: list[Class]) -> list[JpaEntity]:
    """Extract JPA Entities from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of JpaEntity objects
    """
    entities = []
    
    for cls in classes:
        # Check if class is a JPA Entity
        is_entity = any(ann.name == "Entity" for ann in cls.annotations)
        
        if not is_entity:
            continue
        
        # Extract table name
        table_name = cls.name.lower()  # default table name
        for ann in cls.annotations:
            if ann.name == "Table":
                if "name" in ann.parameters:
                    table_name = ann.parameters["name"]
                break
        
        # Extract columns from properties
        columns = []
        relationships = []
        
        for prop in cls.properties:
            # Check if property has JPA column annotations
            jpa_annotations = [ann for ann in prop.annotations if ann.category == "jpa"]
            
            if jpa_annotations:
                # Extract column information
                column_name = prop.name  # default column name
                nullable = True
                unique = False
                length = 0
                precision = 0
                scale = 0
                
                for ann in jpa_annotations:
                    if ann.name == "Column":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                        if "nullable" in ann.parameters:
                            nullable = ann.parameters["nullable"]
                        if "unique" in ann.parameters:
                            unique = ann.parameters["unique"]
                        if "length" in ann.parameters:
                            length = ann.parameters["length"]
                        if "precision" in ann.parameters:
                            precision = ann.parameters["precision"]
                        if "scale" in ann.parameters:
                            scale = ann.parameters["scale"]
                    elif ann.name == "Id":
                        column_name = "id"  # Primary key column
                        nullable = False
                        unique = True
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                
                # Check for relationship annotations
                relationship_type = None
                target_entity = ""
                mapped_by = ""
                join_column = ""
                join_table = ""
                cascade = []
                fetch = "LAZY"
                
                for ann in jpa_annotations:
                    if ann.name in ["OneToOne", "OneToMany", "ManyToOne", "ManyToMany"]:
                        relationship_type = ann.name
                        if "targetEntity" in ann.parameters:
                            target_entity = ann.parameters["targetEntity"]
                        if "mappedBy" in ann.parameters:
                            mapped_by = ann.parameters["mappedBy"]
                        if "cascade" in ann.parameters:
                            cascade = ann.parameters["cascade"] if isinstance(ann.parameters["cascade"], list) else [ann.parameters["cascade"]]
                        if "fetch" in ann.parameters:
                            fetch = ann.parameters["fetch"]
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            join_column = ann.parameters["name"]
                    elif ann.name == "JoinTable":
                        if "name" in ann.parameters:
                            join_table = ann.parameters["name"]
                
                # Create column info
                column_info = {
                    "property_name": prop.name,
                    "column_name": column_name,
                    "data_type": prop.type,
                    "nullable": nullable,
                    "unique": unique,
                    "length": length,
                    "precision": precision,
                    "scale": scale,
                    "annotations": [ann.name for ann in jpa_annotations]
                }
                columns.append(column_info)
                
                # Create relationship info if it's a relationship
                if relationship_type:
                    relationship_info = {
                        "type": relationship_type,
                        "target_entity": target_entity,
                        "mapped_by": mapped_by,
                        "join_column": join_column,
                        "join_table": join_table,
                        "cascade": cascade,
                        "fetch": fetch,
                        "annotations": [ann.name for ann in jpa_annotations]
                    }
                    relationships.append(relationship_info)
        
        # Create entity
        entity = JpaEntity(
            name=cls.name,
            table_name=table_name,
            columns=columns,
            relationships=relationships,
            annotations=[ann.name for ann in cls.annotations if ann.category == "jpa"],
            package_name=cls.package_name,
            file_path=cls.file_path
        )
        entities.append(entity)
    
    return entities


def parse_yaml_config(file_path: str) -> ConfigFile:
    """Parse YAML configuration file.
    
    Args:
        file_path: Path to the YAML file
        
    Returns:
        ConfigFile object
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = yaml.safe_load(f)
        
        if not content:
            content = {}
        
        # Extract file info
        file_name = os.path.basename(file_path)
        file_type = "yaml" if file_path.endswith('.yaml') else "yml"
        
        # Extract profiles
        profiles = []
        if 'spring' in content and 'profiles' in content['spring']:
            if 'active' in content['spring']['profiles']:
                profiles = content['spring']['profiles']['active']
                if isinstance(profiles, str):
                    profiles = [profiles]
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        # Extract sections
        sections = []
        for key, value in content.items():
            if isinstance(value, dict):
                sections.append({
                    "name": key,
                    "properties": value,
                    "type": "section"
                })
        
        return ConfigFile(
            name=file_name,
            file_path=file_path,
            file_type=file_type,
            properties=content,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing YAML file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="yaml",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def parse_properties_config(file_path: str) -> ConfigFile:
    """Parse Properties configuration file.
    
    Args:
        file_path: Path to the properties file
        
    Returns:
        ConfigFile object
    """
    try:
        properties = {}
        sections = []
        profiles = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                
                # Skip empty lines and comments
                if not line or line.startswith('#'):
                    continue
                
                # Parse key=value pairs
                if '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    
                    # Remove quotes if present
                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]
                    elif value.startswith("'") and value.endswith("'"):
                        value = value[1:-1]
                    
                    properties[key] = value
                    
                    # Check for profiles
                    if key == 'spring.profiles.active':
                        profiles = [p.strip() for p in value.split(',')]
        
        # Group properties by section
        section_map = {}
        for key, value in properties.items():
            if '.' in key:
                section = key.split('.')[0]
                if section not in section_map:
                    section_map[section] = {}
                section_map[section][key] = value
            else:
                if 'root' not in section_map:
                    section_map['root'] = {}
                section_map['root'][key] = value
        
        for section_name, section_props in section_map.items():
            sections.append({
                "name": section_name,
                "properties": section_props,
                "type": "section"
            })
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties=properties,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing Properties file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def extract_database_config(config_file: ConfigFile) -> DatabaseConfig:
    """Extract database configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        DatabaseConfig object
    """
    db_config = DatabaseConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        spring_config = config_file.properties.get('spring', {})
        datasource_config = spring_config.get('datasource', {})
        jpa_config = spring_config.get('jpa', {})
        
        db_config.driver = datasource_config.get('driver-class-name', '')
        db_config.url = datasource_config.get('url', '')
        db_config.username = datasource_config.get('username', '')
        db_config.password = datasource_config.get('password', '')
        db_config.dialect = jpa_config.get('database-platform', '')
        db_config.hibernate_ddl_auto = jpa_config.get('hibernate', {}).get('ddl-auto', '')
        db_config.show_sql = jpa_config.get('show-sql', False)
        db_config.format_sql = jpa_config.get('properties', {}).get('hibernate', {}).get('format_sql', False)
        
        # Store additional JPA properties
        if 'properties' in jpa_config:
            db_config.jpa_properties = jpa_config['properties']
    
    else:
        # Properties format
        props = config_file.properties
        
        db_config.driver = props.get('spring.datasource.driver-class-name', '')
        db_config.url = props.get('spring.datasource.url', '')
        db_config.username = props.get('spring.datasource.username', '')
        db_config.password = props.get('spring.datasource.password', '')
        db_config.dialect = props.get('spring.jpa.database-platform', '')
        db_config.hibernate_ddl_auto = props.get('spring.jpa.hibernate.ddl-auto', '')
        db_config.show_sql = props.get('spring.jpa.show-sql', 'false').lower() == 'true'
        db_config.format_sql = props.get('spring.jpa.properties.hibernate.format_sql', 'false').lower() == 'true'
        
        # Store additional JPA properties
        jpa_props = {}
        for key, value in props.items():
            if key.startswith('spring.jpa.properties.'):
                jpa_props[key] = value
        db_config.jpa_properties = jpa_props
    
    return db_config


def extract_server_config(config_file: ConfigFile) -> ServerConfig:
    """Extract server configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        ServerConfig object
    """
    server_config = ServerConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        server_props = config_file.properties.get('server', {})
        
        server_config.port = server_props.get('port', 8080)
        server_config.context_path = server_props.get('servlet', {}).get('context-path', '')
        server_config.servlet_path = server_props.get('servlet', {}).get('path', '')
        
        # SSL configuration
        ssl_config = server_props.get('ssl', {})
        server_config.ssl_enabled = bool(ssl_config)
        server_config.ssl_key_store = ssl_config.get('key-store', '')
        server_config.ssl_key_store_password = ssl_config.get('key-store-password', '')
        server_config.ssl_key_store_type = ssl_config.get('key-store-type', '')
    
    else:
        # Properties format
        props = config_file.properties
        
        server_config.port = int(props.get('server.port', '8080'))
        server_config.context_path = props.get('server.servlet.context-path', '')
        server_config.servlet_path = props.get('server.servlet.path', '')
        
        # SSL configuration
        server_config.ssl_enabled = any(key.startswith('server.ssl.') for key in props.keys())
        server_config.ssl_key_store = props.get('server.ssl.key-store', '')
        server_config.ssl_key_store_password = props.get('server.ssl.key-store-password', '')
        server_config.ssl_key_store_type = props.get('server.ssl.key-store-type', '')
    
    return server_config


def extract_security_config(config_file: ConfigFile) -> SecurityConfig:
    """Extract security configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        SecurityConfig object
    """
    security_config = SecurityConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        security_props = config_file.properties.get('security', {})
        jwt_props = security_props.get('jwt', {})
        cors_props = security_props.get('cors', {})
        
        security_config.enabled = bool(security_props)
        security_config.authentication_type = security_props.get('authentication-type', '')
        security_config.jwt_secret = jwt_props.get('secret', '')
        security_config.jwt_expiration = jwt_props.get('expiration', 0)
        security_config.cors_allowed_origins = cors_props.get('allowed-origins', [])
        security_config.cors_allowed_methods = cors_props.get('allowed-methods', [])
        security_config.cors_allowed_headers = cors_props.get('allowed-headers', [])
    
    else:
        # Properties format
        props = config_file.properties
        
        security_config.enabled = any(key.startswith('security.') for key in props.keys())
        security_config.authentication_type = props.get('security.authentication-type', '')
        security_config.jwt_secret = props.get('security.jwt.secret', '')
        security_config.jwt_expiration = int(props.get('security.jwt.expiration', '0'))
        
        # CORS configuration
        origins = props.get('security.cors.allowed-origins', '')
        if origins:
            security_config.cors_allowed_origins = [o.strip() for o in origins.split(',')]
        
        methods = props.get('security.cors.allowed-methods', '')
        if methods:
            security_config.cors_allowed_methods = [m.strip() for m in methods.split(',')]
        
        headers = props.get('security.cors.allowed-headers', '')
        if headers:
            security_config.cors_allowed_headers = [h.strip() for h in headers.split(',')]
    
    return security_config


def extract_logging_config(config_file: ConfigFile) -> LoggingConfig:
    """Extract logging configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        LoggingConfig object
    """
    logging_config = LoggingConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        logging_props = config_file.properties.get('logging', {})
        
        logging_config.level = logging_props.get('level', {}).get('root', 'INFO')
        logging_config.pattern = logging_props.get('pattern', {}).get('console', '')
        logging_config.file_path = logging_props.get('file', {}).get('name', '')
        logging_config.max_file_size = logging_props.get('file', {}).get('max-size', '')
        logging_config.max_history = logging_props.get('file', {}).get('max-history', 0)
        logging_config.console_output = logging_props.get('console', {}).get('enabled', True)
    
    else:
        # Properties format
        props = config_file.properties
        
        logging_config.level = props.get('logging.level.root', 'INFO')
        logging_config.pattern = props.get('logging.pattern.console', '')
        logging_config.file_path = props.get('logging.file.name', '')
        logging_config.max_file_size = props.get('logging.file.max-size', '')
        logging_config.max_history = int(props.get('logging.file.max-history', '0'))
        logging_config.console_output = props.get('logging.console.enabled', 'true').lower() == 'true'
    
    return logging_config


def extract_config_files(directory: str) -> list[ConfigFile]:
    """Extract configuration files from directory.
    
    Args:
        directory: Directory to search for config files
        
    Returns:
        List of ConfigFile objects
    """
    config_files = []
    
    # Common config file patterns
    config_patterns = [
        "application.yml",
        "application.yaml", 
        "application.properties",
        "application-*.properties",
        "bootstrap.yml",
        "bootstrap.yaml",
        "bootstrap.properties"
    ]
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            # Check if file matches any config pattern
            is_config_file = False
            for pattern in config_patterns:
                if pattern == file or (pattern.endswith('*') and file.startswith(pattern[:-1])):
                    is_config_file = True
                    break
            
            if is_config_file:
                file_path = os.path.join(root, file)
                
                if file.endswith(('.yml', '.yaml')):
                    config_file = parse_yaml_config(file_path)
                elif file.endswith('.properties'):
                    config_file = parse_properties_config(file_path)
                else:
                    continue
                
                config_files.append(config_file)
    
    return config_files


def extract_test_classes_from_classes(classes: list[Class]) -> list[TestClass]:
    """Extract test classes from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of TestClass objects
    """
    test_classes = []
    
    for cls in classes:
        # Check if class is a test class
        test_annotations = [ann for ann in cls.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
        
        if not test_annotations:
            continue
        
        # Determine test framework and type
        test_framework = "junit"  # default
        test_type = "unit"  # default
        
        for ann in test_annotations:
            if ann.name in ["SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest", "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest"]:
                test_framework = "spring_test"
                if ann.name == "SpringBootTest":
                    test_type = "integration"
                else:
                    test_type = "slice"
            elif ann.name in ["TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass"]:
                test_framework = "testng"
            elif ann.name in ["Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll"]:
                test_framework = "junit"
        
        # Extract test methods
        test_methods = []
        setup_methods = []
        
        for method in cls.methods:
            method_annotations = [ann.name for ann in method.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
            
            if method_annotations:
                # Check if it's a setup/teardown method
                if any(ann in method_annotations for ann in ["BeforeEach", "AfterEach", "BeforeAll", "AfterAll", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass", "BeforeSuite", "AfterSuite"]):
                    setup_methods.append({
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters]
                    })
                else:
                    # Regular test method
                    test_method_info = {
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                        "assertions": [],
                        "mock_calls": [],
                        "test_data": [],
                        "expected_exceptions": [],
                        "timeout": 0,
                        "display_name": ""
                    }
                    
                    # Extract display name
                    for ann in method.annotations:
                        if ann.name == "DisplayName" and "value" in ann.parameters:
                            test_method_info["display_name"] = ann.parameters["value"]
                        elif ann.name == "Timeout" and "value" in ann.parameters:
                            test_method_info["timeout"] = ann.parameters["value"]
                    
                    # Extract expected exceptions
                    for ann in method.annotations:
                        if ann.name == "ExpectedExceptions" and "value" in ann.parameters:
                            test_method_info["expected_exceptions"] = ann.parameters["value"] if isinstance(ann.parameters["value"], list) else [ann.parameters["value"]]
                    
                    test_methods.append(test_method_info)
        
        # Extract mock dependencies
        mock_dependencies = []
        for prop in cls.properties:
            prop_annotations = [ann.name for ann in prop.annotations if classify_test_annotation(ann.name) in ["mockito", "spring_test"]]
            if prop_annotations:
                mock_dependencies.append({
                    "name": prop.name,
                    "type": prop.type,
                    "annotations": prop_annotations,
                    "mock_type": "mock" if "Mock" in prop_annotations else "spy" if "Spy" in prop_annotations else "bean"
                })
        
        # Extract test configurations
        test_configurations = []
        for ann in cls.annotations:
            if ann.name in ["TestConfiguration", "ActiveProfiles", "TestPropertySource"]:
                config_info = {
                    "name": ann.name,
                    "type": "configuration" if ann.name == "TestConfiguration" else "profile" if ann.name == "ActiveProfiles" else "property",
                    "properties": ann.parameters,
                    "active_profiles": ann.parameters.get("value", []) if ann.name == "ActiveProfiles" else [],
                    "test_slices": [],
                    "mock_beans": [],
                    "spy_beans": []
                }
                test_configurations.append(config_info)
        
        # Create test class
        test_class = TestClass(
            name=cls.name,
            package_name=cls.package_name,
            test_framework=test_framework,
            test_type=test_type,
            annotations=[ann.name for ann in test_annotations],
            test_methods=test_methods,
            setup_methods=setup_methods,
            mock_dependencies=mock_dependencies,
            test_configurations=test_configurations,
            file_path=cls.file_path
        )
        test_classes.append(test_class)
    
    return test_classes


def analyze_test_methods(test_class: TestClass, class_obj: Class) -> list[TestMethod]:
    """Analyze test methods for assertions, mock calls, and test data.
    
    Args:
        test_class: TestClass object
        class_obj: Original Class object
        
    Returns:
        List of analyzed TestMethod objects
    """
    test_methods = []
    
    for method_info in test_class.test_methods:
        # Find the corresponding method in the class
        method_obj = None
        for method in class_obj.methods:
            if method.name == method_info["name"]:
                method_obj = method
                break
        
        if not method_obj:
            continue
        
        # Analyze method source code for assertions and mock calls
        assertions = []
        mock_calls = []
        test_data = []
        
        if method_obj.source:
            source_code = method_obj.source
            
            # Find assertions (JUnit, AssertJ, etc.)
            assertion_patterns = [
                r'assert\w+\(',  # JUnit assertions
                r'assertThat\(',  # AssertJ
                r'assertEquals\(',  # JUnit
                r'assertTrue\(',  # JUnit
                r'assertFalse\(',  # JUnit
                r'assertNotNull\(',  # JUnit
                r'assertNull\(',  # JUnit
                r'assertThrows\(',  # JUnit 5
                r'assertDoesNotThrow\(',  # JUnit 5
                r'verify\(',  # Mockito verify
                r'when\(',  # Mockito when
                r'then\(',  # Mockito then
                r'given\(',  # BDDMockito given
                r'willReturn\(',  # Mockito willReturn
                r'willThrow\(',  # Mockito willThrow
            ]
            
            for pattern in assertion_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    assertions.append({
                        "type": match,
                        "line": source_code.find(match) + 1
                    })
            
            # Find mock calls
            mock_call_patterns = [
                r'(\w+)\.(\w+)\(',  # Method calls on objects
                r'mock\(',  # Mockito mock creation
                r'spy\(',  # Mockito spy creation
                r'@Mock\s+(\w+)',  # @Mock annotation
                r'@Spy\s+(\w+)',  # @Spy annotation
                r'@InjectMocks\s+(\w+)',  # @InjectMocks annotation
            ]
            
            for pattern in mock_call_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        mock_calls.append({
                            "object": match[0],
                            "method": match[1],
                            "type": "method_call"
                        })
                    else:
                        mock_calls.append({
                            "type": match,
                            "line": source_code.find(match) + 1
                        })
            
            # Find test data setup
            test_data_patterns = [
                r'new\s+(\w+)\(',  # Object creation
                r'(\w+)\s*=\s*new\s+(\w+)\(',  # Variable assignment with new
                r'@ValueSource\(',  # JUnit 5 @ValueSource
                r'@CsvSource\(',  # JUnit 5 @CsvSource
                r'@MethodSource\(',  # JUnit 5 @MethodSource
            ]
            
            for pattern in test_data_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        test_data.append({
                            "variable": match[0],
                            "type": match[1],
                            "pattern": "object_creation"
                        })
                    else:
                        test_data.append({
                            "type": match,
                            "pattern": "annotation"
                        })
        
        # Create TestMethod object
        test_method = TestMethod(
            name=method_info["name"],
            return_type=method_info["return_type"],
            annotations=method_info["annotations"],
            assertions=assertions,
            mock_calls=mock_calls,
            test_data=test_data,
            expected_exceptions=method_info["expected_exceptions"],
            timeout=method_info["timeout"],
            display_name=method_info["display_name"]
        )
        test_methods.append(test_method)
    
    return test_methods


def generate_lombok_methods(properties: list[Field], class_name: str, package_name: str) -> list[Method]:
    """Generate Lombok @Data methods (getters, setters, equals, hashCode, toString) for properties."""
    methods = []
    
    # Generate getters and setters for each property
    for prop in properties:
        # Getter
        getter_name = f"get{prop.name[0].upper()}{prop.name[1:]}"
        if prop.type == "Boolean" and prop.name.startswith("is"):
            # For boolean fields starting with 'is', use the field name as getter
            getter_name = prop.name
        
        getter = Method(
            name=getter_name,
            logical_name=f"{package_name}.{class_name}.{getter_name}",
            return_type=prop.type,
            parameters=[],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[],
            description=f"Generated getter for {prop.name} field"  # Generated method description
        )
        methods.append(getter)
        
        # Setter
        setter_name = f"set{prop.name[0].upper()}{prop.name[1:]}"
        setter_param = Field(
            name=prop.name,
            logical_name=f"{package_name}.{class_name}.{prop.name}",
            type=prop.type,
            package_name=package_name,
            class_name=class_name
        )
        
        setter = Method(
            name=setter_name,
            logical_name=f"{package_name}.{class_name}.{setter_name}",
            return_type="void",
            parameters=[setter_param],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[],
            description=f"Generated setter for {prop.name} field"  # Generated method description
        )
        methods.append(setter)
    
    # Generate equals method
    equals_method = Method(
        name="equals",
        logical_name=f"{package_name}.{class_name}.equals",
        return_type="boolean",
        parameters=[Field(name="obj", logical_name=f"{package_name}.{class_name}.obj", type="Object", package_name=package_name, class_name=class_name)],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated equals method for object comparison"  # Generated method description
    )
    methods.append(equals_method)
    
    # Generate hashCode method
    hashcode_method = Method(
        name="hashCode",
        logical_name=f"{package_name}.{class_name}.hashCode",
        return_type="int",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated hashCode method for object hashing"  # Generated method description
    )
    methods.append(hashcode_method)
    
    # Generate toString method
    tostring_method = Method(
        name="toString",
        logical_name=f"{package_name}.{class_name}.toString",
        return_type="String",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated toString method for string representation"  # Generated method description
    )
    methods.append(tostring_method)
    
    return methods


def parse_java_project(directory: str) -> tuple[list[Package], list[Class], dict[str, str], list[Bean], list[BeanDependency], list[Endpoint], list[MyBatisMapper], list[JpaEntity], list[ConfigFile], list[TestClass], list[SqlStatement], str]:
    """Parse Java project and return parsed entities."""
    logger = get_logger(__name__)
    """Parses all Java files in a directory and returns a tuple of (packages, classes, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name)."""
    
    # Extract project name from directory path
    project_name = extract_project_name(directory)
    packages = {}
    classes = {}
    class_to_package_map = {}  # Maps class_key to package_name

    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith(".java"):
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    file_content = f.read() # Read file content once
                try:
                    tree = javalang.parse.parse(file_content)
                    package_name = tree.package.name if tree.package else ""
                    
                    # Create or update package node
                    if package_name and package_name not in packages:
                        packages[package_name] = Package(
                            name=package_name
                        )
                    elif not package_name:
                        # Handle classes without package (default package)
                        package_name = "default"
                        if package_name not in packages:
                            packages[package_name] = Package(
                                name=package_name
                            )
                    
                    import_map = {}
                    for imp in tree.imports:
                        class_name = imp.path.split('.')[-1]
                        import_map[class_name] = imp.path

                    for _, class_declaration in tree.filter(
                        javalang.tree.ClassDeclaration
                    ):
                        class_name = class_declaration.name
                        class_key = f"{package_name}.{class_name}"
                        
                        # Debug: Check if this is the User class
                        if "User" in class_name:
                            logger.debug(f"Found User class - {class_key}")
                            logger.debug(f"Methods count: {len(class_declaration.methods)}")
                            logger.debug(f"Constructors count: {len(class_declaration.constructors)}")
                        
                        # Extract class source code - use the entire file content
                        class_source = file_content


                        if class_key not in classes:
                            # Parse class annotations
                            class_annotations = parse_annotations(class_declaration.annotations, "class") if hasattr(class_declaration, 'annotations') else []
                            
                            classes[class_key] = Class(
                                name=class_name,
                                logical_name=class_key,  # Add logical_name
                                file_path=file_path,
                                type="class", # Simplified for now
                                source=class_source, # Add class source
                                annotations=class_annotations,
                                package_name=package_name
                            )
                            class_to_package_map[class_key] = package_name
                        
                        # --- Start of new import logic ---
                        for imp in tree.imports:
                            classes[class_key].imports.append(imp.path)
                        # --- End of new import logic ---

                        # --- Start of new inheritance logic ---
                        # Handle 'extends'
                        if class_declaration.extends:
                            superclass_name = class_declaration.extends.name
                            # Try to resolve fully qualified name for superclass
                            if superclass_name in import_map:
                                classes[class_key].superclass = import_map[superclass_name]
                            else:
                                # Assume same package or fully qualified if not in import_map
                                classes[class_key].superclass = f"{package_name}.{superclass_name}" if package_name else superclass_name

                        # Handle 'implements'
                        if class_declaration.implements: # Add this check
                            for impl_ref in class_declaration.implements:
                                interface_name = impl_ref.name
                                # Try to resolve fully qualified name for interface
                                if interface_name in import_map:
                                    classes[class_key].interfaces.append(import_map[interface_name])
                                else:
                                    # Assume same package or fully qualified if not in import_map
                                    classes[class_key].interfaces.append(f"{package_name}.{interface_name}" if package_name else interface_name)
                        # --- End of new inheritance logic ---

                        field_map = {}
                        for field_declaration in class_declaration.fields:
                            for declarator in field_declaration.declarators:
                                field_map[declarator.name] = field_declaration.type.name
                                
                                # Parse field annotations
                                field_annotations = parse_annotations(field_declaration.annotations, "field") if hasattr(field_declaration, 'annotations') else []
                                
                                # Extract initial value if present
                                initial_value = ""
                                if hasattr(declarator, 'initializer') and declarator.initializer:
                                    # Convert the initializer to string representation
                                    if hasattr(declarator.initializer, 'value'):
                                        initial_value = str(declarator.initializer.value)
                                    elif hasattr(declarator.initializer, 'type'):
                                        initial_value = str(declarator.initializer.type)
                                    else:
                                        initial_value = str(declarator.initializer)
                                
                                prop = Field(
                                    name=declarator.name,
                                    logical_name=f"{package_name}.{class_name}.{declarator.name}",
                                    type=field_declaration.type.name,
                                    modifiers=list(field_declaration.modifiers), # Add modifiers
                                    package_name=package_name,
                                    class_name=class_name,
                                    annotations=field_annotations,
                                    initial_value=initial_value,
                                    description=""  # TODO: Extract description from comments or annotations
                                )
                                classes[class_key].properties.append(prop)

                        all_declarations = class_declaration.methods + class_declaration.constructors
                        
                        # Debug: Check User class method processing
                        if "User" in class_name:
                            logger.debug(f"Processing User class methods - total declarations: {len(all_declarations)}")
                            for i, decl in enumerate(all_declarations):
                                logger.debug(f"Declaration {i}: {type(decl).__name__} - {decl.name}")
                        
                        for declaration in all_declarations:
                            local_var_map = field_map.copy()
                            params = []
                            for param in declaration.parameters:
                                param_type_name = 'Unknown'
                                if hasattr(param.type, 'name'):
                                    param_type_name = param.type.name
                                local_var_map[param.name] = param_type_name
                                params.append(Field(name=param.name, logical_name=f"{package_name}.{class_name}.{param.name}", type=param_type_name, package_name=package_name, class_name=class_name))

                            if declaration.body:
                                for _, var_decl in declaration.filter(javalang.tree.LocalVariableDeclaration):
                                    for declarator in var_decl.declarators:
                                        local_var_map[declarator.name] = var_decl.type.name
                            
                            if isinstance(declaration, javalang.tree.MethodDeclaration):
                                return_type = declaration.return_type.name if declaration.return_type else "void"
                            else: # ConstructorDeclaration
                                return_type = "constructor"

                            # Extract modifiers
                            modifiers = list(declaration.modifiers)
                            
                            # Parse method annotations
                            method_annotations = parse_annotations(declaration.annotations, "method") if hasattr(declaration, 'annotations') else []

                            # Extract method source code
                            method_source = ""
                            if declaration.position:
                                lines = file_content.splitlines(keepends=True) # Keep line endings
                                start_line = declaration.position.line - 1
                                
                                # Find the end of the method by matching braces
                                brace_count = 0
                                end_line = start_line
                                for i in range(start_line, len(lines)):
                                    line = lines[i]
                                    for char in line:
                                        if char == '{':
                                            brace_count += 1
                                        elif char == '}':
                                            brace_count -= 1
                                            if brace_count == 0:
                                                end_line = i
                                                break
                                    if brace_count == 0:
                                        break
                                
                                method_source = "".join(lines[start_line:end_line + 1])

                            method = Method(
                                name=declaration.name,
                                logical_name=f"{class_key}.{declaration.name}",  # Add logical_name
                                return_type=return_type,
                                parameters=params,
                                modifiers=modifiers,
                                source=method_source, # Add method source
                                package_name=package_name,
                                annotations=method_annotations
                            )
                            classes[class_key].methods.append(method)

                            # Extract method calls with order information
                            call_order = 0
                            for _, invocation in declaration.filter(javalang.tree.MethodInvocation):
                                target_class_name = None
                                resolved_target_package = ""
                                resolved_target_class_name = ""
                                
                                if invocation.qualifier:
                                    # External method call
                                    if invocation.qualifier in local_var_map:
                                        target_class_name = local_var_map[invocation.qualifier]
                                    else:
                                        target_class_name = invocation.qualifier
                                    
                                    if target_class_name:
                                        if target_class_name == "System.out":
                                            resolved_target_package = "java.io"
                                            resolved_target_class_name = "PrintStream"
                                        else:
                                            if target_class_name in import_map:
                                                resolved_target_package = ".".join(import_map[target_class_name].split(".")[:-1])
                                            else:
                                                resolved_target_package = package_name
                                                resolved_target_class_name = target_class_name
                                else:
                                    # Same class method call
                                    resolved_target_package = package_name
                                    resolved_target_class_name = class_name

                                if resolved_target_class_name:
                                    # Get line number from invocation position
                                    line_number = invocation.position.line if invocation.position else 0

                                    call = MethodCall(
                                        source_package=package_name,
                                        source_class=class_name,
                                        source_method=declaration.name,
                                        target_package=resolved_target_package,
                                        target_class=resolved_target_class_name,
                                        target_method=invocation.member,
                                        call_order=call_order,
                                        line_number=line_number,
                                        return_type="void"  # Default return type, can be enhanced later
                                    )
                                    classes[class_key].calls.append(call)
                                    call_order += 1
                        
                        # Check for Lombok @Data annotation and generate methods
                        has_data_annotation = any(ann.name == "Data" for ann in classes[class_key].annotations)
                        if has_data_annotation:
                            logger.debug(f"Found @Data annotation on {class_name}, generating Lombok methods")
                            lombok_methods = generate_lombok_methods(classes[class_key].properties, class_name, package_name)
                            classes[class_key].methods.extend(lombok_methods)
                            logger.debug(f"Generated {len(lombok_methods)} Lombok methods for {class_name}")
                except javalang.parser.JavaSyntaxError as e:
                    print(f"Syntax error in {file_path}: {e}")
                    continue
                except Exception as e:
                    print(f"Error parsing {file_path}: {e}")
                    continue
    
    # Extract beans, analyze dependencies, extract endpoints, extract MyBatis mappers, extract JPA entities, extract config files, and extract test classes
    classes_list = list(classes.values())
    beans = extract_beans_from_classes(classes_list)
    dependencies = analyze_bean_dependencies(classes_list, beans)
    endpoints = extract_endpoints_from_classes(classes_list)
    mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
    jpa_entities = extract_jpa_entities_from_classes(classes_list)
    config_files = extract_config_files(directory)
    test_classes = extract_test_classes_from_classes(classes_list)
    
    # Also extract XML mappers
    xml_mappers = extract_mybatis_xml_mappers(directory)
    mybatis_mappers.extend(xml_mappers)
    
    # Extract SQL statements from MyBatis mappers
    sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
    
    return list(packages.values()), classes_list, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name
```

이제 실제 메서드 파싱 부분에서도 description을 추가하겠습니다.


```python
import os
import yaml
import re
from pathlib import Path

import javalang

from src.models.graph_entities import Class, Method, MethodCall, Field, Package, Annotation, Bean, BeanDependency, Endpoint, MyBatisMapper, MyBatisSqlStatement, MyBatisResultMap, SqlStatement, JpaEntity, JpaColumn, JpaRelationship, ConfigFile, DatabaseConfig, ServerConfig, SecurityConfig, LoggingConfig, TestClass, TestMethod, TestConfiguration
from src.utils.logger import get_logger
from typing import Optional, List, Literal


def extract_project_name(java_source_folder: str) -> str:
    """
    JAVA_SOURCE_FOLDER 경로에서 프로젝트 이름을 추출합니다.
    
    Args:
        java_source_folder: Java 소스 폴더 경로
        
    Returns:
        프로젝트 이름 (마지막 디렉토리명)
    """
    # 경로를 정규화하고 마지막 디렉토리명 추출
    path = Path(java_source_folder).resolve()
    return path.name


def extract_sql_statements_from_mappers(mybatis_mappers: list[MyBatisMapper], project_name: str) -> list[SqlStatement]:
    """
    MyBatis mappers에서 SQL statements를 추출합니다.
    
    Args:
        mybatis_mappers: MyBatis mapper 객체들의 리스트
        project_name: 프로젝트 이름
        
    Returns:
        SqlStatement 객체들의 리스트
    """
    sql_statements = []
    
    for mapper in mybatis_mappers:
        for sql_dict in mapper.sql_statements:
            # MyBatisSqlStatement를 SqlStatement로 변환
            sql_statement = SqlStatement(
                id=sql_dict.get('id', ''),
                sql_type=sql_dict.get('sql_type', ''),
                sql_content=sql_dict.get('sql_content', ''),
                parameter_type=sql_dict.get('parameter_type', ''),
                result_type=sql_dict.get('result_type', ''),
                result_map=sql_dict.get('result_map', ''),
                mapper_name=mapper.name,
                annotations=[],  # TODO: annotations를 파싱하여 추가
                project_name=project_name
            )
            sql_statements.append(sql_statement)
    
    return sql_statements


def parse_annotations(annotations, target_type: str = "class") -> list[Annotation]:
    """Parse Java annotations into Annotation objects.
    
    Args:
        annotations: List of annotation nodes from javalang
        target_type: Type of target ("class", "method", "field")
    """
    result = []
    for annotation in annotations:
        annotation_name = annotation.name
        parameters = {}
        
        # Parse annotation parameters if they exist
        if hasattr(annotation, 'element') and annotation.element:
            for element in annotation.element:
                if hasattr(element, 'name') and hasattr(element, 'value'):
                    parameters[element.name] = element.value.value if hasattr(element.value, 'value') else str(element.value)
        
        result.append(Annotation(
            name=annotation_name,
            parameters=parameters,
            target_type=target_type,
            category=classify_springboot_annotation(annotation_name)
        ))
    
    return result


def classify_springboot_annotation(annotation_name: str) -> str:
    """Classify SpringBoot annotations into categories.
    
    Args:
        annotation_name: Name of the annotation (e.g., "@Component", "@Service")
        
    Returns:
        Category of the annotation
    """
    # Component annotations
    component_annotations = {
        "Component", "Service", "Repository", "Controller", 
        "RestController", "Configuration", "Bean"
    }
    
    # Injection annotations
    injection_annotations = {
        "Autowired", "Resource", "Value", "Qualifier", "Primary"
    }
    
    # Web annotations
    web_annotations = {
        "RequestMapping", "GetMapping", "PostMapping", "PutMapping", 
        "DeleteMapping", "PatchMapping", "RequestParam", "PathVariable",
        "RequestBody", "ResponseBody", "ResponseStatus"
    }
    
    # JPA annotations
    jpa_annotations = {
        "Entity", "Table", "Id", "Column", "OneToMany", "ManyToOne",
        "OneToOne", "ManyToMany", "JoinColumn", "GeneratedValue"
    }
    
    # Test annotations
    test_annotations = {
        "Test", "SpringBootTest", "DataJpaTest", "WebMvcTest",
        "MockBean", "SpyBean", "TestPropertySource"
    }
    
    # Security annotations
    security_annotations = {
        "PreAuthorize", "PostAuthorize", "Secured", "RolesAllowed",
        "EnableWebSecurity", "EnableGlobalMethodSecurity"
    }
    
    # Validation annotations
    validation_annotations = {
        "Valid", "NotNull", "NotBlank", "NotEmpty", "Size", "Min", "Max",
        "Pattern", "Email", "AssertTrue", "AssertFalse"
    }
    
    # MyBatis annotations
    mybatis_annotations = {
        "Mapper", "Select", "Insert", "Update", "Delete", "SelectProvider",
        "InsertProvider", "UpdateProvider", "DeleteProvider", "Results",
        "Result", "One", "Many", "MapKey", "Options", "SelectKey"
    }
    
    if annotation_name in component_annotations:
        return "component"
    elif annotation_name in injection_annotations:
        return "injection"
    elif annotation_name in web_annotations:
        return "web"
    elif annotation_name in jpa_annotations:
        return "jpa"
    elif annotation_name in test_annotations:
        return "test"
    elif annotation_name in security_annotations:
        return "security"
    elif annotation_name in validation_annotations:
        return "validation"
    elif annotation_name in mybatis_annotations:
        return "mybatis"
    else:
        return "other"


def classify_test_annotation(annotation_name: str) -> str:
    """Classify test annotations into categories.
    
    Args:
        annotation_name: Name of the annotation
        
    Returns:
        Category of the test annotation
    """
    # JUnit annotations
    junit_annotations = {
        "Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll",
        "DisplayName", "ParameterizedTest", "ValueSource", "CsvSource",
        "MethodSource", "Timeout", "Disabled", "Nested", "RepeatedTest",
        "Order", "TestMethodOrder", "TestInstance", "TestClassOrder"
    }
    
    # Spring Boot Test annotations
    spring_test_annotations = {
        "SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest",
        "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest",
        "MockBean", "SpyBean", "TestConfiguration", "ActiveProfiles",
        "TestPropertySource", "DirtiesContext", "Transactional",
        "Rollback", "Commit", "Sql", "SqlGroup", "AutoConfigureTestDatabase",
        "AutoConfigureMockMvc", "AutoConfigureWebMvc", "AutoConfigureWebClient",
        "MockMvc", "TestEntityManager", "TestContainers", "DynamicPropertySource"
    }
    
    # TestNG annotations
    testng_annotations = {
        "TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass",
        "BeforeSuite", "AfterSuite", "BeforeGroups", "AfterGroups",
        "DataProvider", "Parameters", "Groups", "Priority", "DependsOnMethods",
        "DependsOnGroups", "ExpectedExceptions", "InvocationCount",
        "SuccessPercentage", "TimeOut"
    }
    
    # Mockito annotations
    mockito_annotations = {
        "Mock", "Spy", "InjectMocks", "Captor", "MockedStatic"
    }
    
    # AssertJ annotations
    assertj_annotations = {
        "AssertJ"
    }
    
    # Other test annotations
    other_test_annotations = {
        "Ignore", "Category", "RunWith", "ExtendWith", "ContextConfiguration"
    }
    
    if annotation_name in junit_annotations:
        return "junit"
    elif annotation_name in spring_test_annotations:
        return "spring_test"
    elif annotation_name in testng_annotations:
        return "testng"
    elif annotation_name in mockito_annotations:
        return "mockito"
    elif annotation_name in assertj_annotations:
        return "assertj"
    elif annotation_name in other_test_annotations:
        return "other_test"
    else:
        return "other"


def extract_beans_from_classes(classes: list[Class]) -> list[Bean]:
    """Extract Spring Beans from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Bean objects
    """
    beans = []
    
    for cls in classes:
        # Check if class has Spring component annotations
        component_annotations = [ann for ann in cls.annotations if ann.category == "component"]
        
        # Also check for @Repository on interfaces
        has_repository_annotation = any(ann.name == "Repository" for ann in cls.annotations)
        
        if component_annotations or has_repository_annotation:
            # Determine bean type based on annotations
            bean_type = "component"  # default
            if any(ann.name in ["Service", "Service"] for ann in cls.annotations):
                bean_type = "service"
            elif any(ann.name in ["Repository", "Repository"] for ann in cls.annotations):
                bean_type = "repository"
            elif any(ann.name in ["Controller", "RestController"] for ann in cls.annotations):
                bean_type = "controller"
            elif any(ann.name in ["Configuration", "Configuration"] for ann in cls.annotations):
                bean_type = "configuration"
            
            # Determine scope (default is singleton)
            scope = "singleton"
            for ann in cls.annotations:
                if ann.name == "Scope":
                    if "value" in ann.parameters:
                        scope = ann.parameters["value"]
                    elif "prototype" in str(ann.parameters):
                        scope = "prototype"
                    elif "request" in str(ann.parameters):
                        scope = "request"
                    elif "session" in str(ann.parameters):
                        scope = "session"
            
            # Create bean name (use class name with first letter lowercase)
            bean_name = cls.name[0].lower() + cls.name[1:] if cls.name else cls.name
            
            # Check for @Bean methods in configuration classes
            bean_methods = []
            if bean_type == "configuration":
                for method in cls.methods:
                    if any(ann.name == "Bean" for ann in method.annotations):
                        bean_methods.append(method)
            
            bean = Bean(
                name=bean_name,
                type=bean_type,
                scope=scope,
                class_name=cls.name,
                package_name=cls.package_name,
                annotation_names=[ann.name for ann in cls.annotations] if cls.annotations else [],
                method_count=len(bean_methods) if bean_type == "configuration" else len(cls.methods) if cls.methods else 0,
                property_count=len(cls.properties) if cls.properties else 0
            )
            beans.append(bean)
    
    return beans


def analyze_bean_dependencies(classes: list[Class], beans: list[Bean]) -> list[BeanDependency]:
    """Analyze dependencies between Spring Beans.
    
    Args:
        classes: List of parsed Class objects
        beans: List of Bean objects
        
    Returns:
        List of BeanDependency objects
    """
    dependencies = []
    
    # Create a mapping from class names to bean names
    class_to_bean = {}
    for bean in beans:
        class_to_bean[bean.class_name] = bean.name
    
    for cls in classes:
        # Check if this class is a bean
        if cls.name not in class_to_bean:
            continue
            
        source_bean = class_to_bean[cls.name]
        
        # Analyze field injections (@Autowired, @Resource, @Value)
        for prop in cls.properties:
            if any(ann.category == "injection" for ann in prop.annotations):
                # Try to determine target bean from field type
                target_bean = None
                field_type = prop.type
                
                # Look for exact class name match
                if field_type in class_to_bean:
                    target_bean = class_to_bean[field_type]
                else:
                    # Look for interface implementations (simplified - just check if type matches any bean class name)
                    for bean in beans:
                        if field_type == bean.class_name:
                            target_bean = bean.name
                            break
                
                if target_bean:
                    injection_type = "field"
                    for ann in prop.annotations:
                        if ann.name == "Autowired":
                            injection_type = "field"
                        elif ann.name == "Resource":
                            injection_type = "field"
                        elif ann.name == "Value":
                            injection_type = "field"
                    
                    dependency = BeanDependency(
                        source_bean=source_bean,
                        target_bean=target_bean,
                        injection_type=injection_type,
                        field_name=prop.name
                    )
                    dependencies.append(dependency)
        
        # Analyze constructor injections
        for method in cls.methods:
            if method.name == cls.name:  # Constructor
                for param in method.parameters:
                    if any(ann.category == "injection" for ann in param.annotations):
                        target_bean = None
                        param_type = param.type
                        
                        if param_type in class_to_bean:
                            target_bean = class_to_bean[param_type]
                        else:
                            # Look for interface implementations (simplified)
                            for bean in beans:
                                if param_type == bean.class_name:
                                    target_bean = bean.name
                                    break
                        
                        if target_bean:
                            dependency = BeanDependency(
                                source_bean=source_bean,
                                target_bean=target_bean,
                                injection_type="constructor",
                                parameter_name=param.name
                            )
                            dependencies.append(dependency)
        
        # Analyze setter injections
        for method in cls.methods:
            if method.name.startswith("set") and len(method.parameters) == 1:
                if any(ann.category == "injection" for ann in method.annotations):
                    param = method.parameters[0]
                    target_bean = None
                    param_type = param.type
                    
                    if param_type in class_to_bean:
                        target_bean = class_to_bean[param_type]
                    else:
                        # Look for interface implementations (simplified)
                        for bean in beans:
                            if param_type == bean.class_name:
                                target_bean = bean.name
                                break
                    
                    if target_bean:
                        dependency = BeanDependency(
                            source_bean=source_bean,
                            target_bean=target_bean,
                            injection_type="setter",
                            method_name=method.name,
                            parameter_name=param.name
                        )
                        dependencies.append(dependency)
    
    return dependencies


def extract_endpoints_from_classes(classes: list[Class]) -> list[Endpoint]:
    """Extract REST API endpoints from controller classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Endpoint objects
    """
    endpoints = []
    
    for cls in classes:
        # Check if class is a controller
        is_controller = any(ann.name in ["Controller", "RestController"] for ann in cls.annotations)
        
        if not is_controller:
            continue
            
        # Get class-level path mapping
        class_path = ""
        for ann in cls.annotations:
            if ann.name == "RequestMapping":
                if "value" in ann.parameters:
                    class_path = ann.parameters["value"]
                break
        
        # Process each method in the controller
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
                
            # Check if method has web mapping annotations
            web_annotations = [ann for ann in method.annotations if ann.category == "web"]
            
            if not web_annotations:
                continue
            
            # Extract endpoint information
            endpoint_path = ""
            http_method = "GET"  # default
            
            for ann in web_annotations:
                if ann.name in ["RequestMapping", "GetMapping", "PostMapping", "PutMapping", "DeleteMapping", "PatchMapping"]:
                    # Extract path
                    if "value" in ann.parameters:
                        endpoint_path = ann.parameters["value"]
                    elif "path" in ann.parameters:
                        endpoint_path = ann.parameters["path"]
                    
                    # Extract HTTP method
                    if ann.name == "GetMapping":
                        http_method = "GET"
                    elif ann.name == "PostMapping":
                        http_method = "POST"
                    elif ann.name == "PutMapping":
                        http_method = "PUT"
                    elif ann.name == "DeleteMapping":
                        http_method = "DELETE"
                    elif ann.name == "PatchMapping":
                        http_method = "PATCH"
                    elif ann.name == "RequestMapping":
                        if "method" in ann.parameters:
                            method_value = ann.parameters["method"]
                            if isinstance(method_value, list) and len(method_value) > 0:
                                http_method = method_value[0]
                            else:
                                http_method = str(method_value)
                        else:
                            http_method = "GET"  # default for RequestMapping
                    break
            
            # Build full path
            full_path = class_path
            if endpoint_path:
                if full_path and not full_path.endswith("/") and not endpoint_path.startswith("/"):
                    full_path += "/"
                full_path += endpoint_path
            elif not full_path:
                full_path = "/"
            
            # Extract method parameters
            parameters = []
            for param in method.parameters:
                param_info = {
                    "name": param.name,
                    "type": param.type,
                    "annotations": [ann.name for ann in param.annotations if ann.category == "web"]
                }
                parameters.append(param_info)
            
            # Extract return type
            return_type = method.return_type if method.return_type != "constructor" else "void"
            
            # Create endpoint
            endpoint = Endpoint(
                path=endpoint_path or "/",
                method=http_method,
                controller_class=cls.name,
                handler_method=method.name,
                parameters=parameters,
                return_type=return_type,
                annotations=[ann.name for ann in web_annotations],
                full_path=full_path
            )
            endpoints.append(endpoint)
    
    return endpoints


def extract_mybatis_mappers_from_classes(classes: list[Class]) -> list[MyBatisMapper]:
    """Extract MyBatis Mappers from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for cls in classes:
        # Check if class is a MyBatis Mapper interface
        is_mapper = any(ann.name == "Mapper" for ann in cls.annotations)
        
        if not is_mapper:
            continue
        
        # Extract mapper methods with MyBatis annotations
        mapper_methods = []
        sql_statements = []
        
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
            
            # Check if method has MyBatis annotations
            mybatis_annotations = [ann for ann in method.annotations if ann.category == "mybatis"]
            
            if not mybatis_annotations:
                continue
            
            # Extract SQL statement information
            sql_type = "SELECT"  # default
            sql_content = ""
            parameter_type = ""
            result_type = ""
            result_map = ""
            
            for ann in mybatis_annotations:
                if ann.name in ["Select", "SelectProvider"]:
                    sql_type = "SELECT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Insert", "InsertProvider"]:
                    sql_type = "INSERT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Update", "UpdateProvider"]:
                    sql_type = "UPDATE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Delete", "DeleteProvider"]:
                    sql_type = "DELETE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                
                # Extract parameter and result type information
                if "parameterType" in ann.parameters:
                    parameter_type = ann.parameters["parameterType"]
                if "resultType" in ann.parameters:
                    result_type = ann.parameters["resultType"]
                if "resultMap" in ann.parameters:
                    result_map = ann.parameters["resultMap"]
            
            # Create method info
            method_info = {
                "name": method.name,
                "return_type": method.return_type,
                "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            mapper_methods.append(method_info)
            
            # Create SQL statement info
            sql_statement = {
                "id": method.name,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            sql_statements.append(sql_statement)
        
        # Create mapper
        mapper = MyBatisMapper(
            name=cls.name,
            type="interface",
            namespace=f"{cls.package_name}.{cls.name}",
            methods=mapper_methods,
            sql_statements=sql_statements,
            file_path=cls.file_path,
            package_name=cls.package_name
        )
        mappers.append(mapper)
    
    return mappers


def parse_mybatis_xml_file(file_path: str) -> MyBatisMapper:
    """Parse MyBatis XML mapper file.
    
    Args:
        file_path: Path to the XML mapper file
        
    Returns:
        MyBatisMapper object
    """
    import xml.etree.ElementTree as ET
    
    try:
        tree = ET.parse(file_path)
        root = tree.getroot()
        
        # Extract namespace
        namespace = root.get("namespace", "")
        
        # Extract SQL statements
        sql_statements = []
        for statement in root.findall(".//*[@id]"):
            statement_id = statement.get("id")
            tag_name = statement.tag.lower()
            
            # Determine SQL type
            sql_type = "SELECT"
            if tag_name == "insert":
                sql_type = "INSERT"
            elif tag_name == "update":
                sql_type = "UPDATE"
            elif tag_name == "delete":
                sql_type = "DELETE"
            
            # Extract SQL content
            sql_content = statement.text.strip() if statement.text else ""
            
            # Extract parameter and result information
            parameter_type = statement.get("parameterType", "")
            result_type = statement.get("resultType", "")
            result_map = statement.get("resultMap", "")
            
            sql_statement = {
                "id": statement_id,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": []
            }
            sql_statements.append(sql_statement)
        
        # Extract ResultMaps
        result_maps = []
        for result_map in root.findall(".//resultMap"):
            result_map_id = result_map.get("id")
            result_map_type = result_map.get("type", "")
            
            properties = []
            for property_elem in result_map.findall(".//result"):
                prop = {
                    "property": property_elem.get("property", ""),
                    "column": property_elem.get("column", ""),
                    "jdbc_type": property_elem.get("jdbcType", "")
                }
                properties.append(prop)
            
            result_map_info = {
                "id": result_map_id,
                "type": result_map_type,
                "properties": properties,
                "associations": [],
                "collections": []
            }
            result_maps.append(result_map_info)
        
        # Create mapper
        mapper_name = namespace.split(".")[-1] if namespace else os.path.basename(file_path).replace(".xml", "")
        package_name = ".".join(namespace.split(".")[:-1]) if namespace else ""
        
        mapper = MyBatisMapper(
            name=mapper_name,
            type="xml",
            namespace=namespace,
            methods=[],  # XML mappers don't have Java methods
            sql_statements=sql_statements,
            file_path=file_path,
            package_name=package_name
        )
        
        return mapper
        
    except ET.ParseError as e:
        print(f"Error parsing XML file {file_path}: {e}")
        return None
    except Exception as e:
        print(f"Error reading XML file {file_path}: {e}")
        return None


def extract_mybatis_xml_mappers(directory: str) -> list[MyBatisMapper]:
    """Extract MyBatis XML mappers from directory.
    
    Args:
        directory: Directory to search for XML mapper files
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith("Mapper.xml") or file.endswith("Dao.xml"):
                file_path = os.path.join(root, file)
                mapper = parse_mybatis_xml_file(file_path)
                if mapper:
                    mappers.append(mapper)
    
    return mappers


def extract_jpa_entities_from_classes(classes: list[Class]) -> list[JpaEntity]:
    """Extract JPA Entities from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of JpaEntity objects
    """
    entities = []
    
    for cls in classes:
        # Check if class is a JPA Entity
        is_entity = any(ann.name == "Entity" for ann in cls.annotations)
        
        if not is_entity:
            continue
        
        # Extract table name
        table_name = cls.name.lower()  # default table name
        for ann in cls.annotations:
            if ann.name == "Table":
                if "name" in ann.parameters:
                    table_name = ann.parameters["name"]
                break
        
        # Extract columns from properties
        columns = []
        relationships = []
        
        for prop in cls.properties:
            # Check if property has JPA column annotations
            jpa_annotations = [ann for ann in prop.annotations if ann.category == "jpa"]
            
            if jpa_annotations:
                # Extract column information
                column_name = prop.name  # default column name
                nullable = True
                unique = False
                length = 0
                precision = 0
                scale = 0
                
                for ann in jpa_annotations:
                    if ann.name == "Column":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                        if "nullable" in ann.parameters:
                            nullable = ann.parameters["nullable"]
                        if "unique" in ann.parameters:
                            unique = ann.parameters["unique"]
                        if "length" in ann.parameters:
                            length = ann.parameters["length"]
                        if "precision" in ann.parameters:
                            precision = ann.parameters["precision"]
                        if "scale" in ann.parameters:
                            scale = ann.parameters["scale"]
                    elif ann.name == "Id":
                        column_name = "id"  # Primary key column
                        nullable = False
                        unique = True
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                
                # Check for relationship annotations
                relationship_type = None
                target_entity = ""
                mapped_by = ""
                join_column = ""
                join_table = ""
                cascade = []
                fetch = "LAZY"
                
                for ann in jpa_annotations:
                    if ann.name in ["OneToOne", "OneToMany", "ManyToOne", "ManyToMany"]:
                        relationship_type = ann.name
                        if "targetEntity" in ann.parameters:
                            target_entity = ann.parameters["targetEntity"]
                        if "mappedBy" in ann.parameters:
                            mapped_by = ann.parameters["mappedBy"]
                        if "cascade" in ann.parameters:
                            cascade = ann.parameters["cascade"] if isinstance(ann.parameters["cascade"], list) else [ann.parameters["cascade"]]
                        if "fetch" in ann.parameters:
                            fetch = ann.parameters["fetch"]
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            join_column = ann.parameters["name"]
                    elif ann.name == "JoinTable":
                        if "name" in ann.parameters:
                            join_table = ann.parameters["name"]
                
                # Create column info
                column_info = {
                    "property_name": prop.name,
                    "column_name": column_name,
                    "data_type": prop.type,
                    "nullable": nullable,
                    "unique": unique,
                    "length": length,
                    "precision": precision,
                    "scale": scale,
                    "annotations": [ann.name for ann in jpa_annotations]
                }
                columns.append(column_info)
                
                # Create relationship info if it's a relationship
                if relationship_type:
                    relationship_info = {
                        "type": relationship_type,
                        "target_entity": target_entity,
                        "mapped_by": mapped_by,
                        "join_column": join_column,
                        "join_table": join_table,
                        "cascade": cascade,
                        "fetch": fetch,
                        "annotations": [ann.name for ann in jpa_annotations]
                    }
                    relationships.append(relationship_info)
        
        # Create entity
        entity = JpaEntity(
            name=cls.name,
            table_name=table_name,
            columns=columns,
            relationships=relationships,
            annotations=[ann.name for ann in cls.annotations if ann.category == "jpa"],
            package_name=cls.package_name,
            file_path=cls.file_path
        )
        entities.append(entity)
    
    return entities


def parse_yaml_config(file_path: str) -> ConfigFile:
    """Parse YAML configuration file.
    
    Args:
        file_path: Path to the YAML file
        
    Returns:
        ConfigFile object
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = yaml.safe_load(f)
        
        if not content:
            content = {}
        
        # Extract file info
        file_name = os.path.basename(file_path)
        file_type = "yaml" if file_path.endswith('.yaml') else "yml"
        
        # Extract profiles
        profiles = []
        if 'spring' in content and 'profiles' in content['spring']:
            if 'active' in content['spring']['profiles']:
                profiles = content['spring']['profiles']['active']
                if isinstance(profiles, str):
                    profiles = [profiles]
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        # Extract sections
        sections = []
        for key, value in content.items():
            if isinstance(value, dict):
                sections.append({
                    "name": key,
                    "properties": value,
                    "type": "section"
                })
        
        return ConfigFile(
            name=file_name,
            file_path=file_path,
            file_type=file_type,
            properties=content,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing YAML file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="yaml",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def parse_properties_config(file_path: str) -> ConfigFile:
    """Parse Properties configuration file.
    
    Args:
        file_path: Path to the properties file
        
    Returns:
        ConfigFile object
    """
    try:
        properties = {}
        sections = []
        profiles = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                
                # Skip empty lines and comments
                if not line or line.startswith('#'):
                    continue
                
                # Parse key=value pairs
                if '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    
                    # Remove quotes if present
                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]
                    elif value.startswith("'") and value.endswith("'"):
                        value = value[1:-1]
                    
                    properties[key] = value
                    
                    # Check for profiles
                    if key == 'spring.profiles.active':
                        profiles = [p.strip() for p in value.split(',')]
        
        # Group properties by section
        section_map = {}
        for key, value in properties.items():
            if '.' in key:
                section = key.split('.')[0]
                if section not in section_map:
                    section_map[section] = {}
                section_map[section][key] = value
            else:
                if 'root' not in section_map:
                    section_map['root'] = {}
                section_map['root'][key] = value
        
        for section_name, section_props in section_map.items():
            sections.append({
                "name": section_name,
                "properties": section_props,
                "type": "section"
            })
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties=properties,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing Properties file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def extract_database_config(config_file: ConfigFile) -> DatabaseConfig:
    """Extract database configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        DatabaseConfig object
    """
    db_config = DatabaseConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        spring_config = config_file.properties.get('spring', {})
        datasource_config = spring_config.get('datasource', {})
        jpa_config = spring_config.get('jpa', {})
        
        db_config.driver = datasource_config.get('driver-class-name', '')
        db_config.url = datasource_config.get('url', '')
        db_config.username = datasource_config.get('username', '')
        db_config.password = datasource_config.get('password', '')
        db_config.dialect = jpa_config.get('database-platform', '')
        db_config.hibernate_ddl_auto = jpa_config.get('hibernate', {}).get('ddl-auto', '')
        db_config.show_sql = jpa_config.get('show-sql', False)
        db_config.format_sql = jpa_config.get('properties', {}).get('hibernate', {}).get('format_sql', False)
        
        # Store additional JPA properties
        if 'properties' in jpa_config:
            db_config.jpa_properties = jpa_config['properties']
    
    else:
        # Properties format
        props = config_file.properties
        
        db_config.driver = props.get('spring.datasource.driver-class-name', '')
        db_config.url = props.get('spring.datasource.url', '')
        db_config.username = props.get('spring.datasource.username', '')
        db_config.password = props.get('spring.datasource.password', '')
        db_config.dialect = props.get('spring.jpa.database-platform', '')
        db_config.hibernate_ddl_auto = props.get('spring.jpa.hibernate.ddl-auto', '')
        db_config.show_sql = props.get('spring.jpa.show-sql', 'false').lower() == 'true'
        db_config.format_sql = props.get('spring.jpa.properties.hibernate.format_sql', 'false').lower() == 'true'
        
        # Store additional JPA properties
        jpa_props = {}
        for key, value in props.items():
            if key.startswith('spring.jpa.properties.'):
                jpa_props[key] = value
        db_config.jpa_properties = jpa_props
    
    return db_config


def extract_server_config(config_file: ConfigFile) -> ServerConfig:
    """Extract server configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        ServerConfig object
    """
    server_config = ServerConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        server_props = config_file.properties.get('server', {})
        
        server_config.port = server_props.get('port', 8080)
        server_config.context_path = server_props.get('servlet', {}).get('context-path', '')
        server_config.servlet_path = server_props.get('servlet', {}).get('path', '')
        
        # SSL configuration
        ssl_config = server_props.get('ssl', {})
        server_config.ssl_enabled = bool(ssl_config)
        server_config.ssl_key_store = ssl_config.get('key-store', '')
        server_config.ssl_key_store_password = ssl_config.get('key-store-password', '')
        server_config.ssl_key_store_type = ssl_config.get('key-store-type', '')
    
    else:
        # Properties format
        props = config_file.properties
        
        server_config.port = int(props.get('server.port', '8080'))
        server_config.context_path = props.get('server.servlet.context-path', '')
        server_config.servlet_path = props.get('server.servlet.path', '')
        
        # SSL configuration
        server_config.ssl_enabled = any(key.startswith('server.ssl.') for key in props.keys())
        server_config.ssl_key_store = props.get('server.ssl.key-store', '')
        server_config.ssl_key_store_password = props.get('server.ssl.key-store-password', '')
        server_config.ssl_key_store_type = props.get('server.ssl.key-store-type', '')
    
    return server_config


def extract_security_config(config_file: ConfigFile) -> SecurityConfig:
    """Extract security configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        SecurityConfig object
    """
    security_config = SecurityConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        security_props = config_file.properties.get('security', {})
        jwt_props = security_props.get('jwt', {})
        cors_props = security_props.get('cors', {})
        
        security_config.enabled = bool(security_props)
        security_config.authentication_type = security_props.get('authentication-type', '')
        security_config.jwt_secret = jwt_props.get('secret', '')
        security_config.jwt_expiration = jwt_props.get('expiration', 0)
        security_config.cors_allowed_origins = cors_props.get('allowed-origins', [])
        security_config.cors_allowed_methods = cors_props.get('allowed-methods', [])
        security_config.cors_allowed_headers = cors_props.get('allowed-headers', [])
    
    else:
        # Properties format
        props = config_file.properties
        
        security_config.enabled = any(key.startswith('security.') for key in props.keys())
        security_config.authentication_type = props.get('security.authentication-type', '')
        security_config.jwt_secret = props.get('security.jwt.secret', '')
        security_config.jwt_expiration = int(props.get('security.jwt.expiration', '0'))
        
        # CORS configuration
        origins = props.get('security.cors.allowed-origins', '')
        if origins:
            security_config.cors_allowed_origins = [o.strip() for o in origins.split(',')]
        
        methods = props.get('security.cors.allowed-methods', '')
        if methods:
            security_config.cors_allowed_methods = [m.strip() for m in methods.split(',')]
        
        headers = props.get('security.cors.allowed-headers', '')
        if headers:
            security_config.cors_allowed_headers = [h.strip() for h in headers.split(',')]
    
    return security_config


def extract_logging_config(config_file: ConfigFile) -> LoggingConfig:
    """Extract logging configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        LoggingConfig object
    """
    logging_config = LoggingConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        logging_props = config_file.properties.get('logging', {})
        
        logging_config.level = logging_props.get('level', {}).get('root', 'INFO')
        logging_config.pattern = logging_props.get('pattern', {}).get('console', '')
        logging_config.file_path = logging_props.get('file', {}).get('name', '')
        logging_config.max_file_size = logging_props.get('file', {}).get('max-size', '')
        logging_config.max_history = logging_props.get('file', {}).get('max-history', 0)
        logging_config.console_output = logging_props.get('console', {}).get('enabled', True)
    
    else:
        # Properties format
        props = config_file.properties
        
        logging_config.level = props.get('logging.level.root', 'INFO')
        logging_config.pattern = props.get('logging.pattern.console', '')
        logging_config.file_path = props.get('logging.file.name', '')
        logging_config.max_file_size = props.get('logging.file.max-size', '')
        logging_config.max_history = int(props.get('logging.file.max-history', '0'))
        logging_config.console_output = props.get('logging.console.enabled', 'true').lower() == 'true'
    
    return logging_config


def extract_config_files(directory: str) -> list[ConfigFile]:
    """Extract configuration files from directory.
    
    Args:
        directory: Directory to search for config files
        
    Returns:
        List of ConfigFile objects
    """
    config_files = []
    
    # Common config file patterns
    config_patterns = [
        "application.yml",
        "application.yaml", 
        "application.properties",
        "application-*.properties",
        "bootstrap.yml",
        "bootstrap.yaml",
        "bootstrap.properties"
    ]
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            # Check if file matches any config pattern
            is_config_file = False
            for pattern in config_patterns:
                if pattern == file or (pattern.endswith('*') and file.startswith(pattern[:-1])):
                    is_config_file = True
                    break
            
            if is_config_file:
                file_path = os.path.join(root, file)
                
                if file.endswith(('.yml', '.yaml')):
                    config_file = parse_yaml_config(file_path)
                elif file.endswith('.properties'):
                    config_file = parse_properties_config(file_path)
                else:
                    continue
                
                config_files.append(config_file)
    
    return config_files


def extract_test_classes_from_classes(classes: list[Class]) -> list[TestClass]:
    """Extract test classes from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of TestClass objects
    """
    test_classes = []
    
    for cls in classes:
        # Check if class is a test class
        test_annotations = [ann for ann in cls.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
        
        if not test_annotations:
            continue
        
        # Determine test framework and type
        test_framework = "junit"  # default
        test_type = "unit"  # default
        
        for ann in test_annotations:
            if ann.name in ["SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest", "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest"]:
                test_framework = "spring_test"
                if ann.name == "SpringBootTest":
                    test_type = "integration"
                else:
                    test_type = "slice"
            elif ann.name in ["TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass"]:
                test_framework = "testng"
            elif ann.name in ["Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll"]:
                test_framework = "junit"
        
        # Extract test methods
        test_methods = []
        setup_methods = []
        
        for method in cls.methods:
            method_annotations = [ann.name for ann in method.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
            
            if method_annotations:
                # Check if it's a setup/teardown method
                if any(ann in method_annotations for ann in ["BeforeEach", "AfterEach", "BeforeAll", "AfterAll", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass", "BeforeSuite", "AfterSuite"]):
                    setup_methods.append({
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters]
                    })
                else:
                    # Regular test method
                    test_method_info = {
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                        "assertions": [],
                        "mock_calls": [],
                        "test_data": [],
                        "expected_exceptions": [],
                        "timeout": 0,
                        "display_name": ""
                    }
                    
                    # Extract display name
                    for ann in method.annotations:
                        if ann.name == "DisplayName" and "value" in ann.parameters:
                            test_method_info["display_name"] = ann.parameters["value"]
                        elif ann.name == "Timeout" and "value" in ann.parameters:
                            test_method_info["timeout"] = ann.parameters["value"]
                    
                    # Extract expected exceptions
                    for ann in method.annotations:
                        if ann.name == "ExpectedExceptions" and "value" in ann.parameters:
                            test_method_info["expected_exceptions"] = ann.parameters["value"] if isinstance(ann.parameters["value"], list) else [ann.parameters["value"]]
                    
                    test_methods.append(test_method_info)
        
        # Extract mock dependencies
        mock_dependencies = []
        for prop in cls.properties:
            prop_annotations = [ann.name for ann in prop.annotations if classify_test_annotation(ann.name) in ["mockito", "spring_test"]]
            if prop_annotations:
                mock_dependencies.append({
                    "name": prop.name,
                    "type": prop.type,
                    "annotations": prop_annotations,
                    "mock_type": "mock" if "Mock" in prop_annotations else "spy" if "Spy" in prop_annotations else "bean"
                })
        
        # Extract test configurations
        test_configurations = []
        for ann in cls.annotations:
            if ann.name in ["TestConfiguration", "ActiveProfiles", "TestPropertySource"]:
                config_info = {
                    "name": ann.name,
                    "type": "configuration" if ann.name == "TestConfiguration" else "profile" if ann.name == "ActiveProfiles" else "property",
                    "properties": ann.parameters,
                    "active_profiles": ann.parameters.get("value", []) if ann.name == "ActiveProfiles" else [],
                    "test_slices": [],
                    "mock_beans": [],
                    "spy_beans": []
                }
                test_configurations.append(config_info)
        
        # Create test class
        test_class = TestClass(
            name=cls.name,
            package_name=cls.package_name,
            test_framework=test_framework,
            test_type=test_type,
            annotations=[ann.name for ann in test_annotations],
            test_methods=test_methods,
            setup_methods=setup_methods,
            mock_dependencies=mock_dependencies,
            test_configurations=test_configurations,
            file_path=cls.file_path
        )
        test_classes.append(test_class)
    
    return test_classes


def analyze_test_methods(test_class: TestClass, class_obj: Class) -> list[TestMethod]:
    """Analyze test methods for assertions, mock calls, and test data.
    
    Args:
        test_class: TestClass object
        class_obj: Original Class object
        
    Returns:
        List of analyzed TestMethod objects
    """
    test_methods = []
    
    for method_info in test_class.test_methods:
        # Find the corresponding method in the class
        method_obj = None
        for method in class_obj.methods:
            if method.name == method_info["name"]:
                method_obj = method
                break
        
        if not method_obj:
            continue
        
        # Analyze method source code for assertions and mock calls
        assertions = []
        mock_calls = []
        test_data = []
        
        if method_obj.source:
            source_code = method_obj.source
            
            # Find assertions (JUnit, AssertJ, etc.)
            assertion_patterns = [
                r'assert\w+\(',  # JUnit assertions
                r'assertThat\(',  # AssertJ
                r'assertEquals\(',  # JUnit
                r'assertTrue\(',  # JUnit
                r'assertFalse\(',  # JUnit
                r'assertNotNull\(',  # JUnit
                r'assertNull\(',  # JUnit
                r'assertThrows\(',  # JUnit 5
                r'assertDoesNotThrow\(',  # JUnit 5
                r'verify\(',  # Mockito verify
                r'when\(',  # Mockito when
                r'then\(',  # Mockito then
                r'given\(',  # BDDMockito given
                r'willReturn\(',  # Mockito willReturn
                r'willThrow\(',  # Mockito willThrow
            ]
            
            for pattern in assertion_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    assertions.append({
                        "type": match,
                        "line": source_code.find(match) + 1
                    })
            
            # Find mock calls
            mock_call_patterns = [
                r'(\w+)\.(\w+)\(',  # Method calls on objects
                r'mock\(',  # Mockito mock creation
                r'spy\(',  # Mockito spy creation
                r'@Mock\s+(\w+)',  # @Mock annotation
                r'@Spy\s+(\w+)',  # @Spy annotation
                r'@InjectMocks\s+(\w+)',  # @InjectMocks annotation
            ]
            
            for pattern in mock_call_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        mock_calls.append({
                            "object": match[0],
                            "method": match[1],
                            "type": "method_call"
                        })
                    else:
                        mock_calls.append({
                            "type": match,
                            "line": source_code.find(match) + 1
                        })
            
            # Find test data setup
            test_data_patterns = [
                r'new\s+(\w+)\(',  # Object creation
                r'(\w+)\s*=\s*new\s+(\w+)\(',  # Variable assignment with new
                r'@ValueSource\(',  # JUnit 5 @ValueSource
                r'@CsvSource\(',  # JUnit 5 @CsvSource
                r'@MethodSource\(',  # JUnit 5 @MethodSource
            ]
            
            for pattern in test_data_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        test_data.append({
                            "variable": match[0],
                            "type": match[1],
                            "pattern": "object_creation"
                        })
                    else:
                        test_data.append({
                            "type": match,
                            "pattern": "annotation"
                        })
        
        # Create TestMethod object
        test_method = TestMethod(
            name=method_info["name"],
            return_type=method_info["return_type"],
            annotations=method_info["annotations"],
            assertions=assertions,
            mock_calls=mock_calls,
            test_data=test_data,
            expected_exceptions=method_info["expected_exceptions"],
            timeout=method_info["timeout"],
            display_name=method_info["display_name"]
        )
        test_methods.append(test_method)
    
    return test_methods


def generate_lombok_methods(properties: list[Field], class_name: str, package_name: str) -> list[Method]:
    """Generate Lombok @Data methods (getters, setters, equals, hashCode, toString) for properties."""
    methods = []
    
    # Generate getters and setters for each property
    for prop in properties:
        # Getter
        getter_name = f"get{prop.name[0].upper()}{prop.name[1:]}"
        if prop.type == "Boolean" and prop.name.startswith("is"):
            # For boolean fields starting with 'is', use the field name as getter
            getter_name = prop.name
        
        getter = Method(
            name=getter_name,
            logical_name=f"{package_name}.{class_name}.{getter_name}",
            return_type=prop.type,
            parameters=[],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[],
            description=f"Generated getter for {prop.name} field"  # Generated method description
        )
        methods.append(getter)
        
        # Setter
        setter_name = f"set{prop.name[0].upper()}{prop.name[1:]}"
        setter_param = Field(
            name=prop.name,
            logical_name=f"{package_name}.{class_name}.{prop.name}",
            type=prop.type,
            package_name=package_name,
            class_name=class_name
        )
        
        setter = Method(
            name=setter_name,
            logical_name=f"{package_name}.{class_name}.{setter_name}",
            return_type="void",
            parameters=[setter_param],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[],
            description=f"Generated setter for {prop.name} field"  # Generated method description
        )
        methods.append(setter)
    
    # Generate equals method
    equals_method = Method(
        name="equals",
        logical_name=f"{package_name}.{class_name}.equals",
        return_type="boolean",
        parameters=[Field(name="obj", logical_name=f"{package_name}.{class_name}.obj", type="Object", package_name=package_name, class_name=class_name)],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated equals method for object comparison"  # Generated method description
    )
    methods.append(equals_method)
    
    # Generate hashCode method
    hashcode_method = Method(
        name="hashCode",
        logical_name=f"{package_name}.{class_name}.hashCode",
        return_type="int",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated hashCode method for object hashing"  # Generated method description
    )
    methods.append(hashcode_method)
    
    # Generate toString method
    tostring_method = Method(
        name="toString",
        logical_name=f"{package_name}.{class_name}.toString",
        return_type="String",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated toString method for string representation"  # Generated method description
    )
    methods.append(tostring_method)
    
    return methods


def parse_java_project(directory: str) -> tuple[list[Package], list[Class], dict[str, str], list[Bean], list[BeanDependency], list[Endpoint], list[MyBatisMapper], list[JpaEntity], list[ConfigFile], list[TestClass], list[SqlStatement], str]:
    """Parse Java project and return parsed entities."""
    logger = get_logger(__name__)
    """Parses all Java files in a directory and returns a tuple of (packages, classes, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name)."""
    
    # Extract project name from directory path
    project_name = extract_project_name(directory)
    packages = {}
    classes = {}
    class_to_package_map = {}  # Maps class_key to package_name

    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith(".java"):
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    file_content = f.read() # Read file content once
                try:
                    tree = javalang.parse.parse(file_content)
                    package_name = tree.package.name if tree.package else ""
                    
                    # Create or update package node
                    if package_name and package_name not in packages:
                        packages[package_name] = Package(
                            name=package_name
                        )
                    elif not package_name:
                        # Handle classes without package (default package)
                        package_name = "default"
                        if package_name not in packages:
                            packages[package_name] = Package(
                                name=package_name
                            )
                    
                    import_map = {}
                    for imp in tree.imports:
                        class_name = imp.path.split('.')[-1]
                        import_map[class_name] = imp.path

                    for _, class_declaration in tree.filter(
                        javalang.tree.ClassDeclaration
                    ):
                        class_name = class_declaration.name
                        class_key = f"{package_name}.{class_name}"
                        
                        # Debug: Check if this is the User class
                        if "User" in class_name:
                            logger.debug(f"Found User class - {class_key}")
                            logger.debug(f"Methods count: {len(class_declaration.methods)}")
                            logger.debug(f"Constructors count: {len(class_declaration.constructors)}")
                        
                        # Extract class source code - use the entire file content
                        class_source = file_content


                        if class_key not in classes:
                            # Parse class annotations
                            class_annotations = parse_annotations(class_declaration.annotations, "class") if hasattr(class_declaration, 'annotations') else []
                            
                            classes[class_key] = Class(
                                name=class_name,
                                logical_name=class_key,  # Add logical_name
                                file_path=file_path,
                                type="class", # Simplified for now
                                source=class_source, # Add class source
                                annotations=class_annotations,
                                package_name=package_name
                            )
                            class_to_package_map[class_key] = package_name
                        
                        # --- Start of new import logic ---
                        for imp in tree.imports:
                            classes[class_key].imports.append(imp.path)
                        # --- End of new import logic ---

                        # --- Start of new inheritance logic ---
                        # Handle 'extends'
                        if class_declaration.extends:
                            superclass_name = class_declaration.extends.name
                            # Try to resolve fully qualified name for superclass
                            if superclass_name in import_map:
                                classes[class_key].superclass = import_map[superclass_name]
                            else:
                                # Assume same package or fully qualified if not in import_map
                                classes[class_key].superclass = f"{package_name}.{superclass_name}" if package_name else superclass_name

                        # Handle 'implements'
                        if class_declaration.implements: # Add this check
                            for impl_ref in class_declaration.implements:
                                interface_name = impl_ref.name
                                # Try to resolve fully qualified name for interface
                                if interface_name in import_map:
                                    classes[class_key].interfaces.append(import_map[interface_name])
                                else:
                                    # Assume same package or fully qualified if not in import_map
                                    classes[class_key].interfaces.append(f"{package_name}.{interface_name}" if package_name else interface_name)
                        # --- End of new inheritance logic ---

                        field_map = {}
                        for field_declaration in class_declaration.fields:
                            for declarator in field_declaration.declarators:
                                field_map[declarator.name] = field_declaration.type.name
                                
                                # Parse field annotations
                                field_annotations = parse_annotations(field_declaration.annotations, "field") if hasattr(field_declaration, 'annotations') else []
                                
                                # Extract initial value if present
                                initial_value = ""
                                if hasattr(declarator, 'initializer') and declarator.initializer:
                                    # Convert the initializer to string representation
                                    if hasattr(declarator.initializer, 'value'):
                                        initial_value = str(declarator.initializer.value)
                                    elif hasattr(declarator.initializer, 'type'):
                                        initial_value = str(declarator.initializer.type)
                                    else:
                                        initial_value = str(declarator.initializer)
                                
                                prop = Field(
                                    name=declarator.name,
                                    logical_name=f"{package_name}.{class_name}.{declarator.name}",
                                    type=field_declaration.type.name,
                                    modifiers=list(field_declaration.modifiers), # Add modifiers
                                    package_name=package_name,
                                    class_name=class_name,
                                    annotations=field_annotations,
                                    initial_value=initial_value,
                                    description=""  # TODO: Extract description from comments or annotations
                                )
                                classes[class_key].properties.append(prop)

                        all_declarations = class_declaration.methods + class_declaration.constructors
                        
                        # Debug: Check User class method processing
                        if "User" in class_name:
                            logger.debug(f"Processing User class methods - total declarations: {len(all_declarations)}")
                            for i, decl in enumerate(all_declarations):
                                logger.debug(f"Declaration {i}: {type(decl).__name__} - {decl.name}")
                        
                        for declaration in all_declarations:
                            local_var_map = field_map.copy()
                            params = []
                            for param in declaration.parameters:
                                param_type_name = 'Unknown'
                                if hasattr(param.type, 'name'):
                                    param_type_name = param.type.name
                                local_var_map[param.name] = param_type_name
                                params.append(Field(name=param.name, logical_name=f"{package_name}.{class_name}.{param.name}", type=param_type_name, package_name=package_name, class_name=class_name))

                            if declaration.body:
                                for _, var_decl in declaration.filter(javalang.tree.LocalVariableDeclaration):
                                    for declarator in var_decl.declarators:
                                        local_var_map[declarator.name] = var_decl.type.name
                            
                            if isinstance(declaration, javalang.tree.MethodDeclaration):
                                return_type = declaration.return_type.name if declaration.return_type else "void"
                            else: # ConstructorDeclaration
                                return_type = "constructor"

                            # Extract modifiers
                            modifiers = list(declaration.modifiers)
                            
                            # Parse method annotations
                            method_annotations = parse_annotations(declaration.annotations, "method") if hasattr(declaration, 'annotations') else []

                            # Extract method source code
                            method_source = ""
                            if declaration.position:
                                lines = file_content.splitlines(keepends=True) # Keep line endings
                                start_line = declaration.position.line - 1
                                
                                # Find the end of the method by matching braces
                                brace_count = 0
                                end_line = start_line
                                for i in range(start_line, len(lines)):
                                    line = lines[i]
                                    for char in line:
                                        if char == '{':
                                            brace_count += 1
                                        elif char == '}':
                                            brace_count -= 1
                                            if brace_count == 0:
                                                end_line = i
                                                break
                                    if brace_count == 0:
                                        break
                                
                                method_source = "".join(lines[start_line:end_line + 1])

                            method = Method(
                                name=declaration.name,
                                logical_name=f"{class_key}.{declaration.name}",  # Add logical_name
                                return_type=return_type,
                                parameters=params,
                                modifiers=modifiers,
                                source=method_source, # Add method source
                                package_name=package_name,
                                annotations=method_annotations,
                                description=""  # TODO: Extract description from comments or annotations
                            )
                            classes[class_key].methods.append(method)

                            # Extract method calls with order information
                            call_order = 0
                            for _, invocation in declaration.filter(javalang.tree.MethodInvocation):
                                target_class_name = None
                                resolved_target_package = ""
                                resolved_target_class_name = ""
                                
                                if invocation.qualifier:
                                    # External method call
                                    if invocation.qualifier in local_var_map:
                                        target_class_name = local_var_map[invocation.qualifier]
                                    else:
                                        target_class_name = invocation.qualifier
                                    
                                    if target_class_name:
                                        if target_class_name == "System.out":
                                            resolved_target_package = "java.io"
                                            resolved_target_class_name = "PrintStream"
                                        else:
                                            if target_class_name in import_map:
                                                resolved_target_package = ".".join(import_map[target_class_name].split(".")[:-1])
                                            else:
                                                resolved_target_package = package_name
                                                resolved_target_class_name = target_class_name
                                else:
                                    # Same class method call
                                    resolved_target_package = package_name
                                    resolved_target_class_name = class_name

                                if resolved_target_class_name:
                                    # Get line number from invocation position
                                    line_number = invocation.position.line if invocation.position else 0

                                    call = MethodCall(
                                        source_package=package_name,
                                        source_class=class_name,
                                        source_method=declaration.name,
                                        target_package=resolved_target_package,
                                        target_class=resolved_target_class_name,
                                        target_method=invocation.member,
                                        call_order=call_order,
                                        line_number=line_number,
                                        return_type="void"  # Default return type, can be enhanced later
                                    )
                                    classes[class_key].calls.append(call)
                                    call_order += 1
                        
                        # Check for Lombok @Data annotation and generate methods
                        has_data_annotation = any(ann.name == "Data" for ann in classes[class_key].annotations)
                        if has_data_annotation:
                            logger.debug(f"Found @Data annotation on {class_name}, generating Lombok methods")
                            lombok_methods = generate_lombok_methods(classes[class_key].properties, class_name, package_name)
                            classes[class_key].methods.extend(lombok_methods)
                            logger.debug(f"Generated {len(lombok_methods)} Lombok methods for {class_name}")
                except javalang.parser.JavaSyntaxError as e:
                    print(f"Syntax error in {file_path}: {e}")
                    continue
                except Exception as e:
                    print(f"Error parsing {file_path}: {e}")
                    continue
    
    # Extract beans, analyze dependencies, extract endpoints, extract MyBatis mappers, extract JPA entities, extract config files, and extract test classes
    classes_list = list(classes.values())
    beans = extract_beans_from_classes(classes_list)
    dependencies = analyze_bean_dependencies(classes_list, beans)
    endpoints = extract_endpoints_from_classes(classes_list)
    mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
    jpa_entities = extract_jpa_entities_from_classes(classes_list)
    config_files = extract_config_files(directory)
    test_classes = extract_test_classes_from_classes(classes_list)
    
    # Also extract XML mappers
    xml_mappers = extract_mybatis_xml_mappers(directory)
    mybatis_mappers.extend(xml_mappers)
    
    # Extract SQL statements from MyBatis mappers
    sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
    
    return list(packages.values()), classes_list, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name
```

이제 Class 생성 부분에서도 description을 추가하겠습니다.


Class 생성 부분을 찾았습니다. 이제 description을 추가하겠습니다.


```python
import os
import yaml
import re
from pathlib import Path

import javalang

from src.models.graph_entities import Class, Method, MethodCall, Field, Package, Annotation, Bean, BeanDependency, Endpoint, MyBatisMapper, MyBatisSqlStatement, MyBatisResultMap, SqlStatement, JpaEntity, JpaColumn, JpaRelationship, ConfigFile, DatabaseConfig, ServerConfig, SecurityConfig, LoggingConfig, TestClass, TestMethod, TestConfiguration
from src.utils.logger import get_logger
from typing import Optional, List, Literal


def extract_project_name(java_source_folder: str) -> str:
    """
    JAVA_SOURCE_FOLDER 경로에서 프로젝트 이름을 추출합니다.
    
    Args:
        java_source_folder: Java 소스 폴더 경로
        
    Returns:
        프로젝트 이름 (마지막 디렉토리명)
    """
    # 경로를 정규화하고 마지막 디렉토리명 추출
    path = Path(java_source_folder).resolve()
    return path.name


def extract_sql_statements_from_mappers(mybatis_mappers: list[MyBatisMapper], project_name: str) -> list[SqlStatement]:
    """
    MyBatis mappers에서 SQL statements를 추출합니다.
    
    Args:
        mybatis_mappers: MyBatis mapper 객체들의 리스트
        project_name: 프로젝트 이름
        
    Returns:
        SqlStatement 객체들의 리스트
    """
    sql_statements = []
    
    for mapper in mybatis_mappers:
        for sql_dict in mapper.sql_statements:
            # MyBatisSqlStatement를 SqlStatement로 변환
            sql_statement = SqlStatement(
                id=sql_dict.get('id', ''),
                sql_type=sql_dict.get('sql_type', ''),
                sql_content=sql_dict.get('sql_content', ''),
                parameter_type=sql_dict.get('parameter_type', ''),
                result_type=sql_dict.get('result_type', ''),
                result_map=sql_dict.get('result_map', ''),
                mapper_name=mapper.name,
                annotations=[],  # TODO: annotations를 파싱하여 추가
                project_name=project_name
            )
            sql_statements.append(sql_statement)
    
    return sql_statements


def parse_annotations(annotations, target_type: str = "class") -> list[Annotation]:
    """Parse Java annotations into Annotation objects.
    
    Args:
        annotations: List of annotation nodes from javalang
        target_type: Type of target ("class", "method", "field")
    """
    result = []
    for annotation in annotations:
        annotation_name = annotation.name
        parameters = {}
        
        # Parse annotation parameters if they exist
        if hasattr(annotation, 'element') and annotation.element:
            for element in annotation.element:
                if hasattr(element, 'name') and hasattr(element, 'value'):
                    parameters[element.name] = element.value.value if hasattr(element.value, 'value') else str(element.value)
        
        result.append(Annotation(
            name=annotation_name,
            parameters=parameters,
            target_type=target_type,
            category=classify_springboot_annotation(annotation_name)
        ))
    
    return result


def classify_springboot_annotation(annotation_name: str) -> str:
    """Classify SpringBoot annotations into categories.
    
    Args:
        annotation_name: Name of the annotation (e.g., "@Component", "@Service")
        
    Returns:
        Category of the annotation
    """
    # Component annotations
    component_annotations = {
        "Component", "Service", "Repository", "Controller", 
        "RestController", "Configuration", "Bean"
    }
    
    # Injection annotations
    injection_annotations = {
        "Autowired", "Resource", "Value", "Qualifier", "Primary"
    }
    
    # Web annotations
    web_annotations = {
        "RequestMapping", "GetMapping", "PostMapping", "PutMapping", 
        "DeleteMapping", "PatchMapping", "RequestParam", "PathVariable",
        "RequestBody", "ResponseBody", "ResponseStatus"
    }
    
    # JPA annotations
    jpa_annotations = {
        "Entity", "Table", "Id", "Column", "OneToMany", "ManyToOne",
        "OneToOne", "ManyToMany", "JoinColumn", "GeneratedValue"
    }
    
    # Test annotations
    test_annotations = {
        "Test", "SpringBootTest", "DataJpaTest", "WebMvcTest",
        "MockBean", "SpyBean", "TestPropertySource"
    }
    
    # Security annotations
    security_annotations = {
        "PreAuthorize", "PostAuthorize", "Secured", "RolesAllowed",
        "EnableWebSecurity", "EnableGlobalMethodSecurity"
    }
    
    # Validation annotations
    validation_annotations = {
        "Valid", "NotNull", "NotBlank", "NotEmpty", "Size", "Min", "Max",
        "Pattern", "Email", "AssertTrue", "AssertFalse"
    }
    
    # MyBatis annotations
    mybatis_annotations = {
        "Mapper", "Select", "Insert", "Update", "Delete", "SelectProvider",
        "InsertProvider", "UpdateProvider", "DeleteProvider", "Results",
        "Result", "One", "Many", "MapKey", "Options", "SelectKey"
    }
    
    if annotation_name in component_annotations:
        return "component"
    elif annotation_name in injection_annotations:
        return "injection"
    elif annotation_name in web_annotations:
        return "web"
    elif annotation_name in jpa_annotations:
        return "jpa"
    elif annotation_name in test_annotations:
        return "test"
    elif annotation_name in security_annotations:
        return "security"
    elif annotation_name in validation_annotations:
        return "validation"
    elif annotation_name in mybatis_annotations:
        return "mybatis"
    else:
        return "other"


def classify_test_annotation(annotation_name: str) -> str:
    """Classify test annotations into categories.
    
    Args:
        annotation_name: Name of the annotation
        
    Returns:
        Category of the test annotation
    """
    # JUnit annotations
    junit_annotations = {
        "Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll",
        "DisplayName", "ParameterizedTest", "ValueSource", "CsvSource",
        "MethodSource", "Timeout", "Disabled", "Nested", "RepeatedTest",
        "Order", "TestMethodOrder", "TestInstance", "TestClassOrder"
    }
    
    # Spring Boot Test annotations
    spring_test_annotations = {
        "SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest",
        "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest",
        "MockBean", "SpyBean", "TestConfiguration", "ActiveProfiles",
        "TestPropertySource", "DirtiesContext", "Transactional",
        "Rollback", "Commit", "Sql", "SqlGroup", "AutoConfigureTestDatabase",
        "AutoConfigureMockMvc", "AutoConfigureWebMvc", "AutoConfigureWebClient",
        "MockMvc", "TestEntityManager", "TestContainers", "DynamicPropertySource"
    }
    
    # TestNG annotations
    testng_annotations = {
        "TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass",
        "BeforeSuite", "AfterSuite", "BeforeGroups", "AfterGroups",
        "DataProvider", "Parameters", "Groups", "Priority", "DependsOnMethods",
        "DependsOnGroups", "ExpectedExceptions", "InvocationCount",
        "SuccessPercentage", "TimeOut"
    }
    
    # Mockito annotations
    mockito_annotations = {
        "Mock", "Spy", "InjectMocks", "Captor", "MockedStatic"
    }
    
    # AssertJ annotations
    assertj_annotations = {
        "AssertJ"
    }
    
    # Other test annotations
    other_test_annotations = {
        "Ignore", "Category", "RunWith", "ExtendWith", "ContextConfiguration"
    }
    
    if annotation_name in junit_annotations:
        return "junit"
    elif annotation_name in spring_test_annotations:
        return "spring_test"
    elif annotation_name in testng_annotations:
        return "testng"
    elif annotation_name in mockito_annotations:
        return "mockito"
    elif annotation_name in assertj_annotations:
        return "assertj"
    elif annotation_name in other_test_annotations:
        return "other_test"
    else:
        return "other"


def extract_beans_from_classes(classes: list[Class]) -> list[Bean]:
    """Extract Spring Beans from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Bean objects
    """
    beans = []
    
    for cls in classes:
        # Check if class has Spring component annotations
        component_annotations = [ann for ann in cls.annotations if ann.category == "component"]
        
        # Also check for @Repository on interfaces
        has_repository_annotation = any(ann.name == "Repository" for ann in cls.annotations)
        
        if component_annotations or has_repository_annotation:
            # Determine bean type based on annotations
            bean_type = "component"  # default
            if any(ann.name in ["Service", "Service"] for ann in cls.annotations):
                bean_type = "service"
            elif any(ann.name in ["Repository", "Repository"] for ann in cls.annotations):
                bean_type = "repository"
            elif any(ann.name in ["Controller", "RestController"] for ann in cls.annotations):
                bean_type = "controller"
            elif any(ann.name in ["Configuration", "Configuration"] for ann in cls.annotations):
                bean_type = "configuration"
            
            # Determine scope (default is singleton)
            scope = "singleton"
            for ann in cls.annotations:
                if ann.name == "Scope":
                    if "value" in ann.parameters:
                        scope = ann.parameters["value"]
                    elif "prototype" in str(ann.parameters):
                        scope = "prototype"
                    elif "request" in str(ann.parameters):
                        scope = "request"
                    elif "session" in str(ann.parameters):
                        scope = "session"
            
            # Create bean name (use class name with first letter lowercase)
            bean_name = cls.name[0].lower() + cls.name[1:] if cls.name else cls.name
            
            # Check for @Bean methods in configuration classes
            bean_methods = []
            if bean_type == "configuration":
                for method in cls.methods:
                    if any(ann.name == "Bean" for ann in method.annotations):
                        bean_methods.append(method)
            
            bean = Bean(
                name=bean_name,
                type=bean_type,
                scope=scope,
                class_name=cls.name,
                package_name=cls.package_name,
                annotation_names=[ann.name for ann in cls.annotations] if cls.annotations else [],
                method_count=len(bean_methods) if bean_type == "configuration" else len(cls.methods) if cls.methods else 0,
                property_count=len(cls.properties) if cls.properties else 0
            )
            beans.append(bean)
    
    return beans


def analyze_bean_dependencies(classes: list[Class], beans: list[Bean]) -> list[BeanDependency]:
    """Analyze dependencies between Spring Beans.
    
    Args:
        classes: List of parsed Class objects
        beans: List of Bean objects
        
    Returns:
        List of BeanDependency objects
    """
    dependencies = []
    
    # Create a mapping from class names to bean names
    class_to_bean = {}
    for bean in beans:
        class_to_bean[bean.class_name] = bean.name
    
    for cls in classes:
        # Check if this class is a bean
        if cls.name not in class_to_bean:
            continue
            
        source_bean = class_to_bean[cls.name]
        
        # Analyze field injections (@Autowired, @Resource, @Value)
        for prop in cls.properties:
            if any(ann.category == "injection" for ann in prop.annotations):
                # Try to determine target bean from field type
                target_bean = None
                field_type = prop.type
                
                # Look for exact class name match
                if field_type in class_to_bean:
                    target_bean = class_to_bean[field_type]
                else:
                    # Look for interface implementations (simplified - just check if type matches any bean class name)
                    for bean in beans:
                        if field_type == bean.class_name:
                            target_bean = bean.name
                            break
                
                if target_bean:
                    injection_type = "field"
                    for ann in prop.annotations:
                        if ann.name == "Autowired":
                            injection_type = "field"
                        elif ann.name == "Resource":
                            injection_type = "field"
                        elif ann.name == "Value":
                            injection_type = "field"
                    
                    dependency = BeanDependency(
                        source_bean=source_bean,
                        target_bean=target_bean,
                        injection_type=injection_type,
                        field_name=prop.name
                    )
                    dependencies.append(dependency)
        
        # Analyze constructor injections
        for method in cls.methods:
            if method.name == cls.name:  # Constructor
                for param in method.parameters:
                    if any(ann.category == "injection" for ann in param.annotations):
                        target_bean = None
                        param_type = param.type
                        
                        if param_type in class_to_bean:
                            target_bean = class_to_bean[param_type]
                        else:
                            # Look for interface implementations (simplified)
                            for bean in beans:
                                if param_type == bean.class_name:
                                    target_bean = bean.name
                                    break
                        
                        if target_bean:
                            dependency = BeanDependency(
                                source_bean=source_bean,
                                target_bean=target_bean,
                                injection_type="constructor",
                                parameter_name=param.name
                            )
                            dependencies.append(dependency)
        
        # Analyze setter injections
        for method in cls.methods:
            if method.name.startswith("set") and len(method.parameters) == 1:
                if any(ann.category == "injection" for ann in method.annotations):
                    param = method.parameters[0]
                    target_bean = None
                    param_type = param.type
                    
                    if param_type in class_to_bean:
                        target_bean = class_to_bean[param_type]
                    else:
                        # Look for interface implementations (simplified)
                        for bean in beans:
                            if param_type == bean.class_name:
                                target_bean = bean.name
                                break
                    
                    if target_bean:
                        dependency = BeanDependency(
                            source_bean=source_bean,
                            target_bean=target_bean,
                            injection_type="setter",
                            method_name=method.name,
                            parameter_name=param.name
                        )
                        dependencies.append(dependency)
    
    return dependencies


def extract_endpoints_from_classes(classes: list[Class]) -> list[Endpoint]:
    """Extract REST API endpoints from controller classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Endpoint objects
    """
    endpoints = []
    
    for cls in classes:
        # Check if class is a controller
        is_controller = any(ann.name in ["Controller", "RestController"] for ann in cls.annotations)
        
        if not is_controller:
            continue
            
        # Get class-level path mapping
        class_path = ""
        for ann in cls.annotations:
            if ann.name == "RequestMapping":
                if "value" in ann.parameters:
                    class_path = ann.parameters["value"]
                break
        
        # Process each method in the controller
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
                
            # Check if method has web mapping annotations
            web_annotations = [ann for ann in method.annotations if ann.category == "web"]
            
            if not web_annotations:
                continue
            
            # Extract endpoint information
            endpoint_path = ""
            http_method = "GET"  # default
            
            for ann in web_annotations:
                if ann.name in ["RequestMapping", "GetMapping", "PostMapping", "PutMapping", "DeleteMapping", "PatchMapping"]:
                    # Extract path
                    if "value" in ann.parameters:
                        endpoint_path = ann.parameters["value"]
                    elif "path" in ann.parameters:
                        endpoint_path = ann.parameters["path"]
                    
                    # Extract HTTP method
                    if ann.name == "GetMapping":
                        http_method = "GET"
                    elif ann.name == "PostMapping":
                        http_method = "POST"
                    elif ann.name == "PutMapping":
                        http_method = "PUT"
                    elif ann.name == "DeleteMapping":
                        http_method = "DELETE"
                    elif ann.name == "PatchMapping":
                        http_method = "PATCH"
                    elif ann.name == "RequestMapping":
                        if "method" in ann.parameters:
                            method_value = ann.parameters["method"]
                            if isinstance(method_value, list) and len(method_value) > 0:
                                http_method = method_value[0]
                            else:
                                http_method = str(method_value)
                        else:
                            http_method = "GET"  # default for RequestMapping
                    break
            
            # Build full path
            full_path = class_path
            if endpoint_path:
                if full_path and not full_path.endswith("/") and not endpoint_path.startswith("/"):
                    full_path += "/"
                full_path += endpoint_path
            elif not full_path:
                full_path = "/"
            
            # Extract method parameters
            parameters = []
            for param in method.parameters:
                param_info = {
                    "name": param.name,
                    "type": param.type,
                    "annotations": [ann.name for ann in param.annotations if ann.category == "web"]
                }
                parameters.append(param_info)
            
            # Extract return type
            return_type = method.return_type if method.return_type != "constructor" else "void"
            
            # Create endpoint
            endpoint = Endpoint(
                path=endpoint_path or "/",
                method=http_method,
                controller_class=cls.name,
                handler_method=method.name,
                parameters=parameters,
                return_type=return_type,
                annotations=[ann.name for ann in web_annotations],
                full_path=full_path
            )
            endpoints.append(endpoint)
    
    return endpoints


def extract_mybatis_mappers_from_classes(classes: list[Class]) -> list[MyBatisMapper]:
    """Extract MyBatis Mappers from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for cls in classes:
        # Check if class is a MyBatis Mapper interface
        is_mapper = any(ann.name == "Mapper" for ann in cls.annotations)
        
        if not is_mapper:
            continue
        
        # Extract mapper methods with MyBatis annotations
        mapper_methods = []
        sql_statements = []
        
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
            
            # Check if method has MyBatis annotations
            mybatis_annotations = [ann for ann in method.annotations if ann.category == "mybatis"]
            
            if not mybatis_annotations:
                continue
            
            # Extract SQL statement information
            sql_type = "SELECT"  # default
            sql_content = ""
            parameter_type = ""
            result_type = ""
            result_map = ""
            
            for ann in mybatis_annotations:
                if ann.name in ["Select", "SelectProvider"]:
                    sql_type = "SELECT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Insert", "InsertProvider"]:
                    sql_type = "INSERT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Update", "UpdateProvider"]:
                    sql_type = "UPDATE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Delete", "DeleteProvider"]:
                    sql_type = "DELETE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                
                # Extract parameter and result type information
                if "parameterType" in ann.parameters:
                    parameter_type = ann.parameters["parameterType"]
                if "resultType" in ann.parameters:
                    result_type = ann.parameters["resultType"]
                if "resultMap" in ann.parameters:
                    result_map = ann.parameters["resultMap"]
            
            # Create method info
            method_info = {
                "name": method.name,
                "return_type": method.return_type,
                "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            mapper_methods.append(method_info)
            
            # Create SQL statement info
            sql_statement = {
                "id": method.name,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            sql_statements.append(sql_statement)
        
        # Create mapper
        mapper = MyBatisMapper(
            name=cls.name,
            type="interface",
            namespace=f"{cls.package_name}.{cls.name}",
            methods=mapper_methods,
            sql_statements=sql_statements,
            file_path=cls.file_path,
            package_name=cls.package_name
        )
        mappers.append(mapper)
    
    return mappers


def parse_mybatis_xml_file(file_path: str) -> MyBatisMapper:
    """Parse MyBatis XML mapper file.
    
    Args:
        file_path: Path to the XML mapper file
        
    Returns:
        MyBatisMapper object
    """
    import xml.etree.ElementTree as ET
    
    try:
        tree = ET.parse(file_path)
        root = tree.getroot()
        
        # Extract namespace
        namespace = root.get("namespace", "")
        
        # Extract SQL statements
        sql_statements = []
        for statement in root.findall(".//*[@id]"):
            statement_id = statement.get("id")
            tag_name = statement.tag.lower()
            
            # Determine SQL type
            sql_type = "SELECT"
            if tag_name == "insert":
                sql_type = "INSERT"
            elif tag_name == "update":
                sql_type = "UPDATE"
            elif tag_name == "delete":
                sql_type = "DELETE"
            
            # Extract SQL content
            sql_content = statement.text.strip() if statement.text else ""
            
            # Extract parameter and result information
            parameter_type = statement.get("parameterType", "")
            result_type = statement.get("resultType", "")
            result_map = statement.get("resultMap", "")
            
            sql_statement = {
                "id": statement_id,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": []
            }
            sql_statements.append(sql_statement)
        
        # Extract ResultMaps
        result_maps = []
        for result_map in root.findall(".//resultMap"):
            result_map_id = result_map.get("id")
            result_map_type = result_map.get("type", "")
            
            properties = []
            for property_elem in result_map.findall(".//result"):
                prop = {
                    "property": property_elem.get("property", ""),
                    "column": property_elem.get("column", ""),
                    "jdbc_type": property_elem.get("jdbcType", "")
                }
                properties.append(prop)
            
            result_map_info = {
                "id": result_map_id,
                "type": result_map_type,
                "properties": properties,
                "associations": [],
                "collections": []
            }
            result_maps.append(result_map_info)
        
        # Create mapper
        mapper_name = namespace.split(".")[-1] if namespace else os.path.basename(file_path).replace(".xml", "")
        package_name = ".".join(namespace.split(".")[:-1]) if namespace else ""
        
        mapper = MyBatisMapper(
            name=mapper_name,
            type="xml",
            namespace=namespace,
            methods=[],  # XML mappers don't have Java methods
            sql_statements=sql_statements,
            file_path=file_path,
            package_name=package_name
        )
        
        return mapper
        
    except ET.ParseError as e:
        print(f"Error parsing XML file {file_path}: {e}")
        return None
    except Exception as e:
        print(f"Error reading XML file {file_path}: {e}")
        return None


def extract_mybatis_xml_mappers(directory: str) -> list[MyBatisMapper]:
    """Extract MyBatis XML mappers from directory.
    
    Args:
        directory: Directory to search for XML mapper files
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith("Mapper.xml") or file.endswith("Dao.xml"):
                file_path = os.path.join(root, file)
                mapper = parse_mybatis_xml_file(file_path)
                if mapper:
                    mappers.append(mapper)
    
    return mappers


def extract_jpa_entities_from_classes(classes: list[Class]) -> list[JpaEntity]:
    """Extract JPA Entities from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of JpaEntity objects
    """
    entities = []
    
    for cls in classes:
        # Check if class is a JPA Entity
        is_entity = any(ann.name == "Entity" for ann in cls.annotations)
        
        if not is_entity:
            continue
        
        # Extract table name
        table_name = cls.name.lower()  # default table name
        for ann in cls.annotations:
            if ann.name == "Table":
                if "name" in ann.parameters:
                    table_name = ann.parameters["name"]
                break
        
        # Extract columns from properties
        columns = []
        relationships = []
        
        for prop in cls.properties:
            # Check if property has JPA column annotations
            jpa_annotations = [ann for ann in prop.annotations if ann.category == "jpa"]
            
            if jpa_annotations:
                # Extract column information
                column_name = prop.name  # default column name
                nullable = True
                unique = False
                length = 0
                precision = 0
                scale = 0
                
                for ann in jpa_annotations:
                    if ann.name == "Column":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                        if "nullable" in ann.parameters:
                            nullable = ann.parameters["nullable"]
                        if "unique" in ann.parameters:
                            unique = ann.parameters["unique"]
                        if "length" in ann.parameters:
                            length = ann.parameters["length"]
                        if "precision" in ann.parameters:
                            precision = ann.parameters["precision"]
                        if "scale" in ann.parameters:
                            scale = ann.parameters["scale"]
                    elif ann.name == "Id":
                        column_name = "id"  # Primary key column
                        nullable = False
                        unique = True
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                
                # Check for relationship annotations
                relationship_type = None
                target_entity = ""
                mapped_by = ""
                join_column = ""
                join_table = ""
                cascade = []
                fetch = "LAZY"
                
                for ann in jpa_annotations:
                    if ann.name in ["OneToOne", "OneToMany", "ManyToOne", "ManyToMany"]:
                        relationship_type = ann.name
                        if "targetEntity" in ann.parameters:
                            target_entity = ann.parameters["targetEntity"]
                        if "mappedBy" in ann.parameters:
                            mapped_by = ann.parameters["mappedBy"]
                        if "cascade" in ann.parameters:
                            cascade = ann.parameters["cascade"] if isinstance(ann.parameters["cascade"], list) else [ann.parameters["cascade"]]
                        if "fetch" in ann.parameters:
                            fetch = ann.parameters["fetch"]
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            join_column = ann.parameters["name"]
                    elif ann.name == "JoinTable":
                        if "name" in ann.parameters:
                            join_table = ann.parameters["name"]
                
                # Create column info
                column_info = {
                    "property_name": prop.name,
                    "column_name": column_name,
                    "data_type": prop.type,
                    "nullable": nullable,
                    "unique": unique,
                    "length": length,
                    "precision": precision,
                    "scale": scale,
                    "annotations": [ann.name for ann in jpa_annotations]
                }
                columns.append(column_info)
                
                # Create relationship info if it's a relationship
                if relationship_type:
                    relationship_info = {
                        "type": relationship_type,
                        "target_entity": target_entity,
                        "mapped_by": mapped_by,
                        "join_column": join_column,
                        "join_table": join_table,
                        "cascade": cascade,
                        "fetch": fetch,
                        "annotations": [ann.name for ann in jpa_annotations]
                    }
                    relationships.append(relationship_info)
        
        # Create entity
        entity = JpaEntity(
            name=cls.name,
            table_name=table_name,
            columns=columns,
            relationships=relationships,
            annotations=[ann.name for ann in cls.annotations if ann.category == "jpa"],
            package_name=cls.package_name,
            file_path=cls.file_path
        )
        entities.append(entity)
    
    return entities


def parse_yaml_config(file_path: str) -> ConfigFile:
    """Parse YAML configuration file.
    
    Args:
        file_path: Path to the YAML file
        
    Returns:
        ConfigFile object
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = yaml.safe_load(f)
        
        if not content:
            content = {}
        
        # Extract file info
        file_name = os.path.basename(file_path)
        file_type = "yaml" if file_path.endswith('.yaml') else "yml"
        
        # Extract profiles
        profiles = []
        if 'spring' in content and 'profiles' in content['spring']:
            if 'active' in content['spring']['profiles']:
                profiles = content['spring']['profiles']['active']
                if isinstance(profiles, str):
                    profiles = [profiles]
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        # Extract sections
        sections = []
        for key, value in content.items():
            if isinstance(value, dict):
                sections.append({
                    "name": key,
                    "properties": value,
                    "type": "section"
                })
        
        return ConfigFile(
            name=file_name,
            file_path=file_path,
            file_type=file_type,
            properties=content,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing YAML file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="yaml",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def parse_properties_config(file_path: str) -> ConfigFile:
    """Parse Properties configuration file.
    
    Args:
        file_path: Path to the properties file
        
    Returns:
        ConfigFile object
    """
    try:
        properties = {}
        sections = []
        profiles = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                
                # Skip empty lines and comments
                if not line or line.startswith('#'):
                    continue
                
                # Parse key=value pairs
                if '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    
                    # Remove quotes if present
                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]
                    elif value.startswith("'") and value.endswith("'"):
                        value = value[1:-1]
                    
                    properties[key] = value
                    
                    # Check for profiles
                    if key == 'spring.profiles.active':
                        profiles = [p.strip() for p in value.split(',')]
        
        # Group properties by section
        section_map = {}
        for key, value in properties.items():
            if '.' in key:
                section = key.split('.')[0]
                if section not in section_map:
                    section_map[section] = {}
                section_map[section][key] = value
            else:
                if 'root' not in section_map:
                    section_map['root'] = {}
                section_map['root'][key] = value
        
        for section_name, section_props in section_map.items():
            sections.append({
                "name": section_name,
                "properties": section_props,
                "type": "section"
            })
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties=properties,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing Properties file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def extract_database_config(config_file: ConfigFile) -> DatabaseConfig:
    """Extract database configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        DatabaseConfig object
    """
    db_config = DatabaseConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        spring_config = config_file.properties.get('spring', {})
        datasource_config = spring_config.get('datasource', {})
        jpa_config = spring_config.get('jpa', {})
        
        db_config.driver = datasource_config.get('driver-class-name', '')
        db_config.url = datasource_config.get('url', '')
        db_config.username = datasource_config.get('username', '')
        db_config.password = datasource_config.get('password', '')
        db_config.dialect = jpa_config.get('database-platform', '')
        db_config.hibernate_ddl_auto = jpa_config.get('hibernate', {}).get('ddl-auto', '')
        db_config.show_sql = jpa_config.get('show-sql', False)
        db_config.format_sql = jpa_config.get('properties', {}).get('hibernate', {}).get('format_sql', False)
        
        # Store additional JPA properties
        if 'properties' in jpa_config:
            db_config.jpa_properties = jpa_config['properties']
    
    else:
        # Properties format
        props = config_file.properties
        
        db_config.driver = props.get('spring.datasource.driver-class-name', '')
        db_config.url = props.get('spring.datasource.url', '')
        db_config.username = props.get('spring.datasource.username', '')
        db_config.password = props.get('spring.datasource.password', '')
        db_config.dialect = props.get('spring.jpa.database-platform', '')
        db_config.hibernate_ddl_auto = props.get('spring.jpa.hibernate.ddl-auto', '')
        db_config.show_sql = props.get('spring.jpa.show-sql', 'false').lower() == 'true'
        db_config.format_sql = props.get('spring.jpa.properties.hibernate.format_sql', 'false').lower() == 'true'
        
        # Store additional JPA properties
        jpa_props = {}
        for key, value in props.items():
            if key.startswith('spring.jpa.properties.'):
                jpa_props[key] = value
        db_config.jpa_properties = jpa_props
    
    return db_config


def extract_server_config(config_file: ConfigFile) -> ServerConfig:
    """Extract server configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        ServerConfig object
    """
    server_config = ServerConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        server_props = config_file.properties.get('server', {})
        
        server_config.port = server_props.get('port', 8080)
        server_config.context_path = server_props.get('servlet', {}).get('context-path', '')
        server_config.servlet_path = server_props.get('servlet', {}).get('path', '')
        
        # SSL configuration
        ssl_config = server_props.get('ssl', {})
        server_config.ssl_enabled = bool(ssl_config)
        server_config.ssl_key_store = ssl_config.get('key-store', '')
        server_config.ssl_key_store_password = ssl_config.get('key-store-password', '')
        server_config.ssl_key_store_type = ssl_config.get('key-store-type', '')
    
    else:
        # Properties format
        props = config_file.properties
        
        server_config.port = int(props.get('server.port', '8080'))
        server_config.context_path = props.get('server.servlet.context-path', '')
        server_config.servlet_path = props.get('server.servlet.path', '')
        
        # SSL configuration
        server_config.ssl_enabled = any(key.startswith('server.ssl.') for key in props.keys())
        server_config.ssl_key_store = props.get('server.ssl.key-store', '')
        server_config.ssl_key_store_password = props.get('server.ssl.key-store-password', '')
        server_config.ssl_key_store_type = props.get('server.ssl.key-store-type', '')
    
    return server_config


def extract_security_config(config_file: ConfigFile) -> SecurityConfig:
    """Extract security configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        SecurityConfig object
    """
    security_config = SecurityConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        security_props = config_file.properties.get('security', {})
        jwt_props = security_props.get('jwt', {})
        cors_props = security_props.get('cors', {})
        
        security_config.enabled = bool(security_props)
        security_config.authentication_type = security_props.get('authentication-type', '')
        security_config.jwt_secret = jwt_props.get('secret', '')
        security_config.jwt_expiration = jwt_props.get('expiration', 0)
        security_config.cors_allowed_origins = cors_props.get('allowed-origins', [])
        security_config.cors_allowed_methods = cors_props.get('allowed-methods', [])
        security_config.cors_allowed_headers = cors_props.get('allowed-headers', [])
    
    else:
        # Properties format
        props = config_file.properties
        
        security_config.enabled = any(key.startswith('security.') for key in props.keys())
        security_config.authentication_type = props.get('security.authentication-type', '')
        security_config.jwt_secret = props.get('security.jwt.secret', '')
        security_config.jwt_expiration = int(props.get('security.jwt.expiration', '0'))
        
        # CORS configuration
        origins = props.get('security.cors.allowed-origins', '')
        if origins:
            security_config.cors_allowed_origins = [o.strip() for o in origins.split(',')]
        
        methods = props.get('security.cors.allowed-methods', '')
        if methods:
            security_config.cors_allowed_methods = [m.strip() for m in methods.split(',')]
        
        headers = props.get('security.cors.allowed-headers', '')
        if headers:
            security_config.cors_allowed_headers = [h.strip() for h in headers.split(',')]
    
    return security_config


def extract_logging_config(config_file: ConfigFile) -> LoggingConfig:
    """Extract logging configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        LoggingConfig object
    """
    logging_config = LoggingConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        logging_props = config_file.properties.get('logging', {})
        
        logging_config.level = logging_props.get('level', {}).get('root', 'INFO')
        logging_config.pattern = logging_props.get('pattern', {}).get('console', '')
        logging_config.file_path = logging_props.get('file', {}).get('name', '')
        logging_config.max_file_size = logging_props.get('file', {}).get('max-size', '')
        logging_config.max_history = logging_props.get('file', {}).get('max-history', 0)
        logging_config.console_output = logging_props.get('console', {}).get('enabled', True)
    
    else:
        # Properties format
        props = config_file.properties
        
        logging_config.level = props.get('logging.level.root', 'INFO')
        logging_config.pattern = props.get('logging.pattern.console', '')
        logging_config.file_path = props.get('logging.file.name', '')
        logging_config.max_file_size = props.get('logging.file.max-size', '')
        logging_config.max_history = int(props.get('logging.file.max-history', '0'))
        logging_config.console_output = props.get('logging.console.enabled', 'true').lower() == 'true'
    
    return logging_config


def extract_config_files(directory: str) -> list[ConfigFile]:
    """Extract configuration files from directory.
    
    Args:
        directory: Directory to search for config files
        
    Returns:
        List of ConfigFile objects
    """
    config_files = []
    
    # Common config file patterns
    config_patterns = [
        "application.yml",
        "application.yaml", 
        "application.properties",
        "application-*.properties",
        "bootstrap.yml",
        "bootstrap.yaml",
        "bootstrap.properties"
    ]
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            # Check if file matches any config pattern
            is_config_file = False
            for pattern in config_patterns:
                if pattern == file or (pattern.endswith('*') and file.startswith(pattern[:-1])):
                    is_config_file = True
                    break
            
            if is_config_file:
                file_path = os.path.join(root, file)
                
                if file.endswith(('.yml', '.yaml')):
                    config_file = parse_yaml_config(file_path)
                elif file.endswith('.properties'):
                    config_file = parse_properties_config(file_path)
                else:
                    continue
                
                config_files.append(config_file)
    
    return config_files


def extract_test_classes_from_classes(classes: list[Class]) -> list[TestClass]:
    """Extract test classes from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of TestClass objects
    """
    test_classes = []
    
    for cls in classes:
        # Check if class is a test class
        test_annotations = [ann for ann in cls.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
        
        if not test_annotations:
            continue
        
        # Determine test framework and type
        test_framework = "junit"  # default
        test_type = "unit"  # default
        
        for ann in test_annotations:
            if ann.name in ["SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest", "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest"]:
                test_framework = "spring_test"
                if ann.name == "SpringBootTest":
                    test_type = "integration"
                else:
                    test_type = "slice"
            elif ann.name in ["TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass"]:
                test_framework = "testng"
            elif ann.name in ["Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll"]:
                test_framework = "junit"
        
        # Extract test methods
        test_methods = []
        setup_methods = []
        
        for method in cls.methods:
            method_annotations = [ann.name for ann in method.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
            
            if method_annotations:
                # Check if it's a setup/teardown method
                if any(ann in method_annotations for ann in ["BeforeEach", "AfterEach", "BeforeAll", "AfterAll", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass", "BeforeSuite", "AfterSuite"]):
                    setup_methods.append({
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters]
                    })
                else:
                    # Regular test method
                    test_method_info = {
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                        "assertions": [],
                        "mock_calls": [],
                        "test_data": [],
                        "expected_exceptions": [],
                        "timeout": 0,
                        "display_name": ""
                    }
                    
                    # Extract display name
                    for ann in method.annotations:
                        if ann.name == "DisplayName" and "value" in ann.parameters:
                            test_method_info["display_name"] = ann.parameters["value"]
                        elif ann.name == "Timeout" and "value" in ann.parameters:
                            test_method_info["timeout"] = ann.parameters["value"]
                    
                    # Extract expected exceptions
                    for ann in method.annotations:
                        if ann.name == "ExpectedExceptions" and "value" in ann.parameters:
                            test_method_info["expected_exceptions"] = ann.parameters["value"] if isinstance(ann.parameters["value"], list) else [ann.parameters["value"]]
                    
                    test_methods.append(test_method_info)
        
        # Extract mock dependencies
        mock_dependencies = []
        for prop in cls.properties:
            prop_annotations = [ann.name for ann in prop.annotations if classify_test_annotation(ann.name) in ["mockito", "spring_test"]]
            if prop_annotations:
                mock_dependencies.append({
                    "name": prop.name,
                    "type": prop.type,
                    "annotations": prop_annotations,
                    "mock_type": "mock" if "Mock" in prop_annotations else "spy" if "Spy" in prop_annotations else "bean"
                })
        
        # Extract test configurations
        test_configurations = []
        for ann in cls.annotations:
            if ann.name in ["TestConfiguration", "ActiveProfiles", "TestPropertySource"]:
                config_info = {
                    "name": ann.name,
                    "type": "configuration" if ann.name == "TestConfiguration" else "profile" if ann.name == "ActiveProfiles" else "property",
                    "properties": ann.parameters,
                    "active_profiles": ann.parameters.get("value", []) if ann.name == "ActiveProfiles" else [],
                    "test_slices": [],
                    "mock_beans": [],
                    "spy_beans": []
                }
                test_configurations.append(config_info)
        
        # Create test class
        test_class = TestClass(
            name=cls.name,
            package_name=cls.package_name,
            test_framework=test_framework,
            test_type=test_type,
            annotations=[ann.name for ann in test_annotations],
            test_methods=test_methods,
            setup_methods=setup_methods,
            mock_dependencies=mock_dependencies,
            test_configurations=test_configurations,
            file_path=cls.file_path
        )
        test_classes.append(test_class)
    
    return test_classes


def analyze_test_methods(test_class: TestClass, class_obj: Class) -> list[TestMethod]:
    """Analyze test methods for assertions, mock calls, and test data.
    
    Args:
        test_class: TestClass object
        class_obj: Original Class object
        
    Returns:
        List of analyzed TestMethod objects
    """
    test_methods = []
    
    for method_info in test_class.test_methods:
        # Find the corresponding method in the class
        method_obj = None
        for method in class_obj.methods:
            if method.name == method_info["name"]:
                method_obj = method
                break
        
        if not method_obj:
            continue
        
        # Analyze method source code for assertions and mock calls
        assertions = []
        mock_calls = []
        test_data = []
        
        if method_obj.source:
            source_code = method_obj.source
            
            # Find assertions (JUnit, AssertJ, etc.)
            assertion_patterns = [
                r'assert\w+\(',  # JUnit assertions
                r'assertThat\(',  # AssertJ
                r'assertEquals\(',  # JUnit
                r'assertTrue\(',  # JUnit
                r'assertFalse\(',  # JUnit
                r'assertNotNull\(',  # JUnit
                r'assertNull\(',  # JUnit
                r'assertThrows\(',  # JUnit 5
                r'assertDoesNotThrow\(',  # JUnit 5
                r'verify\(',  # Mockito verify
                r'when\(',  # Mockito when
                r'then\(',  # Mockito then
                r'given\(',  # BDDMockito given
                r'willReturn\(',  # Mockito willReturn
                r'willThrow\(',  # Mockito willThrow
            ]
            
            for pattern in assertion_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    assertions.append({
                        "type": match,
                        "line": source_code.find(match) + 1
                    })
            
            # Find mock calls
            mock_call_patterns = [
                r'(\w+)\.(\w+)\(',  # Method calls on objects
                r'mock\(',  # Mockito mock creation
                r'spy\(',  # Mockito spy creation
                r'@Mock\s+(\w+)',  # @Mock annotation
                r'@Spy\s+(\w+)',  # @Spy annotation
                r'@InjectMocks\s+(\w+)',  # @InjectMocks annotation
            ]
            
            for pattern in mock_call_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        mock_calls.append({
                            "object": match[0],
                            "method": match[1],
                            "type": "method_call"
                        })
                    else:
                        mock_calls.append({
                            "type": match,
                            "line": source_code.find(match) + 1
                        })
            
            # Find test data setup
            test_data_patterns = [
                r'new\s+(\w+)\(',  # Object creation
                r'(\w+)\s*=\s*new\s+(\w+)\(',  # Variable assignment with new
                r'@ValueSource\(',  # JUnit 5 @ValueSource
                r'@CsvSource\(',  # JUnit 5 @CsvSource
                r'@MethodSource\(',  # JUnit 5 @MethodSource
            ]
            
            for pattern in test_data_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        test_data.append({
                            "variable": match[0],
                            "type": match[1],
                            "pattern": "object_creation"
                        })
                    else:
                        test_data.append({
                            "type": match,
                            "pattern": "annotation"
                        })
        
        # Create TestMethod object
        test_method = TestMethod(
            name=method_info["name"],
            return_type=method_info["return_type"],
            annotations=method_info["annotations"],
            assertions=assertions,
            mock_calls=mock_calls,
            test_data=test_data,
            expected_exceptions=method_info["expected_exceptions"],
            timeout=method_info["timeout"],
            display_name=method_info["display_name"]
        )
        test_methods.append(test_method)
    
    return test_methods


def generate_lombok_methods(properties: list[Field], class_name: str, package_name: str) -> list[Method]:
    """Generate Lombok @Data methods (getters, setters, equals, hashCode, toString) for properties."""
    methods = []
    
    # Generate getters and setters for each property
    for prop in properties:
        # Getter
        getter_name = f"get{prop.name[0].upper()}{prop.name[1:]}"
        if prop.type == "Boolean" and prop.name.startswith("is"):
            # For boolean fields starting with 'is', use the field name as getter
            getter_name = prop.name
        
        getter = Method(
            name=getter_name,
            logical_name=f"{package_name}.{class_name}.{getter_name}",
            return_type=prop.type,
            parameters=[],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[],
            description=f"Generated getter for {prop.name} field"  # Generated method description
        )
        methods.append(getter)
        
        # Setter
        setter_name = f"set{prop.name[0].upper()}{prop.name[1:]}"
        setter_param = Field(
            name=prop.name,
            logical_name=f"{package_name}.{class_name}.{prop.name}",
            type=prop.type,
            package_name=package_name,
            class_name=class_name
        )
        
        setter = Method(
            name=setter_name,
            logical_name=f"{package_name}.{class_name}.{setter_name}",
            return_type="void",
            parameters=[setter_param],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[],
            description=f"Generated setter for {prop.name} field"  # Generated method description
        )
        methods.append(setter)
    
    # Generate equals method
    equals_method = Method(
        name="equals",
        logical_name=f"{package_name}.{class_name}.equals",
        return_type="boolean",
        parameters=[Field(name="obj", logical_name=f"{package_name}.{class_name}.obj", type="Object", package_name=package_name, class_name=class_name)],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated equals method for object comparison"  # Generated method description
    )
    methods.append(equals_method)
    
    # Generate hashCode method
    hashcode_method = Method(
        name="hashCode",
        logical_name=f"{package_name}.{class_name}.hashCode",
        return_type="int",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated hashCode method for object hashing"  # Generated method description
    )
    methods.append(hashcode_method)
    
    # Generate toString method
    tostring_method = Method(
        name="toString",
        logical_name=f"{package_name}.{class_name}.toString",
        return_type="String",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated toString method for string representation"  # Generated method description
    )
    methods.append(tostring_method)
    
    return methods


def parse_java_project(directory: str) -> tuple[list[Package], list[Class], dict[str, str], list[Bean], list[BeanDependency], list[Endpoint], list[MyBatisMapper], list[JpaEntity], list[ConfigFile], list[TestClass], list[SqlStatement], str]:
    """Parse Java project and return parsed entities."""
    logger = get_logger(__name__)
    """Parses all Java files in a directory and returns a tuple of (packages, classes, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name)."""
    
    # Extract project name from directory path
    project_name = extract_project_name(directory)
    packages = {}
    classes = {}
    class_to_package_map = {}  # Maps class_key to package_name

    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith(".java"):
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    file_content = f.read() # Read file content once
                try:
                    tree = javalang.parse.parse(file_content)
                    package_name = tree.package.name if tree.package else ""
                    
                    # Create or update package node
                    if package_name and package_name not in packages:
                        packages[package_name] = Package(
                            name=package_name
                        )
                    elif not package_name:
                        # Handle classes without package (default package)
                        package_name = "default"
                        if package_name not in packages:
                            packages[package_name] = Package(
                                name=package_name
                            )
                    
                    import_map = {}
                    for imp in tree.imports:
                        class_name = imp.path.split('.')[-1]
                        import_map[class_name] = imp.path

                    for _, class_declaration in tree.filter(
                        javalang.tree.ClassDeclaration
                    ):
                        class_name = class_declaration.name
                        class_key = f"{package_name}.{class_name}"
                        
                        # Debug: Check if this is the User class
                        if "User" in class_name:
                            logger.debug(f"Found User class - {class_key}")
                            logger.debug(f"Methods count: {len(class_declaration.methods)}")
                            logger.debug(f"Constructors count: {len(class_declaration.constructors)}")
                        
                        # Extract class source code - use the entire file content
                        class_source = file_content


                        if class_key not in classes:
                            # Parse class annotations
                            class_annotations = parse_annotations(class_declaration.annotations, "class") if hasattr(class_declaration, 'annotations') else []
                            
                            classes[class_key] = Class(
                                name=class_name,
                                logical_name=class_key,  # Add logical_name
                                file_path=file_path,
                                type="class", # Simplified for now
                                source=class_source, # Add class source
                                annotations=class_annotations,
                                package_name=package_name,
                                description=""  # TODO: Extract description from comments or annotations
                            )
                            class_to_package_map[class_key] = package_name
                        
                        # --- Start of new import logic ---
                        for imp in tree.imports:
                            classes[class_key].imports.append(imp.path)
                        # --- End of new import logic ---

                        # --- Start of new inheritance logic ---
                        # Handle 'extends'
                        if class_declaration.extends:
                            superclass_name = class_declaration.extends.name
                            # Try to resolve fully qualified name for superclass
                            if superclass_name in import_map:
                                classes[class_key].superclass = import_map[superclass_name]
                            else:
                                # Assume same package or fully qualified if not in import_map
                                classes[class_key].superclass = f"{package_name}.{superclass_name}" if package_name else superclass_name

                        # Handle 'implements'
                        if class_declaration.implements: # Add this check
                            for impl_ref in class_declaration.implements:
                                interface_name = impl_ref.name
                                # Try to resolve fully qualified name for interface
                                if interface_name in import_map:
                                    classes[class_key].interfaces.append(import_map[interface_name])
                                else:
                                    # Assume same package or fully qualified if not in import_map
                                    classes[class_key].interfaces.append(f"{package_name}.{interface_name}" if package_name else interface_name)
                        # --- End of new inheritance logic ---

                        field_map = {}
                        for field_declaration in class_declaration.fields:
                            for declarator in field_declaration.declarators:
                                field_map[declarator.name] = field_declaration.type.name
                                
                                # Parse field annotations
                                field_annotations = parse_annotations(field_declaration.annotations, "field") if hasattr(field_declaration, 'annotations') else []
                                
                                # Extract initial value if present
                                initial_value = ""
                                if hasattr(declarator, 'initializer') and declarator.initializer:
                                    # Convert the initializer to string representation
                                    if hasattr(declarator.initializer, 'value'):
                                        initial_value = str(declarator.initializer.value)
                                    elif hasattr(declarator.initializer, 'type'):
                                        initial_value = str(declarator.initializer.type)
                                    else:
                                        initial_value = str(declarator.initializer)
                                
                                prop = Field(
                                    name=declarator.name,
                                    logical_name=f"{package_name}.{class_name}.{declarator.name}",
                                    type=field_declaration.type.name,
                                    modifiers=list(field_declaration.modifiers), # Add modifiers
                                    package_name=package_name,
                                    class_name=class_name,
                                    annotations=field_annotations,
                                    initial_value=initial_value,
                                    description=""  # TODO: Extract description from comments or annotations
                                )
                                classes[class_key].properties.append(prop)

                        all_declarations = class_declaration.methods + class_declaration.constructors
                        
                        # Debug: Check User class method processing
                        if "User" in class_name:
                            logger.debug(f"Processing User class methods - total declarations: {len(all_declarations)}")
                            for i, decl in enumerate(all_declarations):
                                logger.debug(f"Declaration {i}: {type(decl).__name__} - {decl.name}")
                        
                        for declaration in all_declarations:
                            local_var_map = field_map.copy()
                            params = []
                            for param in declaration.parameters:
                                param_type_name = 'Unknown'
                                if hasattr(param.type, 'name'):
                                    param_type_name = param.type.name
                                local_var_map[param.name] = param_type_name
                                params.append(Field(name=param.name, logical_name=f"{package_name}.{class_name}.{param.name}", type=param_type_name, package_name=package_name, class_name=class_name))

                            if declaration.body:
                                for _, var_decl in declaration.filter(javalang.tree.LocalVariableDeclaration):
                                    for declarator in var_decl.declarators:
                                        local_var_map[declarator.name] = var_decl.type.name
                            
                            if isinstance(declaration, javalang.tree.MethodDeclaration):
                                return_type = declaration.return_type.name if declaration.return_type else "void"
                            else: # ConstructorDeclaration
                                return_type = "constructor"

                            # Extract modifiers
                            modifiers = list(declaration.modifiers)
                            
                            # Parse method annotations
                            method_annotations = parse_annotations(declaration.annotations, "method") if hasattr(declaration, 'annotations') else []

                            # Extract method source code
                            method_source = ""
                            if declaration.position:
                                lines = file_content.splitlines(keepends=True) # Keep line endings
                                start_line = declaration.position.line - 1
                                
                                # Find the end of the method by matching braces
                                brace_count = 0
                                end_line = start_line
                                for i in range(start_line, len(lines)):
                                    line = lines[i]
                                    for char in line:
                                        if char == '{':
                                            brace_count += 1
                                        elif char == '}':
                                            brace_count -= 1
                                            if brace_count == 0:
                                                end_line = i
                                                break
                                    if brace_count == 0:
                                        break
                                
                                method_source = "".join(lines[start_line:end_line + 1])

                            method = Method(
                                name=declaration.name,
                                logical_name=f"{class_key}.{declaration.name}",  # Add logical_name
                                return_type=return_type,
                                parameters=params,
                                modifiers=modifiers,
                                source=method_source, # Add method source
                                package_name=package_name,
                                annotations=method_annotations,
                                description=""  # TODO: Extract description from comments or annotations
                            )
                            classes[class_key].methods.append(method)

                            # Extract method calls with order information
                            call_order = 0
                            for _, invocation in declaration.filter(javalang.tree.MethodInvocation):
                                target_class_name = None
                                resolved_target_package = ""
                                resolved_target_class_name = ""
                                
                                if invocation.qualifier:
                                    # External method call
                                    if invocation.qualifier in local_var_map:
                                        target_class_name = local_var_map[invocation.qualifier]
                                    else:
                                        target_class_name = invocation.qualifier
                                    
                                    if target_class_name:
                                        if target_class_name == "System.out":
                                            resolved_target_package = "java.io"
                                            resolved_target_class_name = "PrintStream"
                                        else:
                                            if target_class_name in import_map:
                                                resolved_target_package = ".".join(import_map[target_class_name].split(".")[:-1])
                                            else:
                                                resolved_target_package = package_name
                                                resolved_target_class_name = target_class_name
                                else:
                                    # Same class method call
                                    resolved_target_package = package_name
                                    resolved_target_class_name = class_name

                                if resolved_target_class_name:
                                    # Get line number from invocation position
                                    line_number = invocation.position.line if invocation.position else 0

                                    call = MethodCall(
                                        source_package=package_name,
                                        source_class=class_name,
                                        source_method=declaration.name,
                                        target_package=resolved_target_package,
                                        target_class=resolved_target_class_name,
                                        target_method=invocation.member,
                                        call_order=call_order,
                                        line_number=line_number,
                                        return_type="void"  # Default return type, can be enhanced later
                                    )
                                    classes[class_key].calls.append(call)
                                    call_order += 1
                        
                        # Check for Lombok @Data annotation and generate methods
                        has_data_annotation = any(ann.name == "Data" for ann in classes[class_key].annotations)
                        if has_data_annotation:
                            logger.debug(f"Found @Data annotation on {class_name}, generating Lombok methods")
                            lombok_methods = generate_lombok_methods(classes[class_key].properties, class_name, package_name)
                            classes[class_key].methods.extend(lombok_methods)
                            logger.debug(f"Generated {len(lombok_methods)} Lombok methods for {class_name}")
                except javalang.parser.JavaSyntaxError as e:
                    print(f"Syntax error in {file_path}: {e}")
                    continue
                except Exception as e:
                    print(f"Error parsing {file_path}: {e}")
                    continue
    
    # Extract beans, analyze dependencies, extract endpoints, extract MyBatis mappers, extract JPA entities, extract config files, and extract test classes
    classes_list = list(classes.values())
    beans = extract_beans_from_classes(classes_list)
    dependencies = analyze_bean_dependencies(classes_list, beans)
    endpoints = extract_endpoints_from_classes(classes_list)
    mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
    jpa_entities = extract_jpa_entities_from_classes(classes_list)
    config_files = extract_config_files(directory)
    test_classes = extract_test_classes_from_classes(classes_list)
    
    # Also extract XML mappers
    xml_mappers = extract_mybatis_xml_mappers(directory)
    mybatis_mappers.extend(xml_mappers)
    
    # Extract SQL statements from MyBatis mappers
    sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
    
    return list(packages.values()), classes_list, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name
```

이제 파서 서비스에서 description 처리 로직 추가가 완료되었습니다.


이제 테스트 코드를 업데이트하겠습니다. 테스트에서 description 필드를 포함하도록 수정하겠습니다.


```python
import pytest
from unittest.mock import MagicMock, patch
import json # Added import for json

from src.services.graph_db import GraphDB
from src.models.graph_entities import Class, Field, Method, MethodCall # Import Method and Field

@pytest.fixture
def mock_db():
    with patch('neo4j.GraphDatabase.driver') as mock_driver_constructor:
        mock_driver_instance = MagicMock()
        mock_driver_constructor.return_value = mock_driver_instance
        db_service = GraphDB("uri", "user", "pass")
        yield db_service, mock_driver_instance
        db_service.close()

def test_add_class(mock_db):
    # Given
    db_service, mock_driver = mock_db
    mock_session = MagicMock()
    mock_tx = MagicMock()
    mock_driver.session.return_value.__enter__.return_value = mock_session
    mock_session.write_transaction.side_effect = lambda func, *args: func(mock_tx, *args)

    test_class = Class(
        name="TestClass",
        package="com.test",
        file_path="/path/to/TestClass.java",
        type="class",
        properties=[Field(name="testProp", type="int")],
        calls=[
            MethodCall(
                source_package="com.test",
                source_class="TestClass",
                source_method="myCallingMethod",
                target_package="com.another",
                target_class="AnotherClass",
                target_method="someCalledMethod"
            )
        ]
    )

    # When
    db_service.add_class(test_class)

    # Then
    assert mock_session.write_transaction.called
    
    # Collect all executed queries
    executed_queries = [call[0][0] for call in mock_tx.run.call_args_list]
    executed_params = [call[1] for call in mock_tx.run.call_args_list]

    # Check the MERGE query for the class itself
    class_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (c:Class {name: $name, package: $package})" in query:
            assert executed_params[i]['name'] == "TestClass"
            assert executed_params[i]['package'] == "com.test"
            class_query_found = True
            break
    assert class_query_found

    # Check the MERGE query for the property
    prop_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name})" in query:
            assert executed_params[i]['prop_name'] == "testProp"
            prop_query_found = True
            break
    assert prop_query_found

    # Check the MERGE query for the call relationship
    call_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (sm)-[r:CALLS]->(tm)" in query: # Changed to match the actual query in graph_db.py
            assert executed_params[i]['source_package'] == "com.test"
            assert executed_params[i]['source_class'] == "TestClass"
            assert executed_params[i]['source_method'] == "myCallingMethod"
            assert executed_params[i]['target_package'] == "com.another"
            assert executed_params[i]['target_class'] == "AnotherClass"
            assert executed_params[i]['target_method'] == "someCalledMethod"
            call_query_found = True
            break
    assert call_query_found


def test_add_class_with_fields(mock_db):
    # Given
    db_service, mock_driver = mock_db
    mock_session = MagicMock()
    mock_tx = MagicMock()
    mock_driver.session.return_value.__enter__.return_value = mock_session
    mock_session.write_transaction.side_effect = lambda func, *args: func(mock_tx, *args)

    test_field_private = Field(
        name="greeting", type="String", modifiers=["private"], description="Private greeting field"
    )
    test_field_public_static_final = Field(
        name="MAX_VALUE", type="int", modifiers=["public", "static", "final"]
    )
    test_class = Class(
        name="Greeter",
        package="com.example",
        file_path="/path/to/Greeter.java",
        source="class Greeter { private String greeting; }",
        properties=[test_field_private, test_field_public_static_final],
    )

    # When
    db_service.add_class(test_class)

    # Then
    # Check the MERGE query for the class itself
    class_merge_call = mock_tx.run.call_args_list[0]
    assert "MERGE (c:Class {name: $name, package: $package})" in class_merge_call[0][0]
    assert class_merge_call[1]['name'] == "Greeter"

    # Check the MERGE query for the first property (greeting)
    prop1_merge_call = mock_tx.run.call_args_list[1]
    assert (
        "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
        "SET p.modifiers = $prop_modifiers "
        "MERGE (c)-[:HAS_FIELD]->(p)"
    ) in prop1_merge_call[0][0]
    assert prop1_merge_call[1]['prop_name'] == "greeting"
    assert prop1_merge_call[1]['prop_type'] == "String"
    assert prop1_merge_call[1]['prop_modifiers'] == ["private"]

    # Check the MERGE query for the second property (MAX_VALUE)
    prop2_merge_call = mock_tx.run.call_args_list[2]
    assert (
        "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
        "SET p.modifiers = $prop_modifiers "
        "MERGE (c)-[:HAS_FIELD]->(p)"
    ) in prop2_merge_call[0][0]
    assert prop2_merge_call[1]['prop_name'] == "MAX_VALUE"
    assert prop2_merge_call[1]['prop_type'] == "int"
    assert prop2_merge_call[1]['prop_modifiers'] == ["public", "static", "final"]

```

```python
import pytest
from unittest.mock import MagicMock, patch
import json # Added import for json

from src.services.graph_db import GraphDB
from src.models.graph_entities import Class, Field, Method, MethodCall # Import Method and Field

@pytest.fixture
def mock_db():
    with patch('neo4j.GraphDatabase.driver') as mock_driver_constructor:
        mock_driver_instance = MagicMock()
        mock_driver_constructor.return_value = mock_driver_instance
        db_service = GraphDB("uri", "user", "pass")
        yield db_service, mock_driver_instance
        db_service.close()

def test_add_class(mock_db):
    # Given
    db_service, mock_driver = mock_db
    mock_session = MagicMock()
    mock_tx = MagicMock()
    mock_driver.session.return_value.__enter__.return_value = mock_session
    mock_session.write_transaction.side_effect = lambda func, *args: func(mock_tx, *args)

    test_class = Class(
        name="TestClass",
        package="com.test",
        file_path="/path/to/TestClass.java",
        type="class",
        properties=[Field(name="testProp", type="int")],
        calls=[
            MethodCall(
                source_package="com.test",
                source_class="TestClass",
                source_method="myCallingMethod",
                target_package="com.another",
                target_class="AnotherClass",
                target_method="someCalledMethod"
            )
        ]
    )

    # When
    db_service.add_class(test_class)

    # Then
    assert mock_session.write_transaction.called
    
    # Collect all executed queries
    executed_queries = [call[0][0] for call in mock_tx.run.call_args_list]
    executed_params = [call[1] for call in mock_tx.run.call_args_list]

    # Check the MERGE query for the class itself
    class_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (c:Class {name: $name, package: $package})" in query:
            assert executed_params[i]['name'] == "TestClass"
            assert executed_params[i]['package'] == "com.test"
            class_query_found = True
            break
    assert class_query_found

    # Check the MERGE query for the property
    prop_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name})" in query:
            assert executed_params[i]['prop_name'] == "testProp"
            prop_query_found = True
            break
    assert prop_query_found

    # Check the MERGE query for the call relationship
    call_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (sm)-[r:CALLS]->(tm)" in query: # Changed to match the actual query in graph_db.py
            assert executed_params[i]['source_package'] == "com.test"
            assert executed_params[i]['source_class'] == "TestClass"
            assert executed_params[i]['source_method'] == "myCallingMethod"
            assert executed_params[i]['target_package'] == "com.another"
            assert executed_params[i]['target_class'] == "AnotherClass"
            assert executed_params[i]['target_method'] == "someCalledMethod"
            call_query_found = True
            break
    assert call_query_found


def test_add_class_with_fields(mock_db):
    # Given
    db_service, mock_driver = mock_db
    mock_session = MagicMock()
    mock_tx = MagicMock()
    mock_driver.session.return_value.__enter__.return_value = mock_session
    mock_session.write_transaction.side_effect = lambda func, *args: func(mock_tx, *args)

    test_field_private = Field(
        name="greeting", type="String", modifiers=["private"], description="Private greeting field"
    )
    test_field_public_static_final = Field(
        name="MAX_VALUE", type="int", modifiers=["public", "static", "final"], description="Public static final constant"
    )
    test_class = Class(
        name="Greeter",
        package="com.example",
        file_path="/path/to/Greeter.java",
        source="class Greeter { private String greeting; }",
        properties=[test_field_private, test_field_public_static_final],
    )

    # When
    db_service.add_class(test_class)

    # Then
    # Check the MERGE query for the class itself
    class_merge_call = mock_tx.run.call_args_list[0]
    assert "MERGE (c:Class {name: $name, package: $package})" in class_merge_call[0][0]
    assert class_merge_call[1]['name'] == "Greeter"

    # Check the MERGE query for the first property (greeting)
    prop1_merge_call = mock_tx.run.call_args_list[1]
    assert (
        "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
        "SET p.modifiers = $prop_modifiers "
        "MERGE (c)-[:HAS_FIELD]->(p)"
    ) in prop1_merge_call[0][0]
    assert prop1_merge_call[1]['prop_name'] == "greeting"
    assert prop1_merge_call[1]['prop_type'] == "String"
    assert prop1_merge_call[1]['prop_modifiers'] == ["private"]

    # Check the MERGE query for the second property (MAX_VALUE)
    prop2_merge_call = mock_tx.run.call_args_list[2]
    assert (
        "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
        "SET p.modifiers = $prop_modifiers "
        "MERGE (c)-[:HAS_FIELD]->(p)"
    ) in prop2_merge_call[0][0]
    assert prop2_merge_call[1]['prop_name'] == "MAX_VALUE"
    assert prop2_merge_call[1]['prop_type'] == "int"
    assert prop2_merge_call[1]['prop_modifiers'] == ["public", "static", "final"]

```

이제 다른 테스트에서도 description을 추가하겠습니다.


```python
import pytest
from unittest.mock import MagicMock, patch
import json # Added import for json

from src.services.graph_db import GraphDB
from src.models.graph_entities import Class, Field, Method, MethodCall # Import Method and Field

@pytest.fixture
def mock_db():
    with patch('neo4j.GraphDatabase.driver') as mock_driver_constructor:
        mock_driver_instance = MagicMock()
        mock_driver_constructor.return_value = mock_driver_instance
        db_service = GraphDB("uri", "user", "pass")
        yield db_service, mock_driver_instance
        db_service.close()

def test_add_class(mock_db):
    # Given
    db_service, mock_driver = mock_db
    mock_session = MagicMock()
    mock_tx = MagicMock()
    mock_driver.session.return_value.__enter__.return_value = mock_session
    mock_session.write_transaction.side_effect = lambda func, *args: func(mock_tx, *args)

    test_class = Class(
        name="TestClass",
        package="com.test",
        file_path="/path/to/TestClass.java",
        type="class",
        properties=[Field(name="testProp", type="int", description="Test property")],
        calls=[
            MethodCall(
                source_package="com.test",
                source_class="TestClass",
                source_method="myCallingMethod",
                target_package="com.another",
                target_class="AnotherClass",
                target_method="someCalledMethod"
            )
        ]
    )

    # When
    db_service.add_class(test_class)

    # Then
    assert mock_session.write_transaction.called
    
    # Collect all executed queries
    executed_queries = [call[0][0] for call in mock_tx.run.call_args_list]
    executed_params = [call[1] for call in mock_tx.run.call_args_list]

    # Check the MERGE query for the class itself
    class_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (c:Class {name: $name, package: $package})" in query:
            assert executed_params[i]['name'] == "TestClass"
            assert executed_params[i]['package'] == "com.test"
            class_query_found = True
            break
    assert class_query_found

    # Check the MERGE query for the property
    prop_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name})" in query:
            assert executed_params[i]['prop_name'] == "testProp"
            prop_query_found = True
            break
    assert prop_query_found

    # Check the MERGE query for the call relationship
    call_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (sm)-[r:CALLS]->(tm)" in query: # Changed to match the actual query in graph_db.py
            assert executed_params[i]['source_package'] == "com.test"
            assert executed_params[i]['source_class'] == "TestClass"
            assert executed_params[i]['source_method'] == "myCallingMethod"
            assert executed_params[i]['target_package'] == "com.another"
            assert executed_params[i]['target_class'] == "AnotherClass"
            assert executed_params[i]['target_method'] == "someCalledMethod"
            call_query_found = True
            break
    assert call_query_found


def test_add_class_with_fields(mock_db):
    # Given
    db_service, mock_driver = mock_db
    mock_session = MagicMock()
    mock_tx = MagicMock()
    mock_driver.session.return_value.__enter__.return_value = mock_session
    mock_session.write_transaction.side_effect = lambda func, *args: func(mock_tx, *args)

    test_field_private = Field(
        name="greeting", type="String", modifiers=["private"], description="Private greeting field"
    )
    test_field_public_static_final = Field(
        name="MAX_VALUE", type="int", modifiers=["public", "static", "final"], description="Public static final constant"
    )
    test_class = Class(
        name="Greeter",
        package="com.example",
        file_path="/path/to/Greeter.java",
        source="class Greeter { private String greeting; }",
        properties=[test_field_private, test_field_public_static_final],
    )

    # When
    db_service.add_class(test_class)

    # Then
    # Check the MERGE query for the class itself
    class_merge_call = mock_tx.run.call_args_list[0]
    assert "MERGE (c:Class {name: $name, package: $package})" in class_merge_call[0][0]
    assert class_merge_call[1]['name'] == "Greeter"

    # Check the MERGE query for the first property (greeting)
    prop1_merge_call = mock_tx.run.call_args_list[1]
    assert (
        "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
        "SET p.modifiers = $prop_modifiers "
        "MERGE (c)-[:HAS_FIELD]->(p)"
    ) in prop1_merge_call[0][0]
    assert prop1_merge_call[1]['prop_name'] == "greeting"
    assert prop1_merge_call[1]['prop_type'] == "String"
    assert prop1_merge_call[1]['prop_modifiers'] == ["private"]

    # Check the MERGE query for the second property (MAX_VALUE)
    prop2_merge_call = mock_tx.run.call_args_list[2]
    assert (
        "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
        "SET p.modifiers = $prop_modifiers "
        "MERGE (c)-[:HAS_FIELD]->(p)"
    ) in prop2_merge_call[0][0]
    assert prop2_merge_call[1]['prop_name'] == "MAX_VALUE"
    assert prop2_merge_call[1]['prop_type'] == "int"
    assert prop2_merge_call[1]['prop_modifiers'] == ["public", "static", "final"]

```

이제 테스트 코드 업데이트가 완료되었습니다.


이제 모든 변경사항에 대해 린터 오류가 있는지 확인하겠습니다.


완벽합니다! 모든 노드에 description 속성을 성공적으로 추가했습니다.

## 완료된 작업 요약

모든 노드에 `description` 속성을 추가하는 작업이 완료되었습니다:

### 1. 모델 클래스 업데이트 (`src/models/graph_entities.py`)
- 모든 모델 클래스에 `description: str = ""` 필드 추가
- 총 25개의 클래스에 description 속성 추가:
  - Annotation, Package, Field, Method, MethodCall
  - Bean, BeanDependency, Endpoint
  - MyBatisMapper, MyBatisSqlStatement, SqlStatement, MyBatisResultMap
  - JpaEntity, JpaColumn, JpaRelationship
  - ConfigFile, DatabaseConfig, ServerConfig, SecurityConfig, LoggingConfig
  - TestClass, TestMethod, TestConfiguration
  - Class

### 2. 데이터베이스 스키마 업데이트 (`src/services/graph_db.py`)
- 모든 노드 생성 쿼리에 `description` 필드 추가
- Package, Class, Method, Field, Bean, Endpoint, MyBatisMapper, JpaEntity, ConfigFile, TestClass, SqlStatement 노드에 description 속성 추가
- 각 노드 생성 시 description 값을 데이터베이스에 저장하도록 수정

### 3. 파서 서비스 업데이트 (`src/services/java_parser.py`)
- Field, Method, Class 생성 시 description 필드 추가
- Lombok 생성 메서드들에 의미있는 description 추가:
  - getter/setter: "Generated getter/setter for {field_name} field"
  - equals: "Generated equals method for object comparison"
  - hashCode: "Generated hashCode method for object hashing"
  - toString: "Generated toString method for string representation"
- 실제 파싱된 메서드와 클래스에는 빈 문자열로 설정 (추후 주석 파싱 로직 추가 예정)

### 4. 테스트 코드 업데이트 (`tests/unit/test_graph_db.py`)
- 테스트에서 사용하는 Field 객체들에 description 추가
- 테스트 데이터에 의미있는 description 값 설정

### 향후 확장 가능성
- **주석 파싱**: JavaDoc 주석이나 일반 주석에서 description 추출
- **어노테이션 기반**: 특정 어노테이션의 값에서 description 추출
- **AI 기반**: 소스 코드를 분석하여 자동으로 description 생성
- **사용자 정의**: 특정 규칙에 따라 description 생성

이제 모든 노드가 description 속성을 가지며, 추후 각 노드의 특징을 간략한 문장으로 표현하거나 소스에서 특정 내용을 파싱해서 저장할 수 있는 기반이 마련되었습니다.

---

**User**

모든 노드에 "ai_description" 속성을 추가해줘
추후 AI LLM을 사용해서 description을 생성하고 그값을 저장할 거야..


---

**Cursor**

모든 노드에 "ai_description" 속성을 추가하겠습니다. 이전에 description을 추가한 것과 동일한 방식으로 진행하겠습니다.


먼저 모델 클래스에 ai_description 속성을 추가하겠습니다.


```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation
    ai_description: str = ""  # AI-generated description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True
    description: str = ""  # Brief description of the logging config


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""
    description: str = ""  # Brief description of the test class


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value
    description: str = ""  # Brief description of the test method


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions
    description: str = ""  # Brief description of the test configuration


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""
    description: str = ""  # Brief description of the class


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation
    ai_description: str = ""  # AI-generated description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package
    ai_description: str = ""  # AI-generated description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True
    description: str = ""  # Brief description of the logging config


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""
    description: str = ""  # Brief description of the test class


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value
    description: str = ""  # Brief description of the test method


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions
    description: str = ""  # Brief description of the test configuration


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""
    description: str = ""  # Brief description of the class


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation
    ai_description: str = ""  # AI-generated description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package
    ai_description: str = ""  # AI-generated description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field
    ai_description: str = ""  # AI-generated description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True
    description: str = ""  # Brief description of the logging config


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""
    description: str = ""  # Brief description of the test class


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value
    description: str = ""  # Brief description of the test method


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions
    description: str = ""  # Brief description of the test configuration


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""
    description: str = ""  # Brief description of the class


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation
    ai_description: str = ""  # AI-generated description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package
    ai_description: str = ""  # AI-generated description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field
    ai_description: str = ""  # AI-generated description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method
    ai_description: str = ""  # AI-generated description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True
    description: str = ""  # Brief description of the logging config


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""
    description: str = ""  # Brief description of the test class


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value
    description: str = ""  # Brief description of the test method


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions
    description: str = ""  # Brief description of the test configuration


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""
    description: str = ""  # Brief description of the class


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation
    ai_description: str = ""  # AI-generated description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package
    ai_description: str = ""  # AI-generated description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field
    ai_description: str = ""  # AI-generated description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method
    ai_description: str = ""  # AI-generated description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call
    ai_description: str = ""  # AI-generated description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True
    description: str = ""  # Brief description of the logging config


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""
    description: str = ""  # Brief description of the test class


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value
    description: str = ""  # Brief description of the test method


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions
    description: str = ""  # Brief description of the test configuration


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""
    description: str = ""  # Brief description of the class


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation
    ai_description: str = ""  # AI-generated description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package
    ai_description: str = ""  # AI-generated description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field
    ai_description: str = ""  # AI-generated description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method
    ai_description: str = ""  # AI-generated description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call
    ai_description: str = ""  # AI-generated description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean
    ai_description: str = ""  # AI-generated description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True
    description: str = ""  # Brief description of the logging config


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""
    description: str = ""  # Brief description of the test class


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value
    description: str = ""  # Brief description of the test method


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions
    description: str = ""  # Brief description of the test configuration


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""
    description: str = ""  # Brief description of the class


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation
    ai_description: str = ""  # AI-generated description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package
    ai_description: str = ""  # AI-generated description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field
    ai_description: str = ""  # AI-generated description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method
    ai_description: str = ""  # AI-generated description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call
    ai_description: str = ""  # AI-generated description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean
    ai_description: str = ""  # AI-generated description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency
    ai_description: str = ""  # AI-generated description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True
    description: str = ""  # Brief description of the logging config


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""
    description: str = ""  # Brief description of the test class


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value
    description: str = ""  # Brief description of the test method


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions
    description: str = ""  # Brief description of the test configuration


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""
    description: str = ""  # Brief description of the class


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation
    ai_description: str = ""  # AI-generated description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package
    ai_description: str = ""  # AI-generated description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field
    ai_description: str = ""  # AI-generated description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method
    ai_description: str = ""  # AI-generated description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call
    ai_description: str = ""  # AI-generated description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean
    ai_description: str = ""  # AI-generated description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency
    ai_description: str = ""  # AI-generated description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint
    ai_description: str = ""  # AI-generated description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True
    description: str = ""  # Brief description of the logging config


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""
    description: str = ""  # Brief description of the test class


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value
    description: str = ""  # Brief description of the test method


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions
    description: str = ""  # Brief description of the test configuration


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""
    description: str = ""  # Brief description of the class


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation
    ai_description: str = ""  # AI-generated description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package
    ai_description: str = ""  # AI-generated description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field
    ai_description: str = ""  # AI-generated description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method
    ai_description: str = ""  # AI-generated description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call
    ai_description: str = ""  # AI-generated description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean
    ai_description: str = ""  # AI-generated description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency
    ai_description: str = ""  # AI-generated description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint
    ai_description: str = ""  # AI-generated description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper
    ai_description: str = ""  # AI-generated description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True
    description: str = ""  # Brief description of the logging config


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""
    description: str = ""  # Brief description of the test class


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value
    description: str = ""  # Brief description of the test method


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions
    description: str = ""  # Brief description of the test configuration


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""
    description: str = ""  # Brief description of the class


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation
    ai_description: str = ""  # AI-generated description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package
    ai_description: str = ""  # AI-generated description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field
    ai_description: str = ""  # AI-generated description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method
    ai_description: str = ""  # AI-generated description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call
    ai_description: str = ""  # AI-generated description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean
    ai_description: str = ""  # AI-generated description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency
    ai_description: str = ""  # AI-generated description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint
    ai_description: str = ""  # AI-generated description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper
    ai_description: str = ""  # AI-generated description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement
    ai_description: str = ""  # AI-generated description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True
    description: str = ""  # Brief description of the logging config


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""
    description: str = ""  # Brief description of the test class


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value
    description: str = ""  # Brief description of the test method


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions
    description: str = ""  # Brief description of the test configuration


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""
    description: str = ""  # Brief description of the class


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation
    ai_description: str = ""  # AI-generated description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package
    ai_description: str = ""  # AI-generated description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field
    ai_description: str = ""  # AI-generated description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method
    ai_description: str = ""  # AI-generated description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call
    ai_description: str = ""  # AI-generated description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean
    ai_description: str = ""  # AI-generated description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency
    ai_description: str = ""  # AI-generated description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint
    ai_description: str = ""  # AI-generated description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper
    ai_description: str = ""  # AI-generated description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement
    ai_description: str = ""  # AI-generated description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement
    ai_description: str = ""  # AI-generated description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True
    description: str = ""  # Brief description of the logging config


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""
    description: str = ""  # Brief description of the test class


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value
    description: str = ""  # Brief description of the test method


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions
    description: str = ""  # Brief description of the test configuration


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""
    description: str = ""  # Brief description of the class


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation
    ai_description: str = ""  # AI-generated description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package
    ai_description: str = ""  # AI-generated description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field
    ai_description: str = ""  # AI-generated description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method
    ai_description: str = ""  # AI-generated description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call
    ai_description: str = ""  # AI-generated description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean
    ai_description: str = ""  # AI-generated description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency
    ai_description: str = ""  # AI-generated description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint
    ai_description: str = ""  # AI-generated description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper
    ai_description: str = ""  # AI-generated description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement
    ai_description: str = ""  # AI-generated description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement
    ai_description: str = ""  # AI-generated description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map
    ai_description: str = ""  # AI-generated description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True
    description: str = ""  # Brief description of the logging config


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""
    description: str = ""  # Brief description of the test class


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value
    description: str = ""  # Brief description of the test method


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions
    description: str = ""  # Brief description of the test configuration


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""
    description: str = ""  # Brief description of the class


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation
    ai_description: str = ""  # AI-generated description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package
    ai_description: str = ""  # AI-generated description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field
    ai_description: str = ""  # AI-generated description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method
    ai_description: str = ""  # AI-generated description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call
    ai_description: str = ""  # AI-generated description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean
    ai_description: str = ""  # AI-generated description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency
    ai_description: str = ""  # AI-generated description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint
    ai_description: str = ""  # AI-generated description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper
    ai_description: str = ""  # AI-generated description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement
    ai_description: str = ""  # AI-generated description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement
    ai_description: str = ""  # AI-generated description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map
    ai_description: str = ""  # AI-generated description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity
    ai_description: str = ""  # AI-generated description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True
    description: str = ""  # Brief description of the logging config


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""
    description: str = ""  # Brief description of the test class


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value
    description: str = ""  # Brief description of the test method


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions
    description: str = ""  # Brief description of the test configuration


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""
    description: str = ""  # Brief description of the class


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation
    ai_description: str = ""  # AI-generated description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package
    ai_description: str = ""  # AI-generated description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field
    ai_description: str = ""  # AI-generated description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method
    ai_description: str = ""  # AI-generated description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call
    ai_description: str = ""  # AI-generated description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean
    ai_description: str = ""  # AI-generated description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency
    ai_description: str = ""  # AI-generated description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint
    ai_description: str = ""  # AI-generated description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper
    ai_description: str = ""  # AI-generated description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement
    ai_description: str = ""  # AI-generated description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement
    ai_description: str = ""  # AI-generated description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map
    ai_description: str = ""  # AI-generated description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity
    ai_description: str = ""  # AI-generated description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column
    ai_description: str = ""  # AI-generated description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True
    description: str = ""  # Brief description of the logging config


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""
    description: str = ""  # Brief description of the test class


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value
    description: str = ""  # Brief description of the test method


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions
    description: str = ""  # Brief description of the test configuration


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""
    description: str = ""  # Brief description of the class


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation
    ai_description: str = ""  # AI-generated description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package
    ai_description: str = ""  # AI-generated description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field
    ai_description: str = ""  # AI-generated description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method
    ai_description: str = ""  # AI-generated description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call
    ai_description: str = ""  # AI-generated description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean
    ai_description: str = ""  # AI-generated description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency
    ai_description: str = ""  # AI-generated description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint
    ai_description: str = ""  # AI-generated description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper
    ai_description: str = ""  # AI-generated description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement
    ai_description: str = ""  # AI-generated description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement
    ai_description: str = ""  # AI-generated description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map
    ai_description: str = ""  # AI-generated description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity
    ai_description: str = ""  # AI-generated description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column
    ai_description: str = ""  # AI-generated description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship
    ai_description: str = ""  # AI-generated description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True
    description: str = ""  # Brief description of the logging config


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""
    description: str = ""  # Brief description of the test class


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value
    description: str = ""  # Brief description of the test method


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions
    description: str = ""  # Brief description of the test configuration


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""
    description: str = ""  # Brief description of the class


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation
    ai_description: str = ""  # AI-generated description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package
    ai_description: str = ""  # AI-generated description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field
    ai_description: str = ""  # AI-generated description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method
    ai_description: str = ""  # AI-generated description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call
    ai_description: str = ""  # AI-generated description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean
    ai_description: str = ""  # AI-generated description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency
    ai_description: str = ""  # AI-generated description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint
    ai_description: str = ""  # AI-generated description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper
    ai_description: str = ""  # AI-generated description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement
    ai_description: str = ""  # AI-generated description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement
    ai_description: str = ""  # AI-generated description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map
    ai_description: str = ""  # AI-generated description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity
    ai_description: str = ""  # AI-generated description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column
    ai_description: str = ""  # AI-generated description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship
    ai_description: str = ""  # AI-generated description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file
    ai_description: str = ""  # AI-generated description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True
    description: str = ""  # Brief description of the logging config


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""
    description: str = ""  # Brief description of the test class


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value
    description: str = ""  # Brief description of the test method


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions
    description: str = ""  # Brief description of the test configuration


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""
    description: str = ""  # Brief description of the class


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation
    ai_description: str = ""  # AI-generated description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package
    ai_description: str = ""  # AI-generated description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field
    ai_description: str = ""  # AI-generated description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method
    ai_description: str = ""  # AI-generated description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call
    ai_description: str = ""  # AI-generated description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean
    ai_description: str = ""  # AI-generated description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency
    ai_description: str = ""  # AI-generated description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint
    ai_description: str = ""  # AI-generated description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper
    ai_description: str = ""  # AI-generated description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement
    ai_description: str = ""  # AI-generated description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement
    ai_description: str = ""  # AI-generated description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map
    ai_description: str = ""  # AI-generated description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity
    ai_description: str = ""  # AI-generated description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column
    ai_description: str = ""  # AI-generated description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship
    ai_description: str = ""  # AI-generated description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file
    ai_description: str = ""  # AI-generated description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config
    ai_description: str = ""  # AI-generated description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True
    description: str = ""  # Brief description of the logging config


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""
    description: str = ""  # Brief description of the test class


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value
    description: str = ""  # Brief description of the test method


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions
    description: str = ""  # Brief description of the test configuration


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""
    description: str = ""  # Brief description of the class


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation
    ai_description: str = ""  # AI-generated description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package
    ai_description: str = ""  # AI-generated description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field
    ai_description: str = ""  # AI-generated description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method
    ai_description: str = ""  # AI-generated description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call
    ai_description: str = ""  # AI-generated description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean
    ai_description: str = ""  # AI-generated description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency
    ai_description: str = ""  # AI-generated description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint
    ai_description: str = ""  # AI-generated description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper
    ai_description: str = ""  # AI-generated description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement
    ai_description: str = ""  # AI-generated description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement
    ai_description: str = ""  # AI-generated description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map
    ai_description: str = ""  # AI-generated description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity
    ai_description: str = ""  # AI-generated description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column
    ai_description: str = ""  # AI-generated description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship
    ai_description: str = ""  # AI-generated description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file
    ai_description: str = ""  # AI-generated description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config
    ai_description: str = ""  # AI-generated description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config
    ai_description: str = ""  # AI-generated description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True
    description: str = ""  # Brief description of the logging config


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""
    description: str = ""  # Brief description of the test class


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value
    description: str = ""  # Brief description of the test method


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions
    description: str = ""  # Brief description of the test configuration


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""
    description: str = ""  # Brief description of the class


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation
    ai_description: str = ""  # AI-generated description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package
    ai_description: str = ""  # AI-generated description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field
    ai_description: str = ""  # AI-generated description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method
    ai_description: str = ""  # AI-generated description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call
    ai_description: str = ""  # AI-generated description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean
    ai_description: str = ""  # AI-generated description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency
    ai_description: str = ""  # AI-generated description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint
    ai_description: str = ""  # AI-generated description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper
    ai_description: str = ""  # AI-generated description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement
    ai_description: str = ""  # AI-generated description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement
    ai_description: str = ""  # AI-generated description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map
    ai_description: str = ""  # AI-generated description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity
    ai_description: str = ""  # AI-generated description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column
    ai_description: str = ""  # AI-generated description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship
    ai_description: str = ""  # AI-generated description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file
    ai_description: str = ""  # AI-generated description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config
    ai_description: str = ""  # AI-generated description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config
    ai_description: str = ""  # AI-generated description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config
    ai_description: str = ""  # AI-generated description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True
    description: str = ""  # Brief description of the logging config


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""
    description: str = ""  # Brief description of the test class


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value
    description: str = ""  # Brief description of the test method


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions
    description: str = ""  # Brief description of the test configuration


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""
    description: str = ""  # Brief description of the class


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation
    ai_description: str = ""  # AI-generated description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package
    ai_description: str = ""  # AI-generated description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field
    ai_description: str = ""  # AI-generated description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method
    ai_description: str = ""  # AI-generated description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call
    ai_description: str = ""  # AI-generated description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean
    ai_description: str = ""  # AI-generated description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency
    ai_description: str = ""  # AI-generated description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint
    ai_description: str = ""  # AI-generated description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper
    ai_description: str = ""  # AI-generated description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement
    ai_description: str = ""  # AI-generated description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement
    ai_description: str = ""  # AI-generated description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map
    ai_description: str = ""  # AI-generated description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity
    ai_description: str = ""  # AI-generated description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column
    ai_description: str = ""  # AI-generated description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship
    ai_description: str = ""  # AI-generated description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file
    ai_description: str = ""  # AI-generated description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config
    ai_description: str = ""  # AI-generated description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config
    ai_description: str = ""  # AI-generated description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config
    ai_description: str = ""  # AI-generated description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True
    description: str = ""  # Brief description of the logging config
    ai_description: str = ""  # AI-generated description of the logging config


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""
    description: str = ""  # Brief description of the test class


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value
    description: str = ""  # Brief description of the test method


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions
    description: str = ""  # Brief description of the test configuration


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""
    description: str = ""  # Brief description of the class


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation
    ai_description: str = ""  # AI-generated description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package
    ai_description: str = ""  # AI-generated description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field
    ai_description: str = ""  # AI-generated description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method
    ai_description: str = ""  # AI-generated description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call
    ai_description: str = ""  # AI-generated description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean
    ai_description: str = ""  # AI-generated description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency
    ai_description: str = ""  # AI-generated description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint
    ai_description: str = ""  # AI-generated description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper
    ai_description: str = ""  # AI-generated description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement
    ai_description: str = ""  # AI-generated description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement
    ai_description: str = ""  # AI-generated description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map
    ai_description: str = ""  # AI-generated description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity
    ai_description: str = ""  # AI-generated description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column
    ai_description: str = ""  # AI-generated description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship
    ai_description: str = ""  # AI-generated description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file
    ai_description: str = ""  # AI-generated description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config
    ai_description: str = ""  # AI-generated description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config
    ai_description: str = ""  # AI-generated description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config
    ai_description: str = ""  # AI-generated description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True
    description: str = ""  # Brief description of the logging config
    ai_description: str = ""  # AI-generated description of the logging config


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""
    description: str = ""  # Brief description of the test class
    ai_description: str = ""  # AI-generated description of the test class


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value
    description: str = ""  # Brief description of the test method


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions
    description: str = ""  # Brief description of the test configuration


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""
    description: str = ""  # Brief description of the class


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation
    ai_description: str = ""  # AI-generated description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package
    ai_description: str = ""  # AI-generated description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field
    ai_description: str = ""  # AI-generated description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method
    ai_description: str = ""  # AI-generated description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call
    ai_description: str = ""  # AI-generated description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean
    ai_description: str = ""  # AI-generated description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency
    ai_description: str = ""  # AI-generated description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint
    ai_description: str = ""  # AI-generated description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper
    ai_description: str = ""  # AI-generated description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement
    ai_description: str = ""  # AI-generated description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement
    ai_description: str = ""  # AI-generated description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map
    ai_description: str = ""  # AI-generated description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity
    ai_description: str = ""  # AI-generated description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column
    ai_description: str = ""  # AI-generated description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship
    ai_description: str = ""  # AI-generated description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file
    ai_description: str = ""  # AI-generated description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config
    ai_description: str = ""  # AI-generated description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config
    ai_description: str = ""  # AI-generated description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config
    ai_description: str = ""  # AI-generated description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True
    description: str = ""  # Brief description of the logging config
    ai_description: str = ""  # AI-generated description of the logging config


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""
    description: str = ""  # Brief description of the test class
    ai_description: str = ""  # AI-generated description of the test class


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value
    description: str = ""  # Brief description of the test method
    ai_description: str = ""  # AI-generated description of the test method


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions
    description: str = ""  # Brief description of the test configuration


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""
    description: str = ""  # Brief description of the class


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation
    ai_description: str = ""  # AI-generated description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package
    ai_description: str = ""  # AI-generated description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field
    ai_description: str = ""  # AI-generated description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method
    ai_description: str = ""  # AI-generated description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call
    ai_description: str = ""  # AI-generated description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean
    ai_description: str = ""  # AI-generated description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency
    ai_description: str = ""  # AI-generated description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint
    ai_description: str = ""  # AI-generated description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper
    ai_description: str = ""  # AI-generated description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement
    ai_description: str = ""  # AI-generated description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement
    ai_description: str = ""  # AI-generated description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map
    ai_description: str = ""  # AI-generated description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity
    ai_description: str = ""  # AI-generated description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column
    ai_description: str = ""  # AI-generated description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship
    ai_description: str = ""  # AI-generated description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file
    ai_description: str = ""  # AI-generated description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config
    ai_description: str = ""  # AI-generated description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config
    ai_description: str = ""  # AI-generated description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config
    ai_description: str = ""  # AI-generated description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True
    description: str = ""  # Brief description of the logging config
    ai_description: str = ""  # AI-generated description of the logging config


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""
    description: str = ""  # Brief description of the test class
    ai_description: str = ""  # AI-generated description of the test class


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value
    description: str = ""  # Brief description of the test method
    ai_description: str = ""  # AI-generated description of the test method


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions
    description: str = ""  # Brief description of the test configuration
    ai_description: str = ""  # AI-generated description of the test configuration


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""
    description: str = ""  # Brief description of the class


```

```python
from pydantic import BaseModel
from typing import Literal, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from typing import List


class Annotation(BaseModel):
    """Represents a Java annotation."""
    
    name: str
    parameters: dict[str, Any] = {}
    target_type: str = "class"  # "class", "method", "field"
    category: str = "other"  # "component", "injection", "web", "jpa", "test", "security", "validation", "other"
    description: str = ""  # Brief description of the annotation
    ai_description: str = ""  # AI-generated description of the annotation


class Package(BaseModel):
    """Represents a Java package."""

    name: str
    logical_name: str = ""
    description: str = ""  # Brief description of the package
    ai_description: str = ""  # AI-generated description of the package


class Field(BaseModel):
    """Represents a field or property within a class."""

    name: str
    logical_name: str = ""
    type: str
    modifiers: list[str] = []
    package_name: str = ""
    class_name: str = ""
    annotations: list[Annotation] = []
    initial_value: str = ""  # Initial value of the field
    description: str = ""  # Brief description of the field
    ai_description: str = ""  # AI-generated description of the field


class Method(BaseModel):
    """Represents a method within a class."""

    name: str
    logical_name: str = ""
    return_type: str
    parameters: list[Field] = []
    modifiers: list[str] = []
    source: str = ""
    package_name: str = ""
    annotations: list[Annotation] = []
    description: str = ""  # Brief description of the method
    ai_description: str = ""  # AI-generated description of the method


class MethodCall(BaseModel):
    """Represents a method call from one method to another."""

    source_package: str
    source_class: str
    source_method: str
    target_package: str
    target_class: str
    target_method: str
    call_order: int = 0  # 순서 정보 (0부터 시작)
    line_number: int = 0  # 소스 코드에서의 라인 번호
    return_type: str = "void"  # 피호출 메서드의 return type
    description: str = ""  # Brief description of the method call
    ai_description: str = ""  # AI-generated description of the method call

    def dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            "source_package": self.source_package,
            "source_class": self.source_class,
            "source_method": self.source_method,
            "target_package": self.target_package,
            "target_class": self.target_class,
            "target_method": self.target_method,
            "call_order": self.call_order,
            "line_number": self.line_number,
            "return_type": self.return_type
        }


class Bean(BaseModel):
    """Represents a Spring Bean."""
    
    name: str
    type: str  # "component", "service", "repository", "controller", "configuration"
    scope: str  # "singleton", "prototype", "request", "session"
    class_name: str
    package_name: str = ""
    annotation_names: list[str] = []  # Just store annotation names
    method_count: int = 0  # Number of methods
    property_count: int = 0  # Number of properties
    description: str = ""  # Brief description of the bean
    ai_description: str = ""  # AI-generated description of the bean


class BeanDependency(BaseModel):
    """Represents a dependency between Spring Beans."""
    
    source_bean: str
    target_bean: str
    injection_type: str  # "field", "constructor", "setter"
    field_name: str = ""
    method_name: str = ""
    parameter_name: str = ""
    description: str = ""  # Brief description of the dependency
    ai_description: str = ""  # AI-generated description of the dependency


class Endpoint(BaseModel):
    """Represents a REST API endpoint."""
    
    path: str
    method: str  # "GET", "POST", "PUT", "DELETE", "PATCH"
    controller_class: str
    handler_method: str
    parameters: list[dict] = []  # Request parameters
    return_type: str = ""
    annotations: list[str] = []  # Web annotations on the method
    full_path: str = ""  # Complete URL path including class-level mapping
    description: str = ""  # Brief description of the endpoint
    ai_description: str = ""  # AI-generated description of the endpoint


class MyBatisMapper(BaseModel):
    """Represents a MyBatis Mapper interface or XML file."""
    
    name: str
    type: str  # "interface", "xml"
    namespace: str = ""
    methods: list[dict] = []  # Mapper methods
    sql_statements: list[dict] = []  # SQL statements
    file_path: str = ""
    package_name: str = ""
    description: str = ""  # Brief description of the mapper
    ai_description: str = ""  # AI-generated description of the mapper


class MyBatisSqlStatement(BaseModel):
    """Represents a MyBatis SQL statement."""
    
    id: str  # Method name or statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[str] = []  # MyBatis annotations
    description: str = ""  # Brief description of the SQL statement
    ai_description: str = ""  # AI-generated description of the SQL statement


class SqlStatement(BaseModel):
    """Represents a SQL statement node in the graph database."""
    
    id: str  # Statement ID
    sql_type: str  # "SELECT", "INSERT", "UPDATE", "DELETE"
    sql_content: str = ""
    parameter_type: str = ""
    result_type: str = ""
    result_map: str = ""
    mapper_name: str = ""
    annotations: list[Annotation] = []  # MyBatis annotations as Annotation objects
    project_name: str = ""
    description: str = ""  # Brief description of the SQL statement
    ai_description: str = ""  # AI-generated description of the SQL statement


class MyBatisResultMap(BaseModel):
    """Represents a MyBatis ResultMap."""
    
    id: str
    type: str
    properties: list[dict] = []  # Property mappings
    associations: list[dict] = []  # Association mappings
    collections: list[dict] = []  # Collection mappings
    mapper_name: str = ""
    description: str = ""  # Brief description of the result map
    ai_description: str = ""  # AI-generated description of the result map


class JpaEntity(BaseModel):
    """Represents a JPA Entity."""
    
    name: str
    table_name: str = ""
    columns: list[dict] = []  # Column mappings
    relationships: list[dict] = []  # Entity relationships
    annotations: list[str] = []  # JPA annotations
    package_name: str = ""
    file_path: str = ""
    description: str = ""  # Brief description of the entity
    ai_description: str = ""  # AI-generated description of the entity


class JpaColumn(BaseModel):
    """Represents a JPA Column mapping."""
    
    property_name: str
    column_name: str = ""
    data_type: str = ""
    nullable: bool = True
    unique: bool = False
    length: int = 0
    precision: int = 0
    scale: int = 0
    annotations: list[str] = []  # Column annotations
    description: str = ""  # Brief description of the column
    ai_description: str = ""  # AI-generated description of the column


class JpaRelationship(BaseModel):
    """Represents a JPA Entity relationship."""
    
    type: str  # "OneToOne", "OneToMany", "ManyToOne", "ManyToMany"
    target_entity: str = ""
    mapped_by: str = ""
    join_column: str = ""
    join_table: str = ""
    cascade: list[str] = []  # Cascade types
    fetch: str = "LAZY"  # Fetch type
    annotations: list[str] = []  # Relationship annotations
    description: str = ""  # Brief description of the relationship
    ai_description: str = ""  # AI-generated description of the relationship


class ConfigFile(BaseModel):
    """Represents a configuration file."""
    
    name: str
    file_path: str
    file_type: str  # "yaml", "yml", "properties"
    properties: dict[str, Any] = {}
    sections: list[dict] = []  # Configuration sections
    profiles: list[str] = []  # Active profiles
    environment: str = ""  # Environment (dev, prod, test)
    description: str = ""  # Brief description of the config file
    ai_description: str = ""  # AI-generated description of the config file


class DatabaseConfig(BaseModel):
    """Represents database configuration."""
    
    driver: str = ""
    url: str = ""
    username: str = ""
    password: str = ""
    dialect: str = ""
    hibernate_ddl_auto: str = ""
    show_sql: bool = False
    format_sql: bool = False
    jpa_properties: dict[str, Any] = {}
    description: str = ""  # Brief description of the database config
    ai_description: str = ""  # AI-generated description of the database config


class ServerConfig(BaseModel):
    """Represents server configuration."""
    
    port: int = 8080
    context_path: str = ""
    servlet_path: str = ""
    ssl_enabled: bool = False
    ssl_key_store: str = ""
    ssl_key_store_password: str = ""
    ssl_key_store_type: str = ""
    description: str = ""  # Brief description of the server config
    ai_description: str = ""  # AI-generated description of the server config


class SecurityConfig(BaseModel):
    """Represents security configuration."""
    
    enabled: bool = False
    authentication_type: str = ""  # "jwt", "session", "oauth2"
    jwt_secret: str = ""
    jwt_expiration: int = 0
    cors_allowed_origins: list[str] = []
    cors_allowed_methods: list[str] = []
    cors_allowed_headers: list[str] = []
    description: str = ""  # Brief description of the security config
    ai_description: str = ""  # AI-generated description of the security config


class LoggingConfig(BaseModel):
    """Represents logging configuration."""
    
    level: str = "INFO"
    pattern: str = ""
    file_path: str = ""
    max_file_size: str = ""
    max_history: int = 0
    console_output: bool = True
    description: str = ""  # Brief description of the logging config
    ai_description: str = ""  # AI-generated description of the logging config


class TestClass(BaseModel):
    """Represents a test class."""
    
    name: str
    package_name: str = ""
    test_framework: str = ""  # "junit", "testng", "spock"
    test_type: str = ""  # "unit", "integration", "end-to-end"
    annotations: list[str] = []  # Test annotations
    test_methods: list[dict] = []  # Test methods
    setup_methods: list[dict] = []  # Setup/teardown methods
    mock_dependencies: list[dict] = []  # Mocked dependencies
    test_configurations: list[dict] = []  # Test configurations
    file_path: str = ""
    description: str = ""  # Brief description of the test class
    ai_description: str = ""  # AI-generated description of the test class


class TestMethod(BaseModel):
    """Represents a test method."""
    
    name: str
    return_type: str = "void"
    annotations: list[str] = []  # Test method annotations
    assertions: list[dict] = []  # Assertions in the test
    mock_calls: list[dict] = []  # Mock method calls
    test_data: list[dict] = []  # Test data setup
    expected_exceptions: list[str] = []  # Expected exceptions
    timeout: int = 0  # Test timeout
    display_name: str = ""  # @DisplayName value
    description: str = ""  # Brief description of the test method
    ai_description: str = ""  # AI-generated description of the test method


class TestConfiguration(BaseModel):
    """Represents test configuration."""
    
    name: str
    type: str = ""  # "configuration", "profile", "property"
    properties: dict[str, Any] = {}
    active_profiles: list[str] = []
    test_slices: list[str] = []  # @WebMvcTest, @DataJpaTest, etc.
    mock_beans: list[dict] = []  # @MockBean definitions
    spy_beans: list[dict] = []  # @SpyBean definitions
    description: str = ""  # Brief description of the test configuration
    ai_description: str = ""  # AI-generated description of the test configuration


class Class(BaseModel):
    """Represents a Java class with its methods, properties, and relationships."""

    name: str
    logical_name: str = ""
    file_path: str
    type: Literal["class", "interface", "enum"] = "class"
    methods: list[Method] = []
    properties: list[Field] = []
    calls: list[MethodCall] = []
    source: str = ""
    superclass: str | None = None
    interfaces: list[str] = []
    imports: list[str] = []
    annotations: list[Annotation] = []
    package_name: str = ""
    description: str = ""  # Brief description of the class
    ai_description: str = ""  # AI-generated description of the class


```

이제 모델 클래스에 ai_description 속성 추가가 완료되었습니다.


이제 데이터베이스 스키마에 ai_description 속성을 추가하겠습니다.


```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description, p.ai_description = $ai_description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description"  # Add project_name and description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description " # Add description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description " # Add description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path,
            description=entity.description or ""
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment, "
            "c.description = $description"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment,
            description=config_file.description or ""
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name, "
            "t.description = $description"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name,
            description=test_class.description or ""
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name, s.description = $description"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name,
            description=sql_statement.description or ""
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description, p.ai_description = $ai_description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
            ai_description=package_node.ai_description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description"  # Add project_name and description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description " # Add description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description " # Add description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path,
            description=entity.description or ""
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment, "
            "c.description = $description"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment,
            description=config_file.description or ""
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name, "
            "t.description = $description"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name,
            description=test_class.description or ""
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name, s.description = $description"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name,
            description=sql_statement.description or ""
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description, p.ai_description = $ai_description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
            ai_description=package_node.ai_description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description, c.ai_description = $ai_description"  # Add project_name, description and ai_description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description " # Add description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description " # Add description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path,
            description=entity.description or ""
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment, "
            "c.description = $description"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment,
            description=config_file.description or ""
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name, "
            "t.description = $description"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name,
            description=test_class.description or ""
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name, s.description = $description"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name,
            description=sql_statement.description or ""
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description, p.ai_description = $ai_description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
            ai_description=package_node.ai_description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description, c.ai_description = $ai_description"  # Add project_name, description and ai_description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
            ai_description=class_node.ai_description or "",  # Add ai_description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description " # Add description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description " # Add description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path,
            description=entity.description or ""
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment, "
            "c.description = $description"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment,
            description=config_file.description or ""
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name, "
            "t.description = $description"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name,
            description=test_class.description or ""
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name, s.description = $description"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name,
            description=sql_statement.description or ""
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description, p.ai_description = $ai_description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
            ai_description=package_node.ai_description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description, c.ai_description = $ai_description"  # Add project_name, description and ai_description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
            ai_description=class_node.ai_description or "",  # Add ai_description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description, " # Add description
                "m.ai_description = $ai_description " # Add ai_description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description " # Add description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path,
            description=entity.description or ""
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment, "
            "c.description = $description"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment,
            description=config_file.description or ""
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name, "
            "t.description = $description"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name,
            description=test_class.description or ""
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name, s.description = $description"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name,
            description=sql_statement.description or ""
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description, p.ai_description = $ai_description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
            ai_description=package_node.ai_description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description, c.ai_description = $ai_description"  # Add project_name, description and ai_description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
            ai_description=class_node.ai_description or "",  # Add ai_description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description, " # Add description
                "m.ai_description = $ai_description " # Add ai_description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
                ai_description=method.ai_description or "", # Add ai_description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description " # Add description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path,
            description=entity.description or ""
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment, "
            "c.description = $description"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment,
            description=config_file.description or ""
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name, "
            "t.description = $description"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name,
            description=test_class.description or ""
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name, s.description = $description"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name,
            description=sql_statement.description or ""
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description, p.ai_description = $ai_description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
            ai_description=package_node.ai_description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description, c.ai_description = $ai_description"  # Add project_name, description and ai_description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
            ai_description=class_node.ai_description or "",  # Add ai_description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description, " # Add description
                "m.ai_description = $ai_description " # Add ai_description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
                ai_description=method.ai_description or "", # Add ai_description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description, " # Add description
                "p.ai_description = $prop_ai_description " # Add ai_description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path,
            description=entity.description or ""
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment, "
            "c.description = $description"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment,
            description=config_file.description or ""
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name, "
            "t.description = $description"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name,
            description=test_class.description or ""
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name, s.description = $description"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name,
            description=sql_statement.description or ""
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description, p.ai_description = $ai_description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
            ai_description=package_node.ai_description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description, c.ai_description = $ai_description"  # Add project_name, description and ai_description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
            ai_description=class_node.ai_description or "",  # Add ai_description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description, " # Add description
                "m.ai_description = $ai_description " # Add ai_description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
                ai_description=method.ai_description or "", # Add ai_description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description, " # Add description
                "p.ai_description = $prop_ai_description " # Add ai_description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
                prop_ai_description=prop.ai_description or "", # Add ai_description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path,
            description=entity.description or ""
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment, "
            "c.description = $description"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment,
            description=config_file.description or ""
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name, "
            "t.description = $description"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name,
            description=test_class.description or ""
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name, s.description = $description"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name,
            description=sql_statement.description or ""
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

이제 다른 주요 노드들에도 ai_description을 추가하겠습니다.


```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description, p.ai_description = $ai_description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
            ai_description=package_node.ai_description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description, c.ai_description = $ai_description"  # Add project_name, description and ai_description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
            ai_description=class_node.ai_description or "",  # Add ai_description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description, " # Add description
                "m.ai_description = $ai_description " # Add ai_description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
                ai_description=method.ai_description or "", # Add ai_description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description, " # Add description
                "p.ai_description = $prop_ai_description " # Add ai_description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
                prop_ai_description=prop.ai_description or "", # Add ai_description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description, b.ai_description = $ai_description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path,
            description=entity.description or ""
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment, "
            "c.description = $description"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment,
            description=config_file.description or ""
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name, "
            "t.description = $description"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name,
            description=test_class.description or ""
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name, s.description = $description"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name,
            description=sql_statement.description or ""
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description, p.ai_description = $ai_description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
            ai_description=package_node.ai_description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description, c.ai_description = $ai_description"  # Add project_name, description and ai_description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
            ai_description=class_node.ai_description or "",  # Add ai_description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description, " # Add description
                "m.ai_description = $ai_description " # Add ai_description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
                ai_description=method.ai_description or "", # Add ai_description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description, " # Add description
                "p.ai_description = $prop_ai_description " # Add ai_description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
                prop_ai_description=prop.ai_description or "", # Add ai_description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description, b.ai_description = $ai_description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or "",
            ai_description=bean.ai_description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path,
            description=entity.description or ""
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment, "
            "c.description = $description"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment,
            description=config_file.description or ""
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name, "
            "t.description = $description"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name,
            description=test_class.description or ""
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name, s.description = $description"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name,
            description=sql_statement.description or ""
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

이제 나머지 주요 노드들에도 ai_description을 추가하겠습니다.


```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description, p.ai_description = $ai_description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
            ai_description=package_node.ai_description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description, c.ai_description = $ai_description"  # Add project_name, description and ai_description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
            ai_description=class_node.ai_description or "",  # Add ai_description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description, " # Add description
                "m.ai_description = $ai_description " # Add ai_description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
                ai_description=method.ai_description or "", # Add ai_description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description, " # Add description
                "p.ai_description = $prop_ai_description " # Add ai_description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
                prop_ai_description=prop.ai_description or "", # Add ai_description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description, b.ai_description = $ai_description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or "",
            ai_description=bean.ai_description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description, e.ai_description = $ai_description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path,
            description=entity.description or ""
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment, "
            "c.description = $description"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment,
            description=config_file.description or ""
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name, "
            "t.description = $description"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name,
            description=test_class.description or ""
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name, s.description = $description"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name,
            description=sql_statement.description or ""
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description, p.ai_description = $ai_description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
            ai_description=package_node.ai_description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description, c.ai_description = $ai_description"  # Add project_name, description and ai_description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
            ai_description=class_node.ai_description or "",  # Add ai_description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description, " # Add description
                "m.ai_description = $ai_description " # Add ai_description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
                ai_description=method.ai_description or "", # Add ai_description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description, " # Add description
                "p.ai_description = $prop_ai_description " # Add ai_description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
                prop_ai_description=prop.ai_description or "", # Add ai_description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description, b.ai_description = $ai_description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or "",
            ai_description=bean.ai_description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description, e.ai_description = $ai_description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or "",
            ai_description=endpoint.ai_description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path,
            description=entity.description or ""
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment, "
            "c.description = $description"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment,
            description=config_file.description or ""
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name, "
            "t.description = $description"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name,
            description=test_class.description or ""
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name, s.description = $description"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name,
            description=sql_statement.description or ""
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

이제 나머지 노드들에도 ai_description을 추가하겠습니다.


```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description, p.ai_description = $ai_description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
            ai_description=package_node.ai_description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description, c.ai_description = $ai_description"  # Add project_name, description and ai_description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
            ai_description=class_node.ai_description or "",  # Add ai_description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description, " # Add description
                "m.ai_description = $ai_description " # Add ai_description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
                ai_description=method.ai_description or "", # Add ai_description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description, " # Add description
                "p.ai_description = $prop_ai_description " # Add ai_description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
                prop_ai_description=prop.ai_description or "", # Add ai_description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description, b.ai_description = $ai_description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or "",
            ai_description=bean.ai_description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description, e.ai_description = $ai_description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or "",
            ai_description=endpoint.ai_description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description, m.ai_description = $ai_description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path,
            description=entity.description or ""
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment, "
            "c.description = $description"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment,
            description=config_file.description or ""
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name, "
            "t.description = $description"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name,
            description=test_class.description or ""
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name, s.description = $description"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name,
            description=sql_statement.description or ""
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description, p.ai_description = $ai_description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
            ai_description=package_node.ai_description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description, c.ai_description = $ai_description"  # Add project_name, description and ai_description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
            ai_description=class_node.ai_description or "",  # Add ai_description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description, " # Add description
                "m.ai_description = $ai_description " # Add ai_description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
                ai_description=method.ai_description or "", # Add ai_description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description, " # Add description
                "p.ai_description = $prop_ai_description " # Add ai_description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
                prop_ai_description=prop.ai_description or "", # Add ai_description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description, b.ai_description = $ai_description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or "",
            ai_description=bean.ai_description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description, e.ai_description = $ai_description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or "",
            ai_description=endpoint.ai_description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description, m.ai_description = $ai_description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or "",
            ai_description=mapper.ai_description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path,
            description=entity.description or ""
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment, "
            "c.description = $description"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment,
            description=config_file.description or ""
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name, "
            "t.description = $description"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name,
            description=test_class.description or ""
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name, s.description = $description"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name,
            description=sql_statement.description or ""
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

이제 나머지 노드들도 계속 업데이트하겠습니다.


```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description, p.ai_description = $ai_description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
            ai_description=package_node.ai_description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description, c.ai_description = $ai_description"  # Add project_name, description and ai_description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
            ai_description=class_node.ai_description or "",  # Add ai_description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description, " # Add description
                "m.ai_description = $ai_description " # Add ai_description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
                ai_description=method.ai_description or "", # Add ai_description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description, " # Add description
                "p.ai_description = $prop_ai_description " # Add ai_description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
                prop_ai_description=prop.ai_description or "", # Add ai_description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description, b.ai_description = $ai_description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or "",
            ai_description=bean.ai_description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description, e.ai_description = $ai_description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or "",
            ai_description=endpoint.ai_description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description, m.ai_description = $ai_description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or "",
            ai_description=mapper.ai_description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description, e.ai_description = $ai_description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path,
            description=entity.description or ""
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment, "
            "c.description = $description"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment,
            description=config_file.description or ""
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name, "
            "t.description = $description"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name,
            description=test_class.description or ""
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name, s.description = $description"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name,
            description=sql_statement.description or ""
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description, p.ai_description = $ai_description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
            ai_description=package_node.ai_description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description, c.ai_description = $ai_description"  # Add project_name, description and ai_description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
            ai_description=class_node.ai_description or "",  # Add ai_description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description, " # Add description
                "m.ai_description = $ai_description " # Add ai_description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
                ai_description=method.ai_description or "", # Add ai_description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description, " # Add description
                "p.ai_description = $prop_ai_description " # Add ai_description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
                prop_ai_description=prop.ai_description or "", # Add ai_description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description, b.ai_description = $ai_description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or "",
            ai_description=bean.ai_description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description, e.ai_description = $ai_description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or "",
            ai_description=endpoint.ai_description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description, m.ai_description = $ai_description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or "",
            ai_description=mapper.ai_description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description, e.ai_description = $ai_description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path,
            description=entity.description or "",
            ai_description=entity.ai_description or ""
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment, "
            "c.description = $description"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment,
            description=config_file.description or ""
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name, "
            "t.description = $description"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name,
            description=test_class.description or ""
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name, s.description = $description"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name,
            description=sql_statement.description or ""
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description, p.ai_description = $ai_description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
            ai_description=package_node.ai_description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description, c.ai_description = $ai_description"  # Add project_name, description and ai_description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
            ai_description=class_node.ai_description or "",  # Add ai_description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description, " # Add description
                "m.ai_description = $ai_description " # Add ai_description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
                ai_description=method.ai_description or "", # Add ai_description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description, " # Add description
                "p.ai_description = $prop_ai_description " # Add ai_description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
                prop_ai_description=prop.ai_description or "", # Add ai_description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description, b.ai_description = $ai_description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or "",
            ai_description=bean.ai_description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description, e.ai_description = $ai_description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or "",
            ai_description=endpoint.ai_description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description, m.ai_description = $ai_description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or "",
            ai_description=mapper.ai_description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description, e.ai_description = $ai_description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path,
            description=entity.description or "",
            ai_description=entity.ai_description or ""
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment, "
            "c.description = $description, c.ai_description = $ai_description"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment,
            description=config_file.description or ""
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name, "
            "t.description = $description"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name,
            description=test_class.description or ""
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name, s.description = $description"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name,
            description=sql_statement.description or ""
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description, p.ai_description = $ai_description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
            ai_description=package_node.ai_description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description, c.ai_description = $ai_description"  # Add project_name, description and ai_description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
            ai_description=class_node.ai_description or "",  # Add ai_description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description, " # Add description
                "m.ai_description = $ai_description " # Add ai_description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
                ai_description=method.ai_description or "", # Add ai_description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description, " # Add description
                "p.ai_description = $prop_ai_description " # Add ai_description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
                prop_ai_description=prop.ai_description or "", # Add ai_description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description, b.ai_description = $ai_description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or "",
            ai_description=bean.ai_description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description, e.ai_description = $ai_description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or "",
            ai_description=endpoint.ai_description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description, m.ai_description = $ai_description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or "",
            ai_description=mapper.ai_description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description, e.ai_description = $ai_description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path,
            description=entity.description or "",
            ai_description=entity.ai_description or ""
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment, "
            "c.description = $description, c.ai_description = $ai_description"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment,
            description=config_file.description or "",
            ai_description=config_file.ai_description or ""
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name, "
            "t.description = $description"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name,
            description=test_class.description or ""
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name, s.description = $description"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name,
            description=sql_statement.description or ""
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description, p.ai_description = $ai_description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
            ai_description=package_node.ai_description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description, c.ai_description = $ai_description"  # Add project_name, description and ai_description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
            ai_description=class_node.ai_description or "",  # Add ai_description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description, " # Add description
                "m.ai_description = $ai_description " # Add ai_description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
                ai_description=method.ai_description or "", # Add ai_description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description, " # Add description
                "p.ai_description = $prop_ai_description " # Add ai_description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
                prop_ai_description=prop.ai_description or "", # Add ai_description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description, b.ai_description = $ai_description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or "",
            ai_description=bean.ai_description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description, e.ai_description = $ai_description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or "",
            ai_description=endpoint.ai_description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description, m.ai_description = $ai_description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or "",
            ai_description=mapper.ai_description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description, e.ai_description = $ai_description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path,
            description=entity.description or "",
            ai_description=entity.ai_description or ""
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment, "
            "c.description = $description, c.ai_description = $ai_description"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment,
            description=config_file.description or "",
            ai_description=config_file.ai_description or ""
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name, "
            "t.description = $description, t.ai_description = $ai_description"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name,
            description=test_class.description or ""
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name, s.description = $description"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name,
            description=sql_statement.description or ""
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description, p.ai_description = $ai_description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
            ai_description=package_node.ai_description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description, c.ai_description = $ai_description"  # Add project_name, description and ai_description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
            ai_description=class_node.ai_description or "",  # Add ai_description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description, " # Add description
                "m.ai_description = $ai_description " # Add ai_description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
                ai_description=method.ai_description or "", # Add ai_description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description, " # Add description
                "p.ai_description = $prop_ai_description " # Add ai_description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
                prop_ai_description=prop.ai_description or "", # Add ai_description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description, b.ai_description = $ai_description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or "",
            ai_description=bean.ai_description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description, e.ai_description = $ai_description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or "",
            ai_description=endpoint.ai_description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description, m.ai_description = $ai_description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or "",
            ai_description=mapper.ai_description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description, e.ai_description = $ai_description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path,
            description=entity.description or "",
            ai_description=entity.ai_description or ""
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment, "
            "c.description = $description, c.ai_description = $ai_description"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment,
            description=config_file.description or "",
            ai_description=config_file.ai_description or ""
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name, "
            "t.description = $description, t.ai_description = $ai_description"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name,
            description=test_class.description or "",
            ai_description=test_class.ai_description or ""
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name, s.description = $description"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name,
            description=sql_statement.description or ""
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description, p.ai_description = $ai_description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
            ai_description=package_node.ai_description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description, c.ai_description = $ai_description"  # Add project_name, description and ai_description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
            ai_description=class_node.ai_description or "",  # Add ai_description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description, " # Add description
                "m.ai_description = $ai_description " # Add ai_description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
                ai_description=method.ai_description or "", # Add ai_description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description, " # Add description
                "p.ai_description = $prop_ai_description " # Add ai_description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
                prop_ai_description=prop.ai_description or "", # Add ai_description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description, b.ai_description = $ai_description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or "",
            ai_description=bean.ai_description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description, e.ai_description = $ai_description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or "",
            ai_description=endpoint.ai_description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description, m.ai_description = $ai_description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or "",
            ai_description=mapper.ai_description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description, e.ai_description = $ai_description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path,
            description=entity.description or "",
            ai_description=entity.ai_description or ""
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment, "
            "c.description = $description, c.ai_description = $ai_description"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment,
            description=config_file.description or "",
            ai_description=config_file.ai_description or ""
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name, "
            "t.description = $description, t.ai_description = $ai_description"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name,
            description=test_class.description or "",
            ai_description=test_class.ai_description or ""
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name, s.description = $description, s.ai_description = $ai_description"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name,
            description=sql_statement.description or ""
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

```python
import json

from neo4j import Driver, GraphDatabase

from src.models.graph_entities import Class, Package, Bean, BeanDependency, Endpoint, MyBatisMapper, SqlStatement, JpaEntity, ConfigFile, TestClass
from src.utils.logger import get_logger


class GraphDB:
    """A service for interacting with the Neo4j database."""

    def __init__(self, uri, user, password):
        """Initializes the database driver."""
        self._driver: Driver = GraphDatabase.driver(uri, auth=(user, password))
        self.logger = get_logger(__name__)

    def close(self):
        """Closes the database connection."""
        self._driver.close()

    def add_package(self, package_node: Package, project_name: str):
        """Adds a package to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_package_node_tx, package_node, project_name)

    def add_class(self, class_node: Class, package_name: str, project_name: str):
        """Adds a class and its relationships to the database
        in a single transaction."""
        with self._driver.session() as session:
            session.execute_write(self._create_class_node_tx, class_node, package_name, project_name)

    @staticmethod
    def _create_package_node_tx(tx, package_node: Package, project_name: str):
        """A transaction function to create a package node."""
        package_query = (
            "MERGE (p:Package {name: $name}) "
            "SET p.project_name = $project_name, p.description = $description, p.ai_description = $ai_description"
        )
        tx.run(
            package_query,
            name=package_node.name,
            project_name=project_name,
            description=package_node.description or "",
            ai_description=package_node.ai_description or "",
        )

    @staticmethod
    def _create_class_node_tx(tx, class_node: Class, package_name: str, project_name: str):
        """A transaction function to create a class, its properties,
        and its method calls."""
        # Create or merge the class node itself
        class_query = (
            "MERGE (c:Class {name: $name}) "
            "SET c.file_path = $file_path, c.type = $type, "
            "c.source = $source, c.logical_name = $logical_name, "
            "c.superclass = $superclass, c.interfaces = $interfaces, "
            "c.imports = $imports, c.package_name = $package_name, "
            "c.project_name = $project_name, c.description = $description, c.ai_description = $ai_description"  # Add project_name, description and ai_description
        )
        tx.run(
            class_query,
            name=class_node.name,
            file_path=class_node.file_path,
            type=class_node.type,
            source=class_node.source,
            logical_name=class_node.logical_name,
            superclass=class_node.superclass,
            interfaces=class_node.interfaces,
            imports=class_node.imports,
            package_name=package_name,  # Add package_name
            project_name=project_name,  # Add project_name
            description=class_node.description or "",  # Add description
            ai_description=class_node.ai_description or "",  # Add ai_description
        ) # Pass all class properties

        # Create relationship between package and class
        if package_name:
            package_class_query = (
                "MATCH (p:Package {name: $package_name}) "
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p)-[:CONTAINS]->(c)"
            )
            tx.run(
                package_class_query,
                package_name=package_name,
                class_name=class_node.name,
            )

        # --- Start of new inheritance relationships logic ---
        # Create EXTENDS relationship
        if class_node.superclass:
            # Split superclass into name and package
            # Assuming superclass is fully qualified or in the same package
            if '.' in class_node.superclass:
                superclass_package = ".".join(class_node.superclass.split('.')[:-1])
                superclass_name = class_node.superclass.split('.')[-1]
            else:
                superclass_package = package_name # Assume same package
                superclass_name = class_node.superclass

            extends_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (s:Class {name: $superclass_name}) "
                "MERGE (c)-[:EXTENDS]->(s)"
            )
            tx.run(
                extends_query,
                class_name=class_node.name,
                superclass_name=superclass_name,
            )

        # Create IMPLEMENTS relationships
        for interface_fqn in class_node.interfaces:
            # Split interface FQN into name and package
            if '.' in interface_fqn:
                interface_package = ".".join(interface_fqn.split('.')[:-1])
                interface_name = interface_fqn.split('.')[-1]
            else:
                interface_package = package_name # Assume same package
                interface_name = interface_fqn

            implements_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $interface_name}) "
                "MERGE (c)-[:IMPLEMENTS]->(i)"
            )
            tx.run(
                implements_query,
                class_name=class_node.name,
                interface_name=interface_name,
            )
        # --- End of new inheritance relationships logic ---

        # --- Start of new import relationships logic ---
        for imported_class_fqn in class_node.imports:
            # Split imported class FQN into name and package
            if '.' in imported_class_fqn:
                imported_class_package = ".".join(imported_class_fqn.split('.')[:-1])
                imported_class_name = imported_class_fqn.split('.')[-1]
            else:
                # This case should ideally not happen for imports, but for robustness
                imported_class_package = "" # Or some default/error handling
                imported_class_name = imported_class_fqn

            # Exclude java.io classes from being imported as nodes
            if imported_class_package.startswith("java.io"):
                continue

            imports_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (i:Class {name: $imported_class_name}) "
                "MERGE (c)-[:IMPORTS]->(i)"
            )
            tx.run(
                imports_query,
                class_name=class_node.name,
                imported_class_name=imported_class_name,
            )
        # --- End of new import relationships logic ---

        # --- Start of new method relationships logic ---
        for method in class_node.methods:
            # Serialize parameters to JSON string
            parameters_json = json.dumps([p.dict() for p in method.parameters])
            # Serialize modifiers to JSON string
            modifiers_json = json.dumps(method.modifiers)
            # Serialize annotations to JSON string
            annotations_json = json.dumps([a.dict() for a in method.annotations])

            method_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (m:Method {name: $method_name, class_name: $class_name}) " # Unique identifier for method
                "SET m.logical_name = $logical_name, "
                "m.return_type = $return_type, "
                "m.parameters_json = $parameters_json, "
                "m.modifiers_json = $modifiers_json, "
                "m.annotations_json = $annotations_json, "
                "m.source = $source, " # Add m.source
                "m.package_name = $package_name, " # Add package_name
                "m.project_name = $project_name, " # Add project_name
                "m.description = $description, " # Add description
                "m.ai_description = $ai_description " # Add ai_description
                "MERGE (c)-[:HAS_METHOD]->(m)"
            )
            # Debug logging
            logger = get_logger(__name__)
            logger.debug(f"Method {method.name} - logical_name: {method.logical_name}, return_type: {method.return_type}, package_name: {method.package_name}")
            
            tx.run(
                method_query,
                class_name=class_node.name,
                method_name=method.name,
                logical_name=method.logical_name or "", # Handle None values
                return_type=method.return_type or "void", # Handle None values
                parameters_json=parameters_json,
                modifiers_json=modifiers_json,
                annotations_json=annotations_json,
                source=method.source or "", # Handle None values
                package_name=method.package_name or "", # Handle None values
                project_name=project_name, # Add project_name
                description=method.description or "", # Add description
                ai_description=method.ai_description or "", # Add ai_description
            ) # Pass all method properties
        # --- End of new method relationships logic ---

        # Create properties and relationships
        for prop in class_node.properties:
            # Serialize modifiers to JSON string
            prop_modifiers_json = json.dumps(prop.modifiers)
            # Serialize annotations to JSON string
            prop_annotations_json = json.dumps([a.dict() for a in prop.annotations])
            
            prop_query = (
                "MATCH (c:Class {name: $class_name}) "
                "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
                "SET p.type = $prop_type, "
                "p.logical_name = $prop_logical_name, " # Add logical_name
                "p.modifiers_json = $prop_modifiers_json, " # Set modifiers as JSON
                "p.annotations_json = $prop_annotations_json, " # Set annotations as JSON
                "p.initial_value = $prop_initial_value, " # Set initial value
                "p.package_name = $package_name, " # Add package_name
                "p.project_name = $project_name, " # Add project_name
                "p.description = $prop_description, " # Add description
                "p.ai_description = $prop_ai_description " # Add ai_description
                "MERGE (c)-[:HAS_FIELD]->(p)"
            )
            tx.run(
                prop_query,
                class_name=class_node.name,
                prop_name=prop.name,
                prop_type=prop.type,
                prop_logical_name=prop.logical_name or "", # Add logical_name
                prop_modifiers_json=prop_modifiers_json, # Pass modifiers as JSON
                prop_annotations_json=prop_annotations_json, # Pass annotations as JSON
                prop_initial_value=prop.initial_value or "", # Pass initial value
                package_name=prop.package_name, # Pass package_name
                project_name=project_name, # Add project_name
                prop_description=prop.description or "", # Add description
                prop_ai_description=prop.ai_description or "", # Add ai_description
            )

        # Create method call relationships (method to method)
        for method_call in class_node.calls:
            # First, ensure the target class exists
            target_class_query = (
                "MERGE (tc:Class {name: $target_class})"
            )
            tx.run(
                target_class_query,
                target_class=method_call.target_class,
            )
            
            # Create the target method if it doesn't exist
            target_method_query = (
                "MATCH (tc:Class {name: $target_class}) "
                "MERGE (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (tc)-[:HAS_METHOD]->(tm)"
            )
            tx.run(
                target_method_query,
                target_class=method_call.target_class,
                target_method=method_call.target_method,
            )
            
            # Create the CALLS relationship between source method and target method
            call_query = (
                "MATCH (sm:Method {name: $source_method, class_name: $source_class}) "
                "MATCH (tm:Method {name: $target_method, class_name: $target_class}) "
                "MERGE (sm)-[r:CALLS]->(tm) "
                "SET r.source_package = $source_package, "
                "r.source_class = $source_class, "
                "r.source_method = $source_method, "
                "r.target_package = $target_package, "
                "r.target_class = $target_class, "
                "r.target_method = $target_method"
            )
            tx.run(
                call_query,
                source_method=method_call.source_method,
                source_class=class_node.name,
                source_package=package_name,
                target_method=method_call.target_method,
                target_class=method_call.target_class,
                target_package=method_call.target_package,
            )

    def add_bean(self, bean: Bean, project_name: str):
        """Adds a Spring Bean to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_node_tx, bean, project_name)

    def add_bean_dependency(self, dependency: BeanDependency, project_name: str):
        """Adds a Bean dependency to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_bean_dependency_tx, dependency, project_name)

    def add_endpoint(self, endpoint: Endpoint, project_name: str):
        """Adds a REST API endpoint to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_endpoint_node_tx, endpoint, project_name)

    def add_mybatis_mapper(self, mapper: MyBatisMapper, project_name: str):
        """Adds a MyBatis mapper to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_mybatis_mapper_node_tx, mapper, project_name)

    def add_jpa_entity(self, entity: JpaEntity, project_name: str):
        """Adds a JPA entity to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_jpa_entity_node_tx, entity, project_name)

    def add_config_file(self, config_file: ConfigFile, project_name: str):
        """Adds a configuration file to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_config_file_node_tx, config_file, project_name)

    def add_test_class(self, test_class: TestClass, project_name: str):
        """Adds a test class to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_test_class_node_tx, test_class, project_name)

    def add_sql_statement(self, sql_statement: SqlStatement, project_name: str):
        """Adds a SQL statement to the database."""
        with self._driver.session() as session:
            session.execute_write(self._create_sql_statement_node_tx, sql_statement, project_name)

    @staticmethod
    def _create_bean_node_tx(tx, bean: Bean, project_name: str):
        """A transaction function to create a Spring Bean node."""
        bean_query = (
            "MERGE (b:Bean {name: $name}) "
            "SET b.type = $type, b.scope = $scope, b.class_name = $class_name, "
            "b.package_name = $package_name, b.annotation_names = $annotation_names, "
            "b.method_count = $method_count, b.property_count = $property_count, "
            "b.project_name = $project_name, b.description = $description, b.ai_description = $ai_description"
        )
        tx.run(
            bean_query,
            name=bean.name,
            type=bean.type,
            scope=bean.scope,
            class_name=bean.class_name,
            package_name=bean.package_name,
            annotation_names=json.dumps(bean.annotation_names),
            method_count=bean.method_count,
            property_count=bean.property_count,
            project_name=project_name,
            description=bean.description or "",
            ai_description=bean.ai_description or ""
        )

    @staticmethod
    def _create_bean_dependency_tx(tx, dependency: BeanDependency, project_name: str):
        """A transaction function to create a Bean dependency relationship."""
        # Create source and target beans if they don't exist
        source_bean_query = "MERGE (sb:Bean {name: $source_bean})"
        target_bean_query = "MERGE (tb:Bean {name: $target_bean})"
        
        tx.run(source_bean_query, source_bean=dependency.source_bean)
        tx.run(target_bean_query, target_bean=dependency.target_bean)
        
        # Create dependency relationship
        dependency_query = (
            "MATCH (sb:Bean {name: $source_bean}), (tb:Bean {name: $target_bean}) "
            "MERGE (sb)-[r:DEPENDS_ON {injection_type: $injection_type, "
            "field_name: $field_name, method_name: $method_name, "
            "parameter_name: $parameter_name}]->(tb)"
        )
        tx.run(
            dependency_query,
            source_bean=dependency.source_bean,
            target_bean=dependency.target_bean,
            injection_type=dependency.injection_type,
            field_name=dependency.field_name,
            method_name=dependency.method_name,
            parameter_name=dependency.parameter_name
        )

    @staticmethod
    def _create_endpoint_node_tx(tx, endpoint: Endpoint, project_name: str):
        """A transaction function to create a REST API endpoint node."""
        endpoint_query = (
            "MERGE (e:Endpoint {path: $path, method: $method}) "
            "SET e.controller_class = $controller_class, e.handler_method = $handler_method, "
            "e.endpoint_parameters = $endpoint_parameters, e.return_type = $return_type, "
            "e.annotations = $annotations, e.full_path = $full_path, "
            "e.project_name = $project_name, e.description = $description, e.ai_description = $ai_description"
        )
        tx.run(
            endpoint_query,
            path=endpoint.path,
            method=endpoint.method,
            controller_class=endpoint.controller_class,
            handler_method=endpoint.handler_method,
            endpoint_parameters=json.dumps(endpoint.parameters),
            return_type=endpoint.return_type,
            annotations=json.dumps(endpoint.annotations),
            full_path=endpoint.full_path,
            project_name=project_name,
            description=endpoint.description or "",
            ai_description=endpoint.ai_description or ""
        )

    @staticmethod
    def _create_mybatis_mapper_node_tx(tx, mapper: MyBatisMapper, project_name: str):
        """A transaction function to create a MyBatis mapper node."""
        mapper_query = (
            "MERGE (m:MyBatisMapper {name: $name}) "
            "SET m.type = $type, m.namespace = $namespace, m.methods = $methods, "
            "m.sql_statements = $sql_statements, m.file_path = $file_path, "
            "m.package_name = $package_name, m.description = $description, m.ai_description = $ai_description"
        )
        tx.run(
            mapper_query,
            name=mapper.name,
            type=mapper.type,
            namespace=mapper.namespace,
            methods=json.dumps(mapper.methods),
            sql_statements=json.dumps(mapper.sql_statements),
            file_path=mapper.file_path,
            package_name=mapper.package_name,
            description=mapper.description or "",
            ai_description=mapper.ai_description or ""
        )

    @staticmethod
    def _create_jpa_entity_node_tx(tx, entity: JpaEntity, project_name: str):
        """A transaction function to create a JPA entity node."""
        entity_query = (
            "MERGE (e:JpaEntity {name: $name}) "
            "SET e.table_name = $table_name, e.columns = $columns, "
            "e.relationships = $relationships, e.annotations = $annotations, "
            "e.package_name = $package_name, e.file_path = $file_path, "
            "e.description = $description, e.ai_description = $ai_description"
        )
        tx.run(
            entity_query,
            name=entity.name,
            table_name=entity.table_name,
            columns=json.dumps(entity.columns),
            relationships=json.dumps(entity.relationships),
            annotations=json.dumps(entity.annotations),
            package_name=entity.package_name,
            file_path=entity.file_path,
            description=entity.description or "",
            ai_description=entity.ai_description or ""
        )

    @staticmethod
    def _create_config_file_node_tx(tx, config_file: ConfigFile, project_name: str):
        """A transaction function to create a configuration file node."""
        config_query = (
            "MERGE (c:ConfigFile {name: $name}) "
            "SET c.file_path = $file_path, c.file_type = $file_type, "
            "c.properties = $properties, c.sections = $sections, "
            "c.profiles = $profiles, c.environment = $environment, "
            "c.description = $description, c.ai_description = $ai_description"
        )
        tx.run(
            config_query,
            name=config_file.name,
            file_path=config_file.file_path,
            file_type=config_file.file_type,
            properties=json.dumps(config_file.properties),
            sections=json.dumps(config_file.sections),
            profiles=json.dumps(config_file.profiles),
            environment=config_file.environment,
            description=config_file.description or "",
            ai_description=config_file.ai_description or ""
        )

    @staticmethod
    def _create_test_class_node_tx(tx, test_class: TestClass, project_name: str):
        """A transaction function to create a test class node."""
        test_query = (
            "MERGE (t:TestClass {name: $name}) "
            "SET t.package_name = $package_name, t.test_framework = $test_framework, "
            "t.test_type = $test_type, t.annotations = $annotations, "
            "t.test_methods = $test_methods, t.setup_methods = $setup_methods, "
            "t.mock_dependencies = $mock_dependencies, t.test_configurations = $test_configurations, "
            "t.file_path = $file_path, t.project_name = $project_name, "
            "t.description = $description, t.ai_description = $ai_description"
        )
        tx.run(
            test_query,
            name=test_class.name,
            package_name=test_class.package_name,
            test_framework=test_class.test_framework,
            test_type=test_class.test_type,
            annotations=json.dumps(test_class.annotations),
            test_methods=json.dumps(test_class.test_methods),
            setup_methods=json.dumps(test_class.setup_methods),
            mock_dependencies=json.dumps(test_class.mock_dependencies),
            test_configurations=json.dumps(test_class.test_configurations),
            file_path=test_class.file_path,
            project_name=project_name,
            description=test_class.description or "",
            ai_description=test_class.ai_description or ""
        )

    @staticmethod
    def _create_sql_statement_node_tx(tx, sql_statement: SqlStatement, project_name: str):
        """A transaction function to create a SQL statement node."""
        sql_query = (
            "MERGE (s:SqlStatement {id: $id, mapper_name: $mapper_name}) "
            "SET s.sql_type = $sql_type, s.sql_content = $sql_content, "
            "s.parameter_type = $parameter_type, s.result_type = $result_type, "
            "s.result_map = $result_map, s.annotations = $annotations, "
            "s.project_name = $project_name, s.description = $description, s.ai_description = $ai_description"
        )
        tx.run(
            sql_query,
            id=sql_statement.id,
            mapper_name=sql_statement.mapper_name,
            sql_type=sql_statement.sql_type,
            sql_content=sql_statement.sql_content,
            parameter_type=sql_statement.parameter_type,
            result_type=sql_statement.result_type,
            result_map=sql_statement.result_map,
            annotations=json.dumps([a.dict() for a in sql_statement.annotations]),
            project_name=project_name,
            description=sql_statement.description or "",
            ai_description=sql_statement.ai_description or ""
        )

    @staticmethod
    def _create_mapper_sql_relationship_tx(tx, mapper_name: str, sql_id: str, project_name: str):
        """A transaction function to create a relationship between MyBatisMapper and SqlStatement."""
        relationship_query = (
            "MATCH (m:MyBatisMapper {name: $mapper_name, project_name: $project_name}) "
            "MATCH (s:SqlStatement {id: $sql_id, mapper_name: $mapper_name, project_name: $project_name}) "
            "MERGE (m)-[:HAS_SQL_STATEMENT]->(s)"
        )
        tx.run(
            relationship_query,
            mapper_name=mapper_name,
            sql_id=sql_id,
            project_name=project_name
        )

    def get_crud_matrix(self, project_name: str = None):
        """Get CRUD matrix showing class-table relationships."""
        query = """
        MATCH (c:Class {project_name: $project_name})
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(s:SqlStatement {project_name: $project_name})
        WITH c, m, s, 
             CASE 
               WHEN s.sql_type = 'SELECT' THEN 'R'
               WHEN s.sql_type = 'INSERT' THEN 'C'
               WHEN s.sql_type = 'UPDATE' THEN 'U'
               WHEN s.sql_type = 'DELETE' THEN 'D'
               ELSE 'O'
             END as crud_operation
        RETURN c.name as class_name,
               c.package_name as package_name,
               collect(DISTINCT s.mapper_name) as tables,
               collect(DISTINCT crud_operation) as operations,
               collect(DISTINCT s.id) as sql_statements
        ORDER BY c.name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

    def get_table_crud_summary(self, project_name: str = None):
        """Get CRUD summary for each table."""
        query = """
        MATCH (s:SqlStatement {project_name: $project_name})
        WITH s.mapper_name as table_name,
             s.sql_type as operation,
             count(s) as count
        RETURN table_name,
               collect({operation: operation, count: count}) as operations
        ORDER BY table_name
        """
        
        with self._driver.session() as session:
            result = session.run(query, project_name=project_name)
            return [record.data() for record in result]

```

이제 데이터베이스 스키마에 ai_description 속성 추가가 완료되었습니다.


이제 파서 서비스에서 ai_description 처리 로직을 추가하겠습니다.


```python
import os
import yaml
import re
from pathlib import Path

import javalang

from src.models.graph_entities import Class, Method, MethodCall, Field, Package, Annotation, Bean, BeanDependency, Endpoint, MyBatisMapper, MyBatisSqlStatement, MyBatisResultMap, SqlStatement, JpaEntity, JpaColumn, JpaRelationship, ConfigFile, DatabaseConfig, ServerConfig, SecurityConfig, LoggingConfig, TestClass, TestMethod, TestConfiguration
from src.utils.logger import get_logger
from typing import Optional, List, Literal


def extract_project_name(java_source_folder: str) -> str:
    """
    JAVA_SOURCE_FOLDER 경로에서 프로젝트 이름을 추출합니다.
    
    Args:
        java_source_folder: Java 소스 폴더 경로
        
    Returns:
        프로젝트 이름 (마지막 디렉토리명)
    """
    # 경로를 정규화하고 마지막 디렉토리명 추출
    path = Path(java_source_folder).resolve()
    return path.name


def extract_sql_statements_from_mappers(mybatis_mappers: list[MyBatisMapper], project_name: str) -> list[SqlStatement]:
    """
    MyBatis mappers에서 SQL statements를 추출합니다.
    
    Args:
        mybatis_mappers: MyBatis mapper 객체들의 리스트
        project_name: 프로젝트 이름
        
    Returns:
        SqlStatement 객체들의 리스트
    """
    sql_statements = []
    
    for mapper in mybatis_mappers:
        for sql_dict in mapper.sql_statements:
            # MyBatisSqlStatement를 SqlStatement로 변환
            sql_statement = SqlStatement(
                id=sql_dict.get('id', ''),
                sql_type=sql_dict.get('sql_type', ''),
                sql_content=sql_dict.get('sql_content', ''),
                parameter_type=sql_dict.get('parameter_type', ''),
                result_type=sql_dict.get('result_type', ''),
                result_map=sql_dict.get('result_map', ''),
                mapper_name=mapper.name,
                annotations=[],  # TODO: annotations를 파싱하여 추가
                project_name=project_name
            )
            sql_statements.append(sql_statement)
    
    return sql_statements


def parse_annotations(annotations, target_type: str = "class") -> list[Annotation]:
    """Parse Java annotations into Annotation objects.
    
    Args:
        annotations: List of annotation nodes from javalang
        target_type: Type of target ("class", "method", "field")
    """
    result = []
    for annotation in annotations:
        annotation_name = annotation.name
        parameters = {}
        
        # Parse annotation parameters if they exist
        if hasattr(annotation, 'element') and annotation.element:
            for element in annotation.element:
                if hasattr(element, 'name') and hasattr(element, 'value'):
                    parameters[element.name] = element.value.value if hasattr(element.value, 'value') else str(element.value)
        
        result.append(Annotation(
            name=annotation_name,
            parameters=parameters,
            target_type=target_type,
            category=classify_springboot_annotation(annotation_name)
        ))
    
    return result


def classify_springboot_annotation(annotation_name: str) -> str:
    """Classify SpringBoot annotations into categories.
    
    Args:
        annotation_name: Name of the annotation (e.g., "@Component", "@Service")
        
    Returns:
        Category of the annotation
    """
    # Component annotations
    component_annotations = {
        "Component", "Service", "Repository", "Controller", 
        "RestController", "Configuration", "Bean"
    }
    
    # Injection annotations
    injection_annotations = {
        "Autowired", "Resource", "Value", "Qualifier", "Primary"
    }
    
    # Web annotations
    web_annotations = {
        "RequestMapping", "GetMapping", "PostMapping", "PutMapping", 
        "DeleteMapping", "PatchMapping", "RequestParam", "PathVariable",
        "RequestBody", "ResponseBody", "ResponseStatus"
    }
    
    # JPA annotations
    jpa_annotations = {
        "Entity", "Table", "Id", "Column", "OneToMany", "ManyToOne",
        "OneToOne", "ManyToMany", "JoinColumn", "GeneratedValue"
    }
    
    # Test annotations
    test_annotations = {
        "Test", "SpringBootTest", "DataJpaTest", "WebMvcTest",
        "MockBean", "SpyBean", "TestPropertySource"
    }
    
    # Security annotations
    security_annotations = {
        "PreAuthorize", "PostAuthorize", "Secured", "RolesAllowed",
        "EnableWebSecurity", "EnableGlobalMethodSecurity"
    }
    
    # Validation annotations
    validation_annotations = {
        "Valid", "NotNull", "NotBlank", "NotEmpty", "Size", "Min", "Max",
        "Pattern", "Email", "AssertTrue", "AssertFalse"
    }
    
    # MyBatis annotations
    mybatis_annotations = {
        "Mapper", "Select", "Insert", "Update", "Delete", "SelectProvider",
        "InsertProvider", "UpdateProvider", "DeleteProvider", "Results",
        "Result", "One", "Many", "MapKey", "Options", "SelectKey"
    }
    
    if annotation_name in component_annotations:
        return "component"
    elif annotation_name in injection_annotations:
        return "injection"
    elif annotation_name in web_annotations:
        return "web"
    elif annotation_name in jpa_annotations:
        return "jpa"
    elif annotation_name in test_annotations:
        return "test"
    elif annotation_name in security_annotations:
        return "security"
    elif annotation_name in validation_annotations:
        return "validation"
    elif annotation_name in mybatis_annotations:
        return "mybatis"
    else:
        return "other"


def classify_test_annotation(annotation_name: str) -> str:
    """Classify test annotations into categories.
    
    Args:
        annotation_name: Name of the annotation
        
    Returns:
        Category of the test annotation
    """
    # JUnit annotations
    junit_annotations = {
        "Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll",
        "DisplayName", "ParameterizedTest", "ValueSource", "CsvSource",
        "MethodSource", "Timeout", "Disabled", "Nested", "RepeatedTest",
        "Order", "TestMethodOrder", "TestInstance", "TestClassOrder"
    }
    
    # Spring Boot Test annotations
    spring_test_annotations = {
        "SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest",
        "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest",
        "MockBean", "SpyBean", "TestConfiguration", "ActiveProfiles",
        "TestPropertySource", "DirtiesContext", "Transactional",
        "Rollback", "Commit", "Sql", "SqlGroup", "AutoConfigureTestDatabase",
        "AutoConfigureMockMvc", "AutoConfigureWebMvc", "AutoConfigureWebClient",
        "MockMvc", "TestEntityManager", "TestContainers", "DynamicPropertySource"
    }
    
    # TestNG annotations
    testng_annotations = {
        "TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass",
        "BeforeSuite", "AfterSuite", "BeforeGroups", "AfterGroups",
        "DataProvider", "Parameters", "Groups", "Priority", "DependsOnMethods",
        "DependsOnGroups", "ExpectedExceptions", "InvocationCount",
        "SuccessPercentage", "TimeOut"
    }
    
    # Mockito annotations
    mockito_annotations = {
        "Mock", "Spy", "InjectMocks", "Captor", "MockedStatic"
    }
    
    # AssertJ annotations
    assertj_annotations = {
        "AssertJ"
    }
    
    # Other test annotations
    other_test_annotations = {
        "Ignore", "Category", "RunWith", "ExtendWith", "ContextConfiguration"
    }
    
    if annotation_name in junit_annotations:
        return "junit"
    elif annotation_name in spring_test_annotations:
        return "spring_test"
    elif annotation_name in testng_annotations:
        return "testng"
    elif annotation_name in mockito_annotations:
        return "mockito"
    elif annotation_name in assertj_annotations:
        return "assertj"
    elif annotation_name in other_test_annotations:
        return "other_test"
    else:
        return "other"


def extract_beans_from_classes(classes: list[Class]) -> list[Bean]:
    """Extract Spring Beans from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Bean objects
    """
    beans = []
    
    for cls in classes:
        # Check if class has Spring component annotations
        component_annotations = [ann for ann in cls.annotations if ann.category == "component"]
        
        # Also check for @Repository on interfaces
        has_repository_annotation = any(ann.name == "Repository" for ann in cls.annotations)
        
        if component_annotations or has_repository_annotation:
            # Determine bean type based on annotations
            bean_type = "component"  # default
            if any(ann.name in ["Service", "Service"] for ann in cls.annotations):
                bean_type = "service"
            elif any(ann.name in ["Repository", "Repository"] for ann in cls.annotations):
                bean_type = "repository"
            elif any(ann.name in ["Controller", "RestController"] for ann in cls.annotations):
                bean_type = "controller"
            elif any(ann.name in ["Configuration", "Configuration"] for ann in cls.annotations):
                bean_type = "configuration"
            
            # Determine scope (default is singleton)
            scope = "singleton"
            for ann in cls.annotations:
                if ann.name == "Scope":
                    if "value" in ann.parameters:
                        scope = ann.parameters["value"]
                    elif "prototype" in str(ann.parameters):
                        scope = "prototype"
                    elif "request" in str(ann.parameters):
                        scope = "request"
                    elif "session" in str(ann.parameters):
                        scope = "session"
            
            # Create bean name (use class name with first letter lowercase)
            bean_name = cls.name[0].lower() + cls.name[1:] if cls.name else cls.name
            
            # Check for @Bean methods in configuration classes
            bean_methods = []
            if bean_type == "configuration":
                for method in cls.methods:
                    if any(ann.name == "Bean" for ann in method.annotations):
                        bean_methods.append(method)
            
            bean = Bean(
                name=bean_name,
                type=bean_type,
                scope=scope,
                class_name=cls.name,
                package_name=cls.package_name,
                annotation_names=[ann.name for ann in cls.annotations] if cls.annotations else [],
                method_count=len(bean_methods) if bean_type == "configuration" else len(cls.methods) if cls.methods else 0,
                property_count=len(cls.properties) if cls.properties else 0
            )
            beans.append(bean)
    
    return beans


def analyze_bean_dependencies(classes: list[Class], beans: list[Bean]) -> list[BeanDependency]:
    """Analyze dependencies between Spring Beans.
    
    Args:
        classes: List of parsed Class objects
        beans: List of Bean objects
        
    Returns:
        List of BeanDependency objects
    """
    dependencies = []
    
    # Create a mapping from class names to bean names
    class_to_bean = {}
    for bean in beans:
        class_to_bean[bean.class_name] = bean.name
    
    for cls in classes:
        # Check if this class is a bean
        if cls.name not in class_to_bean:
            continue
            
        source_bean = class_to_bean[cls.name]
        
        # Analyze field injections (@Autowired, @Resource, @Value)
        for prop in cls.properties:
            if any(ann.category == "injection" for ann in prop.annotations):
                # Try to determine target bean from field type
                target_bean = None
                field_type = prop.type
                
                # Look for exact class name match
                if field_type in class_to_bean:
                    target_bean = class_to_bean[field_type]
                else:
                    # Look for interface implementations (simplified - just check if type matches any bean class name)
                    for bean in beans:
                        if field_type == bean.class_name:
                            target_bean = bean.name
                            break
                
                if target_bean:
                    injection_type = "field"
                    for ann in prop.annotations:
                        if ann.name == "Autowired":
                            injection_type = "field"
                        elif ann.name == "Resource":
                            injection_type = "field"
                        elif ann.name == "Value":
                            injection_type = "field"
                    
                    dependency = BeanDependency(
                        source_bean=source_bean,
                        target_bean=target_bean,
                        injection_type=injection_type,
                        field_name=prop.name
                    )
                    dependencies.append(dependency)
        
        # Analyze constructor injections
        for method in cls.methods:
            if method.name == cls.name:  # Constructor
                for param in method.parameters:
                    if any(ann.category == "injection" for ann in param.annotations):
                        target_bean = None
                        param_type = param.type
                        
                        if param_type in class_to_bean:
                            target_bean = class_to_bean[param_type]
                        else:
                            # Look for interface implementations (simplified)
                            for bean in beans:
                                if param_type == bean.class_name:
                                    target_bean = bean.name
                                    break
                        
                        if target_bean:
                            dependency = BeanDependency(
                                source_bean=source_bean,
                                target_bean=target_bean,
                                injection_type="constructor",
                                parameter_name=param.name
                            )
                            dependencies.append(dependency)
        
        # Analyze setter injections
        for method in cls.methods:
            if method.name.startswith("set") and len(method.parameters) == 1:
                if any(ann.category == "injection" for ann in method.annotations):
                    param = method.parameters[0]
                    target_bean = None
                    param_type = param.type
                    
                    if param_type in class_to_bean:
                        target_bean = class_to_bean[param_type]
                    else:
                        # Look for interface implementations (simplified)
                        for bean in beans:
                            if param_type == bean.class_name:
                                target_bean = bean.name
                                break
                    
                    if target_bean:
                        dependency = BeanDependency(
                            source_bean=source_bean,
                            target_bean=target_bean,
                            injection_type="setter",
                            method_name=method.name,
                            parameter_name=param.name
                        )
                        dependencies.append(dependency)
    
    return dependencies


def extract_endpoints_from_classes(classes: list[Class]) -> list[Endpoint]:
    """Extract REST API endpoints from controller classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Endpoint objects
    """
    endpoints = []
    
    for cls in classes:
        # Check if class is a controller
        is_controller = any(ann.name in ["Controller", "RestController"] for ann in cls.annotations)
        
        if not is_controller:
            continue
            
        # Get class-level path mapping
        class_path = ""
        for ann in cls.annotations:
            if ann.name == "RequestMapping":
                if "value" in ann.parameters:
                    class_path = ann.parameters["value"]
                break
        
        # Process each method in the controller
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
                
            # Check if method has web mapping annotations
            web_annotations = [ann for ann in method.annotations if ann.category == "web"]
            
            if not web_annotations:
                continue
            
            # Extract endpoint information
            endpoint_path = ""
            http_method = "GET"  # default
            
            for ann in web_annotations:
                if ann.name in ["RequestMapping", "GetMapping", "PostMapping", "PutMapping", "DeleteMapping", "PatchMapping"]:
                    # Extract path
                    if "value" in ann.parameters:
                        endpoint_path = ann.parameters["value"]
                    elif "path" in ann.parameters:
                        endpoint_path = ann.parameters["path"]
                    
                    # Extract HTTP method
                    if ann.name == "GetMapping":
                        http_method = "GET"
                    elif ann.name == "PostMapping":
                        http_method = "POST"
                    elif ann.name == "PutMapping":
                        http_method = "PUT"
                    elif ann.name == "DeleteMapping":
                        http_method = "DELETE"
                    elif ann.name == "PatchMapping":
                        http_method = "PATCH"
                    elif ann.name == "RequestMapping":
                        if "method" in ann.parameters:
                            method_value = ann.parameters["method"]
                            if isinstance(method_value, list) and len(method_value) > 0:
                                http_method = method_value[0]
                            else:
                                http_method = str(method_value)
                        else:
                            http_method = "GET"  # default for RequestMapping
                    break
            
            # Build full path
            full_path = class_path
            if endpoint_path:
                if full_path and not full_path.endswith("/") and not endpoint_path.startswith("/"):
                    full_path += "/"
                full_path += endpoint_path
            elif not full_path:
                full_path = "/"
            
            # Extract method parameters
            parameters = []
            for param in method.parameters:
                param_info = {
                    "name": param.name,
                    "type": param.type,
                    "annotations": [ann.name for ann in param.annotations if ann.category == "web"]
                }
                parameters.append(param_info)
            
            # Extract return type
            return_type = method.return_type if method.return_type != "constructor" else "void"
            
            # Create endpoint
            endpoint = Endpoint(
                path=endpoint_path or "/",
                method=http_method,
                controller_class=cls.name,
                handler_method=method.name,
                parameters=parameters,
                return_type=return_type,
                annotations=[ann.name for ann in web_annotations],
                full_path=full_path
            )
            endpoints.append(endpoint)
    
    return endpoints


def extract_mybatis_mappers_from_classes(classes: list[Class]) -> list[MyBatisMapper]:
    """Extract MyBatis Mappers from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for cls in classes:
        # Check if class is a MyBatis Mapper interface
        is_mapper = any(ann.name == "Mapper" for ann in cls.annotations)
        
        if not is_mapper:
            continue
        
        # Extract mapper methods with MyBatis annotations
        mapper_methods = []
        sql_statements = []
        
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
            
            # Check if method has MyBatis annotations
            mybatis_annotations = [ann for ann in method.annotations if ann.category == "mybatis"]
            
            if not mybatis_annotations:
                continue
            
            # Extract SQL statement information
            sql_type = "SELECT"  # default
            sql_content = ""
            parameter_type = ""
            result_type = ""
            result_map = ""
            
            for ann in mybatis_annotations:
                if ann.name in ["Select", "SelectProvider"]:
                    sql_type = "SELECT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Insert", "InsertProvider"]:
                    sql_type = "INSERT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Update", "UpdateProvider"]:
                    sql_type = "UPDATE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Delete", "DeleteProvider"]:
                    sql_type = "DELETE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                
                # Extract parameter and result type information
                if "parameterType" in ann.parameters:
                    parameter_type = ann.parameters["parameterType"]
                if "resultType" in ann.parameters:
                    result_type = ann.parameters["resultType"]
                if "resultMap" in ann.parameters:
                    result_map = ann.parameters["resultMap"]
            
            # Create method info
            method_info = {
                "name": method.name,
                "return_type": method.return_type,
                "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            mapper_methods.append(method_info)
            
            # Create SQL statement info
            sql_statement = {
                "id": method.name,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            sql_statements.append(sql_statement)
        
        # Create mapper
        mapper = MyBatisMapper(
            name=cls.name,
            type="interface",
            namespace=f"{cls.package_name}.{cls.name}",
            methods=mapper_methods,
            sql_statements=sql_statements,
            file_path=cls.file_path,
            package_name=cls.package_name
        )
        mappers.append(mapper)
    
    return mappers


def parse_mybatis_xml_file(file_path: str) -> MyBatisMapper:
    """Parse MyBatis XML mapper file.
    
    Args:
        file_path: Path to the XML mapper file
        
    Returns:
        MyBatisMapper object
    """
    import xml.etree.ElementTree as ET
    
    try:
        tree = ET.parse(file_path)
        root = tree.getroot()
        
        # Extract namespace
        namespace = root.get("namespace", "")
        
        # Extract SQL statements
        sql_statements = []
        for statement in root.findall(".//*[@id]"):
            statement_id = statement.get("id")
            tag_name = statement.tag.lower()
            
            # Determine SQL type
            sql_type = "SELECT"
            if tag_name == "insert":
                sql_type = "INSERT"
            elif tag_name == "update":
                sql_type = "UPDATE"
            elif tag_name == "delete":
                sql_type = "DELETE"
            
            # Extract SQL content
            sql_content = statement.text.strip() if statement.text else ""
            
            # Extract parameter and result information
            parameter_type = statement.get("parameterType", "")
            result_type = statement.get("resultType", "")
            result_map = statement.get("resultMap", "")
            
            sql_statement = {
                "id": statement_id,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": []
            }
            sql_statements.append(sql_statement)
        
        # Extract ResultMaps
        result_maps = []
        for result_map in root.findall(".//resultMap"):
            result_map_id = result_map.get("id")
            result_map_type = result_map.get("type", "")
            
            properties = []
            for property_elem in result_map.findall(".//result"):
                prop = {
                    "property": property_elem.get("property", ""),
                    "column": property_elem.get("column", ""),
                    "jdbc_type": property_elem.get("jdbcType", "")
                }
                properties.append(prop)
            
            result_map_info = {
                "id": result_map_id,
                "type": result_map_type,
                "properties": properties,
                "associations": [],
                "collections": []
            }
            result_maps.append(result_map_info)
        
        # Create mapper
        mapper_name = namespace.split(".")[-1] if namespace else os.path.basename(file_path).replace(".xml", "")
        package_name = ".".join(namespace.split(".")[:-1]) if namespace else ""
        
        mapper = MyBatisMapper(
            name=mapper_name,
            type="xml",
            namespace=namespace,
            methods=[],  # XML mappers don't have Java methods
            sql_statements=sql_statements,
            file_path=file_path,
            package_name=package_name
        )
        
        return mapper
        
    except ET.ParseError as e:
        print(f"Error parsing XML file {file_path}: {e}")
        return None
    except Exception as e:
        print(f"Error reading XML file {file_path}: {e}")
        return None


def extract_mybatis_xml_mappers(directory: str) -> list[MyBatisMapper]:
    """Extract MyBatis XML mappers from directory.
    
    Args:
        directory: Directory to search for XML mapper files
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith("Mapper.xml") or file.endswith("Dao.xml"):
                file_path = os.path.join(root, file)
                mapper = parse_mybatis_xml_file(file_path)
                if mapper:
                    mappers.append(mapper)
    
    return mappers


def extract_jpa_entities_from_classes(classes: list[Class]) -> list[JpaEntity]:
    """Extract JPA Entities from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of JpaEntity objects
    """
    entities = []
    
    for cls in classes:
        # Check if class is a JPA Entity
        is_entity = any(ann.name == "Entity" for ann in cls.annotations)
        
        if not is_entity:
            continue
        
        # Extract table name
        table_name = cls.name.lower()  # default table name
        for ann in cls.annotations:
            if ann.name == "Table":
                if "name" in ann.parameters:
                    table_name = ann.parameters["name"]
                break
        
        # Extract columns from properties
        columns = []
        relationships = []
        
        for prop in cls.properties:
            # Check if property has JPA column annotations
            jpa_annotations = [ann for ann in prop.annotations if ann.category == "jpa"]
            
            if jpa_annotations:
                # Extract column information
                column_name = prop.name  # default column name
                nullable = True
                unique = False
                length = 0
                precision = 0
                scale = 0
                
                for ann in jpa_annotations:
                    if ann.name == "Column":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                        if "nullable" in ann.parameters:
                            nullable = ann.parameters["nullable"]
                        if "unique" in ann.parameters:
                            unique = ann.parameters["unique"]
                        if "length" in ann.parameters:
                            length = ann.parameters["length"]
                        if "precision" in ann.parameters:
                            precision = ann.parameters["precision"]
                        if "scale" in ann.parameters:
                            scale = ann.parameters["scale"]
                    elif ann.name == "Id":
                        column_name = "id"  # Primary key column
                        nullable = False
                        unique = True
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                
                # Check for relationship annotations
                relationship_type = None
                target_entity = ""
                mapped_by = ""
                join_column = ""
                join_table = ""
                cascade = []
                fetch = "LAZY"
                
                for ann in jpa_annotations:
                    if ann.name in ["OneToOne", "OneToMany", "ManyToOne", "ManyToMany"]:
                        relationship_type = ann.name
                        if "targetEntity" in ann.parameters:
                            target_entity = ann.parameters["targetEntity"]
                        if "mappedBy" in ann.parameters:
                            mapped_by = ann.parameters["mappedBy"]
                        if "cascade" in ann.parameters:
                            cascade = ann.parameters["cascade"] if isinstance(ann.parameters["cascade"], list) else [ann.parameters["cascade"]]
                        if "fetch" in ann.parameters:
                            fetch = ann.parameters["fetch"]
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            join_column = ann.parameters["name"]
                    elif ann.name == "JoinTable":
                        if "name" in ann.parameters:
                            join_table = ann.parameters["name"]
                
                # Create column info
                column_info = {
                    "property_name": prop.name,
                    "column_name": column_name,
                    "data_type": prop.type,
                    "nullable": nullable,
                    "unique": unique,
                    "length": length,
                    "precision": precision,
                    "scale": scale,
                    "annotations": [ann.name for ann in jpa_annotations]
                }
                columns.append(column_info)
                
                # Create relationship info if it's a relationship
                if relationship_type:
                    relationship_info = {
                        "type": relationship_type,
                        "target_entity": target_entity,
                        "mapped_by": mapped_by,
                        "join_column": join_column,
                        "join_table": join_table,
                        "cascade": cascade,
                        "fetch": fetch,
                        "annotations": [ann.name for ann in jpa_annotations]
                    }
                    relationships.append(relationship_info)
        
        # Create entity
        entity = JpaEntity(
            name=cls.name,
            table_name=table_name,
            columns=columns,
            relationships=relationships,
            annotations=[ann.name for ann in cls.annotations if ann.category == "jpa"],
            package_name=cls.package_name,
            file_path=cls.file_path
        )
        entities.append(entity)
    
    return entities


def parse_yaml_config(file_path: str) -> ConfigFile:
    """Parse YAML configuration file.
    
    Args:
        file_path: Path to the YAML file
        
    Returns:
        ConfigFile object
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = yaml.safe_load(f)
        
        if not content:
            content = {}
        
        # Extract file info
        file_name = os.path.basename(file_path)
        file_type = "yaml" if file_path.endswith('.yaml') else "yml"
        
        # Extract profiles
        profiles = []
        if 'spring' in content and 'profiles' in content['spring']:
            if 'active' in content['spring']['profiles']:
                profiles = content['spring']['profiles']['active']
                if isinstance(profiles, str):
                    profiles = [profiles]
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        # Extract sections
        sections = []
        for key, value in content.items():
            if isinstance(value, dict):
                sections.append({
                    "name": key,
                    "properties": value,
                    "type": "section"
                })
        
        return ConfigFile(
            name=file_name,
            file_path=file_path,
            file_type=file_type,
            properties=content,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing YAML file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="yaml",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def parse_properties_config(file_path: str) -> ConfigFile:
    """Parse Properties configuration file.
    
    Args:
        file_path: Path to the properties file
        
    Returns:
        ConfigFile object
    """
    try:
        properties = {}
        sections = []
        profiles = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                
                # Skip empty lines and comments
                if not line or line.startswith('#'):
                    continue
                
                # Parse key=value pairs
                if '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    
                    # Remove quotes if present
                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]
                    elif value.startswith("'") and value.endswith("'"):
                        value = value[1:-1]
                    
                    properties[key] = value
                    
                    # Check for profiles
                    if key == 'spring.profiles.active':
                        profiles = [p.strip() for p in value.split(',')]
        
        # Group properties by section
        section_map = {}
        for key, value in properties.items():
            if '.' in key:
                section = key.split('.')[0]
                if section not in section_map:
                    section_map[section] = {}
                section_map[section][key] = value
            else:
                if 'root' not in section_map:
                    section_map['root'] = {}
                section_map['root'][key] = value
        
        for section_name, section_props in section_map.items():
            sections.append({
                "name": section_name,
                "properties": section_props,
                "type": "section"
            })
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties=properties,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing Properties file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def extract_database_config(config_file: ConfigFile) -> DatabaseConfig:
    """Extract database configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        DatabaseConfig object
    """
    db_config = DatabaseConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        spring_config = config_file.properties.get('spring', {})
        datasource_config = spring_config.get('datasource', {})
        jpa_config = spring_config.get('jpa', {})
        
        db_config.driver = datasource_config.get('driver-class-name', '')
        db_config.url = datasource_config.get('url', '')
        db_config.username = datasource_config.get('username', '')
        db_config.password = datasource_config.get('password', '')
        db_config.dialect = jpa_config.get('database-platform', '')
        db_config.hibernate_ddl_auto = jpa_config.get('hibernate', {}).get('ddl-auto', '')
        db_config.show_sql = jpa_config.get('show-sql', False)
        db_config.format_sql = jpa_config.get('properties', {}).get('hibernate', {}).get('format_sql', False)
        
        # Store additional JPA properties
        if 'properties' in jpa_config:
            db_config.jpa_properties = jpa_config['properties']
    
    else:
        # Properties format
        props = config_file.properties
        
        db_config.driver = props.get('spring.datasource.driver-class-name', '')
        db_config.url = props.get('spring.datasource.url', '')
        db_config.username = props.get('spring.datasource.username', '')
        db_config.password = props.get('spring.datasource.password', '')
        db_config.dialect = props.get('spring.jpa.database-platform', '')
        db_config.hibernate_ddl_auto = props.get('spring.jpa.hibernate.ddl-auto', '')
        db_config.show_sql = props.get('spring.jpa.show-sql', 'false').lower() == 'true'
        db_config.format_sql = props.get('spring.jpa.properties.hibernate.format_sql', 'false').lower() == 'true'
        
        # Store additional JPA properties
        jpa_props = {}
        for key, value in props.items():
            if key.startswith('spring.jpa.properties.'):
                jpa_props[key] = value
        db_config.jpa_properties = jpa_props
    
    return db_config


def extract_server_config(config_file: ConfigFile) -> ServerConfig:
    """Extract server configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        ServerConfig object
    """
    server_config = ServerConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        server_props = config_file.properties.get('server', {})
        
        server_config.port = server_props.get('port', 8080)
        server_config.context_path = server_props.get('servlet', {}).get('context-path', '')
        server_config.servlet_path = server_props.get('servlet', {}).get('path', '')
        
        # SSL configuration
        ssl_config = server_props.get('ssl', {})
        server_config.ssl_enabled = bool(ssl_config)
        server_config.ssl_key_store = ssl_config.get('key-store', '')
        server_config.ssl_key_store_password = ssl_config.get('key-store-password', '')
        server_config.ssl_key_store_type = ssl_config.get('key-store-type', '')
    
    else:
        # Properties format
        props = config_file.properties
        
        server_config.port = int(props.get('server.port', '8080'))
        server_config.context_path = props.get('server.servlet.context-path', '')
        server_config.servlet_path = props.get('server.servlet.path', '')
        
        # SSL configuration
        server_config.ssl_enabled = any(key.startswith('server.ssl.') for key in props.keys())
        server_config.ssl_key_store = props.get('server.ssl.key-store', '')
        server_config.ssl_key_store_password = props.get('server.ssl.key-store-password', '')
        server_config.ssl_key_store_type = props.get('server.ssl.key-store-type', '')
    
    return server_config


def extract_security_config(config_file: ConfigFile) -> SecurityConfig:
    """Extract security configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        SecurityConfig object
    """
    security_config = SecurityConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        security_props = config_file.properties.get('security', {})
        jwt_props = security_props.get('jwt', {})
        cors_props = security_props.get('cors', {})
        
        security_config.enabled = bool(security_props)
        security_config.authentication_type = security_props.get('authentication-type', '')
        security_config.jwt_secret = jwt_props.get('secret', '')
        security_config.jwt_expiration = jwt_props.get('expiration', 0)
        security_config.cors_allowed_origins = cors_props.get('allowed-origins', [])
        security_config.cors_allowed_methods = cors_props.get('allowed-methods', [])
        security_config.cors_allowed_headers = cors_props.get('allowed-headers', [])
    
    else:
        # Properties format
        props = config_file.properties
        
        security_config.enabled = any(key.startswith('security.') for key in props.keys())
        security_config.authentication_type = props.get('security.authentication-type', '')
        security_config.jwt_secret = props.get('security.jwt.secret', '')
        security_config.jwt_expiration = int(props.get('security.jwt.expiration', '0'))
        
        # CORS configuration
        origins = props.get('security.cors.allowed-origins', '')
        if origins:
            security_config.cors_allowed_origins = [o.strip() for o in origins.split(',')]
        
        methods = props.get('security.cors.allowed-methods', '')
        if methods:
            security_config.cors_allowed_methods = [m.strip() for m in methods.split(',')]
        
        headers = props.get('security.cors.allowed-headers', '')
        if headers:
            security_config.cors_allowed_headers = [h.strip() for h in headers.split(',')]
    
    return security_config


def extract_logging_config(config_file: ConfigFile) -> LoggingConfig:
    """Extract logging configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        LoggingConfig object
    """
    logging_config = LoggingConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        logging_props = config_file.properties.get('logging', {})
        
        logging_config.level = logging_props.get('level', {}).get('root', 'INFO')
        logging_config.pattern = logging_props.get('pattern', {}).get('console', '')
        logging_config.file_path = logging_props.get('file', {}).get('name', '')
        logging_config.max_file_size = logging_props.get('file', {}).get('max-size', '')
        logging_config.max_history = logging_props.get('file', {}).get('max-history', 0)
        logging_config.console_output = logging_props.get('console', {}).get('enabled', True)
    
    else:
        # Properties format
        props = config_file.properties
        
        logging_config.level = props.get('logging.level.root', 'INFO')
        logging_config.pattern = props.get('logging.pattern.console', '')
        logging_config.file_path = props.get('logging.file.name', '')
        logging_config.max_file_size = props.get('logging.file.max-size', '')
        logging_config.max_history = int(props.get('logging.file.max-history', '0'))
        logging_config.console_output = props.get('logging.console.enabled', 'true').lower() == 'true'
    
    return logging_config


def extract_config_files(directory: str) -> list[ConfigFile]:
    """Extract configuration files from directory.
    
    Args:
        directory: Directory to search for config files
        
    Returns:
        List of ConfigFile objects
    """
    config_files = []
    
    # Common config file patterns
    config_patterns = [
        "application.yml",
        "application.yaml", 
        "application.properties",
        "application-*.properties",
        "bootstrap.yml",
        "bootstrap.yaml",
        "bootstrap.properties"
    ]
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            # Check if file matches any config pattern
            is_config_file = False
            for pattern in config_patterns:
                if pattern == file or (pattern.endswith('*') and file.startswith(pattern[:-1])):
                    is_config_file = True
                    break
            
            if is_config_file:
                file_path = os.path.join(root, file)
                
                if file.endswith(('.yml', '.yaml')):
                    config_file = parse_yaml_config(file_path)
                elif file.endswith('.properties'):
                    config_file = parse_properties_config(file_path)
                else:
                    continue
                
                config_files.append(config_file)
    
    return config_files


def extract_test_classes_from_classes(classes: list[Class]) -> list[TestClass]:
    """Extract test classes from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of TestClass objects
    """
    test_classes = []
    
    for cls in classes:
        # Check if class is a test class
        test_annotations = [ann for ann in cls.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
        
        if not test_annotations:
            continue
        
        # Determine test framework and type
        test_framework = "junit"  # default
        test_type = "unit"  # default
        
        for ann in test_annotations:
            if ann.name in ["SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest", "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest"]:
                test_framework = "spring_test"
                if ann.name == "SpringBootTest":
                    test_type = "integration"
                else:
                    test_type = "slice"
            elif ann.name in ["TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass"]:
                test_framework = "testng"
            elif ann.name in ["Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll"]:
                test_framework = "junit"
        
        # Extract test methods
        test_methods = []
        setup_methods = []
        
        for method in cls.methods:
            method_annotations = [ann.name for ann in method.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
            
            if method_annotations:
                # Check if it's a setup/teardown method
                if any(ann in method_annotations for ann in ["BeforeEach", "AfterEach", "BeforeAll", "AfterAll", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass", "BeforeSuite", "AfterSuite"]):
                    setup_methods.append({
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters]
                    })
                else:
                    # Regular test method
                    test_method_info = {
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                        "assertions": [],
                        "mock_calls": [],
                        "test_data": [],
                        "expected_exceptions": [],
                        "timeout": 0,
                        "display_name": ""
                    }
                    
                    # Extract display name
                    for ann in method.annotations:
                        if ann.name == "DisplayName" and "value" in ann.parameters:
                            test_method_info["display_name"] = ann.parameters["value"]
                        elif ann.name == "Timeout" and "value" in ann.parameters:
                            test_method_info["timeout"] = ann.parameters["value"]
                    
                    # Extract expected exceptions
                    for ann in method.annotations:
                        if ann.name == "ExpectedExceptions" and "value" in ann.parameters:
                            test_method_info["expected_exceptions"] = ann.parameters["value"] if isinstance(ann.parameters["value"], list) else [ann.parameters["value"]]
                    
                    test_methods.append(test_method_info)
        
        # Extract mock dependencies
        mock_dependencies = []
        for prop in cls.properties:
            prop_annotations = [ann.name for ann in prop.annotations if classify_test_annotation(ann.name) in ["mockito", "spring_test"]]
            if prop_annotations:
                mock_dependencies.append({
                    "name": prop.name,
                    "type": prop.type,
                    "annotations": prop_annotations,
                    "mock_type": "mock" if "Mock" in prop_annotations else "spy" if "Spy" in prop_annotations else "bean"
                })
        
        # Extract test configurations
        test_configurations = []
        for ann in cls.annotations:
            if ann.name in ["TestConfiguration", "ActiveProfiles", "TestPropertySource"]:
                config_info = {
                    "name": ann.name,
                    "type": "configuration" if ann.name == "TestConfiguration" else "profile" if ann.name == "ActiveProfiles" else "property",
                    "properties": ann.parameters,
                    "active_profiles": ann.parameters.get("value", []) if ann.name == "ActiveProfiles" else [],
                    "test_slices": [],
                    "mock_beans": [],
                    "spy_beans": []
                }
                test_configurations.append(config_info)
        
        # Create test class
        test_class = TestClass(
            name=cls.name,
            package_name=cls.package_name,
            test_framework=test_framework,
            test_type=test_type,
            annotations=[ann.name for ann in test_annotations],
            test_methods=test_methods,
            setup_methods=setup_methods,
            mock_dependencies=mock_dependencies,
            test_configurations=test_configurations,
            file_path=cls.file_path
        )
        test_classes.append(test_class)
    
    return test_classes


def analyze_test_methods(test_class: TestClass, class_obj: Class) -> list[TestMethod]:
    """Analyze test methods for assertions, mock calls, and test data.
    
    Args:
        test_class: TestClass object
        class_obj: Original Class object
        
    Returns:
        List of analyzed TestMethod objects
    """
    test_methods = []
    
    for method_info in test_class.test_methods:
        # Find the corresponding method in the class
        method_obj = None
        for method in class_obj.methods:
            if method.name == method_info["name"]:
                method_obj = method
                break
        
        if not method_obj:
            continue
        
        # Analyze method source code for assertions and mock calls
        assertions = []
        mock_calls = []
        test_data = []
        
        if method_obj.source:
            source_code = method_obj.source
            
            # Find assertions (JUnit, AssertJ, etc.)
            assertion_patterns = [
                r'assert\w+\(',  # JUnit assertions
                r'assertThat\(',  # AssertJ
                r'assertEquals\(',  # JUnit
                r'assertTrue\(',  # JUnit
                r'assertFalse\(',  # JUnit
                r'assertNotNull\(',  # JUnit
                r'assertNull\(',  # JUnit
                r'assertThrows\(',  # JUnit 5
                r'assertDoesNotThrow\(',  # JUnit 5
                r'verify\(',  # Mockito verify
                r'when\(',  # Mockito when
                r'then\(',  # Mockito then
                r'given\(',  # BDDMockito given
                r'willReturn\(',  # Mockito willReturn
                r'willThrow\(',  # Mockito willThrow
            ]
            
            for pattern in assertion_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    assertions.append({
                        "type": match,
                        "line": source_code.find(match) + 1
                    })
            
            # Find mock calls
            mock_call_patterns = [
                r'(\w+)\.(\w+)\(',  # Method calls on objects
                r'mock\(',  # Mockito mock creation
                r'spy\(',  # Mockito spy creation
                r'@Mock\s+(\w+)',  # @Mock annotation
                r'@Spy\s+(\w+)',  # @Spy annotation
                r'@InjectMocks\s+(\w+)',  # @InjectMocks annotation
            ]
            
            for pattern in mock_call_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        mock_calls.append({
                            "object": match[0],
                            "method": match[1],
                            "type": "method_call"
                        })
                    else:
                        mock_calls.append({
                            "type": match,
                            "line": source_code.find(match) + 1
                        })
            
            # Find test data setup
            test_data_patterns = [
                r'new\s+(\w+)\(',  # Object creation
                r'(\w+)\s*=\s*new\s+(\w+)\(',  # Variable assignment with new
                r'@ValueSource\(',  # JUnit 5 @ValueSource
                r'@CsvSource\(',  # JUnit 5 @CsvSource
                r'@MethodSource\(',  # JUnit 5 @MethodSource
            ]
            
            for pattern in test_data_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        test_data.append({
                            "variable": match[0],
                            "type": match[1],
                            "pattern": "object_creation"
                        })
                    else:
                        test_data.append({
                            "type": match,
                            "pattern": "annotation"
                        })
        
        # Create TestMethod object
        test_method = TestMethod(
            name=method_info["name"],
            return_type=method_info["return_type"],
            annotations=method_info["annotations"],
            assertions=assertions,
            mock_calls=mock_calls,
            test_data=test_data,
            expected_exceptions=method_info["expected_exceptions"],
            timeout=method_info["timeout"],
            display_name=method_info["display_name"]
        )
        test_methods.append(test_method)
    
    return test_methods


def generate_lombok_methods(properties: list[Field], class_name: str, package_name: str) -> list[Method]:
    """Generate Lombok @Data methods (getters, setters, equals, hashCode, toString) for properties."""
    methods = []
    
    # Generate getters and setters for each property
    for prop in properties:
        # Getter
        getter_name = f"get{prop.name[0].upper()}{prop.name[1:]}"
        if prop.type == "Boolean" and prop.name.startswith("is"):
            # For boolean fields starting with 'is', use the field name as getter
            getter_name = prop.name
        
        getter = Method(
            name=getter_name,
            logical_name=f"{package_name}.{class_name}.{getter_name}",
            return_type=prop.type,
            parameters=[],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[],
            description=f"Generated getter for {prop.name} field"  # Generated method description
        )
        methods.append(getter)
        
        # Setter
        setter_name = f"set{prop.name[0].upper()}{prop.name[1:]}"
        setter_param = Field(
            name=prop.name,
            logical_name=f"{package_name}.{class_name}.{prop.name}",
            type=prop.type,
            package_name=package_name,
            class_name=class_name
        )
        
        setter = Method(
            name=setter_name,
            logical_name=f"{package_name}.{class_name}.{setter_name}",
            return_type="void",
            parameters=[setter_param],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[],
            description=f"Generated setter for {prop.name} field"  # Generated method description
        )
        methods.append(setter)
    
    # Generate equals method
    equals_method = Method(
        name="equals",
        logical_name=f"{package_name}.{class_name}.equals",
        return_type="boolean",
        parameters=[Field(name="obj", logical_name=f"{package_name}.{class_name}.obj", type="Object", package_name=package_name, class_name=class_name)],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated equals method for object comparison"  # Generated method description
    )
    methods.append(equals_method)
    
    # Generate hashCode method
    hashcode_method = Method(
        name="hashCode",
        logical_name=f"{package_name}.{class_name}.hashCode",
        return_type="int",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated hashCode method for object hashing"  # Generated method description
    )
    methods.append(hashcode_method)
    
    # Generate toString method
    tostring_method = Method(
        name="toString",
        logical_name=f"{package_name}.{class_name}.toString",
        return_type="String",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated toString method for string representation"  # Generated method description
    )
    methods.append(tostring_method)
    
    return methods


def parse_java_project(directory: str) -> tuple[list[Package], list[Class], dict[str, str], list[Bean], list[BeanDependency], list[Endpoint], list[MyBatisMapper], list[JpaEntity], list[ConfigFile], list[TestClass], list[SqlStatement], str]:
    """Parse Java project and return parsed entities."""
    logger = get_logger(__name__)
    """Parses all Java files in a directory and returns a tuple of (packages, classes, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name)."""
    
    # Extract project name from directory path
    project_name = extract_project_name(directory)
    packages = {}
    classes = {}
    class_to_package_map = {}  # Maps class_key to package_name

    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith(".java"):
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    file_content = f.read() # Read file content once
                try:
                    tree = javalang.parse.parse(file_content)
                    package_name = tree.package.name if tree.package else ""
                    
                    # Create or update package node
                    if package_name and package_name not in packages:
                        packages[package_name] = Package(
                            name=package_name
                        )
                    elif not package_name:
                        # Handle classes without package (default package)
                        package_name = "default"
                        if package_name not in packages:
                            packages[package_name] = Package(
                                name=package_name
                            )
                    
                    import_map = {}
                    for imp in tree.imports:
                        class_name = imp.path.split('.')[-1]
                        import_map[class_name] = imp.path

                    for _, class_declaration in tree.filter(
                        javalang.tree.ClassDeclaration
                    ):
                        class_name = class_declaration.name
                        class_key = f"{package_name}.{class_name}"
                        
                        # Debug: Check if this is the User class
                        if "User" in class_name:
                            logger.debug(f"Found User class - {class_key}")
                            logger.debug(f"Methods count: {len(class_declaration.methods)}")
                            logger.debug(f"Constructors count: {len(class_declaration.constructors)}")
                        
                        # Extract class source code - use the entire file content
                        class_source = file_content


                        if class_key not in classes:
                            # Parse class annotations
                            class_annotations = parse_annotations(class_declaration.annotations, "class") if hasattr(class_declaration, 'annotations') else []
                            
                            classes[class_key] = Class(
                                name=class_name,
                                logical_name=class_key,  # Add logical_name
                                file_path=file_path,
                                type="class", # Simplified for now
                                source=class_source, # Add class source
                                annotations=class_annotations,
                                package_name=package_name,
                                description=""  # TODO: Extract description from comments or annotations
                            )
                            class_to_package_map[class_key] = package_name
                        
                        # --- Start of new import logic ---
                        for imp in tree.imports:
                            classes[class_key].imports.append(imp.path)
                        # --- End of new import logic ---

                        # --- Start of new inheritance logic ---
                        # Handle 'extends'
                        if class_declaration.extends:
                            superclass_name = class_declaration.extends.name
                            # Try to resolve fully qualified name for superclass
                            if superclass_name in import_map:
                                classes[class_key].superclass = import_map[superclass_name]
                            else:
                                # Assume same package or fully qualified if not in import_map
                                classes[class_key].superclass = f"{package_name}.{superclass_name}" if package_name else superclass_name

                        # Handle 'implements'
                        if class_declaration.implements: # Add this check
                            for impl_ref in class_declaration.implements:
                                interface_name = impl_ref.name
                                # Try to resolve fully qualified name for interface
                                if interface_name in import_map:
                                    classes[class_key].interfaces.append(import_map[interface_name])
                                else:
                                    # Assume same package or fully qualified if not in import_map
                                    classes[class_key].interfaces.append(f"{package_name}.{interface_name}" if package_name else interface_name)
                        # --- End of new inheritance logic ---

                        field_map = {}
                        for field_declaration in class_declaration.fields:
                            for declarator in field_declaration.declarators:
                                field_map[declarator.name] = field_declaration.type.name
                                
                                # Parse field annotations
                                field_annotations = parse_annotations(field_declaration.annotations, "field") if hasattr(field_declaration, 'annotations') else []
                                
                                # Extract initial value if present
                                initial_value = ""
                                if hasattr(declarator, 'initializer') and declarator.initializer:
                                    # Convert the initializer to string representation
                                    if hasattr(declarator.initializer, 'value'):
                                        initial_value = str(declarator.initializer.value)
                                    elif hasattr(declarator.initializer, 'type'):
                                        initial_value = str(declarator.initializer.type)
                                    else:
                                        initial_value = str(declarator.initializer)
                                
                                prop = Field(
                                    name=declarator.name,
                                    logical_name=f"{package_name}.{class_name}.{declarator.name}",
                                    type=field_declaration.type.name,
                                    modifiers=list(field_declaration.modifiers), # Add modifiers
                                    package_name=package_name,
                                    class_name=class_name,
                                    annotations=field_annotations,
                                    initial_value=initial_value,
                                    description="",  # TODO: Extract description from comments or annotations
                                    ai_description=""  # TODO: Generate AI description using LLM
                                )
                                classes[class_key].properties.append(prop)

                        all_declarations = class_declaration.methods + class_declaration.constructors
                        
                        # Debug: Check User class method processing
                        if "User" in class_name:
                            logger.debug(f"Processing User class methods - total declarations: {len(all_declarations)}")
                            for i, decl in enumerate(all_declarations):
                                logger.debug(f"Declaration {i}: {type(decl).__name__} - {decl.name}")
                        
                        for declaration in all_declarations:
                            local_var_map = field_map.copy()
                            params = []
                            for param in declaration.parameters:
                                param_type_name = 'Unknown'
                                if hasattr(param.type, 'name'):
                                    param_type_name = param.type.name
                                local_var_map[param.name] = param_type_name
                                params.append(Field(name=param.name, logical_name=f"{package_name}.{class_name}.{param.name}", type=param_type_name, package_name=package_name, class_name=class_name))

                            if declaration.body:
                                for _, var_decl in declaration.filter(javalang.tree.LocalVariableDeclaration):
                                    for declarator in var_decl.declarators:
                                        local_var_map[declarator.name] = var_decl.type.name
                            
                            if isinstance(declaration, javalang.tree.MethodDeclaration):
                                return_type = declaration.return_type.name if declaration.return_type else "void"
                            else: # ConstructorDeclaration
                                return_type = "constructor"

                            # Extract modifiers
                            modifiers = list(declaration.modifiers)
                            
                            # Parse method annotations
                            method_annotations = parse_annotations(declaration.annotations, "method") if hasattr(declaration, 'annotations') else []

                            # Extract method source code
                            method_source = ""
                            if declaration.position:
                                lines = file_content.splitlines(keepends=True) # Keep line endings
                                start_line = declaration.position.line - 1
                                
                                # Find the end of the method by matching braces
                                brace_count = 0
                                end_line = start_line
                                for i in range(start_line, len(lines)):
                                    line = lines[i]
                                    for char in line:
                                        if char == '{':
                                            brace_count += 1
                                        elif char == '}':
                                            brace_count -= 1
                                            if brace_count == 0:
                                                end_line = i
                                                break
                                    if brace_count == 0:
                                        break
                                
                                method_source = "".join(lines[start_line:end_line + 1])

                            method = Method(
                                name=declaration.name,
                                logical_name=f"{class_key}.{declaration.name}",  # Add logical_name
                                return_type=return_type,
                                parameters=params,
                                modifiers=modifiers,
                                source=method_source, # Add method source
                                package_name=package_name,
                                annotations=method_annotations,
                                description=""  # TODO: Extract description from comments or annotations
                            )
                            classes[class_key].methods.append(method)

                            # Extract method calls with order information
                            call_order = 0
                            for _, invocation in declaration.filter(javalang.tree.MethodInvocation):
                                target_class_name = None
                                resolved_target_package = ""
                                resolved_target_class_name = ""
                                
                                if invocation.qualifier:
                                    # External method call
                                    if invocation.qualifier in local_var_map:
                                        target_class_name = local_var_map[invocation.qualifier]
                                    else:
                                        target_class_name = invocation.qualifier
                                    
                                    if target_class_name:
                                        if target_class_name == "System.out":
                                            resolved_target_package = "java.io"
                                            resolved_target_class_name = "PrintStream"
                                        else:
                                            if target_class_name in import_map:
                                                resolved_target_package = ".".join(import_map[target_class_name].split(".")[:-1])
                                            else:
                                                resolved_target_package = package_name
                                                resolved_target_class_name = target_class_name
                                else:
                                    # Same class method call
                                    resolved_target_package = package_name
                                    resolved_target_class_name = class_name

                                if resolved_target_class_name:
                                    # Get line number from invocation position
                                    line_number = invocation.position.line if invocation.position else 0

                                    call = MethodCall(
                                        source_package=package_name,
                                        source_class=class_name,
                                        source_method=declaration.name,
                                        target_package=resolved_target_package,
                                        target_class=resolved_target_class_name,
                                        target_method=invocation.member,
                                        call_order=call_order,
                                        line_number=line_number,
                                        return_type="void"  # Default return type, can be enhanced later
                                    )
                                    classes[class_key].calls.append(call)
                                    call_order += 1
                        
                        # Check for Lombok @Data annotation and generate methods
                        has_data_annotation = any(ann.name == "Data" for ann in classes[class_key].annotations)
                        if has_data_annotation:
                            logger.debug(f"Found @Data annotation on {class_name}, generating Lombok methods")
                            lombok_methods = generate_lombok_methods(classes[class_key].properties, class_name, package_name)
                            classes[class_key].methods.extend(lombok_methods)
                            logger.debug(f"Generated {len(lombok_methods)} Lombok methods for {class_name}")
                except javalang.parser.JavaSyntaxError as e:
                    print(f"Syntax error in {file_path}: {e}")
                    continue
                except Exception as e:
                    print(f"Error parsing {file_path}: {e}")
                    continue
    
    # Extract beans, analyze dependencies, extract endpoints, extract MyBatis mappers, extract JPA entities, extract config files, and extract test classes
    classes_list = list(classes.values())
    beans = extract_beans_from_classes(classes_list)
    dependencies = analyze_bean_dependencies(classes_list, beans)
    endpoints = extract_endpoints_from_classes(classes_list)
    mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
    jpa_entities = extract_jpa_entities_from_classes(classes_list)
    config_files = extract_config_files(directory)
    test_classes = extract_test_classes_from_classes(classes_list)
    
    # Also extract XML mappers
    xml_mappers = extract_mybatis_xml_mappers(directory)
    mybatis_mappers.extend(xml_mappers)
    
    # Extract SQL statements from MyBatis mappers
    sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
    
    return list(packages.values()), classes_list, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name
```

이제 Lombok 생성 메서드들에도 ai_description을 추가하겠습니다.


```python
import os
import yaml
import re
from pathlib import Path

import javalang

from src.models.graph_entities import Class, Method, MethodCall, Field, Package, Annotation, Bean, BeanDependency, Endpoint, MyBatisMapper, MyBatisSqlStatement, MyBatisResultMap, SqlStatement, JpaEntity, JpaColumn, JpaRelationship, ConfigFile, DatabaseConfig, ServerConfig, SecurityConfig, LoggingConfig, TestClass, TestMethod, TestConfiguration
from src.utils.logger import get_logger
from typing import Optional, List, Literal


def extract_project_name(java_source_folder: str) -> str:
    """
    JAVA_SOURCE_FOLDER 경로에서 프로젝트 이름을 추출합니다.
    
    Args:
        java_source_folder: Java 소스 폴더 경로
        
    Returns:
        프로젝트 이름 (마지막 디렉토리명)
    """
    # 경로를 정규화하고 마지막 디렉토리명 추출
    path = Path(java_source_folder).resolve()
    return path.name


def extract_sql_statements_from_mappers(mybatis_mappers: list[MyBatisMapper], project_name: str) -> list[SqlStatement]:
    """
    MyBatis mappers에서 SQL statements를 추출합니다.
    
    Args:
        mybatis_mappers: MyBatis mapper 객체들의 리스트
        project_name: 프로젝트 이름
        
    Returns:
        SqlStatement 객체들의 리스트
    """
    sql_statements = []
    
    for mapper in mybatis_mappers:
        for sql_dict in mapper.sql_statements:
            # MyBatisSqlStatement를 SqlStatement로 변환
            sql_statement = SqlStatement(
                id=sql_dict.get('id', ''),
                sql_type=sql_dict.get('sql_type', ''),
                sql_content=sql_dict.get('sql_content', ''),
                parameter_type=sql_dict.get('parameter_type', ''),
                result_type=sql_dict.get('result_type', ''),
                result_map=sql_dict.get('result_map', ''),
                mapper_name=mapper.name,
                annotations=[],  # TODO: annotations를 파싱하여 추가
                project_name=project_name
            )
            sql_statements.append(sql_statement)
    
    return sql_statements


def parse_annotations(annotations, target_type: str = "class") -> list[Annotation]:
    """Parse Java annotations into Annotation objects.
    
    Args:
        annotations: List of annotation nodes from javalang
        target_type: Type of target ("class", "method", "field")
    """
    result = []
    for annotation in annotations:
        annotation_name = annotation.name
        parameters = {}
        
        # Parse annotation parameters if they exist
        if hasattr(annotation, 'element') and annotation.element:
            for element in annotation.element:
                if hasattr(element, 'name') and hasattr(element, 'value'):
                    parameters[element.name] = element.value.value if hasattr(element.value, 'value') else str(element.value)
        
        result.append(Annotation(
            name=annotation_name,
            parameters=parameters,
            target_type=target_type,
            category=classify_springboot_annotation(annotation_name)
        ))
    
    return result


def classify_springboot_annotation(annotation_name: str) -> str:
    """Classify SpringBoot annotations into categories.
    
    Args:
        annotation_name: Name of the annotation (e.g., "@Component", "@Service")
        
    Returns:
        Category of the annotation
    """
    # Component annotations
    component_annotations = {
        "Component", "Service", "Repository", "Controller", 
        "RestController", "Configuration", "Bean"
    }
    
    # Injection annotations
    injection_annotations = {
        "Autowired", "Resource", "Value", "Qualifier", "Primary"
    }
    
    # Web annotations
    web_annotations = {
        "RequestMapping", "GetMapping", "PostMapping", "PutMapping", 
        "DeleteMapping", "PatchMapping", "RequestParam", "PathVariable",
        "RequestBody", "ResponseBody", "ResponseStatus"
    }
    
    # JPA annotations
    jpa_annotations = {
        "Entity", "Table", "Id", "Column", "OneToMany", "ManyToOne",
        "OneToOne", "ManyToMany", "JoinColumn", "GeneratedValue"
    }
    
    # Test annotations
    test_annotations = {
        "Test", "SpringBootTest", "DataJpaTest", "WebMvcTest",
        "MockBean", "SpyBean", "TestPropertySource"
    }
    
    # Security annotations
    security_annotations = {
        "PreAuthorize", "PostAuthorize", "Secured", "RolesAllowed",
        "EnableWebSecurity", "EnableGlobalMethodSecurity"
    }
    
    # Validation annotations
    validation_annotations = {
        "Valid", "NotNull", "NotBlank", "NotEmpty", "Size", "Min", "Max",
        "Pattern", "Email", "AssertTrue", "AssertFalse"
    }
    
    # MyBatis annotations
    mybatis_annotations = {
        "Mapper", "Select", "Insert", "Update", "Delete", "SelectProvider",
        "InsertProvider", "UpdateProvider", "DeleteProvider", "Results",
        "Result", "One", "Many", "MapKey", "Options", "SelectKey"
    }
    
    if annotation_name in component_annotations:
        return "component"
    elif annotation_name in injection_annotations:
        return "injection"
    elif annotation_name in web_annotations:
        return "web"
    elif annotation_name in jpa_annotations:
        return "jpa"
    elif annotation_name in test_annotations:
        return "test"
    elif annotation_name in security_annotations:
        return "security"
    elif annotation_name in validation_annotations:
        return "validation"
    elif annotation_name in mybatis_annotations:
        return "mybatis"
    else:
        return "other"


def classify_test_annotation(annotation_name: str) -> str:
    """Classify test annotations into categories.
    
    Args:
        annotation_name: Name of the annotation
        
    Returns:
        Category of the test annotation
    """
    # JUnit annotations
    junit_annotations = {
        "Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll",
        "DisplayName", "ParameterizedTest", "ValueSource", "CsvSource",
        "MethodSource", "Timeout", "Disabled", "Nested", "RepeatedTest",
        "Order", "TestMethodOrder", "TestInstance", "TestClassOrder"
    }
    
    # Spring Boot Test annotations
    spring_test_annotations = {
        "SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest",
        "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest",
        "MockBean", "SpyBean", "TestConfiguration", "ActiveProfiles",
        "TestPropertySource", "DirtiesContext", "Transactional",
        "Rollback", "Commit", "Sql", "SqlGroup", "AutoConfigureTestDatabase",
        "AutoConfigureMockMvc", "AutoConfigureWebMvc", "AutoConfigureWebClient",
        "MockMvc", "TestEntityManager", "TestContainers", "DynamicPropertySource"
    }
    
    # TestNG annotations
    testng_annotations = {
        "TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass",
        "BeforeSuite", "AfterSuite", "BeforeGroups", "AfterGroups",
        "DataProvider", "Parameters", "Groups", "Priority", "DependsOnMethods",
        "DependsOnGroups", "ExpectedExceptions", "InvocationCount",
        "SuccessPercentage", "TimeOut"
    }
    
    # Mockito annotations
    mockito_annotations = {
        "Mock", "Spy", "InjectMocks", "Captor", "MockedStatic"
    }
    
    # AssertJ annotations
    assertj_annotations = {
        "AssertJ"
    }
    
    # Other test annotations
    other_test_annotations = {
        "Ignore", "Category", "RunWith", "ExtendWith", "ContextConfiguration"
    }
    
    if annotation_name in junit_annotations:
        return "junit"
    elif annotation_name in spring_test_annotations:
        return "spring_test"
    elif annotation_name in testng_annotations:
        return "testng"
    elif annotation_name in mockito_annotations:
        return "mockito"
    elif annotation_name in assertj_annotations:
        return "assertj"
    elif annotation_name in other_test_annotations:
        return "other_test"
    else:
        return "other"


def extract_beans_from_classes(classes: list[Class]) -> list[Bean]:
    """Extract Spring Beans from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Bean objects
    """
    beans = []
    
    for cls in classes:
        # Check if class has Spring component annotations
        component_annotations = [ann for ann in cls.annotations if ann.category == "component"]
        
        # Also check for @Repository on interfaces
        has_repository_annotation = any(ann.name == "Repository" for ann in cls.annotations)
        
        if component_annotations or has_repository_annotation:
            # Determine bean type based on annotations
            bean_type = "component"  # default
            if any(ann.name in ["Service", "Service"] for ann in cls.annotations):
                bean_type = "service"
            elif any(ann.name in ["Repository", "Repository"] for ann in cls.annotations):
                bean_type = "repository"
            elif any(ann.name in ["Controller", "RestController"] for ann in cls.annotations):
                bean_type = "controller"
            elif any(ann.name in ["Configuration", "Configuration"] for ann in cls.annotations):
                bean_type = "configuration"
            
            # Determine scope (default is singleton)
            scope = "singleton"
            for ann in cls.annotations:
                if ann.name == "Scope":
                    if "value" in ann.parameters:
                        scope = ann.parameters["value"]
                    elif "prototype" in str(ann.parameters):
                        scope = "prototype"
                    elif "request" in str(ann.parameters):
                        scope = "request"
                    elif "session" in str(ann.parameters):
                        scope = "session"
            
            # Create bean name (use class name with first letter lowercase)
            bean_name = cls.name[0].lower() + cls.name[1:] if cls.name else cls.name
            
            # Check for @Bean methods in configuration classes
            bean_methods = []
            if bean_type == "configuration":
                for method in cls.methods:
                    if any(ann.name == "Bean" for ann in method.annotations):
                        bean_methods.append(method)
            
            bean = Bean(
                name=bean_name,
                type=bean_type,
                scope=scope,
                class_name=cls.name,
                package_name=cls.package_name,
                annotation_names=[ann.name for ann in cls.annotations] if cls.annotations else [],
                method_count=len(bean_methods) if bean_type == "configuration" else len(cls.methods) if cls.methods else 0,
                property_count=len(cls.properties) if cls.properties else 0
            )
            beans.append(bean)
    
    return beans


def analyze_bean_dependencies(classes: list[Class], beans: list[Bean]) -> list[BeanDependency]:
    """Analyze dependencies between Spring Beans.
    
    Args:
        classes: List of parsed Class objects
        beans: List of Bean objects
        
    Returns:
        List of BeanDependency objects
    """
    dependencies = []
    
    # Create a mapping from class names to bean names
    class_to_bean = {}
    for bean in beans:
        class_to_bean[bean.class_name] = bean.name
    
    for cls in classes:
        # Check if this class is a bean
        if cls.name not in class_to_bean:
            continue
            
        source_bean = class_to_bean[cls.name]
        
        # Analyze field injections (@Autowired, @Resource, @Value)
        for prop in cls.properties:
            if any(ann.category == "injection" for ann in prop.annotations):
                # Try to determine target bean from field type
                target_bean = None
                field_type = prop.type
                
                # Look for exact class name match
                if field_type in class_to_bean:
                    target_bean = class_to_bean[field_type]
                else:
                    # Look for interface implementations (simplified - just check if type matches any bean class name)
                    for bean in beans:
                        if field_type == bean.class_name:
                            target_bean = bean.name
                            break
                
                if target_bean:
                    injection_type = "field"
                    for ann in prop.annotations:
                        if ann.name == "Autowired":
                            injection_type = "field"
                        elif ann.name == "Resource":
                            injection_type = "field"
                        elif ann.name == "Value":
                            injection_type = "field"
                    
                    dependency = BeanDependency(
                        source_bean=source_bean,
                        target_bean=target_bean,
                        injection_type=injection_type,
                        field_name=prop.name
                    )
                    dependencies.append(dependency)
        
        # Analyze constructor injections
        for method in cls.methods:
            if method.name == cls.name:  # Constructor
                for param in method.parameters:
                    if any(ann.category == "injection" for ann in param.annotations):
                        target_bean = None
                        param_type = param.type
                        
                        if param_type in class_to_bean:
                            target_bean = class_to_bean[param_type]
                        else:
                            # Look for interface implementations (simplified)
                            for bean in beans:
                                if param_type == bean.class_name:
                                    target_bean = bean.name
                                    break
                        
                        if target_bean:
                            dependency = BeanDependency(
                                source_bean=source_bean,
                                target_bean=target_bean,
                                injection_type="constructor",
                                parameter_name=param.name
                            )
                            dependencies.append(dependency)
        
        # Analyze setter injections
        for method in cls.methods:
            if method.name.startswith("set") and len(method.parameters) == 1:
                if any(ann.category == "injection" for ann in method.annotations):
                    param = method.parameters[0]
                    target_bean = None
                    param_type = param.type
                    
                    if param_type in class_to_bean:
                        target_bean = class_to_bean[param_type]
                    else:
                        # Look for interface implementations (simplified)
                        for bean in beans:
                            if param_type == bean.class_name:
                                target_bean = bean.name
                                break
                    
                    if target_bean:
                        dependency = BeanDependency(
                            source_bean=source_bean,
                            target_bean=target_bean,
                            injection_type="setter",
                            method_name=method.name,
                            parameter_name=param.name
                        )
                        dependencies.append(dependency)
    
    return dependencies


def extract_endpoints_from_classes(classes: list[Class]) -> list[Endpoint]:
    """Extract REST API endpoints from controller classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Endpoint objects
    """
    endpoints = []
    
    for cls in classes:
        # Check if class is a controller
        is_controller = any(ann.name in ["Controller", "RestController"] for ann in cls.annotations)
        
        if not is_controller:
            continue
            
        # Get class-level path mapping
        class_path = ""
        for ann in cls.annotations:
            if ann.name == "RequestMapping":
                if "value" in ann.parameters:
                    class_path = ann.parameters["value"]
                break
        
        # Process each method in the controller
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
                
            # Check if method has web mapping annotations
            web_annotations = [ann for ann in method.annotations if ann.category == "web"]
            
            if not web_annotations:
                continue
            
            # Extract endpoint information
            endpoint_path = ""
            http_method = "GET"  # default
            
            for ann in web_annotations:
                if ann.name in ["RequestMapping", "GetMapping", "PostMapping", "PutMapping", "DeleteMapping", "PatchMapping"]:
                    # Extract path
                    if "value" in ann.parameters:
                        endpoint_path = ann.parameters["value"]
                    elif "path" in ann.parameters:
                        endpoint_path = ann.parameters["path"]
                    
                    # Extract HTTP method
                    if ann.name == "GetMapping":
                        http_method = "GET"
                    elif ann.name == "PostMapping":
                        http_method = "POST"
                    elif ann.name == "PutMapping":
                        http_method = "PUT"
                    elif ann.name == "DeleteMapping":
                        http_method = "DELETE"
                    elif ann.name == "PatchMapping":
                        http_method = "PATCH"
                    elif ann.name == "RequestMapping":
                        if "method" in ann.parameters:
                            method_value = ann.parameters["method"]
                            if isinstance(method_value, list) and len(method_value) > 0:
                                http_method = method_value[0]
                            else:
                                http_method = str(method_value)
                        else:
                            http_method = "GET"  # default for RequestMapping
                    break
            
            # Build full path
            full_path = class_path
            if endpoint_path:
                if full_path and not full_path.endswith("/") and not endpoint_path.startswith("/"):
                    full_path += "/"
                full_path += endpoint_path
            elif not full_path:
                full_path = "/"
            
            # Extract method parameters
            parameters = []
            for param in method.parameters:
                param_info = {
                    "name": param.name,
                    "type": param.type,
                    "annotations": [ann.name for ann in param.annotations if ann.category == "web"]
                }
                parameters.append(param_info)
            
            # Extract return type
            return_type = method.return_type if method.return_type != "constructor" else "void"
            
            # Create endpoint
            endpoint = Endpoint(
                path=endpoint_path or "/",
                method=http_method,
                controller_class=cls.name,
                handler_method=method.name,
                parameters=parameters,
                return_type=return_type,
                annotations=[ann.name for ann in web_annotations],
                full_path=full_path
            )
            endpoints.append(endpoint)
    
    return endpoints


def extract_mybatis_mappers_from_classes(classes: list[Class]) -> list[MyBatisMapper]:
    """Extract MyBatis Mappers from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for cls in classes:
        # Check if class is a MyBatis Mapper interface
        is_mapper = any(ann.name == "Mapper" for ann in cls.annotations)
        
        if not is_mapper:
            continue
        
        # Extract mapper methods with MyBatis annotations
        mapper_methods = []
        sql_statements = []
        
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
            
            # Check if method has MyBatis annotations
            mybatis_annotations = [ann for ann in method.annotations if ann.category == "mybatis"]
            
            if not mybatis_annotations:
                continue
            
            # Extract SQL statement information
            sql_type = "SELECT"  # default
            sql_content = ""
            parameter_type = ""
            result_type = ""
            result_map = ""
            
            for ann in mybatis_annotations:
                if ann.name in ["Select", "SelectProvider"]:
                    sql_type = "SELECT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Insert", "InsertProvider"]:
                    sql_type = "INSERT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Update", "UpdateProvider"]:
                    sql_type = "UPDATE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Delete", "DeleteProvider"]:
                    sql_type = "DELETE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                
                # Extract parameter and result type information
                if "parameterType" in ann.parameters:
                    parameter_type = ann.parameters["parameterType"]
                if "resultType" in ann.parameters:
                    result_type = ann.parameters["resultType"]
                if "resultMap" in ann.parameters:
                    result_map = ann.parameters["resultMap"]
            
            # Create method info
            method_info = {
                "name": method.name,
                "return_type": method.return_type,
                "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            mapper_methods.append(method_info)
            
            # Create SQL statement info
            sql_statement = {
                "id": method.name,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            sql_statements.append(sql_statement)
        
        # Create mapper
        mapper = MyBatisMapper(
            name=cls.name,
            type="interface",
            namespace=f"{cls.package_name}.{cls.name}",
            methods=mapper_methods,
            sql_statements=sql_statements,
            file_path=cls.file_path,
            package_name=cls.package_name
        )
        mappers.append(mapper)
    
    return mappers


def parse_mybatis_xml_file(file_path: str) -> MyBatisMapper:
    """Parse MyBatis XML mapper file.
    
    Args:
        file_path: Path to the XML mapper file
        
    Returns:
        MyBatisMapper object
    """
    import xml.etree.ElementTree as ET
    
    try:
        tree = ET.parse(file_path)
        root = tree.getroot()
        
        # Extract namespace
        namespace = root.get("namespace", "")
        
        # Extract SQL statements
        sql_statements = []
        for statement in root.findall(".//*[@id]"):
            statement_id = statement.get("id")
            tag_name = statement.tag.lower()
            
            # Determine SQL type
            sql_type = "SELECT"
            if tag_name == "insert":
                sql_type = "INSERT"
            elif tag_name == "update":
                sql_type = "UPDATE"
            elif tag_name == "delete":
                sql_type = "DELETE"
            
            # Extract SQL content
            sql_content = statement.text.strip() if statement.text else ""
            
            # Extract parameter and result information
            parameter_type = statement.get("parameterType", "")
            result_type = statement.get("resultType", "")
            result_map = statement.get("resultMap", "")
            
            sql_statement = {
                "id": statement_id,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": []
            }
            sql_statements.append(sql_statement)
        
        # Extract ResultMaps
        result_maps = []
        for result_map in root.findall(".//resultMap"):
            result_map_id = result_map.get("id")
            result_map_type = result_map.get("type", "")
            
            properties = []
            for property_elem in result_map.findall(".//result"):
                prop = {
                    "property": property_elem.get("property", ""),
                    "column": property_elem.get("column", ""),
                    "jdbc_type": property_elem.get("jdbcType", "")
                }
                properties.append(prop)
            
            result_map_info = {
                "id": result_map_id,
                "type": result_map_type,
                "properties": properties,
                "associations": [],
                "collections": []
            }
            result_maps.append(result_map_info)
        
        # Create mapper
        mapper_name = namespace.split(".")[-1] if namespace else os.path.basename(file_path).replace(".xml", "")
        package_name = ".".join(namespace.split(".")[:-1]) if namespace else ""
        
        mapper = MyBatisMapper(
            name=mapper_name,
            type="xml",
            namespace=namespace,
            methods=[],  # XML mappers don't have Java methods
            sql_statements=sql_statements,
            file_path=file_path,
            package_name=package_name
        )
        
        return mapper
        
    except ET.ParseError as e:
        print(f"Error parsing XML file {file_path}: {e}")
        return None
    except Exception as e:
        print(f"Error reading XML file {file_path}: {e}")
        return None


def extract_mybatis_xml_mappers(directory: str) -> list[MyBatisMapper]:
    """Extract MyBatis XML mappers from directory.
    
    Args:
        directory: Directory to search for XML mapper files
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith("Mapper.xml") or file.endswith("Dao.xml"):
                file_path = os.path.join(root, file)
                mapper = parse_mybatis_xml_file(file_path)
                if mapper:
                    mappers.append(mapper)
    
    return mappers


def extract_jpa_entities_from_classes(classes: list[Class]) -> list[JpaEntity]:
    """Extract JPA Entities from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of JpaEntity objects
    """
    entities = []
    
    for cls in classes:
        # Check if class is a JPA Entity
        is_entity = any(ann.name == "Entity" for ann in cls.annotations)
        
        if not is_entity:
            continue
        
        # Extract table name
        table_name = cls.name.lower()  # default table name
        for ann in cls.annotations:
            if ann.name == "Table":
                if "name" in ann.parameters:
                    table_name = ann.parameters["name"]
                break
        
        # Extract columns from properties
        columns = []
        relationships = []
        
        for prop in cls.properties:
            # Check if property has JPA column annotations
            jpa_annotations = [ann for ann in prop.annotations if ann.category == "jpa"]
            
            if jpa_annotations:
                # Extract column information
                column_name = prop.name  # default column name
                nullable = True
                unique = False
                length = 0
                precision = 0
                scale = 0
                
                for ann in jpa_annotations:
                    if ann.name == "Column":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                        if "nullable" in ann.parameters:
                            nullable = ann.parameters["nullable"]
                        if "unique" in ann.parameters:
                            unique = ann.parameters["unique"]
                        if "length" in ann.parameters:
                            length = ann.parameters["length"]
                        if "precision" in ann.parameters:
                            precision = ann.parameters["precision"]
                        if "scale" in ann.parameters:
                            scale = ann.parameters["scale"]
                    elif ann.name == "Id":
                        column_name = "id"  # Primary key column
                        nullable = False
                        unique = True
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                
                # Check for relationship annotations
                relationship_type = None
                target_entity = ""
                mapped_by = ""
                join_column = ""
                join_table = ""
                cascade = []
                fetch = "LAZY"
                
                for ann in jpa_annotations:
                    if ann.name in ["OneToOne", "OneToMany", "ManyToOne", "ManyToMany"]:
                        relationship_type = ann.name
                        if "targetEntity" in ann.parameters:
                            target_entity = ann.parameters["targetEntity"]
                        if "mappedBy" in ann.parameters:
                            mapped_by = ann.parameters["mappedBy"]
                        if "cascade" in ann.parameters:
                            cascade = ann.parameters["cascade"] if isinstance(ann.parameters["cascade"], list) else [ann.parameters["cascade"]]
                        if "fetch" in ann.parameters:
                            fetch = ann.parameters["fetch"]
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            join_column = ann.parameters["name"]
                    elif ann.name == "JoinTable":
                        if "name" in ann.parameters:
                            join_table = ann.parameters["name"]
                
                # Create column info
                column_info = {
                    "property_name": prop.name,
                    "column_name": column_name,
                    "data_type": prop.type,
                    "nullable": nullable,
                    "unique": unique,
                    "length": length,
                    "precision": precision,
                    "scale": scale,
                    "annotations": [ann.name for ann in jpa_annotations]
                }
                columns.append(column_info)
                
                # Create relationship info if it's a relationship
                if relationship_type:
                    relationship_info = {
                        "type": relationship_type,
                        "target_entity": target_entity,
                        "mapped_by": mapped_by,
                        "join_column": join_column,
                        "join_table": join_table,
                        "cascade": cascade,
                        "fetch": fetch,
                        "annotations": [ann.name for ann in jpa_annotations]
                    }
                    relationships.append(relationship_info)
        
        # Create entity
        entity = JpaEntity(
            name=cls.name,
            table_name=table_name,
            columns=columns,
            relationships=relationships,
            annotations=[ann.name for ann in cls.annotations if ann.category == "jpa"],
            package_name=cls.package_name,
            file_path=cls.file_path
        )
        entities.append(entity)
    
    return entities


def parse_yaml_config(file_path: str) -> ConfigFile:
    """Parse YAML configuration file.
    
    Args:
        file_path: Path to the YAML file
        
    Returns:
        ConfigFile object
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = yaml.safe_load(f)
        
        if not content:
            content = {}
        
        # Extract file info
        file_name = os.path.basename(file_path)
        file_type = "yaml" if file_path.endswith('.yaml') else "yml"
        
        # Extract profiles
        profiles = []
        if 'spring' in content and 'profiles' in content['spring']:
            if 'active' in content['spring']['profiles']:
                profiles = content['spring']['profiles']['active']
                if isinstance(profiles, str):
                    profiles = [profiles]
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        # Extract sections
        sections = []
        for key, value in content.items():
            if isinstance(value, dict):
                sections.append({
                    "name": key,
                    "properties": value,
                    "type": "section"
                })
        
        return ConfigFile(
            name=file_name,
            file_path=file_path,
            file_type=file_type,
            properties=content,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing YAML file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="yaml",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def parse_properties_config(file_path: str) -> ConfigFile:
    """Parse Properties configuration file.
    
    Args:
        file_path: Path to the properties file
        
    Returns:
        ConfigFile object
    """
    try:
        properties = {}
        sections = []
        profiles = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                
                # Skip empty lines and comments
                if not line or line.startswith('#'):
                    continue
                
                # Parse key=value pairs
                if '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    
                    # Remove quotes if present
                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]
                    elif value.startswith("'") and value.endswith("'"):
                        value = value[1:-1]
                    
                    properties[key] = value
                    
                    # Check for profiles
                    if key == 'spring.profiles.active':
                        profiles = [p.strip() for p in value.split(',')]
        
        # Group properties by section
        section_map = {}
        for key, value in properties.items():
            if '.' in key:
                section = key.split('.')[0]
                if section not in section_map:
                    section_map[section] = {}
                section_map[section][key] = value
            else:
                if 'root' not in section_map:
                    section_map['root'] = {}
                section_map['root'][key] = value
        
        for section_name, section_props in section_map.items():
            sections.append({
                "name": section_name,
                "properties": section_props,
                "type": "section"
            })
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties=properties,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing Properties file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def extract_database_config(config_file: ConfigFile) -> DatabaseConfig:
    """Extract database configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        DatabaseConfig object
    """
    db_config = DatabaseConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        spring_config = config_file.properties.get('spring', {})
        datasource_config = spring_config.get('datasource', {})
        jpa_config = spring_config.get('jpa', {})
        
        db_config.driver = datasource_config.get('driver-class-name', '')
        db_config.url = datasource_config.get('url', '')
        db_config.username = datasource_config.get('username', '')
        db_config.password = datasource_config.get('password', '')
        db_config.dialect = jpa_config.get('database-platform', '')
        db_config.hibernate_ddl_auto = jpa_config.get('hibernate', {}).get('ddl-auto', '')
        db_config.show_sql = jpa_config.get('show-sql', False)
        db_config.format_sql = jpa_config.get('properties', {}).get('hibernate', {}).get('format_sql', False)
        
        # Store additional JPA properties
        if 'properties' in jpa_config:
            db_config.jpa_properties = jpa_config['properties']
    
    else:
        # Properties format
        props = config_file.properties
        
        db_config.driver = props.get('spring.datasource.driver-class-name', '')
        db_config.url = props.get('spring.datasource.url', '')
        db_config.username = props.get('spring.datasource.username', '')
        db_config.password = props.get('spring.datasource.password', '')
        db_config.dialect = props.get('spring.jpa.database-platform', '')
        db_config.hibernate_ddl_auto = props.get('spring.jpa.hibernate.ddl-auto', '')
        db_config.show_sql = props.get('spring.jpa.show-sql', 'false').lower() == 'true'
        db_config.format_sql = props.get('spring.jpa.properties.hibernate.format_sql', 'false').lower() == 'true'
        
        # Store additional JPA properties
        jpa_props = {}
        for key, value in props.items():
            if key.startswith('spring.jpa.properties.'):
                jpa_props[key] = value
        db_config.jpa_properties = jpa_props
    
    return db_config


def extract_server_config(config_file: ConfigFile) -> ServerConfig:
    """Extract server configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        ServerConfig object
    """
    server_config = ServerConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        server_props = config_file.properties.get('server', {})
        
        server_config.port = server_props.get('port', 8080)
        server_config.context_path = server_props.get('servlet', {}).get('context-path', '')
        server_config.servlet_path = server_props.get('servlet', {}).get('path', '')
        
        # SSL configuration
        ssl_config = server_props.get('ssl', {})
        server_config.ssl_enabled = bool(ssl_config)
        server_config.ssl_key_store = ssl_config.get('key-store', '')
        server_config.ssl_key_store_password = ssl_config.get('key-store-password', '')
        server_config.ssl_key_store_type = ssl_config.get('key-store-type', '')
    
    else:
        # Properties format
        props = config_file.properties
        
        server_config.port = int(props.get('server.port', '8080'))
        server_config.context_path = props.get('server.servlet.context-path', '')
        server_config.servlet_path = props.get('server.servlet.path', '')
        
        # SSL configuration
        server_config.ssl_enabled = any(key.startswith('server.ssl.') for key in props.keys())
        server_config.ssl_key_store = props.get('server.ssl.key-store', '')
        server_config.ssl_key_store_password = props.get('server.ssl.key-store-password', '')
        server_config.ssl_key_store_type = props.get('server.ssl.key-store-type', '')
    
    return server_config


def extract_security_config(config_file: ConfigFile) -> SecurityConfig:
    """Extract security configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        SecurityConfig object
    """
    security_config = SecurityConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        security_props = config_file.properties.get('security', {})
        jwt_props = security_props.get('jwt', {})
        cors_props = security_props.get('cors', {})
        
        security_config.enabled = bool(security_props)
        security_config.authentication_type = security_props.get('authentication-type', '')
        security_config.jwt_secret = jwt_props.get('secret', '')
        security_config.jwt_expiration = jwt_props.get('expiration', 0)
        security_config.cors_allowed_origins = cors_props.get('allowed-origins', [])
        security_config.cors_allowed_methods = cors_props.get('allowed-methods', [])
        security_config.cors_allowed_headers = cors_props.get('allowed-headers', [])
    
    else:
        # Properties format
        props = config_file.properties
        
        security_config.enabled = any(key.startswith('security.') for key in props.keys())
        security_config.authentication_type = props.get('security.authentication-type', '')
        security_config.jwt_secret = props.get('security.jwt.secret', '')
        security_config.jwt_expiration = int(props.get('security.jwt.expiration', '0'))
        
        # CORS configuration
        origins = props.get('security.cors.allowed-origins', '')
        if origins:
            security_config.cors_allowed_origins = [o.strip() for o in origins.split(',')]
        
        methods = props.get('security.cors.allowed-methods', '')
        if methods:
            security_config.cors_allowed_methods = [m.strip() for m in methods.split(',')]
        
        headers = props.get('security.cors.allowed-headers', '')
        if headers:
            security_config.cors_allowed_headers = [h.strip() for h in headers.split(',')]
    
    return security_config


def extract_logging_config(config_file: ConfigFile) -> LoggingConfig:
    """Extract logging configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        LoggingConfig object
    """
    logging_config = LoggingConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        logging_props = config_file.properties.get('logging', {})
        
        logging_config.level = logging_props.get('level', {}).get('root', 'INFO')
        logging_config.pattern = logging_props.get('pattern', {}).get('console', '')
        logging_config.file_path = logging_props.get('file', {}).get('name', '')
        logging_config.max_file_size = logging_props.get('file', {}).get('max-size', '')
        logging_config.max_history = logging_props.get('file', {}).get('max-history', 0)
        logging_config.console_output = logging_props.get('console', {}).get('enabled', True)
    
    else:
        # Properties format
        props = config_file.properties
        
        logging_config.level = props.get('logging.level.root', 'INFO')
        logging_config.pattern = props.get('logging.pattern.console', '')
        logging_config.file_path = props.get('logging.file.name', '')
        logging_config.max_file_size = props.get('logging.file.max-size', '')
        logging_config.max_history = int(props.get('logging.file.max-history', '0'))
        logging_config.console_output = props.get('logging.console.enabled', 'true').lower() == 'true'
    
    return logging_config


def extract_config_files(directory: str) -> list[ConfigFile]:
    """Extract configuration files from directory.
    
    Args:
        directory: Directory to search for config files
        
    Returns:
        List of ConfigFile objects
    """
    config_files = []
    
    # Common config file patterns
    config_patterns = [
        "application.yml",
        "application.yaml", 
        "application.properties",
        "application-*.properties",
        "bootstrap.yml",
        "bootstrap.yaml",
        "bootstrap.properties"
    ]
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            # Check if file matches any config pattern
            is_config_file = False
            for pattern in config_patterns:
                if pattern == file or (pattern.endswith('*') and file.startswith(pattern[:-1])):
                    is_config_file = True
                    break
            
            if is_config_file:
                file_path = os.path.join(root, file)
                
                if file.endswith(('.yml', '.yaml')):
                    config_file = parse_yaml_config(file_path)
                elif file.endswith('.properties'):
                    config_file = parse_properties_config(file_path)
                else:
                    continue
                
                config_files.append(config_file)
    
    return config_files


def extract_test_classes_from_classes(classes: list[Class]) -> list[TestClass]:
    """Extract test classes from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of TestClass objects
    """
    test_classes = []
    
    for cls in classes:
        # Check if class is a test class
        test_annotations = [ann for ann in cls.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
        
        if not test_annotations:
            continue
        
        # Determine test framework and type
        test_framework = "junit"  # default
        test_type = "unit"  # default
        
        for ann in test_annotations:
            if ann.name in ["SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest", "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest"]:
                test_framework = "spring_test"
                if ann.name == "SpringBootTest":
                    test_type = "integration"
                else:
                    test_type = "slice"
            elif ann.name in ["TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass"]:
                test_framework = "testng"
            elif ann.name in ["Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll"]:
                test_framework = "junit"
        
        # Extract test methods
        test_methods = []
        setup_methods = []
        
        for method in cls.methods:
            method_annotations = [ann.name for ann in method.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
            
            if method_annotations:
                # Check if it's a setup/teardown method
                if any(ann in method_annotations for ann in ["BeforeEach", "AfterEach", "BeforeAll", "AfterAll", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass", "BeforeSuite", "AfterSuite"]):
                    setup_methods.append({
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters]
                    })
                else:
                    # Regular test method
                    test_method_info = {
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                        "assertions": [],
                        "mock_calls": [],
                        "test_data": [],
                        "expected_exceptions": [],
                        "timeout": 0,
                        "display_name": ""
                    }
                    
                    # Extract display name
                    for ann in method.annotations:
                        if ann.name == "DisplayName" and "value" in ann.parameters:
                            test_method_info["display_name"] = ann.parameters["value"]
                        elif ann.name == "Timeout" and "value" in ann.parameters:
                            test_method_info["timeout"] = ann.parameters["value"]
                    
                    # Extract expected exceptions
                    for ann in method.annotations:
                        if ann.name == "ExpectedExceptions" and "value" in ann.parameters:
                            test_method_info["expected_exceptions"] = ann.parameters["value"] if isinstance(ann.parameters["value"], list) else [ann.parameters["value"]]
                    
                    test_methods.append(test_method_info)
        
        # Extract mock dependencies
        mock_dependencies = []
        for prop in cls.properties:
            prop_annotations = [ann.name for ann in prop.annotations if classify_test_annotation(ann.name) in ["mockito", "spring_test"]]
            if prop_annotations:
                mock_dependencies.append({
                    "name": prop.name,
                    "type": prop.type,
                    "annotations": prop_annotations,
                    "mock_type": "mock" if "Mock" in prop_annotations else "spy" if "Spy" in prop_annotations else "bean"
                })
        
        # Extract test configurations
        test_configurations = []
        for ann in cls.annotations:
            if ann.name in ["TestConfiguration", "ActiveProfiles", "TestPropertySource"]:
                config_info = {
                    "name": ann.name,
                    "type": "configuration" if ann.name == "TestConfiguration" else "profile" if ann.name == "ActiveProfiles" else "property",
                    "properties": ann.parameters,
                    "active_profiles": ann.parameters.get("value", []) if ann.name == "ActiveProfiles" else [],
                    "test_slices": [],
                    "mock_beans": [],
                    "spy_beans": []
                }
                test_configurations.append(config_info)
        
        # Create test class
        test_class = TestClass(
            name=cls.name,
            package_name=cls.package_name,
            test_framework=test_framework,
            test_type=test_type,
            annotations=[ann.name for ann in test_annotations],
            test_methods=test_methods,
            setup_methods=setup_methods,
            mock_dependencies=mock_dependencies,
            test_configurations=test_configurations,
            file_path=cls.file_path
        )
        test_classes.append(test_class)
    
    return test_classes


def analyze_test_methods(test_class: TestClass, class_obj: Class) -> list[TestMethod]:
    """Analyze test methods for assertions, mock calls, and test data.
    
    Args:
        test_class: TestClass object
        class_obj: Original Class object
        
    Returns:
        List of analyzed TestMethod objects
    """
    test_methods = []
    
    for method_info in test_class.test_methods:
        # Find the corresponding method in the class
        method_obj = None
        for method in class_obj.methods:
            if method.name == method_info["name"]:
                method_obj = method
                break
        
        if not method_obj:
            continue
        
        # Analyze method source code for assertions and mock calls
        assertions = []
        mock_calls = []
        test_data = []
        
        if method_obj.source:
            source_code = method_obj.source
            
            # Find assertions (JUnit, AssertJ, etc.)
            assertion_patterns = [
                r'assert\w+\(',  # JUnit assertions
                r'assertThat\(',  # AssertJ
                r'assertEquals\(',  # JUnit
                r'assertTrue\(',  # JUnit
                r'assertFalse\(',  # JUnit
                r'assertNotNull\(',  # JUnit
                r'assertNull\(',  # JUnit
                r'assertThrows\(',  # JUnit 5
                r'assertDoesNotThrow\(',  # JUnit 5
                r'verify\(',  # Mockito verify
                r'when\(',  # Mockito when
                r'then\(',  # Mockito then
                r'given\(',  # BDDMockito given
                r'willReturn\(',  # Mockito willReturn
                r'willThrow\(',  # Mockito willThrow
            ]
            
            for pattern in assertion_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    assertions.append({
                        "type": match,
                        "line": source_code.find(match) + 1
                    })
            
            # Find mock calls
            mock_call_patterns = [
                r'(\w+)\.(\w+)\(',  # Method calls on objects
                r'mock\(',  # Mockito mock creation
                r'spy\(',  # Mockito spy creation
                r'@Mock\s+(\w+)',  # @Mock annotation
                r'@Spy\s+(\w+)',  # @Spy annotation
                r'@InjectMocks\s+(\w+)',  # @InjectMocks annotation
            ]
            
            for pattern in mock_call_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        mock_calls.append({
                            "object": match[0],
                            "method": match[1],
                            "type": "method_call"
                        })
                    else:
                        mock_calls.append({
                            "type": match,
                            "line": source_code.find(match) + 1
                        })
            
            # Find test data setup
            test_data_patterns = [
                r'new\s+(\w+)\(',  # Object creation
                r'(\w+)\s*=\s*new\s+(\w+)\(',  # Variable assignment with new
                r'@ValueSource\(',  # JUnit 5 @ValueSource
                r'@CsvSource\(',  # JUnit 5 @CsvSource
                r'@MethodSource\(',  # JUnit 5 @MethodSource
            ]
            
            for pattern in test_data_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        test_data.append({
                            "variable": match[0],
                            "type": match[1],
                            "pattern": "object_creation"
                        })
                    else:
                        test_data.append({
                            "type": match,
                            "pattern": "annotation"
                        })
        
        # Create TestMethod object
        test_method = TestMethod(
            name=method_info["name"],
            return_type=method_info["return_type"],
            annotations=method_info["annotations"],
            assertions=assertions,
            mock_calls=mock_calls,
            test_data=test_data,
            expected_exceptions=method_info["expected_exceptions"],
            timeout=method_info["timeout"],
            display_name=method_info["display_name"]
        )
        test_methods.append(test_method)
    
    return test_methods


def generate_lombok_methods(properties: list[Field], class_name: str, package_name: str) -> list[Method]:
    """Generate Lombok @Data methods (getters, setters, equals, hashCode, toString) for properties."""
    methods = []
    
    # Generate getters and setters for each property
    for prop in properties:
        # Getter
        getter_name = f"get{prop.name[0].upper()}{prop.name[1:]}"
        if prop.type == "Boolean" and prop.name.startswith("is"):
            # For boolean fields starting with 'is', use the field name as getter
            getter_name = prop.name
        
        getter = Method(
            name=getter_name,
            logical_name=f"{package_name}.{class_name}.{getter_name}",
            return_type=prop.type,
            parameters=[],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[],
            description=f"Generated getter for {prop.name} field",  # Generated method description
            ai_description=""  # TODO: Generate AI description using LLM
        )
        methods.append(getter)
        
        # Setter
        setter_name = f"set{prop.name[0].upper()}{prop.name[1:]}"
        setter_param = Field(
            name=prop.name,
            logical_name=f"{package_name}.{class_name}.{prop.name}",
            type=prop.type,
            package_name=package_name,
            class_name=class_name
        )
        
        setter = Method(
            name=setter_name,
            logical_name=f"{package_name}.{class_name}.{setter_name}",
            return_type="void",
            parameters=[setter_param],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[],
            description=f"Generated setter for {prop.name} field"  # Generated method description
        )
        methods.append(setter)
    
    # Generate equals method
    equals_method = Method(
        name="equals",
        logical_name=f"{package_name}.{class_name}.equals",
        return_type="boolean",
        parameters=[Field(name="obj", logical_name=f"{package_name}.{class_name}.obj", type="Object", package_name=package_name, class_name=class_name)],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated equals method for object comparison"  # Generated method description
    )
    methods.append(equals_method)
    
    # Generate hashCode method
    hashcode_method = Method(
        name="hashCode",
        logical_name=f"{package_name}.{class_name}.hashCode",
        return_type="int",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated hashCode method for object hashing"  # Generated method description
    )
    methods.append(hashcode_method)
    
    # Generate toString method
    tostring_method = Method(
        name="toString",
        logical_name=f"{package_name}.{class_name}.toString",
        return_type="String",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated toString method for string representation"  # Generated method description
    )
    methods.append(tostring_method)
    
    return methods


def parse_java_project(directory: str) -> tuple[list[Package], list[Class], dict[str, str], list[Bean], list[BeanDependency], list[Endpoint], list[MyBatisMapper], list[JpaEntity], list[ConfigFile], list[TestClass], list[SqlStatement], str]:
    """Parse Java project and return parsed entities."""
    logger = get_logger(__name__)
    """Parses all Java files in a directory and returns a tuple of (packages, classes, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name)."""
    
    # Extract project name from directory path
    project_name = extract_project_name(directory)
    packages = {}
    classes = {}
    class_to_package_map = {}  # Maps class_key to package_name

    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith(".java"):
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    file_content = f.read() # Read file content once
                try:
                    tree = javalang.parse.parse(file_content)
                    package_name = tree.package.name if tree.package else ""
                    
                    # Create or update package node
                    if package_name and package_name not in packages:
                        packages[package_name] = Package(
                            name=package_name
                        )
                    elif not package_name:
                        # Handle classes without package (default package)
                        package_name = "default"
                        if package_name not in packages:
                            packages[package_name] = Package(
                                name=package_name
                            )
                    
                    import_map = {}
                    for imp in tree.imports:
                        class_name = imp.path.split('.')[-1]
                        import_map[class_name] = imp.path

                    for _, class_declaration in tree.filter(
                        javalang.tree.ClassDeclaration
                    ):
                        class_name = class_declaration.name
                        class_key = f"{package_name}.{class_name}"
                        
                        # Debug: Check if this is the User class
                        if "User" in class_name:
                            logger.debug(f"Found User class - {class_key}")
                            logger.debug(f"Methods count: {len(class_declaration.methods)}")
                            logger.debug(f"Constructors count: {len(class_declaration.constructors)}")
                        
                        # Extract class source code - use the entire file content
                        class_source = file_content


                        if class_key not in classes:
                            # Parse class annotations
                            class_annotations = parse_annotations(class_declaration.annotations, "class") if hasattr(class_declaration, 'annotations') else []
                            
                            classes[class_key] = Class(
                                name=class_name,
                                logical_name=class_key,  # Add logical_name
                                file_path=file_path,
                                type="class", # Simplified for now
                                source=class_source, # Add class source
                                annotations=class_annotations,
                                package_name=package_name,
                                description=""  # TODO: Extract description from comments or annotations
                            )
                            class_to_package_map[class_key] = package_name
                        
                        # --- Start of new import logic ---
                        for imp in tree.imports:
                            classes[class_key].imports.append(imp.path)
                        # --- End of new import logic ---

                        # --- Start of new inheritance logic ---
                        # Handle 'extends'
                        if class_declaration.extends:
                            superclass_name = class_declaration.extends.name
                            # Try to resolve fully qualified name for superclass
                            if superclass_name in import_map:
                                classes[class_key].superclass = import_map[superclass_name]
                            else:
                                # Assume same package or fully qualified if not in import_map
                                classes[class_key].superclass = f"{package_name}.{superclass_name}" if package_name else superclass_name

                        # Handle 'implements'
                        if class_declaration.implements: # Add this check
                            for impl_ref in class_declaration.implements:
                                interface_name = impl_ref.name
                                # Try to resolve fully qualified name for interface
                                if interface_name in import_map:
                                    classes[class_key].interfaces.append(import_map[interface_name])
                                else:
                                    # Assume same package or fully qualified if not in import_map
                                    classes[class_key].interfaces.append(f"{package_name}.{interface_name}" if package_name else interface_name)
                        # --- End of new inheritance logic ---

                        field_map = {}
                        for field_declaration in class_declaration.fields:
                            for declarator in field_declaration.declarators:
                                field_map[declarator.name] = field_declaration.type.name
                                
                                # Parse field annotations
                                field_annotations = parse_annotations(field_declaration.annotations, "field") if hasattr(field_declaration, 'annotations') else []
                                
                                # Extract initial value if present
                                initial_value = ""
                                if hasattr(declarator, 'initializer') and declarator.initializer:
                                    # Convert the initializer to string representation
                                    if hasattr(declarator.initializer, 'value'):
                                        initial_value = str(declarator.initializer.value)
                                    elif hasattr(declarator.initializer, 'type'):
                                        initial_value = str(declarator.initializer.type)
                                    else:
                                        initial_value = str(declarator.initializer)
                                
                                prop = Field(
                                    name=declarator.name,
                                    logical_name=f"{package_name}.{class_name}.{declarator.name}",
                                    type=field_declaration.type.name,
                                    modifiers=list(field_declaration.modifiers), # Add modifiers
                                    package_name=package_name,
                                    class_name=class_name,
                                    annotations=field_annotations,
                                    initial_value=initial_value,
                                    description="",  # TODO: Extract description from comments or annotations
                                    ai_description=""  # TODO: Generate AI description using LLM
                                )
                                classes[class_key].properties.append(prop)

                        all_declarations = class_declaration.methods + class_declaration.constructors
                        
                        # Debug: Check User class method processing
                        if "User" in class_name:
                            logger.debug(f"Processing User class methods - total declarations: {len(all_declarations)}")
                            for i, decl in enumerate(all_declarations):
                                logger.debug(f"Declaration {i}: {type(decl).__name__} - {decl.name}")
                        
                        for declaration in all_declarations:
                            local_var_map = field_map.copy()
                            params = []
                            for param in declaration.parameters:
                                param_type_name = 'Unknown'
                                if hasattr(param.type, 'name'):
                                    param_type_name = param.type.name
                                local_var_map[param.name] = param_type_name
                                params.append(Field(name=param.name, logical_name=f"{package_name}.{class_name}.{param.name}", type=param_type_name, package_name=package_name, class_name=class_name))

                            if declaration.body:
                                for _, var_decl in declaration.filter(javalang.tree.LocalVariableDeclaration):
                                    for declarator in var_decl.declarators:
                                        local_var_map[declarator.name] = var_decl.type.name
                            
                            if isinstance(declaration, javalang.tree.MethodDeclaration):
                                return_type = declaration.return_type.name if declaration.return_type else "void"
                            else: # ConstructorDeclaration
                                return_type = "constructor"

                            # Extract modifiers
                            modifiers = list(declaration.modifiers)
                            
                            # Parse method annotations
                            method_annotations = parse_annotations(declaration.annotations, "method") if hasattr(declaration, 'annotations') else []

                            # Extract method source code
                            method_source = ""
                            if declaration.position:
                                lines = file_content.splitlines(keepends=True) # Keep line endings
                                start_line = declaration.position.line - 1
                                
                                # Find the end of the method by matching braces
                                brace_count = 0
                                end_line = start_line
                                for i in range(start_line, len(lines)):
                                    line = lines[i]
                                    for char in line:
                                        if char == '{':
                                            brace_count += 1
                                        elif char == '}':
                                            brace_count -= 1
                                            if brace_count == 0:
                                                end_line = i
                                                break
                                    if brace_count == 0:
                                        break
                                
                                method_source = "".join(lines[start_line:end_line + 1])

                            method = Method(
                                name=declaration.name,
                                logical_name=f"{class_key}.{declaration.name}",  # Add logical_name
                                return_type=return_type,
                                parameters=params,
                                modifiers=modifiers,
                                source=method_source, # Add method source
                                package_name=package_name,
                                annotations=method_annotations,
                                description=""  # TODO: Extract description from comments or annotations
                            )
                            classes[class_key].methods.append(method)

                            # Extract method calls with order information
                            call_order = 0
                            for _, invocation in declaration.filter(javalang.tree.MethodInvocation):
                                target_class_name = None
                                resolved_target_package = ""
                                resolved_target_class_name = ""
                                
                                if invocation.qualifier:
                                    # External method call
                                    if invocation.qualifier in local_var_map:
                                        target_class_name = local_var_map[invocation.qualifier]
                                    else:
                                        target_class_name = invocation.qualifier
                                    
                                    if target_class_name:
                                        if target_class_name == "System.out":
                                            resolved_target_package = "java.io"
                                            resolved_target_class_name = "PrintStream"
                                        else:
                                            if target_class_name in import_map:
                                                resolved_target_package = ".".join(import_map[target_class_name].split(".")[:-1])
                                            else:
                                                resolved_target_package = package_name
                                                resolved_target_class_name = target_class_name
                                else:
                                    # Same class method call
                                    resolved_target_package = package_name
                                    resolved_target_class_name = class_name

                                if resolved_target_class_name:
                                    # Get line number from invocation position
                                    line_number = invocation.position.line if invocation.position else 0

                                    call = MethodCall(
                                        source_package=package_name,
                                        source_class=class_name,
                                        source_method=declaration.name,
                                        target_package=resolved_target_package,
                                        target_class=resolved_target_class_name,
                                        target_method=invocation.member,
                                        call_order=call_order,
                                        line_number=line_number,
                                        return_type="void"  # Default return type, can be enhanced later
                                    )
                                    classes[class_key].calls.append(call)
                                    call_order += 1
                        
                        # Check for Lombok @Data annotation and generate methods
                        has_data_annotation = any(ann.name == "Data" for ann in classes[class_key].annotations)
                        if has_data_annotation:
                            logger.debug(f"Found @Data annotation on {class_name}, generating Lombok methods")
                            lombok_methods = generate_lombok_methods(classes[class_key].properties, class_name, package_name)
                            classes[class_key].methods.extend(lombok_methods)
                            logger.debug(f"Generated {len(lombok_methods)} Lombok methods for {class_name}")
                except javalang.parser.JavaSyntaxError as e:
                    print(f"Syntax error in {file_path}: {e}")
                    continue
                except Exception as e:
                    print(f"Error parsing {file_path}: {e}")
                    continue
    
    # Extract beans, analyze dependencies, extract endpoints, extract MyBatis mappers, extract JPA entities, extract config files, and extract test classes
    classes_list = list(classes.values())
    beans = extract_beans_from_classes(classes_list)
    dependencies = analyze_bean_dependencies(classes_list, beans)
    endpoints = extract_endpoints_from_classes(classes_list)
    mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
    jpa_entities = extract_jpa_entities_from_classes(classes_list)
    config_files = extract_config_files(directory)
    test_classes = extract_test_classes_from_classes(classes_list)
    
    # Also extract XML mappers
    xml_mappers = extract_mybatis_xml_mappers(directory)
    mybatis_mappers.extend(xml_mappers)
    
    # Extract SQL statements from MyBatis mappers
    sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
    
    return list(packages.values()), classes_list, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name
```

```python
import os
import yaml
import re
from pathlib import Path

import javalang

from src.models.graph_entities import Class, Method, MethodCall, Field, Package, Annotation, Bean, BeanDependency, Endpoint, MyBatisMapper, MyBatisSqlStatement, MyBatisResultMap, SqlStatement, JpaEntity, JpaColumn, JpaRelationship, ConfigFile, DatabaseConfig, ServerConfig, SecurityConfig, LoggingConfig, TestClass, TestMethod, TestConfiguration
from src.utils.logger import get_logger
from typing import Optional, List, Literal


def extract_project_name(java_source_folder: str) -> str:
    """
    JAVA_SOURCE_FOLDER 경로에서 프로젝트 이름을 추출합니다.
    
    Args:
        java_source_folder: Java 소스 폴더 경로
        
    Returns:
        프로젝트 이름 (마지막 디렉토리명)
    """
    # 경로를 정규화하고 마지막 디렉토리명 추출
    path = Path(java_source_folder).resolve()
    return path.name


def extract_sql_statements_from_mappers(mybatis_mappers: list[MyBatisMapper], project_name: str) -> list[SqlStatement]:
    """
    MyBatis mappers에서 SQL statements를 추출합니다.
    
    Args:
        mybatis_mappers: MyBatis mapper 객체들의 리스트
        project_name: 프로젝트 이름
        
    Returns:
        SqlStatement 객체들의 리스트
    """
    sql_statements = []
    
    for mapper in mybatis_mappers:
        for sql_dict in mapper.sql_statements:
            # MyBatisSqlStatement를 SqlStatement로 변환
            sql_statement = SqlStatement(
                id=sql_dict.get('id', ''),
                sql_type=sql_dict.get('sql_type', ''),
                sql_content=sql_dict.get('sql_content', ''),
                parameter_type=sql_dict.get('parameter_type', ''),
                result_type=sql_dict.get('result_type', ''),
                result_map=sql_dict.get('result_map', ''),
                mapper_name=mapper.name,
                annotations=[],  # TODO: annotations를 파싱하여 추가
                project_name=project_name
            )
            sql_statements.append(sql_statement)
    
    return sql_statements


def parse_annotations(annotations, target_type: str = "class") -> list[Annotation]:
    """Parse Java annotations into Annotation objects.
    
    Args:
        annotations: List of annotation nodes from javalang
        target_type: Type of target ("class", "method", "field")
    """
    result = []
    for annotation in annotations:
        annotation_name = annotation.name
        parameters = {}
        
        # Parse annotation parameters if they exist
        if hasattr(annotation, 'element') and annotation.element:
            for element in annotation.element:
                if hasattr(element, 'name') and hasattr(element, 'value'):
                    parameters[element.name] = element.value.value if hasattr(element.value, 'value') else str(element.value)
        
        result.append(Annotation(
            name=annotation_name,
            parameters=parameters,
            target_type=target_type,
            category=classify_springboot_annotation(annotation_name)
        ))
    
    return result


def classify_springboot_annotation(annotation_name: str) -> str:
    """Classify SpringBoot annotations into categories.
    
    Args:
        annotation_name: Name of the annotation (e.g., "@Component", "@Service")
        
    Returns:
        Category of the annotation
    """
    # Component annotations
    component_annotations = {
        "Component", "Service", "Repository", "Controller", 
        "RestController", "Configuration", "Bean"
    }
    
    # Injection annotations
    injection_annotations = {
        "Autowired", "Resource", "Value", "Qualifier", "Primary"
    }
    
    # Web annotations
    web_annotations = {
        "RequestMapping", "GetMapping", "PostMapping", "PutMapping", 
        "DeleteMapping", "PatchMapping", "RequestParam", "PathVariable",
        "RequestBody", "ResponseBody", "ResponseStatus"
    }
    
    # JPA annotations
    jpa_annotations = {
        "Entity", "Table", "Id", "Column", "OneToMany", "ManyToOne",
        "OneToOne", "ManyToMany", "JoinColumn", "GeneratedValue"
    }
    
    # Test annotations
    test_annotations = {
        "Test", "SpringBootTest", "DataJpaTest", "WebMvcTest",
        "MockBean", "SpyBean", "TestPropertySource"
    }
    
    # Security annotations
    security_annotations = {
        "PreAuthorize", "PostAuthorize", "Secured", "RolesAllowed",
        "EnableWebSecurity", "EnableGlobalMethodSecurity"
    }
    
    # Validation annotations
    validation_annotations = {
        "Valid", "NotNull", "NotBlank", "NotEmpty", "Size", "Min", "Max",
        "Pattern", "Email", "AssertTrue", "AssertFalse"
    }
    
    # MyBatis annotations
    mybatis_annotations = {
        "Mapper", "Select", "Insert", "Update", "Delete", "SelectProvider",
        "InsertProvider", "UpdateProvider", "DeleteProvider", "Results",
        "Result", "One", "Many", "MapKey", "Options", "SelectKey"
    }
    
    if annotation_name in component_annotations:
        return "component"
    elif annotation_name in injection_annotations:
        return "injection"
    elif annotation_name in web_annotations:
        return "web"
    elif annotation_name in jpa_annotations:
        return "jpa"
    elif annotation_name in test_annotations:
        return "test"
    elif annotation_name in security_annotations:
        return "security"
    elif annotation_name in validation_annotations:
        return "validation"
    elif annotation_name in mybatis_annotations:
        return "mybatis"
    else:
        return "other"


def classify_test_annotation(annotation_name: str) -> str:
    """Classify test annotations into categories.
    
    Args:
        annotation_name: Name of the annotation
        
    Returns:
        Category of the test annotation
    """
    # JUnit annotations
    junit_annotations = {
        "Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll",
        "DisplayName", "ParameterizedTest", "ValueSource", "CsvSource",
        "MethodSource", "Timeout", "Disabled", "Nested", "RepeatedTest",
        "Order", "TestMethodOrder", "TestInstance", "TestClassOrder"
    }
    
    # Spring Boot Test annotations
    spring_test_annotations = {
        "SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest",
        "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest",
        "MockBean", "SpyBean", "TestConfiguration", "ActiveProfiles",
        "TestPropertySource", "DirtiesContext", "Transactional",
        "Rollback", "Commit", "Sql", "SqlGroup", "AutoConfigureTestDatabase",
        "AutoConfigureMockMvc", "AutoConfigureWebMvc", "AutoConfigureWebClient",
        "MockMvc", "TestEntityManager", "TestContainers", "DynamicPropertySource"
    }
    
    # TestNG annotations
    testng_annotations = {
        "TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass",
        "BeforeSuite", "AfterSuite", "BeforeGroups", "AfterGroups",
        "DataProvider", "Parameters", "Groups", "Priority", "DependsOnMethods",
        "DependsOnGroups", "ExpectedExceptions", "InvocationCount",
        "SuccessPercentage", "TimeOut"
    }
    
    # Mockito annotations
    mockito_annotations = {
        "Mock", "Spy", "InjectMocks", "Captor", "MockedStatic"
    }
    
    # AssertJ annotations
    assertj_annotations = {
        "AssertJ"
    }
    
    # Other test annotations
    other_test_annotations = {
        "Ignore", "Category", "RunWith", "ExtendWith", "ContextConfiguration"
    }
    
    if annotation_name in junit_annotations:
        return "junit"
    elif annotation_name in spring_test_annotations:
        return "spring_test"
    elif annotation_name in testng_annotations:
        return "testng"
    elif annotation_name in mockito_annotations:
        return "mockito"
    elif annotation_name in assertj_annotations:
        return "assertj"
    elif annotation_name in other_test_annotations:
        return "other_test"
    else:
        return "other"


def extract_beans_from_classes(classes: list[Class]) -> list[Bean]:
    """Extract Spring Beans from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Bean objects
    """
    beans = []
    
    for cls in classes:
        # Check if class has Spring component annotations
        component_annotations = [ann for ann in cls.annotations if ann.category == "component"]
        
        # Also check for @Repository on interfaces
        has_repository_annotation = any(ann.name == "Repository" for ann in cls.annotations)
        
        if component_annotations or has_repository_annotation:
            # Determine bean type based on annotations
            bean_type = "component"  # default
            if any(ann.name in ["Service", "Service"] for ann in cls.annotations):
                bean_type = "service"
            elif any(ann.name in ["Repository", "Repository"] for ann in cls.annotations):
                bean_type = "repository"
            elif any(ann.name in ["Controller", "RestController"] for ann in cls.annotations):
                bean_type = "controller"
            elif any(ann.name in ["Configuration", "Configuration"] for ann in cls.annotations):
                bean_type = "configuration"
            
            # Determine scope (default is singleton)
            scope = "singleton"
            for ann in cls.annotations:
                if ann.name == "Scope":
                    if "value" in ann.parameters:
                        scope = ann.parameters["value"]
                    elif "prototype" in str(ann.parameters):
                        scope = "prototype"
                    elif "request" in str(ann.parameters):
                        scope = "request"
                    elif "session" in str(ann.parameters):
                        scope = "session"
            
            # Create bean name (use class name with first letter lowercase)
            bean_name = cls.name[0].lower() + cls.name[1:] if cls.name else cls.name
            
            # Check for @Bean methods in configuration classes
            bean_methods = []
            if bean_type == "configuration":
                for method in cls.methods:
                    if any(ann.name == "Bean" for ann in method.annotations):
                        bean_methods.append(method)
            
            bean = Bean(
                name=bean_name,
                type=bean_type,
                scope=scope,
                class_name=cls.name,
                package_name=cls.package_name,
                annotation_names=[ann.name for ann in cls.annotations] if cls.annotations else [],
                method_count=len(bean_methods) if bean_type == "configuration" else len(cls.methods) if cls.methods else 0,
                property_count=len(cls.properties) if cls.properties else 0
            )
            beans.append(bean)
    
    return beans


def analyze_bean_dependencies(classes: list[Class], beans: list[Bean]) -> list[BeanDependency]:
    """Analyze dependencies between Spring Beans.
    
    Args:
        classes: List of parsed Class objects
        beans: List of Bean objects
        
    Returns:
        List of BeanDependency objects
    """
    dependencies = []
    
    # Create a mapping from class names to bean names
    class_to_bean = {}
    for bean in beans:
        class_to_bean[bean.class_name] = bean.name
    
    for cls in classes:
        # Check if this class is a bean
        if cls.name not in class_to_bean:
            continue
            
        source_bean = class_to_bean[cls.name]
        
        # Analyze field injections (@Autowired, @Resource, @Value)
        for prop in cls.properties:
            if any(ann.category == "injection" for ann in prop.annotations):
                # Try to determine target bean from field type
                target_bean = None
                field_type = prop.type
                
                # Look for exact class name match
                if field_type in class_to_bean:
                    target_bean = class_to_bean[field_type]
                else:
                    # Look for interface implementations (simplified - just check if type matches any bean class name)
                    for bean in beans:
                        if field_type == bean.class_name:
                            target_bean = bean.name
                            break
                
                if target_bean:
                    injection_type = "field"
                    for ann in prop.annotations:
                        if ann.name == "Autowired":
                            injection_type = "field"
                        elif ann.name == "Resource":
                            injection_type = "field"
                        elif ann.name == "Value":
                            injection_type = "field"
                    
                    dependency = BeanDependency(
                        source_bean=source_bean,
                        target_bean=target_bean,
                        injection_type=injection_type,
                        field_name=prop.name
                    )
                    dependencies.append(dependency)
        
        # Analyze constructor injections
        for method in cls.methods:
            if method.name == cls.name:  # Constructor
                for param in method.parameters:
                    if any(ann.category == "injection" for ann in param.annotations):
                        target_bean = None
                        param_type = param.type
                        
                        if param_type in class_to_bean:
                            target_bean = class_to_bean[param_type]
                        else:
                            # Look for interface implementations (simplified)
                            for bean in beans:
                                if param_type == bean.class_name:
                                    target_bean = bean.name
                                    break
                        
                        if target_bean:
                            dependency = BeanDependency(
                                source_bean=source_bean,
                                target_bean=target_bean,
                                injection_type="constructor",
                                parameter_name=param.name
                            )
                            dependencies.append(dependency)
        
        # Analyze setter injections
        for method in cls.methods:
            if method.name.startswith("set") and len(method.parameters) == 1:
                if any(ann.category == "injection" for ann in method.annotations):
                    param = method.parameters[0]
                    target_bean = None
                    param_type = param.type
                    
                    if param_type in class_to_bean:
                        target_bean = class_to_bean[param_type]
                    else:
                        # Look for interface implementations (simplified)
                        for bean in beans:
                            if param_type == bean.class_name:
                                target_bean = bean.name
                                break
                    
                    if target_bean:
                        dependency = BeanDependency(
                            source_bean=source_bean,
                            target_bean=target_bean,
                            injection_type="setter",
                            method_name=method.name,
                            parameter_name=param.name
                        )
                        dependencies.append(dependency)
    
    return dependencies


def extract_endpoints_from_classes(classes: list[Class]) -> list[Endpoint]:
    """Extract REST API endpoints from controller classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Endpoint objects
    """
    endpoints = []
    
    for cls in classes:
        # Check if class is a controller
        is_controller = any(ann.name in ["Controller", "RestController"] for ann in cls.annotations)
        
        if not is_controller:
            continue
            
        # Get class-level path mapping
        class_path = ""
        for ann in cls.annotations:
            if ann.name == "RequestMapping":
                if "value" in ann.parameters:
                    class_path = ann.parameters["value"]
                break
        
        # Process each method in the controller
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
                
            # Check if method has web mapping annotations
            web_annotations = [ann for ann in method.annotations if ann.category == "web"]
            
            if not web_annotations:
                continue
            
            # Extract endpoint information
            endpoint_path = ""
            http_method = "GET"  # default
            
            for ann in web_annotations:
                if ann.name in ["RequestMapping", "GetMapping", "PostMapping", "PutMapping", "DeleteMapping", "PatchMapping"]:
                    # Extract path
                    if "value" in ann.parameters:
                        endpoint_path = ann.parameters["value"]
                    elif "path" in ann.parameters:
                        endpoint_path = ann.parameters["path"]
                    
                    # Extract HTTP method
                    if ann.name == "GetMapping":
                        http_method = "GET"
                    elif ann.name == "PostMapping":
                        http_method = "POST"
                    elif ann.name == "PutMapping":
                        http_method = "PUT"
                    elif ann.name == "DeleteMapping":
                        http_method = "DELETE"
                    elif ann.name == "PatchMapping":
                        http_method = "PATCH"
                    elif ann.name == "RequestMapping":
                        if "method" in ann.parameters:
                            method_value = ann.parameters["method"]
                            if isinstance(method_value, list) and len(method_value) > 0:
                                http_method = method_value[0]
                            else:
                                http_method = str(method_value)
                        else:
                            http_method = "GET"  # default for RequestMapping
                    break
            
            # Build full path
            full_path = class_path
            if endpoint_path:
                if full_path and not full_path.endswith("/") and not endpoint_path.startswith("/"):
                    full_path += "/"
                full_path += endpoint_path
            elif not full_path:
                full_path = "/"
            
            # Extract method parameters
            parameters = []
            for param in method.parameters:
                param_info = {
                    "name": param.name,
                    "type": param.type,
                    "annotations": [ann.name for ann in param.annotations if ann.category == "web"]
                }
                parameters.append(param_info)
            
            # Extract return type
            return_type = method.return_type if method.return_type != "constructor" else "void"
            
            # Create endpoint
            endpoint = Endpoint(
                path=endpoint_path or "/",
                method=http_method,
                controller_class=cls.name,
                handler_method=method.name,
                parameters=parameters,
                return_type=return_type,
                annotations=[ann.name for ann in web_annotations],
                full_path=full_path
            )
            endpoints.append(endpoint)
    
    return endpoints


def extract_mybatis_mappers_from_classes(classes: list[Class]) -> list[MyBatisMapper]:
    """Extract MyBatis Mappers from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for cls in classes:
        # Check if class is a MyBatis Mapper interface
        is_mapper = any(ann.name == "Mapper" for ann in cls.annotations)
        
        if not is_mapper:
            continue
        
        # Extract mapper methods with MyBatis annotations
        mapper_methods = []
        sql_statements = []
        
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
            
            # Check if method has MyBatis annotations
            mybatis_annotations = [ann for ann in method.annotations if ann.category == "mybatis"]
            
            if not mybatis_annotations:
                continue
            
            # Extract SQL statement information
            sql_type = "SELECT"  # default
            sql_content = ""
            parameter_type = ""
            result_type = ""
            result_map = ""
            
            for ann in mybatis_annotations:
                if ann.name in ["Select", "SelectProvider"]:
                    sql_type = "SELECT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Insert", "InsertProvider"]:
                    sql_type = "INSERT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Update", "UpdateProvider"]:
                    sql_type = "UPDATE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Delete", "DeleteProvider"]:
                    sql_type = "DELETE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                
                # Extract parameter and result type information
                if "parameterType" in ann.parameters:
                    parameter_type = ann.parameters["parameterType"]
                if "resultType" in ann.parameters:
                    result_type = ann.parameters["resultType"]
                if "resultMap" in ann.parameters:
                    result_map = ann.parameters["resultMap"]
            
            # Create method info
            method_info = {
                "name": method.name,
                "return_type": method.return_type,
                "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            mapper_methods.append(method_info)
            
            # Create SQL statement info
            sql_statement = {
                "id": method.name,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            sql_statements.append(sql_statement)
        
        # Create mapper
        mapper = MyBatisMapper(
            name=cls.name,
            type="interface",
            namespace=f"{cls.package_name}.{cls.name}",
            methods=mapper_methods,
            sql_statements=sql_statements,
            file_path=cls.file_path,
            package_name=cls.package_name
        )
        mappers.append(mapper)
    
    return mappers


def parse_mybatis_xml_file(file_path: str) -> MyBatisMapper:
    """Parse MyBatis XML mapper file.
    
    Args:
        file_path: Path to the XML mapper file
        
    Returns:
        MyBatisMapper object
    """
    import xml.etree.ElementTree as ET
    
    try:
        tree = ET.parse(file_path)
        root = tree.getroot()
        
        # Extract namespace
        namespace = root.get("namespace", "")
        
        # Extract SQL statements
        sql_statements = []
        for statement in root.findall(".//*[@id]"):
            statement_id = statement.get("id")
            tag_name = statement.tag.lower()
            
            # Determine SQL type
            sql_type = "SELECT"
            if tag_name == "insert":
                sql_type = "INSERT"
            elif tag_name == "update":
                sql_type = "UPDATE"
            elif tag_name == "delete":
                sql_type = "DELETE"
            
            # Extract SQL content
            sql_content = statement.text.strip() if statement.text else ""
            
            # Extract parameter and result information
            parameter_type = statement.get("parameterType", "")
            result_type = statement.get("resultType", "")
            result_map = statement.get("resultMap", "")
            
            sql_statement = {
                "id": statement_id,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": []
            }
            sql_statements.append(sql_statement)
        
        # Extract ResultMaps
        result_maps = []
        for result_map in root.findall(".//resultMap"):
            result_map_id = result_map.get("id")
            result_map_type = result_map.get("type", "")
            
            properties = []
            for property_elem in result_map.findall(".//result"):
                prop = {
                    "property": property_elem.get("property", ""),
                    "column": property_elem.get("column", ""),
                    "jdbc_type": property_elem.get("jdbcType", "")
                }
                properties.append(prop)
            
            result_map_info = {
                "id": result_map_id,
                "type": result_map_type,
                "properties": properties,
                "associations": [],
                "collections": []
            }
            result_maps.append(result_map_info)
        
        # Create mapper
        mapper_name = namespace.split(".")[-1] if namespace else os.path.basename(file_path).replace(".xml", "")
        package_name = ".".join(namespace.split(".")[:-1]) if namespace else ""
        
        mapper = MyBatisMapper(
            name=mapper_name,
            type="xml",
            namespace=namespace,
            methods=[],  # XML mappers don't have Java methods
            sql_statements=sql_statements,
            file_path=file_path,
            package_name=package_name
        )
        
        return mapper
        
    except ET.ParseError as e:
        print(f"Error parsing XML file {file_path}: {e}")
        return None
    except Exception as e:
        print(f"Error reading XML file {file_path}: {e}")
        return None


def extract_mybatis_xml_mappers(directory: str) -> list[MyBatisMapper]:
    """Extract MyBatis XML mappers from directory.
    
    Args:
        directory: Directory to search for XML mapper files
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith("Mapper.xml") or file.endswith("Dao.xml"):
                file_path = os.path.join(root, file)
                mapper = parse_mybatis_xml_file(file_path)
                if mapper:
                    mappers.append(mapper)
    
    return mappers


def extract_jpa_entities_from_classes(classes: list[Class]) -> list[JpaEntity]:
    """Extract JPA Entities from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of JpaEntity objects
    """
    entities = []
    
    for cls in classes:
        # Check if class is a JPA Entity
        is_entity = any(ann.name == "Entity" for ann in cls.annotations)
        
        if not is_entity:
            continue
        
        # Extract table name
        table_name = cls.name.lower()  # default table name
        for ann in cls.annotations:
            if ann.name == "Table":
                if "name" in ann.parameters:
                    table_name = ann.parameters["name"]
                break
        
        # Extract columns from properties
        columns = []
        relationships = []
        
        for prop in cls.properties:
            # Check if property has JPA column annotations
            jpa_annotations = [ann for ann in prop.annotations if ann.category == "jpa"]
            
            if jpa_annotations:
                # Extract column information
                column_name = prop.name  # default column name
                nullable = True
                unique = False
                length = 0
                precision = 0
                scale = 0
                
                for ann in jpa_annotations:
                    if ann.name == "Column":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                        if "nullable" in ann.parameters:
                            nullable = ann.parameters["nullable"]
                        if "unique" in ann.parameters:
                            unique = ann.parameters["unique"]
                        if "length" in ann.parameters:
                            length = ann.parameters["length"]
                        if "precision" in ann.parameters:
                            precision = ann.parameters["precision"]
                        if "scale" in ann.parameters:
                            scale = ann.parameters["scale"]
                    elif ann.name == "Id":
                        column_name = "id"  # Primary key column
                        nullable = False
                        unique = True
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                
                # Check for relationship annotations
                relationship_type = None
                target_entity = ""
                mapped_by = ""
                join_column = ""
                join_table = ""
                cascade = []
                fetch = "LAZY"
                
                for ann in jpa_annotations:
                    if ann.name in ["OneToOne", "OneToMany", "ManyToOne", "ManyToMany"]:
                        relationship_type = ann.name
                        if "targetEntity" in ann.parameters:
                            target_entity = ann.parameters["targetEntity"]
                        if "mappedBy" in ann.parameters:
                            mapped_by = ann.parameters["mappedBy"]
                        if "cascade" in ann.parameters:
                            cascade = ann.parameters["cascade"] if isinstance(ann.parameters["cascade"], list) else [ann.parameters["cascade"]]
                        if "fetch" in ann.parameters:
                            fetch = ann.parameters["fetch"]
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            join_column = ann.parameters["name"]
                    elif ann.name == "JoinTable":
                        if "name" in ann.parameters:
                            join_table = ann.parameters["name"]
                
                # Create column info
                column_info = {
                    "property_name": prop.name,
                    "column_name": column_name,
                    "data_type": prop.type,
                    "nullable": nullable,
                    "unique": unique,
                    "length": length,
                    "precision": precision,
                    "scale": scale,
                    "annotations": [ann.name for ann in jpa_annotations]
                }
                columns.append(column_info)
                
                # Create relationship info if it's a relationship
                if relationship_type:
                    relationship_info = {
                        "type": relationship_type,
                        "target_entity": target_entity,
                        "mapped_by": mapped_by,
                        "join_column": join_column,
                        "join_table": join_table,
                        "cascade": cascade,
                        "fetch": fetch,
                        "annotations": [ann.name for ann in jpa_annotations]
                    }
                    relationships.append(relationship_info)
        
        # Create entity
        entity = JpaEntity(
            name=cls.name,
            table_name=table_name,
            columns=columns,
            relationships=relationships,
            annotations=[ann.name for ann in cls.annotations if ann.category == "jpa"],
            package_name=cls.package_name,
            file_path=cls.file_path
        )
        entities.append(entity)
    
    return entities


def parse_yaml_config(file_path: str) -> ConfigFile:
    """Parse YAML configuration file.
    
    Args:
        file_path: Path to the YAML file
        
    Returns:
        ConfigFile object
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = yaml.safe_load(f)
        
        if not content:
            content = {}
        
        # Extract file info
        file_name = os.path.basename(file_path)
        file_type = "yaml" if file_path.endswith('.yaml') else "yml"
        
        # Extract profiles
        profiles = []
        if 'spring' in content and 'profiles' in content['spring']:
            if 'active' in content['spring']['profiles']:
                profiles = content['spring']['profiles']['active']
                if isinstance(profiles, str):
                    profiles = [profiles]
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        # Extract sections
        sections = []
        for key, value in content.items():
            if isinstance(value, dict):
                sections.append({
                    "name": key,
                    "properties": value,
                    "type": "section"
                })
        
        return ConfigFile(
            name=file_name,
            file_path=file_path,
            file_type=file_type,
            properties=content,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing YAML file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="yaml",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def parse_properties_config(file_path: str) -> ConfigFile:
    """Parse Properties configuration file.
    
    Args:
        file_path: Path to the properties file
        
    Returns:
        ConfigFile object
    """
    try:
        properties = {}
        sections = []
        profiles = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                
                # Skip empty lines and comments
                if not line or line.startswith('#'):
                    continue
                
                # Parse key=value pairs
                if '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    
                    # Remove quotes if present
                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]
                    elif value.startswith("'") and value.endswith("'"):
                        value = value[1:-1]
                    
                    properties[key] = value
                    
                    # Check for profiles
                    if key == 'spring.profiles.active':
                        profiles = [p.strip() for p in value.split(',')]
        
        # Group properties by section
        section_map = {}
        for key, value in properties.items():
            if '.' in key:
                section = key.split('.')[0]
                if section not in section_map:
                    section_map[section] = {}
                section_map[section][key] = value
            else:
                if 'root' not in section_map:
                    section_map['root'] = {}
                section_map['root'][key] = value
        
        for section_name, section_props in section_map.items():
            sections.append({
                "name": section_name,
                "properties": section_props,
                "type": "section"
            })
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties=properties,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing Properties file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def extract_database_config(config_file: ConfigFile) -> DatabaseConfig:
    """Extract database configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        DatabaseConfig object
    """
    db_config = DatabaseConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        spring_config = config_file.properties.get('spring', {})
        datasource_config = spring_config.get('datasource', {})
        jpa_config = spring_config.get('jpa', {})
        
        db_config.driver = datasource_config.get('driver-class-name', '')
        db_config.url = datasource_config.get('url', '')
        db_config.username = datasource_config.get('username', '')
        db_config.password = datasource_config.get('password', '')
        db_config.dialect = jpa_config.get('database-platform', '')
        db_config.hibernate_ddl_auto = jpa_config.get('hibernate', {}).get('ddl-auto', '')
        db_config.show_sql = jpa_config.get('show-sql', False)
        db_config.format_sql = jpa_config.get('properties', {}).get('hibernate', {}).get('format_sql', False)
        
        # Store additional JPA properties
        if 'properties' in jpa_config:
            db_config.jpa_properties = jpa_config['properties']
    
    else:
        # Properties format
        props = config_file.properties
        
        db_config.driver = props.get('spring.datasource.driver-class-name', '')
        db_config.url = props.get('spring.datasource.url', '')
        db_config.username = props.get('spring.datasource.username', '')
        db_config.password = props.get('spring.datasource.password', '')
        db_config.dialect = props.get('spring.jpa.database-platform', '')
        db_config.hibernate_ddl_auto = props.get('spring.jpa.hibernate.ddl-auto', '')
        db_config.show_sql = props.get('spring.jpa.show-sql', 'false').lower() == 'true'
        db_config.format_sql = props.get('spring.jpa.properties.hibernate.format_sql', 'false').lower() == 'true'
        
        # Store additional JPA properties
        jpa_props = {}
        for key, value in props.items():
            if key.startswith('spring.jpa.properties.'):
                jpa_props[key] = value
        db_config.jpa_properties = jpa_props
    
    return db_config


def extract_server_config(config_file: ConfigFile) -> ServerConfig:
    """Extract server configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        ServerConfig object
    """
    server_config = ServerConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        server_props = config_file.properties.get('server', {})
        
        server_config.port = server_props.get('port', 8080)
        server_config.context_path = server_props.get('servlet', {}).get('context-path', '')
        server_config.servlet_path = server_props.get('servlet', {}).get('path', '')
        
        # SSL configuration
        ssl_config = server_props.get('ssl', {})
        server_config.ssl_enabled = bool(ssl_config)
        server_config.ssl_key_store = ssl_config.get('key-store', '')
        server_config.ssl_key_store_password = ssl_config.get('key-store-password', '')
        server_config.ssl_key_store_type = ssl_config.get('key-store-type', '')
    
    else:
        # Properties format
        props = config_file.properties
        
        server_config.port = int(props.get('server.port', '8080'))
        server_config.context_path = props.get('server.servlet.context-path', '')
        server_config.servlet_path = props.get('server.servlet.path', '')
        
        # SSL configuration
        server_config.ssl_enabled = any(key.startswith('server.ssl.') for key in props.keys())
        server_config.ssl_key_store = props.get('server.ssl.key-store', '')
        server_config.ssl_key_store_password = props.get('server.ssl.key-store-password', '')
        server_config.ssl_key_store_type = props.get('server.ssl.key-store-type', '')
    
    return server_config


def extract_security_config(config_file: ConfigFile) -> SecurityConfig:
    """Extract security configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        SecurityConfig object
    """
    security_config = SecurityConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        security_props = config_file.properties.get('security', {})
        jwt_props = security_props.get('jwt', {})
        cors_props = security_props.get('cors', {})
        
        security_config.enabled = bool(security_props)
        security_config.authentication_type = security_props.get('authentication-type', '')
        security_config.jwt_secret = jwt_props.get('secret', '')
        security_config.jwt_expiration = jwt_props.get('expiration', 0)
        security_config.cors_allowed_origins = cors_props.get('allowed-origins', [])
        security_config.cors_allowed_methods = cors_props.get('allowed-methods', [])
        security_config.cors_allowed_headers = cors_props.get('allowed-headers', [])
    
    else:
        # Properties format
        props = config_file.properties
        
        security_config.enabled = any(key.startswith('security.') for key in props.keys())
        security_config.authentication_type = props.get('security.authentication-type', '')
        security_config.jwt_secret = props.get('security.jwt.secret', '')
        security_config.jwt_expiration = int(props.get('security.jwt.expiration', '0'))
        
        # CORS configuration
        origins = props.get('security.cors.allowed-origins', '')
        if origins:
            security_config.cors_allowed_origins = [o.strip() for o in origins.split(',')]
        
        methods = props.get('security.cors.allowed-methods', '')
        if methods:
            security_config.cors_allowed_methods = [m.strip() for m in methods.split(',')]
        
        headers = props.get('security.cors.allowed-headers', '')
        if headers:
            security_config.cors_allowed_headers = [h.strip() for h in headers.split(',')]
    
    return security_config


def extract_logging_config(config_file: ConfigFile) -> LoggingConfig:
    """Extract logging configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        LoggingConfig object
    """
    logging_config = LoggingConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        logging_props = config_file.properties.get('logging', {})
        
        logging_config.level = logging_props.get('level', {}).get('root', 'INFO')
        logging_config.pattern = logging_props.get('pattern', {}).get('console', '')
        logging_config.file_path = logging_props.get('file', {}).get('name', '')
        logging_config.max_file_size = logging_props.get('file', {}).get('max-size', '')
        logging_config.max_history = logging_props.get('file', {}).get('max-history', 0)
        logging_config.console_output = logging_props.get('console', {}).get('enabled', True)
    
    else:
        # Properties format
        props = config_file.properties
        
        logging_config.level = props.get('logging.level.root', 'INFO')
        logging_config.pattern = props.get('logging.pattern.console', '')
        logging_config.file_path = props.get('logging.file.name', '')
        logging_config.max_file_size = props.get('logging.file.max-size', '')
        logging_config.max_history = int(props.get('logging.file.max-history', '0'))
        logging_config.console_output = props.get('logging.console.enabled', 'true').lower() == 'true'
    
    return logging_config


def extract_config_files(directory: str) -> list[ConfigFile]:
    """Extract configuration files from directory.
    
    Args:
        directory: Directory to search for config files
        
    Returns:
        List of ConfigFile objects
    """
    config_files = []
    
    # Common config file patterns
    config_patterns = [
        "application.yml",
        "application.yaml", 
        "application.properties",
        "application-*.properties",
        "bootstrap.yml",
        "bootstrap.yaml",
        "bootstrap.properties"
    ]
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            # Check if file matches any config pattern
            is_config_file = False
            for pattern in config_patterns:
                if pattern == file or (pattern.endswith('*') and file.startswith(pattern[:-1])):
                    is_config_file = True
                    break
            
            if is_config_file:
                file_path = os.path.join(root, file)
                
                if file.endswith(('.yml', '.yaml')):
                    config_file = parse_yaml_config(file_path)
                elif file.endswith('.properties'):
                    config_file = parse_properties_config(file_path)
                else:
                    continue
                
                config_files.append(config_file)
    
    return config_files


def extract_test_classes_from_classes(classes: list[Class]) -> list[TestClass]:
    """Extract test classes from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of TestClass objects
    """
    test_classes = []
    
    for cls in classes:
        # Check if class is a test class
        test_annotations = [ann for ann in cls.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
        
        if not test_annotations:
            continue
        
        # Determine test framework and type
        test_framework = "junit"  # default
        test_type = "unit"  # default
        
        for ann in test_annotations:
            if ann.name in ["SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest", "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest"]:
                test_framework = "spring_test"
                if ann.name == "SpringBootTest":
                    test_type = "integration"
                else:
                    test_type = "slice"
            elif ann.name in ["TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass"]:
                test_framework = "testng"
            elif ann.name in ["Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll"]:
                test_framework = "junit"
        
        # Extract test methods
        test_methods = []
        setup_methods = []
        
        for method in cls.methods:
            method_annotations = [ann.name for ann in method.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
            
            if method_annotations:
                # Check if it's a setup/teardown method
                if any(ann in method_annotations for ann in ["BeforeEach", "AfterEach", "BeforeAll", "AfterAll", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass", "BeforeSuite", "AfterSuite"]):
                    setup_methods.append({
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters]
                    })
                else:
                    # Regular test method
                    test_method_info = {
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                        "assertions": [],
                        "mock_calls": [],
                        "test_data": [],
                        "expected_exceptions": [],
                        "timeout": 0,
                        "display_name": ""
                    }
                    
                    # Extract display name
                    for ann in method.annotations:
                        if ann.name == "DisplayName" and "value" in ann.parameters:
                            test_method_info["display_name"] = ann.parameters["value"]
                        elif ann.name == "Timeout" and "value" in ann.parameters:
                            test_method_info["timeout"] = ann.parameters["value"]
                    
                    # Extract expected exceptions
                    for ann in method.annotations:
                        if ann.name == "ExpectedExceptions" and "value" in ann.parameters:
                            test_method_info["expected_exceptions"] = ann.parameters["value"] if isinstance(ann.parameters["value"], list) else [ann.parameters["value"]]
                    
                    test_methods.append(test_method_info)
        
        # Extract mock dependencies
        mock_dependencies = []
        for prop in cls.properties:
            prop_annotations = [ann.name for ann in prop.annotations if classify_test_annotation(ann.name) in ["mockito", "spring_test"]]
            if prop_annotations:
                mock_dependencies.append({
                    "name": prop.name,
                    "type": prop.type,
                    "annotations": prop_annotations,
                    "mock_type": "mock" if "Mock" in prop_annotations else "spy" if "Spy" in prop_annotations else "bean"
                })
        
        # Extract test configurations
        test_configurations = []
        for ann in cls.annotations:
            if ann.name in ["TestConfiguration", "ActiveProfiles", "TestPropertySource"]:
                config_info = {
                    "name": ann.name,
                    "type": "configuration" if ann.name == "TestConfiguration" else "profile" if ann.name == "ActiveProfiles" else "property",
                    "properties": ann.parameters,
                    "active_profiles": ann.parameters.get("value", []) if ann.name == "ActiveProfiles" else [],
                    "test_slices": [],
                    "mock_beans": [],
                    "spy_beans": []
                }
                test_configurations.append(config_info)
        
        # Create test class
        test_class = TestClass(
            name=cls.name,
            package_name=cls.package_name,
            test_framework=test_framework,
            test_type=test_type,
            annotations=[ann.name for ann in test_annotations],
            test_methods=test_methods,
            setup_methods=setup_methods,
            mock_dependencies=mock_dependencies,
            test_configurations=test_configurations,
            file_path=cls.file_path
        )
        test_classes.append(test_class)
    
    return test_classes


def analyze_test_methods(test_class: TestClass, class_obj: Class) -> list[TestMethod]:
    """Analyze test methods for assertions, mock calls, and test data.
    
    Args:
        test_class: TestClass object
        class_obj: Original Class object
        
    Returns:
        List of analyzed TestMethod objects
    """
    test_methods = []
    
    for method_info in test_class.test_methods:
        # Find the corresponding method in the class
        method_obj = None
        for method in class_obj.methods:
            if method.name == method_info["name"]:
                method_obj = method
                break
        
        if not method_obj:
            continue
        
        # Analyze method source code for assertions and mock calls
        assertions = []
        mock_calls = []
        test_data = []
        
        if method_obj.source:
            source_code = method_obj.source
            
            # Find assertions (JUnit, AssertJ, etc.)
            assertion_patterns = [
                r'assert\w+\(',  # JUnit assertions
                r'assertThat\(',  # AssertJ
                r'assertEquals\(',  # JUnit
                r'assertTrue\(',  # JUnit
                r'assertFalse\(',  # JUnit
                r'assertNotNull\(',  # JUnit
                r'assertNull\(',  # JUnit
                r'assertThrows\(',  # JUnit 5
                r'assertDoesNotThrow\(',  # JUnit 5
                r'verify\(',  # Mockito verify
                r'when\(',  # Mockito when
                r'then\(',  # Mockito then
                r'given\(',  # BDDMockito given
                r'willReturn\(',  # Mockito willReturn
                r'willThrow\(',  # Mockito willThrow
            ]
            
            for pattern in assertion_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    assertions.append({
                        "type": match,
                        "line": source_code.find(match) + 1
                    })
            
            # Find mock calls
            mock_call_patterns = [
                r'(\w+)\.(\w+)\(',  # Method calls on objects
                r'mock\(',  # Mockito mock creation
                r'spy\(',  # Mockito spy creation
                r'@Mock\s+(\w+)',  # @Mock annotation
                r'@Spy\s+(\w+)',  # @Spy annotation
                r'@InjectMocks\s+(\w+)',  # @InjectMocks annotation
            ]
            
            for pattern in mock_call_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        mock_calls.append({
                            "object": match[0],
                            "method": match[1],
                            "type": "method_call"
                        })
                    else:
                        mock_calls.append({
                            "type": match,
                            "line": source_code.find(match) + 1
                        })
            
            # Find test data setup
            test_data_patterns = [
                r'new\s+(\w+)\(',  # Object creation
                r'(\w+)\s*=\s*new\s+(\w+)\(',  # Variable assignment with new
                r'@ValueSource\(',  # JUnit 5 @ValueSource
                r'@CsvSource\(',  # JUnit 5 @CsvSource
                r'@MethodSource\(',  # JUnit 5 @MethodSource
            ]
            
            for pattern in test_data_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        test_data.append({
                            "variable": match[0],
                            "type": match[1],
                            "pattern": "object_creation"
                        })
                    else:
                        test_data.append({
                            "type": match,
                            "pattern": "annotation"
                        })
        
        # Create TestMethod object
        test_method = TestMethod(
            name=method_info["name"],
            return_type=method_info["return_type"],
            annotations=method_info["annotations"],
            assertions=assertions,
            mock_calls=mock_calls,
            test_data=test_data,
            expected_exceptions=method_info["expected_exceptions"],
            timeout=method_info["timeout"],
            display_name=method_info["display_name"]
        )
        test_methods.append(test_method)
    
    return test_methods


def generate_lombok_methods(properties: list[Field], class_name: str, package_name: str) -> list[Method]:
    """Generate Lombok @Data methods (getters, setters, equals, hashCode, toString) for properties."""
    methods = []
    
    # Generate getters and setters for each property
    for prop in properties:
        # Getter
        getter_name = f"get{prop.name[0].upper()}{prop.name[1:]}"
        if prop.type == "Boolean" and prop.name.startswith("is"):
            # For boolean fields starting with 'is', use the field name as getter
            getter_name = prop.name
        
        getter = Method(
            name=getter_name,
            logical_name=f"{package_name}.{class_name}.{getter_name}",
            return_type=prop.type,
            parameters=[],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[],
            description=f"Generated getter for {prop.name} field",  # Generated method description
            ai_description=""  # TODO: Generate AI description using LLM
        )
        methods.append(getter)
        
        # Setter
        setter_name = f"set{prop.name[0].upper()}{prop.name[1:]}"
        setter_param = Field(
            name=prop.name,
            logical_name=f"{package_name}.{class_name}.{prop.name}",
            type=prop.type,
            package_name=package_name,
            class_name=class_name
        )
        
        setter = Method(
            name=setter_name,
            logical_name=f"{package_name}.{class_name}.{setter_name}",
            return_type="void",
            parameters=[setter_param],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[],
            description=f"Generated setter for {prop.name} field",  # Generated method description
            ai_description=""  # TODO: Generate AI description using LLM
        )
        methods.append(setter)
    
    # Generate equals method
    equals_method = Method(
        name="equals",
        logical_name=f"{package_name}.{class_name}.equals",
        return_type="boolean",
        parameters=[Field(name="obj", logical_name=f"{package_name}.{class_name}.obj", type="Object", package_name=package_name, class_name=class_name)],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated equals method for object comparison"  # Generated method description
    )
    methods.append(equals_method)
    
    # Generate hashCode method
    hashcode_method = Method(
        name="hashCode",
        logical_name=f"{package_name}.{class_name}.hashCode",
        return_type="int",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated hashCode method for object hashing"  # Generated method description
    )
    methods.append(hashcode_method)
    
    # Generate toString method
    tostring_method = Method(
        name="toString",
        logical_name=f"{package_name}.{class_name}.toString",
        return_type="String",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated toString method for string representation"  # Generated method description
    )
    methods.append(tostring_method)
    
    return methods


def parse_java_project(directory: str) -> tuple[list[Package], list[Class], dict[str, str], list[Bean], list[BeanDependency], list[Endpoint], list[MyBatisMapper], list[JpaEntity], list[ConfigFile], list[TestClass], list[SqlStatement], str]:
    """Parse Java project and return parsed entities."""
    logger = get_logger(__name__)
    """Parses all Java files in a directory and returns a tuple of (packages, classes, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name)."""
    
    # Extract project name from directory path
    project_name = extract_project_name(directory)
    packages = {}
    classes = {}
    class_to_package_map = {}  # Maps class_key to package_name

    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith(".java"):
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    file_content = f.read() # Read file content once
                try:
                    tree = javalang.parse.parse(file_content)
                    package_name = tree.package.name if tree.package else ""
                    
                    # Create or update package node
                    if package_name and package_name not in packages:
                        packages[package_name] = Package(
                            name=package_name
                        )
                    elif not package_name:
                        # Handle classes without package (default package)
                        package_name = "default"
                        if package_name not in packages:
                            packages[package_name] = Package(
                                name=package_name
                            )
                    
                    import_map = {}
                    for imp in tree.imports:
                        class_name = imp.path.split('.')[-1]
                        import_map[class_name] = imp.path

                    for _, class_declaration in tree.filter(
                        javalang.tree.ClassDeclaration
                    ):
                        class_name = class_declaration.name
                        class_key = f"{package_name}.{class_name}"
                        
                        # Debug: Check if this is the User class
                        if "User" in class_name:
                            logger.debug(f"Found User class - {class_key}")
                            logger.debug(f"Methods count: {len(class_declaration.methods)}")
                            logger.debug(f"Constructors count: {len(class_declaration.constructors)}")
                        
                        # Extract class source code - use the entire file content
                        class_source = file_content


                        if class_key not in classes:
                            # Parse class annotations
                            class_annotations = parse_annotations(class_declaration.annotations, "class") if hasattr(class_declaration, 'annotations') else []
                            
                            classes[class_key] = Class(
                                name=class_name,
                                logical_name=class_key,  # Add logical_name
                                file_path=file_path,
                                type="class", # Simplified for now
                                source=class_source, # Add class source
                                annotations=class_annotations,
                                package_name=package_name,
                                description=""  # TODO: Extract description from comments or annotations
                            )
                            class_to_package_map[class_key] = package_name
                        
                        # --- Start of new import logic ---
                        for imp in tree.imports:
                            classes[class_key].imports.append(imp.path)
                        # --- End of new import logic ---

                        # --- Start of new inheritance logic ---
                        # Handle 'extends'
                        if class_declaration.extends:
                            superclass_name = class_declaration.extends.name
                            # Try to resolve fully qualified name for superclass
                            if superclass_name in import_map:
                                classes[class_key].superclass = import_map[superclass_name]
                            else:
                                # Assume same package or fully qualified if not in import_map
                                classes[class_key].superclass = f"{package_name}.{superclass_name}" if package_name else superclass_name

                        # Handle 'implements'
                        if class_declaration.implements: # Add this check
                            for impl_ref in class_declaration.implements:
                                interface_name = impl_ref.name
                                # Try to resolve fully qualified name for interface
                                if interface_name in import_map:
                                    classes[class_key].interfaces.append(import_map[interface_name])
                                else:
                                    # Assume same package or fully qualified if not in import_map
                                    classes[class_key].interfaces.append(f"{package_name}.{interface_name}" if package_name else interface_name)
                        # --- End of new inheritance logic ---

                        field_map = {}
                        for field_declaration in class_declaration.fields:
                            for declarator in field_declaration.declarators:
                                field_map[declarator.name] = field_declaration.type.name
                                
                                # Parse field annotations
                                field_annotations = parse_annotations(field_declaration.annotations, "field") if hasattr(field_declaration, 'annotations') else []
                                
                                # Extract initial value if present
                                initial_value = ""
                                if hasattr(declarator, 'initializer') and declarator.initializer:
                                    # Convert the initializer to string representation
                                    if hasattr(declarator.initializer, 'value'):
                                        initial_value = str(declarator.initializer.value)
                                    elif hasattr(declarator.initializer, 'type'):
                                        initial_value = str(declarator.initializer.type)
                                    else:
                                        initial_value = str(declarator.initializer)
                                
                                prop = Field(
                                    name=declarator.name,
                                    logical_name=f"{package_name}.{class_name}.{declarator.name}",
                                    type=field_declaration.type.name,
                                    modifiers=list(field_declaration.modifiers), # Add modifiers
                                    package_name=package_name,
                                    class_name=class_name,
                                    annotations=field_annotations,
                                    initial_value=initial_value,
                                    description="",  # TODO: Extract description from comments or annotations
                                    ai_description=""  # TODO: Generate AI description using LLM
                                )
                                classes[class_key].properties.append(prop)

                        all_declarations = class_declaration.methods + class_declaration.constructors
                        
                        # Debug: Check User class method processing
                        if "User" in class_name:
                            logger.debug(f"Processing User class methods - total declarations: {len(all_declarations)}")
                            for i, decl in enumerate(all_declarations):
                                logger.debug(f"Declaration {i}: {type(decl).__name__} - {decl.name}")
                        
                        for declaration in all_declarations:
                            local_var_map = field_map.copy()
                            params = []
                            for param in declaration.parameters:
                                param_type_name = 'Unknown'
                                if hasattr(param.type, 'name'):
                                    param_type_name = param.type.name
                                local_var_map[param.name] = param_type_name
                                params.append(Field(name=param.name, logical_name=f"{package_name}.{class_name}.{param.name}", type=param_type_name, package_name=package_name, class_name=class_name))

                            if declaration.body:
                                for _, var_decl in declaration.filter(javalang.tree.LocalVariableDeclaration):
                                    for declarator in var_decl.declarators:
                                        local_var_map[declarator.name] = var_decl.type.name
                            
                            if isinstance(declaration, javalang.tree.MethodDeclaration):
                                return_type = declaration.return_type.name if declaration.return_type else "void"
                            else: # ConstructorDeclaration
                                return_type = "constructor"

                            # Extract modifiers
                            modifiers = list(declaration.modifiers)
                            
                            # Parse method annotations
                            method_annotations = parse_annotations(declaration.annotations, "method") if hasattr(declaration, 'annotations') else []

                            # Extract method source code
                            method_source = ""
                            if declaration.position:
                                lines = file_content.splitlines(keepends=True) # Keep line endings
                                start_line = declaration.position.line - 1
                                
                                # Find the end of the method by matching braces
                                brace_count = 0
                                end_line = start_line
                                for i in range(start_line, len(lines)):
                                    line = lines[i]
                                    for char in line:
                                        if char == '{':
                                            brace_count += 1
                                        elif char == '}':
                                            brace_count -= 1
                                            if brace_count == 0:
                                                end_line = i
                                                break
                                    if brace_count == 0:
                                        break
                                
                                method_source = "".join(lines[start_line:end_line + 1])

                            method = Method(
                                name=declaration.name,
                                logical_name=f"{class_key}.{declaration.name}",  # Add logical_name
                                return_type=return_type,
                                parameters=params,
                                modifiers=modifiers,
                                source=method_source, # Add method source
                                package_name=package_name,
                                annotations=method_annotations,
                                description=""  # TODO: Extract description from comments or annotations
                            )
                            classes[class_key].methods.append(method)

                            # Extract method calls with order information
                            call_order = 0
                            for _, invocation in declaration.filter(javalang.tree.MethodInvocation):
                                target_class_name = None
                                resolved_target_package = ""
                                resolved_target_class_name = ""
                                
                                if invocation.qualifier:
                                    # External method call
                                    if invocation.qualifier in local_var_map:
                                        target_class_name = local_var_map[invocation.qualifier]
                                    else:
                                        target_class_name = invocation.qualifier
                                    
                                    if target_class_name:
                                        if target_class_name == "System.out":
                                            resolved_target_package = "java.io"
                                            resolved_target_class_name = "PrintStream"
                                        else:
                                            if target_class_name in import_map:
                                                resolved_target_package = ".".join(import_map[target_class_name].split(".")[:-1])
                                            else:
                                                resolved_target_package = package_name
                                                resolved_target_class_name = target_class_name
                                else:
                                    # Same class method call
                                    resolved_target_package = package_name
                                    resolved_target_class_name = class_name

                                if resolved_target_class_name:
                                    # Get line number from invocation position
                                    line_number = invocation.position.line if invocation.position else 0

                                    call = MethodCall(
                                        source_package=package_name,
                                        source_class=class_name,
                                        source_method=declaration.name,
                                        target_package=resolved_target_package,
                                        target_class=resolved_target_class_name,
                                        target_method=invocation.member,
                                        call_order=call_order,
                                        line_number=line_number,
                                        return_type="void"  # Default return type, can be enhanced later
                                    )
                                    classes[class_key].calls.append(call)
                                    call_order += 1
                        
                        # Check for Lombok @Data annotation and generate methods
                        has_data_annotation = any(ann.name == "Data" for ann in classes[class_key].annotations)
                        if has_data_annotation:
                            logger.debug(f"Found @Data annotation on {class_name}, generating Lombok methods")
                            lombok_methods = generate_lombok_methods(classes[class_key].properties, class_name, package_name)
                            classes[class_key].methods.extend(lombok_methods)
                            logger.debug(f"Generated {len(lombok_methods)} Lombok methods for {class_name}")
                except javalang.parser.JavaSyntaxError as e:
                    print(f"Syntax error in {file_path}: {e}")
                    continue
                except Exception as e:
                    print(f"Error parsing {file_path}: {e}")
                    continue
    
    # Extract beans, analyze dependencies, extract endpoints, extract MyBatis mappers, extract JPA entities, extract config files, and extract test classes
    classes_list = list(classes.values())
    beans = extract_beans_from_classes(classes_list)
    dependencies = analyze_bean_dependencies(classes_list, beans)
    endpoints = extract_endpoints_from_classes(classes_list)
    mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
    jpa_entities = extract_jpa_entities_from_classes(classes_list)
    config_files = extract_config_files(directory)
    test_classes = extract_test_classes_from_classes(classes_list)
    
    # Also extract XML mappers
    xml_mappers = extract_mybatis_xml_mappers(directory)
    mybatis_mappers.extend(xml_mappers)
    
    # Extract SQL statements from MyBatis mappers
    sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
    
    return list(packages.values()), classes_list, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name
```

```python
import os
import yaml
import re
from pathlib import Path

import javalang

from src.models.graph_entities import Class, Method, MethodCall, Field, Package, Annotation, Bean, BeanDependency, Endpoint, MyBatisMapper, MyBatisSqlStatement, MyBatisResultMap, SqlStatement, JpaEntity, JpaColumn, JpaRelationship, ConfigFile, DatabaseConfig, ServerConfig, SecurityConfig, LoggingConfig, TestClass, TestMethod, TestConfiguration
from src.utils.logger import get_logger
from typing import Optional, List, Literal


def extract_project_name(java_source_folder: str) -> str:
    """
    JAVA_SOURCE_FOLDER 경로에서 프로젝트 이름을 추출합니다.
    
    Args:
        java_source_folder: Java 소스 폴더 경로
        
    Returns:
        프로젝트 이름 (마지막 디렉토리명)
    """
    # 경로를 정규화하고 마지막 디렉토리명 추출
    path = Path(java_source_folder).resolve()
    return path.name


def extract_sql_statements_from_mappers(mybatis_mappers: list[MyBatisMapper], project_name: str) -> list[SqlStatement]:
    """
    MyBatis mappers에서 SQL statements를 추출합니다.
    
    Args:
        mybatis_mappers: MyBatis mapper 객체들의 리스트
        project_name: 프로젝트 이름
        
    Returns:
        SqlStatement 객체들의 리스트
    """
    sql_statements = []
    
    for mapper in mybatis_mappers:
        for sql_dict in mapper.sql_statements:
            # MyBatisSqlStatement를 SqlStatement로 변환
            sql_statement = SqlStatement(
                id=sql_dict.get('id', ''),
                sql_type=sql_dict.get('sql_type', ''),
                sql_content=sql_dict.get('sql_content', ''),
                parameter_type=sql_dict.get('parameter_type', ''),
                result_type=sql_dict.get('result_type', ''),
                result_map=sql_dict.get('result_map', ''),
                mapper_name=mapper.name,
                annotations=[],  # TODO: annotations를 파싱하여 추가
                project_name=project_name
            )
            sql_statements.append(sql_statement)
    
    return sql_statements


def parse_annotations(annotations, target_type: str = "class") -> list[Annotation]:
    """Parse Java annotations into Annotation objects.
    
    Args:
        annotations: List of annotation nodes from javalang
        target_type: Type of target ("class", "method", "field")
    """
    result = []
    for annotation in annotations:
        annotation_name = annotation.name
        parameters = {}
        
        # Parse annotation parameters if they exist
        if hasattr(annotation, 'element') and annotation.element:
            for element in annotation.element:
                if hasattr(element, 'name') and hasattr(element, 'value'):
                    parameters[element.name] = element.value.value if hasattr(element.value, 'value') else str(element.value)
        
        result.append(Annotation(
            name=annotation_name,
            parameters=parameters,
            target_type=target_type,
            category=classify_springboot_annotation(annotation_name)
        ))
    
    return result


def classify_springboot_annotation(annotation_name: str) -> str:
    """Classify SpringBoot annotations into categories.
    
    Args:
        annotation_name: Name of the annotation (e.g., "@Component", "@Service")
        
    Returns:
        Category of the annotation
    """
    # Component annotations
    component_annotations = {
        "Component", "Service", "Repository", "Controller", 
        "RestController", "Configuration", "Bean"
    }
    
    # Injection annotations
    injection_annotations = {
        "Autowired", "Resource", "Value", "Qualifier", "Primary"
    }
    
    # Web annotations
    web_annotations = {
        "RequestMapping", "GetMapping", "PostMapping", "PutMapping", 
        "DeleteMapping", "PatchMapping", "RequestParam", "PathVariable",
        "RequestBody", "ResponseBody", "ResponseStatus"
    }
    
    # JPA annotations
    jpa_annotations = {
        "Entity", "Table", "Id", "Column", "OneToMany", "ManyToOne",
        "OneToOne", "ManyToMany", "JoinColumn", "GeneratedValue"
    }
    
    # Test annotations
    test_annotations = {
        "Test", "SpringBootTest", "DataJpaTest", "WebMvcTest",
        "MockBean", "SpyBean", "TestPropertySource"
    }
    
    # Security annotations
    security_annotations = {
        "PreAuthorize", "PostAuthorize", "Secured", "RolesAllowed",
        "EnableWebSecurity", "EnableGlobalMethodSecurity"
    }
    
    # Validation annotations
    validation_annotations = {
        "Valid", "NotNull", "NotBlank", "NotEmpty", "Size", "Min", "Max",
        "Pattern", "Email", "AssertTrue", "AssertFalse"
    }
    
    # MyBatis annotations
    mybatis_annotations = {
        "Mapper", "Select", "Insert", "Update", "Delete", "SelectProvider",
        "InsertProvider", "UpdateProvider", "DeleteProvider", "Results",
        "Result", "One", "Many", "MapKey", "Options", "SelectKey"
    }
    
    if annotation_name in component_annotations:
        return "component"
    elif annotation_name in injection_annotations:
        return "injection"
    elif annotation_name in web_annotations:
        return "web"
    elif annotation_name in jpa_annotations:
        return "jpa"
    elif annotation_name in test_annotations:
        return "test"
    elif annotation_name in security_annotations:
        return "security"
    elif annotation_name in validation_annotations:
        return "validation"
    elif annotation_name in mybatis_annotations:
        return "mybatis"
    else:
        return "other"


def classify_test_annotation(annotation_name: str) -> str:
    """Classify test annotations into categories.
    
    Args:
        annotation_name: Name of the annotation
        
    Returns:
        Category of the test annotation
    """
    # JUnit annotations
    junit_annotations = {
        "Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll",
        "DisplayName", "ParameterizedTest", "ValueSource", "CsvSource",
        "MethodSource", "Timeout", "Disabled", "Nested", "RepeatedTest",
        "Order", "TestMethodOrder", "TestInstance", "TestClassOrder"
    }
    
    # Spring Boot Test annotations
    spring_test_annotations = {
        "SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest",
        "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest",
        "MockBean", "SpyBean", "TestConfiguration", "ActiveProfiles",
        "TestPropertySource", "DirtiesContext", "Transactional",
        "Rollback", "Commit", "Sql", "SqlGroup", "AutoConfigureTestDatabase",
        "AutoConfigureMockMvc", "AutoConfigureWebMvc", "AutoConfigureWebClient",
        "MockMvc", "TestEntityManager", "TestContainers", "DynamicPropertySource"
    }
    
    # TestNG annotations
    testng_annotations = {
        "TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass",
        "BeforeSuite", "AfterSuite", "BeforeGroups", "AfterGroups",
        "DataProvider", "Parameters", "Groups", "Priority", "DependsOnMethods",
        "DependsOnGroups", "ExpectedExceptions", "InvocationCount",
        "SuccessPercentage", "TimeOut"
    }
    
    # Mockito annotations
    mockito_annotations = {
        "Mock", "Spy", "InjectMocks", "Captor", "MockedStatic"
    }
    
    # AssertJ annotations
    assertj_annotations = {
        "AssertJ"
    }
    
    # Other test annotations
    other_test_annotations = {
        "Ignore", "Category", "RunWith", "ExtendWith", "ContextConfiguration"
    }
    
    if annotation_name in junit_annotations:
        return "junit"
    elif annotation_name in spring_test_annotations:
        return "spring_test"
    elif annotation_name in testng_annotations:
        return "testng"
    elif annotation_name in mockito_annotations:
        return "mockito"
    elif annotation_name in assertj_annotations:
        return "assertj"
    elif annotation_name in other_test_annotations:
        return "other_test"
    else:
        return "other"


def extract_beans_from_classes(classes: list[Class]) -> list[Bean]:
    """Extract Spring Beans from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Bean objects
    """
    beans = []
    
    for cls in classes:
        # Check if class has Spring component annotations
        component_annotations = [ann for ann in cls.annotations if ann.category == "component"]
        
        # Also check for @Repository on interfaces
        has_repository_annotation = any(ann.name == "Repository" for ann in cls.annotations)
        
        if component_annotations or has_repository_annotation:
            # Determine bean type based on annotations
            bean_type = "component"  # default
            if any(ann.name in ["Service", "Service"] for ann in cls.annotations):
                bean_type = "service"
            elif any(ann.name in ["Repository", "Repository"] for ann in cls.annotations):
                bean_type = "repository"
            elif any(ann.name in ["Controller", "RestController"] for ann in cls.annotations):
                bean_type = "controller"
            elif any(ann.name in ["Configuration", "Configuration"] for ann in cls.annotations):
                bean_type = "configuration"
            
            # Determine scope (default is singleton)
            scope = "singleton"
            for ann in cls.annotations:
                if ann.name == "Scope":
                    if "value" in ann.parameters:
                        scope = ann.parameters["value"]
                    elif "prototype" in str(ann.parameters):
                        scope = "prototype"
                    elif "request" in str(ann.parameters):
                        scope = "request"
                    elif "session" in str(ann.parameters):
                        scope = "session"
            
            # Create bean name (use class name with first letter lowercase)
            bean_name = cls.name[0].lower() + cls.name[1:] if cls.name else cls.name
            
            # Check for @Bean methods in configuration classes
            bean_methods = []
            if bean_type == "configuration":
                for method in cls.methods:
                    if any(ann.name == "Bean" for ann in method.annotations):
                        bean_methods.append(method)
            
            bean = Bean(
                name=bean_name,
                type=bean_type,
                scope=scope,
                class_name=cls.name,
                package_name=cls.package_name,
                annotation_names=[ann.name for ann in cls.annotations] if cls.annotations else [],
                method_count=len(bean_methods) if bean_type == "configuration" else len(cls.methods) if cls.methods else 0,
                property_count=len(cls.properties) if cls.properties else 0
            )
            beans.append(bean)
    
    return beans


def analyze_bean_dependencies(classes: list[Class], beans: list[Bean]) -> list[BeanDependency]:
    """Analyze dependencies between Spring Beans.
    
    Args:
        classes: List of parsed Class objects
        beans: List of Bean objects
        
    Returns:
        List of BeanDependency objects
    """
    dependencies = []
    
    # Create a mapping from class names to bean names
    class_to_bean = {}
    for bean in beans:
        class_to_bean[bean.class_name] = bean.name
    
    for cls in classes:
        # Check if this class is a bean
        if cls.name not in class_to_bean:
            continue
            
        source_bean = class_to_bean[cls.name]
        
        # Analyze field injections (@Autowired, @Resource, @Value)
        for prop in cls.properties:
            if any(ann.category == "injection" for ann in prop.annotations):
                # Try to determine target bean from field type
                target_bean = None
                field_type = prop.type
                
                # Look for exact class name match
                if field_type in class_to_bean:
                    target_bean = class_to_bean[field_type]
                else:
                    # Look for interface implementations (simplified - just check if type matches any bean class name)
                    for bean in beans:
                        if field_type == bean.class_name:
                            target_bean = bean.name
                            break
                
                if target_bean:
                    injection_type = "field"
                    for ann in prop.annotations:
                        if ann.name == "Autowired":
                            injection_type = "field"
                        elif ann.name == "Resource":
                            injection_type = "field"
                        elif ann.name == "Value":
                            injection_type = "field"
                    
                    dependency = BeanDependency(
                        source_bean=source_bean,
                        target_bean=target_bean,
                        injection_type=injection_type,
                        field_name=prop.name
                    )
                    dependencies.append(dependency)
        
        # Analyze constructor injections
        for method in cls.methods:
            if method.name == cls.name:  # Constructor
                for param in method.parameters:
                    if any(ann.category == "injection" for ann in param.annotations):
                        target_bean = None
                        param_type = param.type
                        
                        if param_type in class_to_bean:
                            target_bean = class_to_bean[param_type]
                        else:
                            # Look for interface implementations (simplified)
                            for bean in beans:
                                if param_type == bean.class_name:
                                    target_bean = bean.name
                                    break
                        
                        if target_bean:
                            dependency = BeanDependency(
                                source_bean=source_bean,
                                target_bean=target_bean,
                                injection_type="constructor",
                                parameter_name=param.name
                            )
                            dependencies.append(dependency)
        
        # Analyze setter injections
        for method in cls.methods:
            if method.name.startswith("set") and len(method.parameters) == 1:
                if any(ann.category == "injection" for ann in method.annotations):
                    param = method.parameters[0]
                    target_bean = None
                    param_type = param.type
                    
                    if param_type in class_to_bean:
                        target_bean = class_to_bean[param_type]
                    else:
                        # Look for interface implementations (simplified)
                        for bean in beans:
                            if param_type == bean.class_name:
                                target_bean = bean.name
                                break
                    
                    if target_bean:
                        dependency = BeanDependency(
                            source_bean=source_bean,
                            target_bean=target_bean,
                            injection_type="setter",
                            method_name=method.name,
                            parameter_name=param.name
                        )
                        dependencies.append(dependency)
    
    return dependencies


def extract_endpoints_from_classes(classes: list[Class]) -> list[Endpoint]:
    """Extract REST API endpoints from controller classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Endpoint objects
    """
    endpoints = []
    
    for cls in classes:
        # Check if class is a controller
        is_controller = any(ann.name in ["Controller", "RestController"] for ann in cls.annotations)
        
        if not is_controller:
            continue
            
        # Get class-level path mapping
        class_path = ""
        for ann in cls.annotations:
            if ann.name == "RequestMapping":
                if "value" in ann.parameters:
                    class_path = ann.parameters["value"]
                break
        
        # Process each method in the controller
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
                
            # Check if method has web mapping annotations
            web_annotations = [ann for ann in method.annotations if ann.category == "web"]
            
            if not web_annotations:
                continue
            
            # Extract endpoint information
            endpoint_path = ""
            http_method = "GET"  # default
            
            for ann in web_annotations:
                if ann.name in ["RequestMapping", "GetMapping", "PostMapping", "PutMapping", "DeleteMapping", "PatchMapping"]:
                    # Extract path
                    if "value" in ann.parameters:
                        endpoint_path = ann.parameters["value"]
                    elif "path" in ann.parameters:
                        endpoint_path = ann.parameters["path"]
                    
                    # Extract HTTP method
                    if ann.name == "GetMapping":
                        http_method = "GET"
                    elif ann.name == "PostMapping":
                        http_method = "POST"
                    elif ann.name == "PutMapping":
                        http_method = "PUT"
                    elif ann.name == "DeleteMapping":
                        http_method = "DELETE"
                    elif ann.name == "PatchMapping":
                        http_method = "PATCH"
                    elif ann.name == "RequestMapping":
                        if "method" in ann.parameters:
                            method_value = ann.parameters["method"]
                            if isinstance(method_value, list) and len(method_value) > 0:
                                http_method = method_value[0]
                            else:
                                http_method = str(method_value)
                        else:
                            http_method = "GET"  # default for RequestMapping
                    break
            
            # Build full path
            full_path = class_path
            if endpoint_path:
                if full_path and not full_path.endswith("/") and not endpoint_path.startswith("/"):
                    full_path += "/"
                full_path += endpoint_path
            elif not full_path:
                full_path = "/"
            
            # Extract method parameters
            parameters = []
            for param in method.parameters:
                param_info = {
                    "name": param.name,
                    "type": param.type,
                    "annotations": [ann.name for ann in param.annotations if ann.category == "web"]
                }
                parameters.append(param_info)
            
            # Extract return type
            return_type = method.return_type if method.return_type != "constructor" else "void"
            
            # Create endpoint
            endpoint = Endpoint(
                path=endpoint_path or "/",
                method=http_method,
                controller_class=cls.name,
                handler_method=method.name,
                parameters=parameters,
                return_type=return_type,
                annotations=[ann.name for ann in web_annotations],
                full_path=full_path
            )
            endpoints.append(endpoint)
    
    return endpoints


def extract_mybatis_mappers_from_classes(classes: list[Class]) -> list[MyBatisMapper]:
    """Extract MyBatis Mappers from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for cls in classes:
        # Check if class is a MyBatis Mapper interface
        is_mapper = any(ann.name == "Mapper" for ann in cls.annotations)
        
        if not is_mapper:
            continue
        
        # Extract mapper methods with MyBatis annotations
        mapper_methods = []
        sql_statements = []
        
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
            
            # Check if method has MyBatis annotations
            mybatis_annotations = [ann for ann in method.annotations if ann.category == "mybatis"]
            
            if not mybatis_annotations:
                continue
            
            # Extract SQL statement information
            sql_type = "SELECT"  # default
            sql_content = ""
            parameter_type = ""
            result_type = ""
            result_map = ""
            
            for ann in mybatis_annotations:
                if ann.name in ["Select", "SelectProvider"]:
                    sql_type = "SELECT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Insert", "InsertProvider"]:
                    sql_type = "INSERT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Update", "UpdateProvider"]:
                    sql_type = "UPDATE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Delete", "DeleteProvider"]:
                    sql_type = "DELETE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                
                # Extract parameter and result type information
                if "parameterType" in ann.parameters:
                    parameter_type = ann.parameters["parameterType"]
                if "resultType" in ann.parameters:
                    result_type = ann.parameters["resultType"]
                if "resultMap" in ann.parameters:
                    result_map = ann.parameters["resultMap"]
            
            # Create method info
            method_info = {
                "name": method.name,
                "return_type": method.return_type,
                "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            mapper_methods.append(method_info)
            
            # Create SQL statement info
            sql_statement = {
                "id": method.name,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            sql_statements.append(sql_statement)
        
        # Create mapper
        mapper = MyBatisMapper(
            name=cls.name,
            type="interface",
            namespace=f"{cls.package_name}.{cls.name}",
            methods=mapper_methods,
            sql_statements=sql_statements,
            file_path=cls.file_path,
            package_name=cls.package_name
        )
        mappers.append(mapper)
    
    return mappers


def parse_mybatis_xml_file(file_path: str) -> MyBatisMapper:
    """Parse MyBatis XML mapper file.
    
    Args:
        file_path: Path to the XML mapper file
        
    Returns:
        MyBatisMapper object
    """
    import xml.etree.ElementTree as ET
    
    try:
        tree = ET.parse(file_path)
        root = tree.getroot()
        
        # Extract namespace
        namespace = root.get("namespace", "")
        
        # Extract SQL statements
        sql_statements = []
        for statement in root.findall(".//*[@id]"):
            statement_id = statement.get("id")
            tag_name = statement.tag.lower()
            
            # Determine SQL type
            sql_type = "SELECT"
            if tag_name == "insert":
                sql_type = "INSERT"
            elif tag_name == "update":
                sql_type = "UPDATE"
            elif tag_name == "delete":
                sql_type = "DELETE"
            
            # Extract SQL content
            sql_content = statement.text.strip() if statement.text else ""
            
            # Extract parameter and result information
            parameter_type = statement.get("parameterType", "")
            result_type = statement.get("resultType", "")
            result_map = statement.get("resultMap", "")
            
            sql_statement = {
                "id": statement_id,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": []
            }
            sql_statements.append(sql_statement)
        
        # Extract ResultMaps
        result_maps = []
        for result_map in root.findall(".//resultMap"):
            result_map_id = result_map.get("id")
            result_map_type = result_map.get("type", "")
            
            properties = []
            for property_elem in result_map.findall(".//result"):
                prop = {
                    "property": property_elem.get("property", ""),
                    "column": property_elem.get("column", ""),
                    "jdbc_type": property_elem.get("jdbcType", "")
                }
                properties.append(prop)
            
            result_map_info = {
                "id": result_map_id,
                "type": result_map_type,
                "properties": properties,
                "associations": [],
                "collections": []
            }
            result_maps.append(result_map_info)
        
        # Create mapper
        mapper_name = namespace.split(".")[-1] if namespace else os.path.basename(file_path).replace(".xml", "")
        package_name = ".".join(namespace.split(".")[:-1]) if namespace else ""
        
        mapper = MyBatisMapper(
            name=mapper_name,
            type="xml",
            namespace=namespace,
            methods=[],  # XML mappers don't have Java methods
            sql_statements=sql_statements,
            file_path=file_path,
            package_name=package_name
        )
        
        return mapper
        
    except ET.ParseError as e:
        print(f"Error parsing XML file {file_path}: {e}")
        return None
    except Exception as e:
        print(f"Error reading XML file {file_path}: {e}")
        return None


def extract_mybatis_xml_mappers(directory: str) -> list[MyBatisMapper]:
    """Extract MyBatis XML mappers from directory.
    
    Args:
        directory: Directory to search for XML mapper files
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith("Mapper.xml") or file.endswith("Dao.xml"):
                file_path = os.path.join(root, file)
                mapper = parse_mybatis_xml_file(file_path)
                if mapper:
                    mappers.append(mapper)
    
    return mappers


def extract_jpa_entities_from_classes(classes: list[Class]) -> list[JpaEntity]:
    """Extract JPA Entities from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of JpaEntity objects
    """
    entities = []
    
    for cls in classes:
        # Check if class is a JPA Entity
        is_entity = any(ann.name == "Entity" for ann in cls.annotations)
        
        if not is_entity:
            continue
        
        # Extract table name
        table_name = cls.name.lower()  # default table name
        for ann in cls.annotations:
            if ann.name == "Table":
                if "name" in ann.parameters:
                    table_name = ann.parameters["name"]
                break
        
        # Extract columns from properties
        columns = []
        relationships = []
        
        for prop in cls.properties:
            # Check if property has JPA column annotations
            jpa_annotations = [ann for ann in prop.annotations if ann.category == "jpa"]
            
            if jpa_annotations:
                # Extract column information
                column_name = prop.name  # default column name
                nullable = True
                unique = False
                length = 0
                precision = 0
                scale = 0
                
                for ann in jpa_annotations:
                    if ann.name == "Column":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                        if "nullable" in ann.parameters:
                            nullable = ann.parameters["nullable"]
                        if "unique" in ann.parameters:
                            unique = ann.parameters["unique"]
                        if "length" in ann.parameters:
                            length = ann.parameters["length"]
                        if "precision" in ann.parameters:
                            precision = ann.parameters["precision"]
                        if "scale" in ann.parameters:
                            scale = ann.parameters["scale"]
                    elif ann.name == "Id":
                        column_name = "id"  # Primary key column
                        nullable = False
                        unique = True
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                
                # Check for relationship annotations
                relationship_type = None
                target_entity = ""
                mapped_by = ""
                join_column = ""
                join_table = ""
                cascade = []
                fetch = "LAZY"
                
                for ann in jpa_annotations:
                    if ann.name in ["OneToOne", "OneToMany", "ManyToOne", "ManyToMany"]:
                        relationship_type = ann.name
                        if "targetEntity" in ann.parameters:
                            target_entity = ann.parameters["targetEntity"]
                        if "mappedBy" in ann.parameters:
                            mapped_by = ann.parameters["mappedBy"]
                        if "cascade" in ann.parameters:
                            cascade = ann.parameters["cascade"] if isinstance(ann.parameters["cascade"], list) else [ann.parameters["cascade"]]
                        if "fetch" in ann.parameters:
                            fetch = ann.parameters["fetch"]
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            join_column = ann.parameters["name"]
                    elif ann.name == "JoinTable":
                        if "name" in ann.parameters:
                            join_table = ann.parameters["name"]
                
                # Create column info
                column_info = {
                    "property_name": prop.name,
                    "column_name": column_name,
                    "data_type": prop.type,
                    "nullable": nullable,
                    "unique": unique,
                    "length": length,
                    "precision": precision,
                    "scale": scale,
                    "annotations": [ann.name for ann in jpa_annotations]
                }
                columns.append(column_info)
                
                # Create relationship info if it's a relationship
                if relationship_type:
                    relationship_info = {
                        "type": relationship_type,
                        "target_entity": target_entity,
                        "mapped_by": mapped_by,
                        "join_column": join_column,
                        "join_table": join_table,
                        "cascade": cascade,
                        "fetch": fetch,
                        "annotations": [ann.name for ann in jpa_annotations]
                    }
                    relationships.append(relationship_info)
        
        # Create entity
        entity = JpaEntity(
            name=cls.name,
            table_name=table_name,
            columns=columns,
            relationships=relationships,
            annotations=[ann.name for ann in cls.annotations if ann.category == "jpa"],
            package_name=cls.package_name,
            file_path=cls.file_path
        )
        entities.append(entity)
    
    return entities


def parse_yaml_config(file_path: str) -> ConfigFile:
    """Parse YAML configuration file.
    
    Args:
        file_path: Path to the YAML file
        
    Returns:
        ConfigFile object
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = yaml.safe_load(f)
        
        if not content:
            content = {}
        
        # Extract file info
        file_name = os.path.basename(file_path)
        file_type = "yaml" if file_path.endswith('.yaml') else "yml"
        
        # Extract profiles
        profiles = []
        if 'spring' in content and 'profiles' in content['spring']:
            if 'active' in content['spring']['profiles']:
                profiles = content['spring']['profiles']['active']
                if isinstance(profiles, str):
                    profiles = [profiles]
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        # Extract sections
        sections = []
        for key, value in content.items():
            if isinstance(value, dict):
                sections.append({
                    "name": key,
                    "properties": value,
                    "type": "section"
                })
        
        return ConfigFile(
            name=file_name,
            file_path=file_path,
            file_type=file_type,
            properties=content,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing YAML file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="yaml",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def parse_properties_config(file_path: str) -> ConfigFile:
    """Parse Properties configuration file.
    
    Args:
        file_path: Path to the properties file
        
    Returns:
        ConfigFile object
    """
    try:
        properties = {}
        sections = []
        profiles = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                
                # Skip empty lines and comments
                if not line or line.startswith('#'):
                    continue
                
                # Parse key=value pairs
                if '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    
                    # Remove quotes if present
                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]
                    elif value.startswith("'") and value.endswith("'"):
                        value = value[1:-1]
                    
                    properties[key] = value
                    
                    # Check for profiles
                    if key == 'spring.profiles.active':
                        profiles = [p.strip() for p in value.split(',')]
        
        # Group properties by section
        section_map = {}
        for key, value in properties.items():
            if '.' in key:
                section = key.split('.')[0]
                if section not in section_map:
                    section_map[section] = {}
                section_map[section][key] = value
            else:
                if 'root' not in section_map:
                    section_map['root'] = {}
                section_map['root'][key] = value
        
        for section_name, section_props in section_map.items():
            sections.append({
                "name": section_name,
                "properties": section_props,
                "type": "section"
            })
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties=properties,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing Properties file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def extract_database_config(config_file: ConfigFile) -> DatabaseConfig:
    """Extract database configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        DatabaseConfig object
    """
    db_config = DatabaseConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        spring_config = config_file.properties.get('spring', {})
        datasource_config = spring_config.get('datasource', {})
        jpa_config = spring_config.get('jpa', {})
        
        db_config.driver = datasource_config.get('driver-class-name', '')
        db_config.url = datasource_config.get('url', '')
        db_config.username = datasource_config.get('username', '')
        db_config.password = datasource_config.get('password', '')
        db_config.dialect = jpa_config.get('database-platform', '')
        db_config.hibernate_ddl_auto = jpa_config.get('hibernate', {}).get('ddl-auto', '')
        db_config.show_sql = jpa_config.get('show-sql', False)
        db_config.format_sql = jpa_config.get('properties', {}).get('hibernate', {}).get('format_sql', False)
        
        # Store additional JPA properties
        if 'properties' in jpa_config:
            db_config.jpa_properties = jpa_config['properties']
    
    else:
        # Properties format
        props = config_file.properties
        
        db_config.driver = props.get('spring.datasource.driver-class-name', '')
        db_config.url = props.get('spring.datasource.url', '')
        db_config.username = props.get('spring.datasource.username', '')
        db_config.password = props.get('spring.datasource.password', '')
        db_config.dialect = props.get('spring.jpa.database-platform', '')
        db_config.hibernate_ddl_auto = props.get('spring.jpa.hibernate.ddl-auto', '')
        db_config.show_sql = props.get('spring.jpa.show-sql', 'false').lower() == 'true'
        db_config.format_sql = props.get('spring.jpa.properties.hibernate.format_sql', 'false').lower() == 'true'
        
        # Store additional JPA properties
        jpa_props = {}
        for key, value in props.items():
            if key.startswith('spring.jpa.properties.'):
                jpa_props[key] = value
        db_config.jpa_properties = jpa_props
    
    return db_config


def extract_server_config(config_file: ConfigFile) -> ServerConfig:
    """Extract server configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        ServerConfig object
    """
    server_config = ServerConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        server_props = config_file.properties.get('server', {})
        
        server_config.port = server_props.get('port', 8080)
        server_config.context_path = server_props.get('servlet', {}).get('context-path', '')
        server_config.servlet_path = server_props.get('servlet', {}).get('path', '')
        
        # SSL configuration
        ssl_config = server_props.get('ssl', {})
        server_config.ssl_enabled = bool(ssl_config)
        server_config.ssl_key_store = ssl_config.get('key-store', '')
        server_config.ssl_key_store_password = ssl_config.get('key-store-password', '')
        server_config.ssl_key_store_type = ssl_config.get('key-store-type', '')
    
    else:
        # Properties format
        props = config_file.properties
        
        server_config.port = int(props.get('server.port', '8080'))
        server_config.context_path = props.get('server.servlet.context-path', '')
        server_config.servlet_path = props.get('server.servlet.path', '')
        
        # SSL configuration
        server_config.ssl_enabled = any(key.startswith('server.ssl.') for key in props.keys())
        server_config.ssl_key_store = props.get('server.ssl.key-store', '')
        server_config.ssl_key_store_password = props.get('server.ssl.key-store-password', '')
        server_config.ssl_key_store_type = props.get('server.ssl.key-store-type', '')
    
    return server_config


def extract_security_config(config_file: ConfigFile) -> SecurityConfig:
    """Extract security configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        SecurityConfig object
    """
    security_config = SecurityConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        security_props = config_file.properties.get('security', {})
        jwt_props = security_props.get('jwt', {})
        cors_props = security_props.get('cors', {})
        
        security_config.enabled = bool(security_props)
        security_config.authentication_type = security_props.get('authentication-type', '')
        security_config.jwt_secret = jwt_props.get('secret', '')
        security_config.jwt_expiration = jwt_props.get('expiration', 0)
        security_config.cors_allowed_origins = cors_props.get('allowed-origins', [])
        security_config.cors_allowed_methods = cors_props.get('allowed-methods', [])
        security_config.cors_allowed_headers = cors_props.get('allowed-headers', [])
    
    else:
        # Properties format
        props = config_file.properties
        
        security_config.enabled = any(key.startswith('security.') for key in props.keys())
        security_config.authentication_type = props.get('security.authentication-type', '')
        security_config.jwt_secret = props.get('security.jwt.secret', '')
        security_config.jwt_expiration = int(props.get('security.jwt.expiration', '0'))
        
        # CORS configuration
        origins = props.get('security.cors.allowed-origins', '')
        if origins:
            security_config.cors_allowed_origins = [o.strip() for o in origins.split(',')]
        
        methods = props.get('security.cors.allowed-methods', '')
        if methods:
            security_config.cors_allowed_methods = [m.strip() for m in methods.split(',')]
        
        headers = props.get('security.cors.allowed-headers', '')
        if headers:
            security_config.cors_allowed_headers = [h.strip() for h in headers.split(',')]
    
    return security_config


def extract_logging_config(config_file: ConfigFile) -> LoggingConfig:
    """Extract logging configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        LoggingConfig object
    """
    logging_config = LoggingConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        logging_props = config_file.properties.get('logging', {})
        
        logging_config.level = logging_props.get('level', {}).get('root', 'INFO')
        logging_config.pattern = logging_props.get('pattern', {}).get('console', '')
        logging_config.file_path = logging_props.get('file', {}).get('name', '')
        logging_config.max_file_size = logging_props.get('file', {}).get('max-size', '')
        logging_config.max_history = logging_props.get('file', {}).get('max-history', 0)
        logging_config.console_output = logging_props.get('console', {}).get('enabled', True)
    
    else:
        # Properties format
        props = config_file.properties
        
        logging_config.level = props.get('logging.level.root', 'INFO')
        logging_config.pattern = props.get('logging.pattern.console', '')
        logging_config.file_path = props.get('logging.file.name', '')
        logging_config.max_file_size = props.get('logging.file.max-size', '')
        logging_config.max_history = int(props.get('logging.file.max-history', '0'))
        logging_config.console_output = props.get('logging.console.enabled', 'true').lower() == 'true'
    
    return logging_config


def extract_config_files(directory: str) -> list[ConfigFile]:
    """Extract configuration files from directory.
    
    Args:
        directory: Directory to search for config files
        
    Returns:
        List of ConfigFile objects
    """
    config_files = []
    
    # Common config file patterns
    config_patterns = [
        "application.yml",
        "application.yaml", 
        "application.properties",
        "application-*.properties",
        "bootstrap.yml",
        "bootstrap.yaml",
        "bootstrap.properties"
    ]
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            # Check if file matches any config pattern
            is_config_file = False
            for pattern in config_patterns:
                if pattern == file or (pattern.endswith('*') and file.startswith(pattern[:-1])):
                    is_config_file = True
                    break
            
            if is_config_file:
                file_path = os.path.join(root, file)
                
                if file.endswith(('.yml', '.yaml')):
                    config_file = parse_yaml_config(file_path)
                elif file.endswith('.properties'):
                    config_file = parse_properties_config(file_path)
                else:
                    continue
                
                config_files.append(config_file)
    
    return config_files


def extract_test_classes_from_classes(classes: list[Class]) -> list[TestClass]:
    """Extract test classes from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of TestClass objects
    """
    test_classes = []
    
    for cls in classes:
        # Check if class is a test class
        test_annotations = [ann for ann in cls.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
        
        if not test_annotations:
            continue
        
        # Determine test framework and type
        test_framework = "junit"  # default
        test_type = "unit"  # default
        
        for ann in test_annotations:
            if ann.name in ["SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest", "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest"]:
                test_framework = "spring_test"
                if ann.name == "SpringBootTest":
                    test_type = "integration"
                else:
                    test_type = "slice"
            elif ann.name in ["TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass"]:
                test_framework = "testng"
            elif ann.name in ["Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll"]:
                test_framework = "junit"
        
        # Extract test methods
        test_methods = []
        setup_methods = []
        
        for method in cls.methods:
            method_annotations = [ann.name for ann in method.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
            
            if method_annotations:
                # Check if it's a setup/teardown method
                if any(ann in method_annotations for ann in ["BeforeEach", "AfterEach", "BeforeAll", "AfterAll", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass", "BeforeSuite", "AfterSuite"]):
                    setup_methods.append({
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters]
                    })
                else:
                    # Regular test method
                    test_method_info = {
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                        "assertions": [],
                        "mock_calls": [],
                        "test_data": [],
                        "expected_exceptions": [],
                        "timeout": 0,
                        "display_name": ""
                    }
                    
                    # Extract display name
                    for ann in method.annotations:
                        if ann.name == "DisplayName" and "value" in ann.parameters:
                            test_method_info["display_name"] = ann.parameters["value"]
                        elif ann.name == "Timeout" and "value" in ann.parameters:
                            test_method_info["timeout"] = ann.parameters["value"]
                    
                    # Extract expected exceptions
                    for ann in method.annotations:
                        if ann.name == "ExpectedExceptions" and "value" in ann.parameters:
                            test_method_info["expected_exceptions"] = ann.parameters["value"] if isinstance(ann.parameters["value"], list) else [ann.parameters["value"]]
                    
                    test_methods.append(test_method_info)
        
        # Extract mock dependencies
        mock_dependencies = []
        for prop in cls.properties:
            prop_annotations = [ann.name for ann in prop.annotations if classify_test_annotation(ann.name) in ["mockito", "spring_test"]]
            if prop_annotations:
                mock_dependencies.append({
                    "name": prop.name,
                    "type": prop.type,
                    "annotations": prop_annotations,
                    "mock_type": "mock" if "Mock" in prop_annotations else "spy" if "Spy" in prop_annotations else "bean"
                })
        
        # Extract test configurations
        test_configurations = []
        for ann in cls.annotations:
            if ann.name in ["TestConfiguration", "ActiveProfiles", "TestPropertySource"]:
                config_info = {
                    "name": ann.name,
                    "type": "configuration" if ann.name == "TestConfiguration" else "profile" if ann.name == "ActiveProfiles" else "property",
                    "properties": ann.parameters,
                    "active_profiles": ann.parameters.get("value", []) if ann.name == "ActiveProfiles" else [],
                    "test_slices": [],
                    "mock_beans": [],
                    "spy_beans": []
                }
                test_configurations.append(config_info)
        
        # Create test class
        test_class = TestClass(
            name=cls.name,
            package_name=cls.package_name,
            test_framework=test_framework,
            test_type=test_type,
            annotations=[ann.name for ann in test_annotations],
            test_methods=test_methods,
            setup_methods=setup_methods,
            mock_dependencies=mock_dependencies,
            test_configurations=test_configurations,
            file_path=cls.file_path
        )
        test_classes.append(test_class)
    
    return test_classes


def analyze_test_methods(test_class: TestClass, class_obj: Class) -> list[TestMethod]:
    """Analyze test methods for assertions, mock calls, and test data.
    
    Args:
        test_class: TestClass object
        class_obj: Original Class object
        
    Returns:
        List of analyzed TestMethod objects
    """
    test_methods = []
    
    for method_info in test_class.test_methods:
        # Find the corresponding method in the class
        method_obj = None
        for method in class_obj.methods:
            if method.name == method_info["name"]:
                method_obj = method
                break
        
        if not method_obj:
            continue
        
        # Analyze method source code for assertions and mock calls
        assertions = []
        mock_calls = []
        test_data = []
        
        if method_obj.source:
            source_code = method_obj.source
            
            # Find assertions (JUnit, AssertJ, etc.)
            assertion_patterns = [
                r'assert\w+\(',  # JUnit assertions
                r'assertThat\(',  # AssertJ
                r'assertEquals\(',  # JUnit
                r'assertTrue\(',  # JUnit
                r'assertFalse\(',  # JUnit
                r'assertNotNull\(',  # JUnit
                r'assertNull\(',  # JUnit
                r'assertThrows\(',  # JUnit 5
                r'assertDoesNotThrow\(',  # JUnit 5
                r'verify\(',  # Mockito verify
                r'when\(',  # Mockito when
                r'then\(',  # Mockito then
                r'given\(',  # BDDMockito given
                r'willReturn\(',  # Mockito willReturn
                r'willThrow\(',  # Mockito willThrow
            ]
            
            for pattern in assertion_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    assertions.append({
                        "type": match,
                        "line": source_code.find(match) + 1
                    })
            
            # Find mock calls
            mock_call_patterns = [
                r'(\w+)\.(\w+)\(',  # Method calls on objects
                r'mock\(',  # Mockito mock creation
                r'spy\(',  # Mockito spy creation
                r'@Mock\s+(\w+)',  # @Mock annotation
                r'@Spy\s+(\w+)',  # @Spy annotation
                r'@InjectMocks\s+(\w+)',  # @InjectMocks annotation
            ]
            
            for pattern in mock_call_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        mock_calls.append({
                            "object": match[0],
                            "method": match[1],
                            "type": "method_call"
                        })
                    else:
                        mock_calls.append({
                            "type": match,
                            "line": source_code.find(match) + 1
                        })
            
            # Find test data setup
            test_data_patterns = [
                r'new\s+(\w+)\(',  # Object creation
                r'(\w+)\s*=\s*new\s+(\w+)\(',  # Variable assignment with new
                r'@ValueSource\(',  # JUnit 5 @ValueSource
                r'@CsvSource\(',  # JUnit 5 @CsvSource
                r'@MethodSource\(',  # JUnit 5 @MethodSource
            ]
            
            for pattern in test_data_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        test_data.append({
                            "variable": match[0],
                            "type": match[1],
                            "pattern": "object_creation"
                        })
                    else:
                        test_data.append({
                            "type": match,
                            "pattern": "annotation"
                        })
        
        # Create TestMethod object
        test_method = TestMethod(
            name=method_info["name"],
            return_type=method_info["return_type"],
            annotations=method_info["annotations"],
            assertions=assertions,
            mock_calls=mock_calls,
            test_data=test_data,
            expected_exceptions=method_info["expected_exceptions"],
            timeout=method_info["timeout"],
            display_name=method_info["display_name"]
        )
        test_methods.append(test_method)
    
    return test_methods


def generate_lombok_methods(properties: list[Field], class_name: str, package_name: str) -> list[Method]:
    """Generate Lombok @Data methods (getters, setters, equals, hashCode, toString) for properties."""
    methods = []
    
    # Generate getters and setters for each property
    for prop in properties:
        # Getter
        getter_name = f"get{prop.name[0].upper()}{prop.name[1:]}"
        if prop.type == "Boolean" and prop.name.startswith("is"):
            # For boolean fields starting with 'is', use the field name as getter
            getter_name = prop.name
        
        getter = Method(
            name=getter_name,
            logical_name=f"{package_name}.{class_name}.{getter_name}",
            return_type=prop.type,
            parameters=[],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[],
            description=f"Generated getter for {prop.name} field",  # Generated method description
            ai_description=""  # TODO: Generate AI description using LLM
        )
        methods.append(getter)
        
        # Setter
        setter_name = f"set{prop.name[0].upper()}{prop.name[1:]}"
        setter_param = Field(
            name=prop.name,
            logical_name=f"{package_name}.{class_name}.{prop.name}",
            type=prop.type,
            package_name=package_name,
            class_name=class_name
        )
        
        setter = Method(
            name=setter_name,
            logical_name=f"{package_name}.{class_name}.{setter_name}",
            return_type="void",
            parameters=[setter_param],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[],
            description=f"Generated setter for {prop.name} field",  # Generated method description
            ai_description=""  # TODO: Generate AI description using LLM
        )
        methods.append(setter)
    
    # Generate equals method
    equals_method = Method(
        name="equals",
        logical_name=f"{package_name}.{class_name}.equals",
        return_type="boolean",
        parameters=[Field(name="obj", logical_name=f"{package_name}.{class_name}.obj", type="Object", package_name=package_name, class_name=class_name)],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated equals method for object comparison",  # Generated method description
        ai_description=""  # TODO: Generate AI description using LLM
    )
    methods.append(equals_method)
    
    # Generate hashCode method
    hashcode_method = Method(
        name="hashCode",
        logical_name=f"{package_name}.{class_name}.hashCode",
        return_type="int",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated hashCode method for object hashing"  # Generated method description
    )
    methods.append(hashcode_method)
    
    # Generate toString method
    tostring_method = Method(
        name="toString",
        logical_name=f"{package_name}.{class_name}.toString",
        return_type="String",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated toString method for string representation"  # Generated method description
    )
    methods.append(tostring_method)
    
    return methods


def parse_java_project(directory: str) -> tuple[list[Package], list[Class], dict[str, str], list[Bean], list[BeanDependency], list[Endpoint], list[MyBatisMapper], list[JpaEntity], list[ConfigFile], list[TestClass], list[SqlStatement], str]:
    """Parse Java project and return parsed entities."""
    logger = get_logger(__name__)
    """Parses all Java files in a directory and returns a tuple of (packages, classes, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name)."""
    
    # Extract project name from directory path
    project_name = extract_project_name(directory)
    packages = {}
    classes = {}
    class_to_package_map = {}  # Maps class_key to package_name

    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith(".java"):
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    file_content = f.read() # Read file content once
                try:
                    tree = javalang.parse.parse(file_content)
                    package_name = tree.package.name if tree.package else ""
                    
                    # Create or update package node
                    if package_name and package_name not in packages:
                        packages[package_name] = Package(
                            name=package_name
                        )
                    elif not package_name:
                        # Handle classes without package (default package)
                        package_name = "default"
                        if package_name not in packages:
                            packages[package_name] = Package(
                                name=package_name
                            )
                    
                    import_map = {}
                    for imp in tree.imports:
                        class_name = imp.path.split('.')[-1]
                        import_map[class_name] = imp.path

                    for _, class_declaration in tree.filter(
                        javalang.tree.ClassDeclaration
                    ):
                        class_name = class_declaration.name
                        class_key = f"{package_name}.{class_name}"
                        
                        # Debug: Check if this is the User class
                        if "User" in class_name:
                            logger.debug(f"Found User class - {class_key}")
                            logger.debug(f"Methods count: {len(class_declaration.methods)}")
                            logger.debug(f"Constructors count: {len(class_declaration.constructors)}")
                        
                        # Extract class source code - use the entire file content
                        class_source = file_content


                        if class_key not in classes:
                            # Parse class annotations
                            class_annotations = parse_annotations(class_declaration.annotations, "class") if hasattr(class_declaration, 'annotations') else []
                            
                            classes[class_key] = Class(
                                name=class_name,
                                logical_name=class_key,  # Add logical_name
                                file_path=file_path,
                                type="class", # Simplified for now
                                source=class_source, # Add class source
                                annotations=class_annotations,
                                package_name=package_name,
                                description=""  # TODO: Extract description from comments or annotations
                            )
                            class_to_package_map[class_key] = package_name
                        
                        # --- Start of new import logic ---
                        for imp in tree.imports:
                            classes[class_key].imports.append(imp.path)
                        # --- End of new import logic ---

                        # --- Start of new inheritance logic ---
                        # Handle 'extends'
                        if class_declaration.extends:
                            superclass_name = class_declaration.extends.name
                            # Try to resolve fully qualified name for superclass
                            if superclass_name in import_map:
                                classes[class_key].superclass = import_map[superclass_name]
                            else:
                                # Assume same package or fully qualified if not in import_map
                                classes[class_key].superclass = f"{package_name}.{superclass_name}" if package_name else superclass_name

                        # Handle 'implements'
                        if class_declaration.implements: # Add this check
                            for impl_ref in class_declaration.implements:
                                interface_name = impl_ref.name
                                # Try to resolve fully qualified name for interface
                                if interface_name in import_map:
                                    classes[class_key].interfaces.append(import_map[interface_name])
                                else:
                                    # Assume same package or fully qualified if not in import_map
                                    classes[class_key].interfaces.append(f"{package_name}.{interface_name}" if package_name else interface_name)
                        # --- End of new inheritance logic ---

                        field_map = {}
                        for field_declaration in class_declaration.fields:
                            for declarator in field_declaration.declarators:
                                field_map[declarator.name] = field_declaration.type.name
                                
                                # Parse field annotations
                                field_annotations = parse_annotations(field_declaration.annotations, "field") if hasattr(field_declaration, 'annotations') else []
                                
                                # Extract initial value if present
                                initial_value = ""
                                if hasattr(declarator, 'initializer') and declarator.initializer:
                                    # Convert the initializer to string representation
                                    if hasattr(declarator.initializer, 'value'):
                                        initial_value = str(declarator.initializer.value)
                                    elif hasattr(declarator.initializer, 'type'):
                                        initial_value = str(declarator.initializer.type)
                                    else:
                                        initial_value = str(declarator.initializer)
                                
                                prop = Field(
                                    name=declarator.name,
                                    logical_name=f"{package_name}.{class_name}.{declarator.name}",
                                    type=field_declaration.type.name,
                                    modifiers=list(field_declaration.modifiers), # Add modifiers
                                    package_name=package_name,
                                    class_name=class_name,
                                    annotations=field_annotations,
                                    initial_value=initial_value,
                                    description="",  # TODO: Extract description from comments or annotations
                                    ai_description=""  # TODO: Generate AI description using LLM
                                )
                                classes[class_key].properties.append(prop)

                        all_declarations = class_declaration.methods + class_declaration.constructors
                        
                        # Debug: Check User class method processing
                        if "User" in class_name:
                            logger.debug(f"Processing User class methods - total declarations: {len(all_declarations)}")
                            for i, decl in enumerate(all_declarations):
                                logger.debug(f"Declaration {i}: {type(decl).__name__} - {decl.name}")
                        
                        for declaration in all_declarations:
                            local_var_map = field_map.copy()
                            params = []
                            for param in declaration.parameters:
                                param_type_name = 'Unknown'
                                if hasattr(param.type, 'name'):
                                    param_type_name = param.type.name
                                local_var_map[param.name] = param_type_name
                                params.append(Field(name=param.name, logical_name=f"{package_name}.{class_name}.{param.name}", type=param_type_name, package_name=package_name, class_name=class_name))

                            if declaration.body:
                                for _, var_decl in declaration.filter(javalang.tree.LocalVariableDeclaration):
                                    for declarator in var_decl.declarators:
                                        local_var_map[declarator.name] = var_decl.type.name
                            
                            if isinstance(declaration, javalang.tree.MethodDeclaration):
                                return_type = declaration.return_type.name if declaration.return_type else "void"
                            else: # ConstructorDeclaration
                                return_type = "constructor"

                            # Extract modifiers
                            modifiers = list(declaration.modifiers)
                            
                            # Parse method annotations
                            method_annotations = parse_annotations(declaration.annotations, "method") if hasattr(declaration, 'annotations') else []

                            # Extract method source code
                            method_source = ""
                            if declaration.position:
                                lines = file_content.splitlines(keepends=True) # Keep line endings
                                start_line = declaration.position.line - 1
                                
                                # Find the end of the method by matching braces
                                brace_count = 0
                                end_line = start_line
                                for i in range(start_line, len(lines)):
                                    line = lines[i]
                                    for char in line:
                                        if char == '{':
                                            brace_count += 1
                                        elif char == '}':
                                            brace_count -= 1
                                            if brace_count == 0:
                                                end_line = i
                                                break
                                    if brace_count == 0:
                                        break
                                
                                method_source = "".join(lines[start_line:end_line + 1])

                            method = Method(
                                name=declaration.name,
                                logical_name=f"{class_key}.{declaration.name}",  # Add logical_name
                                return_type=return_type,
                                parameters=params,
                                modifiers=modifiers,
                                source=method_source, # Add method source
                                package_name=package_name,
                                annotations=method_annotations,
                                description=""  # TODO: Extract description from comments or annotations
                            )
                            classes[class_key].methods.append(method)

                            # Extract method calls with order information
                            call_order = 0
                            for _, invocation in declaration.filter(javalang.tree.MethodInvocation):
                                target_class_name = None
                                resolved_target_package = ""
                                resolved_target_class_name = ""
                                
                                if invocation.qualifier:
                                    # External method call
                                    if invocation.qualifier in local_var_map:
                                        target_class_name = local_var_map[invocation.qualifier]
                                    else:
                                        target_class_name = invocation.qualifier
                                    
                                    if target_class_name:
                                        if target_class_name == "System.out":
                                            resolved_target_package = "java.io"
                                            resolved_target_class_name = "PrintStream"
                                        else:
                                            if target_class_name in import_map:
                                                resolved_target_package = ".".join(import_map[target_class_name].split(".")[:-1])
                                            else:
                                                resolved_target_package = package_name
                                                resolved_target_class_name = target_class_name
                                else:
                                    # Same class method call
                                    resolved_target_package = package_name
                                    resolved_target_class_name = class_name

                                if resolved_target_class_name:
                                    # Get line number from invocation position
                                    line_number = invocation.position.line if invocation.position else 0

                                    call = MethodCall(
                                        source_package=package_name,
                                        source_class=class_name,
                                        source_method=declaration.name,
                                        target_package=resolved_target_package,
                                        target_class=resolved_target_class_name,
                                        target_method=invocation.member,
                                        call_order=call_order,
                                        line_number=line_number,
                                        return_type="void"  # Default return type, can be enhanced later
                                    )
                                    classes[class_key].calls.append(call)
                                    call_order += 1
                        
                        # Check for Lombok @Data annotation and generate methods
                        has_data_annotation = any(ann.name == "Data" for ann in classes[class_key].annotations)
                        if has_data_annotation:
                            logger.debug(f"Found @Data annotation on {class_name}, generating Lombok methods")
                            lombok_methods = generate_lombok_methods(classes[class_key].properties, class_name, package_name)
                            classes[class_key].methods.extend(lombok_methods)
                            logger.debug(f"Generated {len(lombok_methods)} Lombok methods for {class_name}")
                except javalang.parser.JavaSyntaxError as e:
                    print(f"Syntax error in {file_path}: {e}")
                    continue
                except Exception as e:
                    print(f"Error parsing {file_path}: {e}")
                    continue
    
    # Extract beans, analyze dependencies, extract endpoints, extract MyBatis mappers, extract JPA entities, extract config files, and extract test classes
    classes_list = list(classes.values())
    beans = extract_beans_from_classes(classes_list)
    dependencies = analyze_bean_dependencies(classes_list, beans)
    endpoints = extract_endpoints_from_classes(classes_list)
    mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
    jpa_entities = extract_jpa_entities_from_classes(classes_list)
    config_files = extract_config_files(directory)
    test_classes = extract_test_classes_from_classes(classes_list)
    
    # Also extract XML mappers
    xml_mappers = extract_mybatis_xml_mappers(directory)
    mybatis_mappers.extend(xml_mappers)
    
    # Extract SQL statements from MyBatis mappers
    sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
    
    return list(packages.values()), classes_list, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name
```

```python
import os
import yaml
import re
from pathlib import Path

import javalang

from src.models.graph_entities import Class, Method, MethodCall, Field, Package, Annotation, Bean, BeanDependency, Endpoint, MyBatisMapper, MyBatisSqlStatement, MyBatisResultMap, SqlStatement, JpaEntity, JpaColumn, JpaRelationship, ConfigFile, DatabaseConfig, ServerConfig, SecurityConfig, LoggingConfig, TestClass, TestMethod, TestConfiguration
from src.utils.logger import get_logger
from typing import Optional, List, Literal


def extract_project_name(java_source_folder: str) -> str:
    """
    JAVA_SOURCE_FOLDER 경로에서 프로젝트 이름을 추출합니다.
    
    Args:
        java_source_folder: Java 소스 폴더 경로
        
    Returns:
        프로젝트 이름 (마지막 디렉토리명)
    """
    # 경로를 정규화하고 마지막 디렉토리명 추출
    path = Path(java_source_folder).resolve()
    return path.name


def extract_sql_statements_from_mappers(mybatis_mappers: list[MyBatisMapper], project_name: str) -> list[SqlStatement]:
    """
    MyBatis mappers에서 SQL statements를 추출합니다.
    
    Args:
        mybatis_mappers: MyBatis mapper 객체들의 리스트
        project_name: 프로젝트 이름
        
    Returns:
        SqlStatement 객체들의 리스트
    """
    sql_statements = []
    
    for mapper in mybatis_mappers:
        for sql_dict in mapper.sql_statements:
            # MyBatisSqlStatement를 SqlStatement로 변환
            sql_statement = SqlStatement(
                id=sql_dict.get('id', ''),
                sql_type=sql_dict.get('sql_type', ''),
                sql_content=sql_dict.get('sql_content', ''),
                parameter_type=sql_dict.get('parameter_type', ''),
                result_type=sql_dict.get('result_type', ''),
                result_map=sql_dict.get('result_map', ''),
                mapper_name=mapper.name,
                annotations=[],  # TODO: annotations를 파싱하여 추가
                project_name=project_name
            )
            sql_statements.append(sql_statement)
    
    return sql_statements


def parse_annotations(annotations, target_type: str = "class") -> list[Annotation]:
    """Parse Java annotations into Annotation objects.
    
    Args:
        annotations: List of annotation nodes from javalang
        target_type: Type of target ("class", "method", "field")
    """
    result = []
    for annotation in annotations:
        annotation_name = annotation.name
        parameters = {}
        
        # Parse annotation parameters if they exist
        if hasattr(annotation, 'element') and annotation.element:
            for element in annotation.element:
                if hasattr(element, 'name') and hasattr(element, 'value'):
                    parameters[element.name] = element.value.value if hasattr(element.value, 'value') else str(element.value)
        
        result.append(Annotation(
            name=annotation_name,
            parameters=parameters,
            target_type=target_type,
            category=classify_springboot_annotation(annotation_name)
        ))
    
    return result


def classify_springboot_annotation(annotation_name: str) -> str:
    """Classify SpringBoot annotations into categories.
    
    Args:
        annotation_name: Name of the annotation (e.g., "@Component", "@Service")
        
    Returns:
        Category of the annotation
    """
    # Component annotations
    component_annotations = {
        "Component", "Service", "Repository", "Controller", 
        "RestController", "Configuration", "Bean"
    }
    
    # Injection annotations
    injection_annotations = {
        "Autowired", "Resource", "Value", "Qualifier", "Primary"
    }
    
    # Web annotations
    web_annotations = {
        "RequestMapping", "GetMapping", "PostMapping", "PutMapping", 
        "DeleteMapping", "PatchMapping", "RequestParam", "PathVariable",
        "RequestBody", "ResponseBody", "ResponseStatus"
    }
    
    # JPA annotations
    jpa_annotations = {
        "Entity", "Table", "Id", "Column", "OneToMany", "ManyToOne",
        "OneToOne", "ManyToMany", "JoinColumn", "GeneratedValue"
    }
    
    # Test annotations
    test_annotations = {
        "Test", "SpringBootTest", "DataJpaTest", "WebMvcTest",
        "MockBean", "SpyBean", "TestPropertySource"
    }
    
    # Security annotations
    security_annotations = {
        "PreAuthorize", "PostAuthorize", "Secured", "RolesAllowed",
        "EnableWebSecurity", "EnableGlobalMethodSecurity"
    }
    
    # Validation annotations
    validation_annotations = {
        "Valid", "NotNull", "NotBlank", "NotEmpty", "Size", "Min", "Max",
        "Pattern", "Email", "AssertTrue", "AssertFalse"
    }
    
    # MyBatis annotations
    mybatis_annotations = {
        "Mapper", "Select", "Insert", "Update", "Delete", "SelectProvider",
        "InsertProvider", "UpdateProvider", "DeleteProvider", "Results",
        "Result", "One", "Many", "MapKey", "Options", "SelectKey"
    }
    
    if annotation_name in component_annotations:
        return "component"
    elif annotation_name in injection_annotations:
        return "injection"
    elif annotation_name in web_annotations:
        return "web"
    elif annotation_name in jpa_annotations:
        return "jpa"
    elif annotation_name in test_annotations:
        return "test"
    elif annotation_name in security_annotations:
        return "security"
    elif annotation_name in validation_annotations:
        return "validation"
    elif annotation_name in mybatis_annotations:
        return "mybatis"
    else:
        return "other"


def classify_test_annotation(annotation_name: str) -> str:
    """Classify test annotations into categories.
    
    Args:
        annotation_name: Name of the annotation
        
    Returns:
        Category of the test annotation
    """
    # JUnit annotations
    junit_annotations = {
        "Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll",
        "DisplayName", "ParameterizedTest", "ValueSource", "CsvSource",
        "MethodSource", "Timeout", "Disabled", "Nested", "RepeatedTest",
        "Order", "TestMethodOrder", "TestInstance", "TestClassOrder"
    }
    
    # Spring Boot Test annotations
    spring_test_annotations = {
        "SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest",
        "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest",
        "MockBean", "SpyBean", "TestConfiguration", "ActiveProfiles",
        "TestPropertySource", "DirtiesContext", "Transactional",
        "Rollback", "Commit", "Sql", "SqlGroup", "AutoConfigureTestDatabase",
        "AutoConfigureMockMvc", "AutoConfigureWebMvc", "AutoConfigureWebClient",
        "MockMvc", "TestEntityManager", "TestContainers", "DynamicPropertySource"
    }
    
    # TestNG annotations
    testng_annotations = {
        "TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass",
        "BeforeSuite", "AfterSuite", "BeforeGroups", "AfterGroups",
        "DataProvider", "Parameters", "Groups", "Priority", "DependsOnMethods",
        "DependsOnGroups", "ExpectedExceptions", "InvocationCount",
        "SuccessPercentage", "TimeOut"
    }
    
    # Mockito annotations
    mockito_annotations = {
        "Mock", "Spy", "InjectMocks", "Captor", "MockedStatic"
    }
    
    # AssertJ annotations
    assertj_annotations = {
        "AssertJ"
    }
    
    # Other test annotations
    other_test_annotations = {
        "Ignore", "Category", "RunWith", "ExtendWith", "ContextConfiguration"
    }
    
    if annotation_name in junit_annotations:
        return "junit"
    elif annotation_name in spring_test_annotations:
        return "spring_test"
    elif annotation_name in testng_annotations:
        return "testng"
    elif annotation_name in mockito_annotations:
        return "mockito"
    elif annotation_name in assertj_annotations:
        return "assertj"
    elif annotation_name in other_test_annotations:
        return "other_test"
    else:
        return "other"


def extract_beans_from_classes(classes: list[Class]) -> list[Bean]:
    """Extract Spring Beans from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Bean objects
    """
    beans = []
    
    for cls in classes:
        # Check if class has Spring component annotations
        component_annotations = [ann for ann in cls.annotations if ann.category == "component"]
        
        # Also check for @Repository on interfaces
        has_repository_annotation = any(ann.name == "Repository" for ann in cls.annotations)
        
        if component_annotations or has_repository_annotation:
            # Determine bean type based on annotations
            bean_type = "component"  # default
            if any(ann.name in ["Service", "Service"] for ann in cls.annotations):
                bean_type = "service"
            elif any(ann.name in ["Repository", "Repository"] for ann in cls.annotations):
                bean_type = "repository"
            elif any(ann.name in ["Controller", "RestController"] for ann in cls.annotations):
                bean_type = "controller"
            elif any(ann.name in ["Configuration", "Configuration"] for ann in cls.annotations):
                bean_type = "configuration"
            
            # Determine scope (default is singleton)
            scope = "singleton"
            for ann in cls.annotations:
                if ann.name == "Scope":
                    if "value" in ann.parameters:
                        scope = ann.parameters["value"]
                    elif "prototype" in str(ann.parameters):
                        scope = "prototype"
                    elif "request" in str(ann.parameters):
                        scope = "request"
                    elif "session" in str(ann.parameters):
                        scope = "session"
            
            # Create bean name (use class name with first letter lowercase)
            bean_name = cls.name[0].lower() + cls.name[1:] if cls.name else cls.name
            
            # Check for @Bean methods in configuration classes
            bean_methods = []
            if bean_type == "configuration":
                for method in cls.methods:
                    if any(ann.name == "Bean" for ann in method.annotations):
                        bean_methods.append(method)
            
            bean = Bean(
                name=bean_name,
                type=bean_type,
                scope=scope,
                class_name=cls.name,
                package_name=cls.package_name,
                annotation_names=[ann.name for ann in cls.annotations] if cls.annotations else [],
                method_count=len(bean_methods) if bean_type == "configuration" else len(cls.methods) if cls.methods else 0,
                property_count=len(cls.properties) if cls.properties else 0
            )
            beans.append(bean)
    
    return beans


def analyze_bean_dependencies(classes: list[Class], beans: list[Bean]) -> list[BeanDependency]:
    """Analyze dependencies between Spring Beans.
    
    Args:
        classes: List of parsed Class objects
        beans: List of Bean objects
        
    Returns:
        List of BeanDependency objects
    """
    dependencies = []
    
    # Create a mapping from class names to bean names
    class_to_bean = {}
    for bean in beans:
        class_to_bean[bean.class_name] = bean.name
    
    for cls in classes:
        # Check if this class is a bean
        if cls.name not in class_to_bean:
            continue
            
        source_bean = class_to_bean[cls.name]
        
        # Analyze field injections (@Autowired, @Resource, @Value)
        for prop in cls.properties:
            if any(ann.category == "injection" for ann in prop.annotations):
                # Try to determine target bean from field type
                target_bean = None
                field_type = prop.type
                
                # Look for exact class name match
                if field_type in class_to_bean:
                    target_bean = class_to_bean[field_type]
                else:
                    # Look for interface implementations (simplified - just check if type matches any bean class name)
                    for bean in beans:
                        if field_type == bean.class_name:
                            target_bean = bean.name
                            break
                
                if target_bean:
                    injection_type = "field"
                    for ann in prop.annotations:
                        if ann.name == "Autowired":
                            injection_type = "field"
                        elif ann.name == "Resource":
                            injection_type = "field"
                        elif ann.name == "Value":
                            injection_type = "field"
                    
                    dependency = BeanDependency(
                        source_bean=source_bean,
                        target_bean=target_bean,
                        injection_type=injection_type,
                        field_name=prop.name
                    )
                    dependencies.append(dependency)
        
        # Analyze constructor injections
        for method in cls.methods:
            if method.name == cls.name:  # Constructor
                for param in method.parameters:
                    if any(ann.category == "injection" for ann in param.annotations):
                        target_bean = None
                        param_type = param.type
                        
                        if param_type in class_to_bean:
                            target_bean = class_to_bean[param_type]
                        else:
                            # Look for interface implementations (simplified)
                            for bean in beans:
                                if param_type == bean.class_name:
                                    target_bean = bean.name
                                    break
                        
                        if target_bean:
                            dependency = BeanDependency(
                                source_bean=source_bean,
                                target_bean=target_bean,
                                injection_type="constructor",
                                parameter_name=param.name
                            )
                            dependencies.append(dependency)
        
        # Analyze setter injections
        for method in cls.methods:
            if method.name.startswith("set") and len(method.parameters) == 1:
                if any(ann.category == "injection" for ann in method.annotations):
                    param = method.parameters[0]
                    target_bean = None
                    param_type = param.type
                    
                    if param_type in class_to_bean:
                        target_bean = class_to_bean[param_type]
                    else:
                        # Look for interface implementations (simplified)
                        for bean in beans:
                            if param_type == bean.class_name:
                                target_bean = bean.name
                                break
                    
                    if target_bean:
                        dependency = BeanDependency(
                            source_bean=source_bean,
                            target_bean=target_bean,
                            injection_type="setter",
                            method_name=method.name,
                            parameter_name=param.name
                        )
                        dependencies.append(dependency)
    
    return dependencies


def extract_endpoints_from_classes(classes: list[Class]) -> list[Endpoint]:
    """Extract REST API endpoints from controller classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Endpoint objects
    """
    endpoints = []
    
    for cls in classes:
        # Check if class is a controller
        is_controller = any(ann.name in ["Controller", "RestController"] for ann in cls.annotations)
        
        if not is_controller:
            continue
            
        # Get class-level path mapping
        class_path = ""
        for ann in cls.annotations:
            if ann.name == "RequestMapping":
                if "value" in ann.parameters:
                    class_path = ann.parameters["value"]
                break
        
        # Process each method in the controller
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
                
            # Check if method has web mapping annotations
            web_annotations = [ann for ann in method.annotations if ann.category == "web"]
            
            if not web_annotations:
                continue
            
            # Extract endpoint information
            endpoint_path = ""
            http_method = "GET"  # default
            
            for ann in web_annotations:
                if ann.name in ["RequestMapping", "GetMapping", "PostMapping", "PutMapping", "DeleteMapping", "PatchMapping"]:
                    # Extract path
                    if "value" in ann.parameters:
                        endpoint_path = ann.parameters["value"]
                    elif "path" in ann.parameters:
                        endpoint_path = ann.parameters["path"]
                    
                    # Extract HTTP method
                    if ann.name == "GetMapping":
                        http_method = "GET"
                    elif ann.name == "PostMapping":
                        http_method = "POST"
                    elif ann.name == "PutMapping":
                        http_method = "PUT"
                    elif ann.name == "DeleteMapping":
                        http_method = "DELETE"
                    elif ann.name == "PatchMapping":
                        http_method = "PATCH"
                    elif ann.name == "RequestMapping":
                        if "method" in ann.parameters:
                            method_value = ann.parameters["method"]
                            if isinstance(method_value, list) and len(method_value) > 0:
                                http_method = method_value[0]
                            else:
                                http_method = str(method_value)
                        else:
                            http_method = "GET"  # default for RequestMapping
                    break
            
            # Build full path
            full_path = class_path
            if endpoint_path:
                if full_path and not full_path.endswith("/") and not endpoint_path.startswith("/"):
                    full_path += "/"
                full_path += endpoint_path
            elif not full_path:
                full_path = "/"
            
            # Extract method parameters
            parameters = []
            for param in method.parameters:
                param_info = {
                    "name": param.name,
                    "type": param.type,
                    "annotations": [ann.name for ann in param.annotations if ann.category == "web"]
                }
                parameters.append(param_info)
            
            # Extract return type
            return_type = method.return_type if method.return_type != "constructor" else "void"
            
            # Create endpoint
            endpoint = Endpoint(
                path=endpoint_path or "/",
                method=http_method,
                controller_class=cls.name,
                handler_method=method.name,
                parameters=parameters,
                return_type=return_type,
                annotations=[ann.name for ann in web_annotations],
                full_path=full_path
            )
            endpoints.append(endpoint)
    
    return endpoints


def extract_mybatis_mappers_from_classes(classes: list[Class]) -> list[MyBatisMapper]:
    """Extract MyBatis Mappers from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for cls in classes:
        # Check if class is a MyBatis Mapper interface
        is_mapper = any(ann.name == "Mapper" for ann in cls.annotations)
        
        if not is_mapper:
            continue
        
        # Extract mapper methods with MyBatis annotations
        mapper_methods = []
        sql_statements = []
        
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
            
            # Check if method has MyBatis annotations
            mybatis_annotations = [ann for ann in method.annotations if ann.category == "mybatis"]
            
            if not mybatis_annotations:
                continue
            
            # Extract SQL statement information
            sql_type = "SELECT"  # default
            sql_content = ""
            parameter_type = ""
            result_type = ""
            result_map = ""
            
            for ann in mybatis_annotations:
                if ann.name in ["Select", "SelectProvider"]:
                    sql_type = "SELECT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Insert", "InsertProvider"]:
                    sql_type = "INSERT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Update", "UpdateProvider"]:
                    sql_type = "UPDATE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Delete", "DeleteProvider"]:
                    sql_type = "DELETE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                
                # Extract parameter and result type information
                if "parameterType" in ann.parameters:
                    parameter_type = ann.parameters["parameterType"]
                if "resultType" in ann.parameters:
                    result_type = ann.parameters["resultType"]
                if "resultMap" in ann.parameters:
                    result_map = ann.parameters["resultMap"]
            
            # Create method info
            method_info = {
                "name": method.name,
                "return_type": method.return_type,
                "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            mapper_methods.append(method_info)
            
            # Create SQL statement info
            sql_statement = {
                "id": method.name,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            sql_statements.append(sql_statement)
        
        # Create mapper
        mapper = MyBatisMapper(
            name=cls.name,
            type="interface",
            namespace=f"{cls.package_name}.{cls.name}",
            methods=mapper_methods,
            sql_statements=sql_statements,
            file_path=cls.file_path,
            package_name=cls.package_name
        )
        mappers.append(mapper)
    
    return mappers


def parse_mybatis_xml_file(file_path: str) -> MyBatisMapper:
    """Parse MyBatis XML mapper file.
    
    Args:
        file_path: Path to the XML mapper file
        
    Returns:
        MyBatisMapper object
    """
    import xml.etree.ElementTree as ET
    
    try:
        tree = ET.parse(file_path)
        root = tree.getroot()
        
        # Extract namespace
        namespace = root.get("namespace", "")
        
        # Extract SQL statements
        sql_statements = []
        for statement in root.findall(".//*[@id]"):
            statement_id = statement.get("id")
            tag_name = statement.tag.lower()
            
            # Determine SQL type
            sql_type = "SELECT"
            if tag_name == "insert":
                sql_type = "INSERT"
            elif tag_name == "update":
                sql_type = "UPDATE"
            elif tag_name == "delete":
                sql_type = "DELETE"
            
            # Extract SQL content
            sql_content = statement.text.strip() if statement.text else ""
            
            # Extract parameter and result information
            parameter_type = statement.get("parameterType", "")
            result_type = statement.get("resultType", "")
            result_map = statement.get("resultMap", "")
            
            sql_statement = {
                "id": statement_id,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": []
            }
            sql_statements.append(sql_statement)
        
        # Extract ResultMaps
        result_maps = []
        for result_map in root.findall(".//resultMap"):
            result_map_id = result_map.get("id")
            result_map_type = result_map.get("type", "")
            
            properties = []
            for property_elem in result_map.findall(".//result"):
                prop = {
                    "property": property_elem.get("property", ""),
                    "column": property_elem.get("column", ""),
                    "jdbc_type": property_elem.get("jdbcType", "")
                }
                properties.append(prop)
            
            result_map_info = {
                "id": result_map_id,
                "type": result_map_type,
                "properties": properties,
                "associations": [],
                "collections": []
            }
            result_maps.append(result_map_info)
        
        # Create mapper
        mapper_name = namespace.split(".")[-1] if namespace else os.path.basename(file_path).replace(".xml", "")
        package_name = ".".join(namespace.split(".")[:-1]) if namespace else ""
        
        mapper = MyBatisMapper(
            name=mapper_name,
            type="xml",
            namespace=namespace,
            methods=[],  # XML mappers don't have Java methods
            sql_statements=sql_statements,
            file_path=file_path,
            package_name=package_name
        )
        
        return mapper
        
    except ET.ParseError as e:
        print(f"Error parsing XML file {file_path}: {e}")
        return None
    except Exception as e:
        print(f"Error reading XML file {file_path}: {e}")
        return None


def extract_mybatis_xml_mappers(directory: str) -> list[MyBatisMapper]:
    """Extract MyBatis XML mappers from directory.
    
    Args:
        directory: Directory to search for XML mapper files
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith("Mapper.xml") or file.endswith("Dao.xml"):
                file_path = os.path.join(root, file)
                mapper = parse_mybatis_xml_file(file_path)
                if mapper:
                    mappers.append(mapper)
    
    return mappers


def extract_jpa_entities_from_classes(classes: list[Class]) -> list[JpaEntity]:
    """Extract JPA Entities from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of JpaEntity objects
    """
    entities = []
    
    for cls in classes:
        # Check if class is a JPA Entity
        is_entity = any(ann.name == "Entity" for ann in cls.annotations)
        
        if not is_entity:
            continue
        
        # Extract table name
        table_name = cls.name.lower()  # default table name
        for ann in cls.annotations:
            if ann.name == "Table":
                if "name" in ann.parameters:
                    table_name = ann.parameters["name"]
                break
        
        # Extract columns from properties
        columns = []
        relationships = []
        
        for prop in cls.properties:
            # Check if property has JPA column annotations
            jpa_annotations = [ann for ann in prop.annotations if ann.category == "jpa"]
            
            if jpa_annotations:
                # Extract column information
                column_name = prop.name  # default column name
                nullable = True
                unique = False
                length = 0
                precision = 0
                scale = 0
                
                for ann in jpa_annotations:
                    if ann.name == "Column":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                        if "nullable" in ann.parameters:
                            nullable = ann.parameters["nullable"]
                        if "unique" in ann.parameters:
                            unique = ann.parameters["unique"]
                        if "length" in ann.parameters:
                            length = ann.parameters["length"]
                        if "precision" in ann.parameters:
                            precision = ann.parameters["precision"]
                        if "scale" in ann.parameters:
                            scale = ann.parameters["scale"]
                    elif ann.name == "Id":
                        column_name = "id"  # Primary key column
                        nullable = False
                        unique = True
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                
                # Check for relationship annotations
                relationship_type = None
                target_entity = ""
                mapped_by = ""
                join_column = ""
                join_table = ""
                cascade = []
                fetch = "LAZY"
                
                for ann in jpa_annotations:
                    if ann.name in ["OneToOne", "OneToMany", "ManyToOne", "ManyToMany"]:
                        relationship_type = ann.name
                        if "targetEntity" in ann.parameters:
                            target_entity = ann.parameters["targetEntity"]
                        if "mappedBy" in ann.parameters:
                            mapped_by = ann.parameters["mappedBy"]
                        if "cascade" in ann.parameters:
                            cascade = ann.parameters["cascade"] if isinstance(ann.parameters["cascade"], list) else [ann.parameters["cascade"]]
                        if "fetch" in ann.parameters:
                            fetch = ann.parameters["fetch"]
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            join_column = ann.parameters["name"]
                    elif ann.name == "JoinTable":
                        if "name" in ann.parameters:
                            join_table = ann.parameters["name"]
                
                # Create column info
                column_info = {
                    "property_name": prop.name,
                    "column_name": column_name,
                    "data_type": prop.type,
                    "nullable": nullable,
                    "unique": unique,
                    "length": length,
                    "precision": precision,
                    "scale": scale,
                    "annotations": [ann.name for ann in jpa_annotations]
                }
                columns.append(column_info)
                
                # Create relationship info if it's a relationship
                if relationship_type:
                    relationship_info = {
                        "type": relationship_type,
                        "target_entity": target_entity,
                        "mapped_by": mapped_by,
                        "join_column": join_column,
                        "join_table": join_table,
                        "cascade": cascade,
                        "fetch": fetch,
                        "annotations": [ann.name for ann in jpa_annotations]
                    }
                    relationships.append(relationship_info)
        
        # Create entity
        entity = JpaEntity(
            name=cls.name,
            table_name=table_name,
            columns=columns,
            relationships=relationships,
            annotations=[ann.name for ann in cls.annotations if ann.category == "jpa"],
            package_name=cls.package_name,
            file_path=cls.file_path
        )
        entities.append(entity)
    
    return entities


def parse_yaml_config(file_path: str) -> ConfigFile:
    """Parse YAML configuration file.
    
    Args:
        file_path: Path to the YAML file
        
    Returns:
        ConfigFile object
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = yaml.safe_load(f)
        
        if not content:
            content = {}
        
        # Extract file info
        file_name = os.path.basename(file_path)
        file_type = "yaml" if file_path.endswith('.yaml') else "yml"
        
        # Extract profiles
        profiles = []
        if 'spring' in content and 'profiles' in content['spring']:
            if 'active' in content['spring']['profiles']:
                profiles = content['spring']['profiles']['active']
                if isinstance(profiles, str):
                    profiles = [profiles]
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        # Extract sections
        sections = []
        for key, value in content.items():
            if isinstance(value, dict):
                sections.append({
                    "name": key,
                    "properties": value,
                    "type": "section"
                })
        
        return ConfigFile(
            name=file_name,
            file_path=file_path,
            file_type=file_type,
            properties=content,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing YAML file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="yaml",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def parse_properties_config(file_path: str) -> ConfigFile:
    """Parse Properties configuration file.
    
    Args:
        file_path: Path to the properties file
        
    Returns:
        ConfigFile object
    """
    try:
        properties = {}
        sections = []
        profiles = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                
                # Skip empty lines and comments
                if not line or line.startswith('#'):
                    continue
                
                # Parse key=value pairs
                if '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    
                    # Remove quotes if present
                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]
                    elif value.startswith("'") and value.endswith("'"):
                        value = value[1:-1]
                    
                    properties[key] = value
                    
                    # Check for profiles
                    if key == 'spring.profiles.active':
                        profiles = [p.strip() for p in value.split(',')]
        
        # Group properties by section
        section_map = {}
        for key, value in properties.items():
            if '.' in key:
                section = key.split('.')[0]
                if section not in section_map:
                    section_map[section] = {}
                section_map[section][key] = value
            else:
                if 'root' not in section_map:
                    section_map['root'] = {}
                section_map['root'][key] = value
        
        for section_name, section_props in section_map.items():
            sections.append({
                "name": section_name,
                "properties": section_props,
                "type": "section"
            })
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties=properties,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing Properties file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def extract_database_config(config_file: ConfigFile) -> DatabaseConfig:
    """Extract database configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        DatabaseConfig object
    """
    db_config = DatabaseConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        spring_config = config_file.properties.get('spring', {})
        datasource_config = spring_config.get('datasource', {})
        jpa_config = spring_config.get('jpa', {})
        
        db_config.driver = datasource_config.get('driver-class-name', '')
        db_config.url = datasource_config.get('url', '')
        db_config.username = datasource_config.get('username', '')
        db_config.password = datasource_config.get('password', '')
        db_config.dialect = jpa_config.get('database-platform', '')
        db_config.hibernate_ddl_auto = jpa_config.get('hibernate', {}).get('ddl-auto', '')
        db_config.show_sql = jpa_config.get('show-sql', False)
        db_config.format_sql = jpa_config.get('properties', {}).get('hibernate', {}).get('format_sql', False)
        
        # Store additional JPA properties
        if 'properties' in jpa_config:
            db_config.jpa_properties = jpa_config['properties']
    
    else:
        # Properties format
        props = config_file.properties
        
        db_config.driver = props.get('spring.datasource.driver-class-name', '')
        db_config.url = props.get('spring.datasource.url', '')
        db_config.username = props.get('spring.datasource.username', '')
        db_config.password = props.get('spring.datasource.password', '')
        db_config.dialect = props.get('spring.jpa.database-platform', '')
        db_config.hibernate_ddl_auto = props.get('spring.jpa.hibernate.ddl-auto', '')
        db_config.show_sql = props.get('spring.jpa.show-sql', 'false').lower() == 'true'
        db_config.format_sql = props.get('spring.jpa.properties.hibernate.format_sql', 'false').lower() == 'true'
        
        # Store additional JPA properties
        jpa_props = {}
        for key, value in props.items():
            if key.startswith('spring.jpa.properties.'):
                jpa_props[key] = value
        db_config.jpa_properties = jpa_props
    
    return db_config


def extract_server_config(config_file: ConfigFile) -> ServerConfig:
    """Extract server configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        ServerConfig object
    """
    server_config = ServerConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        server_props = config_file.properties.get('server', {})
        
        server_config.port = server_props.get('port', 8080)
        server_config.context_path = server_props.get('servlet', {}).get('context-path', '')
        server_config.servlet_path = server_props.get('servlet', {}).get('path', '')
        
        # SSL configuration
        ssl_config = server_props.get('ssl', {})
        server_config.ssl_enabled = bool(ssl_config)
        server_config.ssl_key_store = ssl_config.get('key-store', '')
        server_config.ssl_key_store_password = ssl_config.get('key-store-password', '')
        server_config.ssl_key_store_type = ssl_config.get('key-store-type', '')
    
    else:
        # Properties format
        props = config_file.properties
        
        server_config.port = int(props.get('server.port', '8080'))
        server_config.context_path = props.get('server.servlet.context-path', '')
        server_config.servlet_path = props.get('server.servlet.path', '')
        
        # SSL configuration
        server_config.ssl_enabled = any(key.startswith('server.ssl.') for key in props.keys())
        server_config.ssl_key_store = props.get('server.ssl.key-store', '')
        server_config.ssl_key_store_password = props.get('server.ssl.key-store-password', '')
        server_config.ssl_key_store_type = props.get('server.ssl.key-store-type', '')
    
    return server_config


def extract_security_config(config_file: ConfigFile) -> SecurityConfig:
    """Extract security configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        SecurityConfig object
    """
    security_config = SecurityConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        security_props = config_file.properties.get('security', {})
        jwt_props = security_props.get('jwt', {})
        cors_props = security_props.get('cors', {})
        
        security_config.enabled = bool(security_props)
        security_config.authentication_type = security_props.get('authentication-type', '')
        security_config.jwt_secret = jwt_props.get('secret', '')
        security_config.jwt_expiration = jwt_props.get('expiration', 0)
        security_config.cors_allowed_origins = cors_props.get('allowed-origins', [])
        security_config.cors_allowed_methods = cors_props.get('allowed-methods', [])
        security_config.cors_allowed_headers = cors_props.get('allowed-headers', [])
    
    else:
        # Properties format
        props = config_file.properties
        
        security_config.enabled = any(key.startswith('security.') for key in props.keys())
        security_config.authentication_type = props.get('security.authentication-type', '')
        security_config.jwt_secret = props.get('security.jwt.secret', '')
        security_config.jwt_expiration = int(props.get('security.jwt.expiration', '0'))
        
        # CORS configuration
        origins = props.get('security.cors.allowed-origins', '')
        if origins:
            security_config.cors_allowed_origins = [o.strip() for o in origins.split(',')]
        
        methods = props.get('security.cors.allowed-methods', '')
        if methods:
            security_config.cors_allowed_methods = [m.strip() for m in methods.split(',')]
        
        headers = props.get('security.cors.allowed-headers', '')
        if headers:
            security_config.cors_allowed_headers = [h.strip() for h in headers.split(',')]
    
    return security_config


def extract_logging_config(config_file: ConfigFile) -> LoggingConfig:
    """Extract logging configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        LoggingConfig object
    """
    logging_config = LoggingConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        logging_props = config_file.properties.get('logging', {})
        
        logging_config.level = logging_props.get('level', {}).get('root', 'INFO')
        logging_config.pattern = logging_props.get('pattern', {}).get('console', '')
        logging_config.file_path = logging_props.get('file', {}).get('name', '')
        logging_config.max_file_size = logging_props.get('file', {}).get('max-size', '')
        logging_config.max_history = logging_props.get('file', {}).get('max-history', 0)
        logging_config.console_output = logging_props.get('console', {}).get('enabled', True)
    
    else:
        # Properties format
        props = config_file.properties
        
        logging_config.level = props.get('logging.level.root', 'INFO')
        logging_config.pattern = props.get('logging.pattern.console', '')
        logging_config.file_path = props.get('logging.file.name', '')
        logging_config.max_file_size = props.get('logging.file.max-size', '')
        logging_config.max_history = int(props.get('logging.file.max-history', '0'))
        logging_config.console_output = props.get('logging.console.enabled', 'true').lower() == 'true'
    
    return logging_config


def extract_config_files(directory: str) -> list[ConfigFile]:
    """Extract configuration files from directory.
    
    Args:
        directory: Directory to search for config files
        
    Returns:
        List of ConfigFile objects
    """
    config_files = []
    
    # Common config file patterns
    config_patterns = [
        "application.yml",
        "application.yaml", 
        "application.properties",
        "application-*.properties",
        "bootstrap.yml",
        "bootstrap.yaml",
        "bootstrap.properties"
    ]
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            # Check if file matches any config pattern
            is_config_file = False
            for pattern in config_patterns:
                if pattern == file or (pattern.endswith('*') and file.startswith(pattern[:-1])):
                    is_config_file = True
                    break
            
            if is_config_file:
                file_path = os.path.join(root, file)
                
                if file.endswith(('.yml', '.yaml')):
                    config_file = parse_yaml_config(file_path)
                elif file.endswith('.properties'):
                    config_file = parse_properties_config(file_path)
                else:
                    continue
                
                config_files.append(config_file)
    
    return config_files


def extract_test_classes_from_classes(classes: list[Class]) -> list[TestClass]:
    """Extract test classes from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of TestClass objects
    """
    test_classes = []
    
    for cls in classes:
        # Check if class is a test class
        test_annotations = [ann for ann in cls.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
        
        if not test_annotations:
            continue
        
        # Determine test framework and type
        test_framework = "junit"  # default
        test_type = "unit"  # default
        
        for ann in test_annotations:
            if ann.name in ["SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest", "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest"]:
                test_framework = "spring_test"
                if ann.name == "SpringBootTest":
                    test_type = "integration"
                else:
                    test_type = "slice"
            elif ann.name in ["TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass"]:
                test_framework = "testng"
            elif ann.name in ["Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll"]:
                test_framework = "junit"
        
        # Extract test methods
        test_methods = []
        setup_methods = []
        
        for method in cls.methods:
            method_annotations = [ann.name for ann in method.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
            
            if method_annotations:
                # Check if it's a setup/teardown method
                if any(ann in method_annotations for ann in ["BeforeEach", "AfterEach", "BeforeAll", "AfterAll", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass", "BeforeSuite", "AfterSuite"]):
                    setup_methods.append({
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters]
                    })
                else:
                    # Regular test method
                    test_method_info = {
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                        "assertions": [],
                        "mock_calls": [],
                        "test_data": [],
                        "expected_exceptions": [],
                        "timeout": 0,
                        "display_name": ""
                    }
                    
                    # Extract display name
                    for ann in method.annotations:
                        if ann.name == "DisplayName" and "value" in ann.parameters:
                            test_method_info["display_name"] = ann.parameters["value"]
                        elif ann.name == "Timeout" and "value" in ann.parameters:
                            test_method_info["timeout"] = ann.parameters["value"]
                    
                    # Extract expected exceptions
                    for ann in method.annotations:
                        if ann.name == "ExpectedExceptions" and "value" in ann.parameters:
                            test_method_info["expected_exceptions"] = ann.parameters["value"] if isinstance(ann.parameters["value"], list) else [ann.parameters["value"]]
                    
                    test_methods.append(test_method_info)
        
        # Extract mock dependencies
        mock_dependencies = []
        for prop in cls.properties:
            prop_annotations = [ann.name for ann in prop.annotations if classify_test_annotation(ann.name) in ["mockito", "spring_test"]]
            if prop_annotations:
                mock_dependencies.append({
                    "name": prop.name,
                    "type": prop.type,
                    "annotations": prop_annotations,
                    "mock_type": "mock" if "Mock" in prop_annotations else "spy" if "Spy" in prop_annotations else "bean"
                })
        
        # Extract test configurations
        test_configurations = []
        for ann in cls.annotations:
            if ann.name in ["TestConfiguration", "ActiveProfiles", "TestPropertySource"]:
                config_info = {
                    "name": ann.name,
                    "type": "configuration" if ann.name == "TestConfiguration" else "profile" if ann.name == "ActiveProfiles" else "property",
                    "properties": ann.parameters,
                    "active_profiles": ann.parameters.get("value", []) if ann.name == "ActiveProfiles" else [],
                    "test_slices": [],
                    "mock_beans": [],
                    "spy_beans": []
                }
                test_configurations.append(config_info)
        
        # Create test class
        test_class = TestClass(
            name=cls.name,
            package_name=cls.package_name,
            test_framework=test_framework,
            test_type=test_type,
            annotations=[ann.name for ann in test_annotations],
            test_methods=test_methods,
            setup_methods=setup_methods,
            mock_dependencies=mock_dependencies,
            test_configurations=test_configurations,
            file_path=cls.file_path
        )
        test_classes.append(test_class)
    
    return test_classes


def analyze_test_methods(test_class: TestClass, class_obj: Class) -> list[TestMethod]:
    """Analyze test methods for assertions, mock calls, and test data.
    
    Args:
        test_class: TestClass object
        class_obj: Original Class object
        
    Returns:
        List of analyzed TestMethod objects
    """
    test_methods = []
    
    for method_info in test_class.test_methods:
        # Find the corresponding method in the class
        method_obj = None
        for method in class_obj.methods:
            if method.name == method_info["name"]:
                method_obj = method
                break
        
        if not method_obj:
            continue
        
        # Analyze method source code for assertions and mock calls
        assertions = []
        mock_calls = []
        test_data = []
        
        if method_obj.source:
            source_code = method_obj.source
            
            # Find assertions (JUnit, AssertJ, etc.)
            assertion_patterns = [
                r'assert\w+\(',  # JUnit assertions
                r'assertThat\(',  # AssertJ
                r'assertEquals\(',  # JUnit
                r'assertTrue\(',  # JUnit
                r'assertFalse\(',  # JUnit
                r'assertNotNull\(',  # JUnit
                r'assertNull\(',  # JUnit
                r'assertThrows\(',  # JUnit 5
                r'assertDoesNotThrow\(',  # JUnit 5
                r'verify\(',  # Mockito verify
                r'when\(',  # Mockito when
                r'then\(',  # Mockito then
                r'given\(',  # BDDMockito given
                r'willReturn\(',  # Mockito willReturn
                r'willThrow\(',  # Mockito willThrow
            ]
            
            for pattern in assertion_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    assertions.append({
                        "type": match,
                        "line": source_code.find(match) + 1
                    })
            
            # Find mock calls
            mock_call_patterns = [
                r'(\w+)\.(\w+)\(',  # Method calls on objects
                r'mock\(',  # Mockito mock creation
                r'spy\(',  # Mockito spy creation
                r'@Mock\s+(\w+)',  # @Mock annotation
                r'@Spy\s+(\w+)',  # @Spy annotation
                r'@InjectMocks\s+(\w+)',  # @InjectMocks annotation
            ]
            
            for pattern in mock_call_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        mock_calls.append({
                            "object": match[0],
                            "method": match[1],
                            "type": "method_call"
                        })
                    else:
                        mock_calls.append({
                            "type": match,
                            "line": source_code.find(match) + 1
                        })
            
            # Find test data setup
            test_data_patterns = [
                r'new\s+(\w+)\(',  # Object creation
                r'(\w+)\s*=\s*new\s+(\w+)\(',  # Variable assignment with new
                r'@ValueSource\(',  # JUnit 5 @ValueSource
                r'@CsvSource\(',  # JUnit 5 @CsvSource
                r'@MethodSource\(',  # JUnit 5 @MethodSource
            ]
            
            for pattern in test_data_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        test_data.append({
                            "variable": match[0],
                            "type": match[1],
                            "pattern": "object_creation"
                        })
                    else:
                        test_data.append({
                            "type": match,
                            "pattern": "annotation"
                        })
        
        # Create TestMethod object
        test_method = TestMethod(
            name=method_info["name"],
            return_type=method_info["return_type"],
            annotations=method_info["annotations"],
            assertions=assertions,
            mock_calls=mock_calls,
            test_data=test_data,
            expected_exceptions=method_info["expected_exceptions"],
            timeout=method_info["timeout"],
            display_name=method_info["display_name"]
        )
        test_methods.append(test_method)
    
    return test_methods


def generate_lombok_methods(properties: list[Field], class_name: str, package_name: str) -> list[Method]:
    """Generate Lombok @Data methods (getters, setters, equals, hashCode, toString) for properties."""
    methods = []
    
    # Generate getters and setters for each property
    for prop in properties:
        # Getter
        getter_name = f"get{prop.name[0].upper()}{prop.name[1:]}"
        if prop.type == "Boolean" and prop.name.startswith("is"):
            # For boolean fields starting with 'is', use the field name as getter
            getter_name = prop.name
        
        getter = Method(
            name=getter_name,
            logical_name=f"{package_name}.{class_name}.{getter_name}",
            return_type=prop.type,
            parameters=[],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[],
            description=f"Generated getter for {prop.name} field",  # Generated method description
            ai_description=""  # TODO: Generate AI description using LLM
        )
        methods.append(getter)
        
        # Setter
        setter_name = f"set{prop.name[0].upper()}{prop.name[1:]}"
        setter_param = Field(
            name=prop.name,
            logical_name=f"{package_name}.{class_name}.{prop.name}",
            type=prop.type,
            package_name=package_name,
            class_name=class_name
        )
        
        setter = Method(
            name=setter_name,
            logical_name=f"{package_name}.{class_name}.{setter_name}",
            return_type="void",
            parameters=[setter_param],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[],
            description=f"Generated setter for {prop.name} field",  # Generated method description
            ai_description=""  # TODO: Generate AI description using LLM
        )
        methods.append(setter)
    
    # Generate equals method
    equals_method = Method(
        name="equals",
        logical_name=f"{package_name}.{class_name}.equals",
        return_type="boolean",
        parameters=[Field(name="obj", logical_name=f"{package_name}.{class_name}.obj", type="Object", package_name=package_name, class_name=class_name)],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated equals method for object comparison",  # Generated method description
        ai_description=""  # TODO: Generate AI description using LLM
    )
    methods.append(equals_method)
    
    # Generate hashCode method
    hashcode_method = Method(
        name="hashCode",
        logical_name=f"{package_name}.{class_name}.hashCode",
        return_type="int",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated hashCode method for object hashing",  # Generated method description
        ai_description=""  # TODO: Generate AI description using LLM
    )
    methods.append(hashcode_method)
    
    # Generate toString method
    tostring_method = Method(
        name="toString",
        logical_name=f"{package_name}.{class_name}.toString",
        return_type="String",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated toString method for string representation"  # Generated method description
    )
    methods.append(tostring_method)
    
    return methods


def parse_java_project(directory: str) -> tuple[list[Package], list[Class], dict[str, str], list[Bean], list[BeanDependency], list[Endpoint], list[MyBatisMapper], list[JpaEntity], list[ConfigFile], list[TestClass], list[SqlStatement], str]:
    """Parse Java project and return parsed entities."""
    logger = get_logger(__name__)
    """Parses all Java files in a directory and returns a tuple of (packages, classes, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name)."""
    
    # Extract project name from directory path
    project_name = extract_project_name(directory)
    packages = {}
    classes = {}
    class_to_package_map = {}  # Maps class_key to package_name

    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith(".java"):
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    file_content = f.read() # Read file content once
                try:
                    tree = javalang.parse.parse(file_content)
                    package_name = tree.package.name if tree.package else ""
                    
                    # Create or update package node
                    if package_name and package_name not in packages:
                        packages[package_name] = Package(
                            name=package_name
                        )
                    elif not package_name:
                        # Handle classes without package (default package)
                        package_name = "default"
                        if package_name not in packages:
                            packages[package_name] = Package(
                                name=package_name
                            )
                    
                    import_map = {}
                    for imp in tree.imports:
                        class_name = imp.path.split('.')[-1]
                        import_map[class_name] = imp.path

                    for _, class_declaration in tree.filter(
                        javalang.tree.ClassDeclaration
                    ):
                        class_name = class_declaration.name
                        class_key = f"{package_name}.{class_name}"
                        
                        # Debug: Check if this is the User class
                        if "User" in class_name:
                            logger.debug(f"Found User class - {class_key}")
                            logger.debug(f"Methods count: {len(class_declaration.methods)}")
                            logger.debug(f"Constructors count: {len(class_declaration.constructors)}")
                        
                        # Extract class source code - use the entire file content
                        class_source = file_content


                        if class_key not in classes:
                            # Parse class annotations
                            class_annotations = parse_annotations(class_declaration.annotations, "class") if hasattr(class_declaration, 'annotations') else []
                            
                            classes[class_key] = Class(
                                name=class_name,
                                logical_name=class_key,  # Add logical_name
                                file_path=file_path,
                                type="class", # Simplified for now
                                source=class_source, # Add class source
                                annotations=class_annotations,
                                package_name=package_name,
                                description=""  # TODO: Extract description from comments or annotations
                            )
                            class_to_package_map[class_key] = package_name
                        
                        # --- Start of new import logic ---
                        for imp in tree.imports:
                            classes[class_key].imports.append(imp.path)
                        # --- End of new import logic ---

                        # --- Start of new inheritance logic ---
                        # Handle 'extends'
                        if class_declaration.extends:
                            superclass_name = class_declaration.extends.name
                            # Try to resolve fully qualified name for superclass
                            if superclass_name in import_map:
                                classes[class_key].superclass = import_map[superclass_name]
                            else:
                                # Assume same package or fully qualified if not in import_map
                                classes[class_key].superclass = f"{package_name}.{superclass_name}" if package_name else superclass_name

                        # Handle 'implements'
                        if class_declaration.implements: # Add this check
                            for impl_ref in class_declaration.implements:
                                interface_name = impl_ref.name
                                # Try to resolve fully qualified name for interface
                                if interface_name in import_map:
                                    classes[class_key].interfaces.append(import_map[interface_name])
                                else:
                                    # Assume same package or fully qualified if not in import_map
                                    classes[class_key].interfaces.append(f"{package_name}.{interface_name}" if package_name else interface_name)
                        # --- End of new inheritance logic ---

                        field_map = {}
                        for field_declaration in class_declaration.fields:
                            for declarator in field_declaration.declarators:
                                field_map[declarator.name] = field_declaration.type.name
                                
                                # Parse field annotations
                                field_annotations = parse_annotations(field_declaration.annotations, "field") if hasattr(field_declaration, 'annotations') else []
                                
                                # Extract initial value if present
                                initial_value = ""
                                if hasattr(declarator, 'initializer') and declarator.initializer:
                                    # Convert the initializer to string representation
                                    if hasattr(declarator.initializer, 'value'):
                                        initial_value = str(declarator.initializer.value)
                                    elif hasattr(declarator.initializer, 'type'):
                                        initial_value = str(declarator.initializer.type)
                                    else:
                                        initial_value = str(declarator.initializer)
                                
                                prop = Field(
                                    name=declarator.name,
                                    logical_name=f"{package_name}.{class_name}.{declarator.name}",
                                    type=field_declaration.type.name,
                                    modifiers=list(field_declaration.modifiers), # Add modifiers
                                    package_name=package_name,
                                    class_name=class_name,
                                    annotations=field_annotations,
                                    initial_value=initial_value,
                                    description="",  # TODO: Extract description from comments or annotations
                                    ai_description=""  # TODO: Generate AI description using LLM
                                )
                                classes[class_key].properties.append(prop)

                        all_declarations = class_declaration.methods + class_declaration.constructors
                        
                        # Debug: Check User class method processing
                        if "User" in class_name:
                            logger.debug(f"Processing User class methods - total declarations: {len(all_declarations)}")
                            for i, decl in enumerate(all_declarations):
                                logger.debug(f"Declaration {i}: {type(decl).__name__} - {decl.name}")
                        
                        for declaration in all_declarations:
                            local_var_map = field_map.copy()
                            params = []
                            for param in declaration.parameters:
                                param_type_name = 'Unknown'
                                if hasattr(param.type, 'name'):
                                    param_type_name = param.type.name
                                local_var_map[param.name] = param_type_name
                                params.append(Field(name=param.name, logical_name=f"{package_name}.{class_name}.{param.name}", type=param_type_name, package_name=package_name, class_name=class_name))

                            if declaration.body:
                                for _, var_decl in declaration.filter(javalang.tree.LocalVariableDeclaration):
                                    for declarator in var_decl.declarators:
                                        local_var_map[declarator.name] = var_decl.type.name
                            
                            if isinstance(declaration, javalang.tree.MethodDeclaration):
                                return_type = declaration.return_type.name if declaration.return_type else "void"
                            else: # ConstructorDeclaration
                                return_type = "constructor"

                            # Extract modifiers
                            modifiers = list(declaration.modifiers)
                            
                            # Parse method annotations
                            method_annotations = parse_annotations(declaration.annotations, "method") if hasattr(declaration, 'annotations') else []

                            # Extract method source code
                            method_source = ""
                            if declaration.position:
                                lines = file_content.splitlines(keepends=True) # Keep line endings
                                start_line = declaration.position.line - 1
                                
                                # Find the end of the method by matching braces
                                brace_count = 0
                                end_line = start_line
                                for i in range(start_line, len(lines)):
                                    line = lines[i]
                                    for char in line:
                                        if char == '{':
                                            brace_count += 1
                                        elif char == '}':
                                            brace_count -= 1
                                            if brace_count == 0:
                                                end_line = i
                                                break
                                    if brace_count == 0:
                                        break
                                
                                method_source = "".join(lines[start_line:end_line + 1])

                            method = Method(
                                name=declaration.name,
                                logical_name=f"{class_key}.{declaration.name}",  # Add logical_name
                                return_type=return_type,
                                parameters=params,
                                modifiers=modifiers,
                                source=method_source, # Add method source
                                package_name=package_name,
                                annotations=method_annotations,
                                description=""  # TODO: Extract description from comments or annotations
                            )
                            classes[class_key].methods.append(method)

                            # Extract method calls with order information
                            call_order = 0
                            for _, invocation in declaration.filter(javalang.tree.MethodInvocation):
                                target_class_name = None
                                resolved_target_package = ""
                                resolved_target_class_name = ""
                                
                                if invocation.qualifier:
                                    # External method call
                                    if invocation.qualifier in local_var_map:
                                        target_class_name = local_var_map[invocation.qualifier]
                                    else:
                                        target_class_name = invocation.qualifier
                                    
                                    if target_class_name:
                                        if target_class_name == "System.out":
                                            resolved_target_package = "java.io"
                                            resolved_target_class_name = "PrintStream"
                                        else:
                                            if target_class_name in import_map:
                                                resolved_target_package = ".".join(import_map[target_class_name].split(".")[:-1])
                                            else:
                                                resolved_target_package = package_name
                                                resolved_target_class_name = target_class_name
                                else:
                                    # Same class method call
                                    resolved_target_package = package_name
                                    resolved_target_class_name = class_name

                                if resolved_target_class_name:
                                    # Get line number from invocation position
                                    line_number = invocation.position.line if invocation.position else 0

                                    call = MethodCall(
                                        source_package=package_name,
                                        source_class=class_name,
                                        source_method=declaration.name,
                                        target_package=resolved_target_package,
                                        target_class=resolved_target_class_name,
                                        target_method=invocation.member,
                                        call_order=call_order,
                                        line_number=line_number,
                                        return_type="void"  # Default return type, can be enhanced later
                                    )
                                    classes[class_key].calls.append(call)
                                    call_order += 1
                        
                        # Check for Lombok @Data annotation and generate methods
                        has_data_annotation = any(ann.name == "Data" for ann in classes[class_key].annotations)
                        if has_data_annotation:
                            logger.debug(f"Found @Data annotation on {class_name}, generating Lombok methods")
                            lombok_methods = generate_lombok_methods(classes[class_key].properties, class_name, package_name)
                            classes[class_key].methods.extend(lombok_methods)
                            logger.debug(f"Generated {len(lombok_methods)} Lombok methods for {class_name}")
                except javalang.parser.JavaSyntaxError as e:
                    print(f"Syntax error in {file_path}: {e}")
                    continue
                except Exception as e:
                    print(f"Error parsing {file_path}: {e}")
                    continue
    
    # Extract beans, analyze dependencies, extract endpoints, extract MyBatis mappers, extract JPA entities, extract config files, and extract test classes
    classes_list = list(classes.values())
    beans = extract_beans_from_classes(classes_list)
    dependencies = analyze_bean_dependencies(classes_list, beans)
    endpoints = extract_endpoints_from_classes(classes_list)
    mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
    jpa_entities = extract_jpa_entities_from_classes(classes_list)
    config_files = extract_config_files(directory)
    test_classes = extract_test_classes_from_classes(classes_list)
    
    # Also extract XML mappers
    xml_mappers = extract_mybatis_xml_mappers(directory)
    mybatis_mappers.extend(xml_mappers)
    
    # Extract SQL statements from MyBatis mappers
    sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
    
    return list(packages.values()), classes_list, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name
```

```python
import os
import yaml
import re
from pathlib import Path

import javalang

from src.models.graph_entities import Class, Method, MethodCall, Field, Package, Annotation, Bean, BeanDependency, Endpoint, MyBatisMapper, MyBatisSqlStatement, MyBatisResultMap, SqlStatement, JpaEntity, JpaColumn, JpaRelationship, ConfigFile, DatabaseConfig, ServerConfig, SecurityConfig, LoggingConfig, TestClass, TestMethod, TestConfiguration
from src.utils.logger import get_logger
from typing import Optional, List, Literal


def extract_project_name(java_source_folder: str) -> str:
    """
    JAVA_SOURCE_FOLDER 경로에서 프로젝트 이름을 추출합니다.
    
    Args:
        java_source_folder: Java 소스 폴더 경로
        
    Returns:
        프로젝트 이름 (마지막 디렉토리명)
    """
    # 경로를 정규화하고 마지막 디렉토리명 추출
    path = Path(java_source_folder).resolve()
    return path.name


def extract_sql_statements_from_mappers(mybatis_mappers: list[MyBatisMapper], project_name: str) -> list[SqlStatement]:
    """
    MyBatis mappers에서 SQL statements를 추출합니다.
    
    Args:
        mybatis_mappers: MyBatis mapper 객체들의 리스트
        project_name: 프로젝트 이름
        
    Returns:
        SqlStatement 객체들의 리스트
    """
    sql_statements = []
    
    for mapper in mybatis_mappers:
        for sql_dict in mapper.sql_statements:
            # MyBatisSqlStatement를 SqlStatement로 변환
            sql_statement = SqlStatement(
                id=sql_dict.get('id', ''),
                sql_type=sql_dict.get('sql_type', ''),
                sql_content=sql_dict.get('sql_content', ''),
                parameter_type=sql_dict.get('parameter_type', ''),
                result_type=sql_dict.get('result_type', ''),
                result_map=sql_dict.get('result_map', ''),
                mapper_name=mapper.name,
                annotations=[],  # TODO: annotations를 파싱하여 추가
                project_name=project_name
            )
            sql_statements.append(sql_statement)
    
    return sql_statements


def parse_annotations(annotations, target_type: str = "class") -> list[Annotation]:
    """Parse Java annotations into Annotation objects.
    
    Args:
        annotations: List of annotation nodes from javalang
        target_type: Type of target ("class", "method", "field")
    """
    result = []
    for annotation in annotations:
        annotation_name = annotation.name
        parameters = {}
        
        # Parse annotation parameters if they exist
        if hasattr(annotation, 'element') and annotation.element:
            for element in annotation.element:
                if hasattr(element, 'name') and hasattr(element, 'value'):
                    parameters[element.name] = element.value.value if hasattr(element.value, 'value') else str(element.value)
        
        result.append(Annotation(
            name=annotation_name,
            parameters=parameters,
            target_type=target_type,
            category=classify_springboot_annotation(annotation_name)
        ))
    
    return result


def classify_springboot_annotation(annotation_name: str) -> str:
    """Classify SpringBoot annotations into categories.
    
    Args:
        annotation_name: Name of the annotation (e.g., "@Component", "@Service")
        
    Returns:
        Category of the annotation
    """
    # Component annotations
    component_annotations = {
        "Component", "Service", "Repository", "Controller", 
        "RestController", "Configuration", "Bean"
    }
    
    # Injection annotations
    injection_annotations = {
        "Autowired", "Resource", "Value", "Qualifier", "Primary"
    }
    
    # Web annotations
    web_annotations = {
        "RequestMapping", "GetMapping", "PostMapping", "PutMapping", 
        "DeleteMapping", "PatchMapping", "RequestParam", "PathVariable",
        "RequestBody", "ResponseBody", "ResponseStatus"
    }
    
    # JPA annotations
    jpa_annotations = {
        "Entity", "Table", "Id", "Column", "OneToMany", "ManyToOne",
        "OneToOne", "ManyToMany", "JoinColumn", "GeneratedValue"
    }
    
    # Test annotations
    test_annotations = {
        "Test", "SpringBootTest", "DataJpaTest", "WebMvcTest",
        "MockBean", "SpyBean", "TestPropertySource"
    }
    
    # Security annotations
    security_annotations = {
        "PreAuthorize", "PostAuthorize", "Secured", "RolesAllowed",
        "EnableWebSecurity", "EnableGlobalMethodSecurity"
    }
    
    # Validation annotations
    validation_annotations = {
        "Valid", "NotNull", "NotBlank", "NotEmpty", "Size", "Min", "Max",
        "Pattern", "Email", "AssertTrue", "AssertFalse"
    }
    
    # MyBatis annotations
    mybatis_annotations = {
        "Mapper", "Select", "Insert", "Update", "Delete", "SelectProvider",
        "InsertProvider", "UpdateProvider", "DeleteProvider", "Results",
        "Result", "One", "Many", "MapKey", "Options", "SelectKey"
    }
    
    if annotation_name in component_annotations:
        return "component"
    elif annotation_name in injection_annotations:
        return "injection"
    elif annotation_name in web_annotations:
        return "web"
    elif annotation_name in jpa_annotations:
        return "jpa"
    elif annotation_name in test_annotations:
        return "test"
    elif annotation_name in security_annotations:
        return "security"
    elif annotation_name in validation_annotations:
        return "validation"
    elif annotation_name in mybatis_annotations:
        return "mybatis"
    else:
        return "other"


def classify_test_annotation(annotation_name: str) -> str:
    """Classify test annotations into categories.
    
    Args:
        annotation_name: Name of the annotation
        
    Returns:
        Category of the test annotation
    """
    # JUnit annotations
    junit_annotations = {
        "Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll",
        "DisplayName", "ParameterizedTest", "ValueSource", "CsvSource",
        "MethodSource", "Timeout", "Disabled", "Nested", "RepeatedTest",
        "Order", "TestMethodOrder", "TestInstance", "TestClassOrder"
    }
    
    # Spring Boot Test annotations
    spring_test_annotations = {
        "SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest",
        "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest",
        "MockBean", "SpyBean", "TestConfiguration", "ActiveProfiles",
        "TestPropertySource", "DirtiesContext", "Transactional",
        "Rollback", "Commit", "Sql", "SqlGroup", "AutoConfigureTestDatabase",
        "AutoConfigureMockMvc", "AutoConfigureWebMvc", "AutoConfigureWebClient",
        "MockMvc", "TestEntityManager", "TestContainers", "DynamicPropertySource"
    }
    
    # TestNG annotations
    testng_annotations = {
        "TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass",
        "BeforeSuite", "AfterSuite", "BeforeGroups", "AfterGroups",
        "DataProvider", "Parameters", "Groups", "Priority", "DependsOnMethods",
        "DependsOnGroups", "ExpectedExceptions", "InvocationCount",
        "SuccessPercentage", "TimeOut"
    }
    
    # Mockito annotations
    mockito_annotations = {
        "Mock", "Spy", "InjectMocks", "Captor", "MockedStatic"
    }
    
    # AssertJ annotations
    assertj_annotations = {
        "AssertJ"
    }
    
    # Other test annotations
    other_test_annotations = {
        "Ignore", "Category", "RunWith", "ExtendWith", "ContextConfiguration"
    }
    
    if annotation_name in junit_annotations:
        return "junit"
    elif annotation_name in spring_test_annotations:
        return "spring_test"
    elif annotation_name in testng_annotations:
        return "testng"
    elif annotation_name in mockito_annotations:
        return "mockito"
    elif annotation_name in assertj_annotations:
        return "assertj"
    elif annotation_name in other_test_annotations:
        return "other_test"
    else:
        return "other"


def extract_beans_from_classes(classes: list[Class]) -> list[Bean]:
    """Extract Spring Beans from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Bean objects
    """
    beans = []
    
    for cls in classes:
        # Check if class has Spring component annotations
        component_annotations = [ann for ann in cls.annotations if ann.category == "component"]
        
        # Also check for @Repository on interfaces
        has_repository_annotation = any(ann.name == "Repository" for ann in cls.annotations)
        
        if component_annotations or has_repository_annotation:
            # Determine bean type based on annotations
            bean_type = "component"  # default
            if any(ann.name in ["Service", "Service"] for ann in cls.annotations):
                bean_type = "service"
            elif any(ann.name in ["Repository", "Repository"] for ann in cls.annotations):
                bean_type = "repository"
            elif any(ann.name in ["Controller", "RestController"] for ann in cls.annotations):
                bean_type = "controller"
            elif any(ann.name in ["Configuration", "Configuration"] for ann in cls.annotations):
                bean_type = "configuration"
            
            # Determine scope (default is singleton)
            scope = "singleton"
            for ann in cls.annotations:
                if ann.name == "Scope":
                    if "value" in ann.parameters:
                        scope = ann.parameters["value"]
                    elif "prototype" in str(ann.parameters):
                        scope = "prototype"
                    elif "request" in str(ann.parameters):
                        scope = "request"
                    elif "session" in str(ann.parameters):
                        scope = "session"
            
            # Create bean name (use class name with first letter lowercase)
            bean_name = cls.name[0].lower() + cls.name[1:] if cls.name else cls.name
            
            # Check for @Bean methods in configuration classes
            bean_methods = []
            if bean_type == "configuration":
                for method in cls.methods:
                    if any(ann.name == "Bean" for ann in method.annotations):
                        bean_methods.append(method)
            
            bean = Bean(
                name=bean_name,
                type=bean_type,
                scope=scope,
                class_name=cls.name,
                package_name=cls.package_name,
                annotation_names=[ann.name for ann in cls.annotations] if cls.annotations else [],
                method_count=len(bean_methods) if bean_type == "configuration" else len(cls.methods) if cls.methods else 0,
                property_count=len(cls.properties) if cls.properties else 0
            )
            beans.append(bean)
    
    return beans


def analyze_bean_dependencies(classes: list[Class], beans: list[Bean]) -> list[BeanDependency]:
    """Analyze dependencies between Spring Beans.
    
    Args:
        classes: List of parsed Class objects
        beans: List of Bean objects
        
    Returns:
        List of BeanDependency objects
    """
    dependencies = []
    
    # Create a mapping from class names to bean names
    class_to_bean = {}
    for bean in beans:
        class_to_bean[bean.class_name] = bean.name
    
    for cls in classes:
        # Check if this class is a bean
        if cls.name not in class_to_bean:
            continue
            
        source_bean = class_to_bean[cls.name]
        
        # Analyze field injections (@Autowired, @Resource, @Value)
        for prop in cls.properties:
            if any(ann.category == "injection" for ann in prop.annotations):
                # Try to determine target bean from field type
                target_bean = None
                field_type = prop.type
                
                # Look for exact class name match
                if field_type in class_to_bean:
                    target_bean = class_to_bean[field_type]
                else:
                    # Look for interface implementations (simplified - just check if type matches any bean class name)
                    for bean in beans:
                        if field_type == bean.class_name:
                            target_bean = bean.name
                            break
                
                if target_bean:
                    injection_type = "field"
                    for ann in prop.annotations:
                        if ann.name == "Autowired":
                            injection_type = "field"
                        elif ann.name == "Resource":
                            injection_type = "field"
                        elif ann.name == "Value":
                            injection_type = "field"
                    
                    dependency = BeanDependency(
                        source_bean=source_bean,
                        target_bean=target_bean,
                        injection_type=injection_type,
                        field_name=prop.name
                    )
                    dependencies.append(dependency)
        
        # Analyze constructor injections
        for method in cls.methods:
            if method.name == cls.name:  # Constructor
                for param in method.parameters:
                    if any(ann.category == "injection" for ann in param.annotations):
                        target_bean = None
                        param_type = param.type
                        
                        if param_type in class_to_bean:
                            target_bean = class_to_bean[param_type]
                        else:
                            # Look for interface implementations (simplified)
                            for bean in beans:
                                if param_type == bean.class_name:
                                    target_bean = bean.name
                                    break
                        
                        if target_bean:
                            dependency = BeanDependency(
                                source_bean=source_bean,
                                target_bean=target_bean,
                                injection_type="constructor",
                                parameter_name=param.name
                            )
                            dependencies.append(dependency)
        
        # Analyze setter injections
        for method in cls.methods:
            if method.name.startswith("set") and len(method.parameters) == 1:
                if any(ann.category == "injection" for ann in method.annotations):
                    param = method.parameters[0]
                    target_bean = None
                    param_type = param.type
                    
                    if param_type in class_to_bean:
                        target_bean = class_to_bean[param_type]
                    else:
                        # Look for interface implementations (simplified)
                        for bean in beans:
                            if param_type == bean.class_name:
                                target_bean = bean.name
                                break
                    
                    if target_bean:
                        dependency = BeanDependency(
                            source_bean=source_bean,
                            target_bean=target_bean,
                            injection_type="setter",
                            method_name=method.name,
                            parameter_name=param.name
                        )
                        dependencies.append(dependency)
    
    return dependencies


def extract_endpoints_from_classes(classes: list[Class]) -> list[Endpoint]:
    """Extract REST API endpoints from controller classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Endpoint objects
    """
    endpoints = []
    
    for cls in classes:
        # Check if class is a controller
        is_controller = any(ann.name in ["Controller", "RestController"] for ann in cls.annotations)
        
        if not is_controller:
            continue
            
        # Get class-level path mapping
        class_path = ""
        for ann in cls.annotations:
            if ann.name == "RequestMapping":
                if "value" in ann.parameters:
                    class_path = ann.parameters["value"]
                break
        
        # Process each method in the controller
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
                
            # Check if method has web mapping annotations
            web_annotations = [ann for ann in method.annotations if ann.category == "web"]
            
            if not web_annotations:
                continue
            
            # Extract endpoint information
            endpoint_path = ""
            http_method = "GET"  # default
            
            for ann in web_annotations:
                if ann.name in ["RequestMapping", "GetMapping", "PostMapping", "PutMapping", "DeleteMapping", "PatchMapping"]:
                    # Extract path
                    if "value" in ann.parameters:
                        endpoint_path = ann.parameters["value"]
                    elif "path" in ann.parameters:
                        endpoint_path = ann.parameters["path"]
                    
                    # Extract HTTP method
                    if ann.name == "GetMapping":
                        http_method = "GET"
                    elif ann.name == "PostMapping":
                        http_method = "POST"
                    elif ann.name == "PutMapping":
                        http_method = "PUT"
                    elif ann.name == "DeleteMapping":
                        http_method = "DELETE"
                    elif ann.name == "PatchMapping":
                        http_method = "PATCH"
                    elif ann.name == "RequestMapping":
                        if "method" in ann.parameters:
                            method_value = ann.parameters["method"]
                            if isinstance(method_value, list) and len(method_value) > 0:
                                http_method = method_value[0]
                            else:
                                http_method = str(method_value)
                        else:
                            http_method = "GET"  # default for RequestMapping
                    break
            
            # Build full path
            full_path = class_path
            if endpoint_path:
                if full_path and not full_path.endswith("/") and not endpoint_path.startswith("/"):
                    full_path += "/"
                full_path += endpoint_path
            elif not full_path:
                full_path = "/"
            
            # Extract method parameters
            parameters = []
            for param in method.parameters:
                param_info = {
                    "name": param.name,
                    "type": param.type,
                    "annotations": [ann.name for ann in param.annotations if ann.category == "web"]
                }
                parameters.append(param_info)
            
            # Extract return type
            return_type = method.return_type if method.return_type != "constructor" else "void"
            
            # Create endpoint
            endpoint = Endpoint(
                path=endpoint_path or "/",
                method=http_method,
                controller_class=cls.name,
                handler_method=method.name,
                parameters=parameters,
                return_type=return_type,
                annotations=[ann.name for ann in web_annotations],
                full_path=full_path
            )
            endpoints.append(endpoint)
    
    return endpoints


def extract_mybatis_mappers_from_classes(classes: list[Class]) -> list[MyBatisMapper]:
    """Extract MyBatis Mappers from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for cls in classes:
        # Check if class is a MyBatis Mapper interface
        is_mapper = any(ann.name == "Mapper" for ann in cls.annotations)
        
        if not is_mapper:
            continue
        
        # Extract mapper methods with MyBatis annotations
        mapper_methods = []
        sql_statements = []
        
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
            
            # Check if method has MyBatis annotations
            mybatis_annotations = [ann for ann in method.annotations if ann.category == "mybatis"]
            
            if not mybatis_annotations:
                continue
            
            # Extract SQL statement information
            sql_type = "SELECT"  # default
            sql_content = ""
            parameter_type = ""
            result_type = ""
            result_map = ""
            
            for ann in mybatis_annotations:
                if ann.name in ["Select", "SelectProvider"]:
                    sql_type = "SELECT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Insert", "InsertProvider"]:
                    sql_type = "INSERT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Update", "UpdateProvider"]:
                    sql_type = "UPDATE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Delete", "DeleteProvider"]:
                    sql_type = "DELETE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                
                # Extract parameter and result type information
                if "parameterType" in ann.parameters:
                    parameter_type = ann.parameters["parameterType"]
                if "resultType" in ann.parameters:
                    result_type = ann.parameters["resultType"]
                if "resultMap" in ann.parameters:
                    result_map = ann.parameters["resultMap"]
            
            # Create method info
            method_info = {
                "name": method.name,
                "return_type": method.return_type,
                "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            mapper_methods.append(method_info)
            
            # Create SQL statement info
            sql_statement = {
                "id": method.name,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            sql_statements.append(sql_statement)
        
        # Create mapper
        mapper = MyBatisMapper(
            name=cls.name,
            type="interface",
            namespace=f"{cls.package_name}.{cls.name}",
            methods=mapper_methods,
            sql_statements=sql_statements,
            file_path=cls.file_path,
            package_name=cls.package_name
        )
        mappers.append(mapper)
    
    return mappers


def parse_mybatis_xml_file(file_path: str) -> MyBatisMapper:
    """Parse MyBatis XML mapper file.
    
    Args:
        file_path: Path to the XML mapper file
        
    Returns:
        MyBatisMapper object
    """
    import xml.etree.ElementTree as ET
    
    try:
        tree = ET.parse(file_path)
        root = tree.getroot()
        
        # Extract namespace
        namespace = root.get("namespace", "")
        
        # Extract SQL statements
        sql_statements = []
        for statement in root.findall(".//*[@id]"):
            statement_id = statement.get("id")
            tag_name = statement.tag.lower()
            
            # Determine SQL type
            sql_type = "SELECT"
            if tag_name == "insert":
                sql_type = "INSERT"
            elif tag_name == "update":
                sql_type = "UPDATE"
            elif tag_name == "delete":
                sql_type = "DELETE"
            
            # Extract SQL content
            sql_content = statement.text.strip() if statement.text else ""
            
            # Extract parameter and result information
            parameter_type = statement.get("parameterType", "")
            result_type = statement.get("resultType", "")
            result_map = statement.get("resultMap", "")
            
            sql_statement = {
                "id": statement_id,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": []
            }
            sql_statements.append(sql_statement)
        
        # Extract ResultMaps
        result_maps = []
        for result_map in root.findall(".//resultMap"):
            result_map_id = result_map.get("id")
            result_map_type = result_map.get("type", "")
            
            properties = []
            for property_elem in result_map.findall(".//result"):
                prop = {
                    "property": property_elem.get("property", ""),
                    "column": property_elem.get("column", ""),
                    "jdbc_type": property_elem.get("jdbcType", "")
                }
                properties.append(prop)
            
            result_map_info = {
                "id": result_map_id,
                "type": result_map_type,
                "properties": properties,
                "associations": [],
                "collections": []
            }
            result_maps.append(result_map_info)
        
        # Create mapper
        mapper_name = namespace.split(".")[-1] if namespace else os.path.basename(file_path).replace(".xml", "")
        package_name = ".".join(namespace.split(".")[:-1]) if namespace else ""
        
        mapper = MyBatisMapper(
            name=mapper_name,
            type="xml",
            namespace=namespace,
            methods=[],  # XML mappers don't have Java methods
            sql_statements=sql_statements,
            file_path=file_path,
            package_name=package_name
        )
        
        return mapper
        
    except ET.ParseError as e:
        print(f"Error parsing XML file {file_path}: {e}")
        return None
    except Exception as e:
        print(f"Error reading XML file {file_path}: {e}")
        return None


def extract_mybatis_xml_mappers(directory: str) -> list[MyBatisMapper]:
    """Extract MyBatis XML mappers from directory.
    
    Args:
        directory: Directory to search for XML mapper files
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith("Mapper.xml") or file.endswith("Dao.xml"):
                file_path = os.path.join(root, file)
                mapper = parse_mybatis_xml_file(file_path)
                if mapper:
                    mappers.append(mapper)
    
    return mappers


def extract_jpa_entities_from_classes(classes: list[Class]) -> list[JpaEntity]:
    """Extract JPA Entities from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of JpaEntity objects
    """
    entities = []
    
    for cls in classes:
        # Check if class is a JPA Entity
        is_entity = any(ann.name == "Entity" for ann in cls.annotations)
        
        if not is_entity:
            continue
        
        # Extract table name
        table_name = cls.name.lower()  # default table name
        for ann in cls.annotations:
            if ann.name == "Table":
                if "name" in ann.parameters:
                    table_name = ann.parameters["name"]
                break
        
        # Extract columns from properties
        columns = []
        relationships = []
        
        for prop in cls.properties:
            # Check if property has JPA column annotations
            jpa_annotations = [ann for ann in prop.annotations if ann.category == "jpa"]
            
            if jpa_annotations:
                # Extract column information
                column_name = prop.name  # default column name
                nullable = True
                unique = False
                length = 0
                precision = 0
                scale = 0
                
                for ann in jpa_annotations:
                    if ann.name == "Column":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                        if "nullable" in ann.parameters:
                            nullable = ann.parameters["nullable"]
                        if "unique" in ann.parameters:
                            unique = ann.parameters["unique"]
                        if "length" in ann.parameters:
                            length = ann.parameters["length"]
                        if "precision" in ann.parameters:
                            precision = ann.parameters["precision"]
                        if "scale" in ann.parameters:
                            scale = ann.parameters["scale"]
                    elif ann.name == "Id":
                        column_name = "id"  # Primary key column
                        nullable = False
                        unique = True
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                
                # Check for relationship annotations
                relationship_type = None
                target_entity = ""
                mapped_by = ""
                join_column = ""
                join_table = ""
                cascade = []
                fetch = "LAZY"
                
                for ann in jpa_annotations:
                    if ann.name in ["OneToOne", "OneToMany", "ManyToOne", "ManyToMany"]:
                        relationship_type = ann.name
                        if "targetEntity" in ann.parameters:
                            target_entity = ann.parameters["targetEntity"]
                        if "mappedBy" in ann.parameters:
                            mapped_by = ann.parameters["mappedBy"]
                        if "cascade" in ann.parameters:
                            cascade = ann.parameters["cascade"] if isinstance(ann.parameters["cascade"], list) else [ann.parameters["cascade"]]
                        if "fetch" in ann.parameters:
                            fetch = ann.parameters["fetch"]
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            join_column = ann.parameters["name"]
                    elif ann.name == "JoinTable":
                        if "name" in ann.parameters:
                            join_table = ann.parameters["name"]
                
                # Create column info
                column_info = {
                    "property_name": prop.name,
                    "column_name": column_name,
                    "data_type": prop.type,
                    "nullable": nullable,
                    "unique": unique,
                    "length": length,
                    "precision": precision,
                    "scale": scale,
                    "annotations": [ann.name for ann in jpa_annotations]
                }
                columns.append(column_info)
                
                # Create relationship info if it's a relationship
                if relationship_type:
                    relationship_info = {
                        "type": relationship_type,
                        "target_entity": target_entity,
                        "mapped_by": mapped_by,
                        "join_column": join_column,
                        "join_table": join_table,
                        "cascade": cascade,
                        "fetch": fetch,
                        "annotations": [ann.name for ann in jpa_annotations]
                    }
                    relationships.append(relationship_info)
        
        # Create entity
        entity = JpaEntity(
            name=cls.name,
            table_name=table_name,
            columns=columns,
            relationships=relationships,
            annotations=[ann.name for ann in cls.annotations if ann.category == "jpa"],
            package_name=cls.package_name,
            file_path=cls.file_path
        )
        entities.append(entity)
    
    return entities


def parse_yaml_config(file_path: str) -> ConfigFile:
    """Parse YAML configuration file.
    
    Args:
        file_path: Path to the YAML file
        
    Returns:
        ConfigFile object
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = yaml.safe_load(f)
        
        if not content:
            content = {}
        
        # Extract file info
        file_name = os.path.basename(file_path)
        file_type = "yaml" if file_path.endswith('.yaml') else "yml"
        
        # Extract profiles
        profiles = []
        if 'spring' in content and 'profiles' in content['spring']:
            if 'active' in content['spring']['profiles']:
                profiles = content['spring']['profiles']['active']
                if isinstance(profiles, str):
                    profiles = [profiles]
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        # Extract sections
        sections = []
        for key, value in content.items():
            if isinstance(value, dict):
                sections.append({
                    "name": key,
                    "properties": value,
                    "type": "section"
                })
        
        return ConfigFile(
            name=file_name,
            file_path=file_path,
            file_type=file_type,
            properties=content,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing YAML file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="yaml",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def parse_properties_config(file_path: str) -> ConfigFile:
    """Parse Properties configuration file.
    
    Args:
        file_path: Path to the properties file
        
    Returns:
        ConfigFile object
    """
    try:
        properties = {}
        sections = []
        profiles = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                
                # Skip empty lines and comments
                if not line or line.startswith('#'):
                    continue
                
                # Parse key=value pairs
                if '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    
                    # Remove quotes if present
                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]
                    elif value.startswith("'") and value.endswith("'"):
                        value = value[1:-1]
                    
                    properties[key] = value
                    
                    # Check for profiles
                    if key == 'spring.profiles.active':
                        profiles = [p.strip() for p in value.split(',')]
        
        # Group properties by section
        section_map = {}
        for key, value in properties.items():
            if '.' in key:
                section = key.split('.')[0]
                if section not in section_map:
                    section_map[section] = {}
                section_map[section][key] = value
            else:
                if 'root' not in section_map:
                    section_map['root'] = {}
                section_map['root'][key] = value
        
        for section_name, section_props in section_map.items():
            sections.append({
                "name": section_name,
                "properties": section_props,
                "type": "section"
            })
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties=properties,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing Properties file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def extract_database_config(config_file: ConfigFile) -> DatabaseConfig:
    """Extract database configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        DatabaseConfig object
    """
    db_config = DatabaseConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        spring_config = config_file.properties.get('spring', {})
        datasource_config = spring_config.get('datasource', {})
        jpa_config = spring_config.get('jpa', {})
        
        db_config.driver = datasource_config.get('driver-class-name', '')
        db_config.url = datasource_config.get('url', '')
        db_config.username = datasource_config.get('username', '')
        db_config.password = datasource_config.get('password', '')
        db_config.dialect = jpa_config.get('database-platform', '')
        db_config.hibernate_ddl_auto = jpa_config.get('hibernate', {}).get('ddl-auto', '')
        db_config.show_sql = jpa_config.get('show-sql', False)
        db_config.format_sql = jpa_config.get('properties', {}).get('hibernate', {}).get('format_sql', False)
        
        # Store additional JPA properties
        if 'properties' in jpa_config:
            db_config.jpa_properties = jpa_config['properties']
    
    else:
        # Properties format
        props = config_file.properties
        
        db_config.driver = props.get('spring.datasource.driver-class-name', '')
        db_config.url = props.get('spring.datasource.url', '')
        db_config.username = props.get('spring.datasource.username', '')
        db_config.password = props.get('spring.datasource.password', '')
        db_config.dialect = props.get('spring.jpa.database-platform', '')
        db_config.hibernate_ddl_auto = props.get('spring.jpa.hibernate.ddl-auto', '')
        db_config.show_sql = props.get('spring.jpa.show-sql', 'false').lower() == 'true'
        db_config.format_sql = props.get('spring.jpa.properties.hibernate.format_sql', 'false').lower() == 'true'
        
        # Store additional JPA properties
        jpa_props = {}
        for key, value in props.items():
            if key.startswith('spring.jpa.properties.'):
                jpa_props[key] = value
        db_config.jpa_properties = jpa_props
    
    return db_config


def extract_server_config(config_file: ConfigFile) -> ServerConfig:
    """Extract server configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        ServerConfig object
    """
    server_config = ServerConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        server_props = config_file.properties.get('server', {})
        
        server_config.port = server_props.get('port', 8080)
        server_config.context_path = server_props.get('servlet', {}).get('context-path', '')
        server_config.servlet_path = server_props.get('servlet', {}).get('path', '')
        
        # SSL configuration
        ssl_config = server_props.get('ssl', {})
        server_config.ssl_enabled = bool(ssl_config)
        server_config.ssl_key_store = ssl_config.get('key-store', '')
        server_config.ssl_key_store_password = ssl_config.get('key-store-password', '')
        server_config.ssl_key_store_type = ssl_config.get('key-store-type', '')
    
    else:
        # Properties format
        props = config_file.properties
        
        server_config.port = int(props.get('server.port', '8080'))
        server_config.context_path = props.get('server.servlet.context-path', '')
        server_config.servlet_path = props.get('server.servlet.path', '')
        
        # SSL configuration
        server_config.ssl_enabled = any(key.startswith('server.ssl.') for key in props.keys())
        server_config.ssl_key_store = props.get('server.ssl.key-store', '')
        server_config.ssl_key_store_password = props.get('server.ssl.key-store-password', '')
        server_config.ssl_key_store_type = props.get('server.ssl.key-store-type', '')
    
    return server_config


def extract_security_config(config_file: ConfigFile) -> SecurityConfig:
    """Extract security configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        SecurityConfig object
    """
    security_config = SecurityConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        security_props = config_file.properties.get('security', {})
        jwt_props = security_props.get('jwt', {})
        cors_props = security_props.get('cors', {})
        
        security_config.enabled = bool(security_props)
        security_config.authentication_type = security_props.get('authentication-type', '')
        security_config.jwt_secret = jwt_props.get('secret', '')
        security_config.jwt_expiration = jwt_props.get('expiration', 0)
        security_config.cors_allowed_origins = cors_props.get('allowed-origins', [])
        security_config.cors_allowed_methods = cors_props.get('allowed-methods', [])
        security_config.cors_allowed_headers = cors_props.get('allowed-headers', [])
    
    else:
        # Properties format
        props = config_file.properties
        
        security_config.enabled = any(key.startswith('security.') for key in props.keys())
        security_config.authentication_type = props.get('security.authentication-type', '')
        security_config.jwt_secret = props.get('security.jwt.secret', '')
        security_config.jwt_expiration = int(props.get('security.jwt.expiration', '0'))
        
        # CORS configuration
        origins = props.get('security.cors.allowed-origins', '')
        if origins:
            security_config.cors_allowed_origins = [o.strip() for o in origins.split(',')]
        
        methods = props.get('security.cors.allowed-methods', '')
        if methods:
            security_config.cors_allowed_methods = [m.strip() for m in methods.split(',')]
        
        headers = props.get('security.cors.allowed-headers', '')
        if headers:
            security_config.cors_allowed_headers = [h.strip() for h in headers.split(',')]
    
    return security_config


def extract_logging_config(config_file: ConfigFile) -> LoggingConfig:
    """Extract logging configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        LoggingConfig object
    """
    logging_config = LoggingConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        logging_props = config_file.properties.get('logging', {})
        
        logging_config.level = logging_props.get('level', {}).get('root', 'INFO')
        logging_config.pattern = logging_props.get('pattern', {}).get('console', '')
        logging_config.file_path = logging_props.get('file', {}).get('name', '')
        logging_config.max_file_size = logging_props.get('file', {}).get('max-size', '')
        logging_config.max_history = logging_props.get('file', {}).get('max-history', 0)
        logging_config.console_output = logging_props.get('console', {}).get('enabled', True)
    
    else:
        # Properties format
        props = config_file.properties
        
        logging_config.level = props.get('logging.level.root', 'INFO')
        logging_config.pattern = props.get('logging.pattern.console', '')
        logging_config.file_path = props.get('logging.file.name', '')
        logging_config.max_file_size = props.get('logging.file.max-size', '')
        logging_config.max_history = int(props.get('logging.file.max-history', '0'))
        logging_config.console_output = props.get('logging.console.enabled', 'true').lower() == 'true'
    
    return logging_config


def extract_config_files(directory: str) -> list[ConfigFile]:
    """Extract configuration files from directory.
    
    Args:
        directory: Directory to search for config files
        
    Returns:
        List of ConfigFile objects
    """
    config_files = []
    
    # Common config file patterns
    config_patterns = [
        "application.yml",
        "application.yaml", 
        "application.properties",
        "application-*.properties",
        "bootstrap.yml",
        "bootstrap.yaml",
        "bootstrap.properties"
    ]
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            # Check if file matches any config pattern
            is_config_file = False
            for pattern in config_patterns:
                if pattern == file or (pattern.endswith('*') and file.startswith(pattern[:-1])):
                    is_config_file = True
                    break
            
            if is_config_file:
                file_path = os.path.join(root, file)
                
                if file.endswith(('.yml', '.yaml')):
                    config_file = parse_yaml_config(file_path)
                elif file.endswith('.properties'):
                    config_file = parse_properties_config(file_path)
                else:
                    continue
                
                config_files.append(config_file)
    
    return config_files


def extract_test_classes_from_classes(classes: list[Class]) -> list[TestClass]:
    """Extract test classes from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of TestClass objects
    """
    test_classes = []
    
    for cls in classes:
        # Check if class is a test class
        test_annotations = [ann for ann in cls.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
        
        if not test_annotations:
            continue
        
        # Determine test framework and type
        test_framework = "junit"  # default
        test_type = "unit"  # default
        
        for ann in test_annotations:
            if ann.name in ["SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest", "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest"]:
                test_framework = "spring_test"
                if ann.name == "SpringBootTest":
                    test_type = "integration"
                else:
                    test_type = "slice"
            elif ann.name in ["TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass"]:
                test_framework = "testng"
            elif ann.name in ["Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll"]:
                test_framework = "junit"
        
        # Extract test methods
        test_methods = []
        setup_methods = []
        
        for method in cls.methods:
            method_annotations = [ann.name for ann in method.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
            
            if method_annotations:
                # Check if it's a setup/teardown method
                if any(ann in method_annotations for ann in ["BeforeEach", "AfterEach", "BeforeAll", "AfterAll", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass", "BeforeSuite", "AfterSuite"]):
                    setup_methods.append({
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters]
                    })
                else:
                    # Regular test method
                    test_method_info = {
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                        "assertions": [],
                        "mock_calls": [],
                        "test_data": [],
                        "expected_exceptions": [],
                        "timeout": 0,
                        "display_name": ""
                    }
                    
                    # Extract display name
                    for ann in method.annotations:
                        if ann.name == "DisplayName" and "value" in ann.parameters:
                            test_method_info["display_name"] = ann.parameters["value"]
                        elif ann.name == "Timeout" and "value" in ann.parameters:
                            test_method_info["timeout"] = ann.parameters["value"]
                    
                    # Extract expected exceptions
                    for ann in method.annotations:
                        if ann.name == "ExpectedExceptions" and "value" in ann.parameters:
                            test_method_info["expected_exceptions"] = ann.parameters["value"] if isinstance(ann.parameters["value"], list) else [ann.parameters["value"]]
                    
                    test_methods.append(test_method_info)
        
        # Extract mock dependencies
        mock_dependencies = []
        for prop in cls.properties:
            prop_annotations = [ann.name for ann in prop.annotations if classify_test_annotation(ann.name) in ["mockito", "spring_test"]]
            if prop_annotations:
                mock_dependencies.append({
                    "name": prop.name,
                    "type": prop.type,
                    "annotations": prop_annotations,
                    "mock_type": "mock" if "Mock" in prop_annotations else "spy" if "Spy" in prop_annotations else "bean"
                })
        
        # Extract test configurations
        test_configurations = []
        for ann in cls.annotations:
            if ann.name in ["TestConfiguration", "ActiveProfiles", "TestPropertySource"]:
                config_info = {
                    "name": ann.name,
                    "type": "configuration" if ann.name == "TestConfiguration" else "profile" if ann.name == "ActiveProfiles" else "property",
                    "properties": ann.parameters,
                    "active_profiles": ann.parameters.get("value", []) if ann.name == "ActiveProfiles" else [],
                    "test_slices": [],
                    "mock_beans": [],
                    "spy_beans": []
                }
                test_configurations.append(config_info)
        
        # Create test class
        test_class = TestClass(
            name=cls.name,
            package_name=cls.package_name,
            test_framework=test_framework,
            test_type=test_type,
            annotations=[ann.name for ann in test_annotations],
            test_methods=test_methods,
            setup_methods=setup_methods,
            mock_dependencies=mock_dependencies,
            test_configurations=test_configurations,
            file_path=cls.file_path
        )
        test_classes.append(test_class)
    
    return test_classes


def analyze_test_methods(test_class: TestClass, class_obj: Class) -> list[TestMethod]:
    """Analyze test methods for assertions, mock calls, and test data.
    
    Args:
        test_class: TestClass object
        class_obj: Original Class object
        
    Returns:
        List of analyzed TestMethod objects
    """
    test_methods = []
    
    for method_info in test_class.test_methods:
        # Find the corresponding method in the class
        method_obj = None
        for method in class_obj.methods:
            if method.name == method_info["name"]:
                method_obj = method
                break
        
        if not method_obj:
            continue
        
        # Analyze method source code for assertions and mock calls
        assertions = []
        mock_calls = []
        test_data = []
        
        if method_obj.source:
            source_code = method_obj.source
            
            # Find assertions (JUnit, AssertJ, etc.)
            assertion_patterns = [
                r'assert\w+\(',  # JUnit assertions
                r'assertThat\(',  # AssertJ
                r'assertEquals\(',  # JUnit
                r'assertTrue\(',  # JUnit
                r'assertFalse\(',  # JUnit
                r'assertNotNull\(',  # JUnit
                r'assertNull\(',  # JUnit
                r'assertThrows\(',  # JUnit 5
                r'assertDoesNotThrow\(',  # JUnit 5
                r'verify\(',  # Mockito verify
                r'when\(',  # Mockito when
                r'then\(',  # Mockito then
                r'given\(',  # BDDMockito given
                r'willReturn\(',  # Mockito willReturn
                r'willThrow\(',  # Mockito willThrow
            ]
            
            for pattern in assertion_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    assertions.append({
                        "type": match,
                        "line": source_code.find(match) + 1
                    })
            
            # Find mock calls
            mock_call_patterns = [
                r'(\w+)\.(\w+)\(',  # Method calls on objects
                r'mock\(',  # Mockito mock creation
                r'spy\(',  # Mockito spy creation
                r'@Mock\s+(\w+)',  # @Mock annotation
                r'@Spy\s+(\w+)',  # @Spy annotation
                r'@InjectMocks\s+(\w+)',  # @InjectMocks annotation
            ]
            
            for pattern in mock_call_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        mock_calls.append({
                            "object": match[0],
                            "method": match[1],
                            "type": "method_call"
                        })
                    else:
                        mock_calls.append({
                            "type": match,
                            "line": source_code.find(match) + 1
                        })
            
            # Find test data setup
            test_data_patterns = [
                r'new\s+(\w+)\(',  # Object creation
                r'(\w+)\s*=\s*new\s+(\w+)\(',  # Variable assignment with new
                r'@ValueSource\(',  # JUnit 5 @ValueSource
                r'@CsvSource\(',  # JUnit 5 @CsvSource
                r'@MethodSource\(',  # JUnit 5 @MethodSource
            ]
            
            for pattern in test_data_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        test_data.append({
                            "variable": match[0],
                            "type": match[1],
                            "pattern": "object_creation"
                        })
                    else:
                        test_data.append({
                            "type": match,
                            "pattern": "annotation"
                        })
        
        # Create TestMethod object
        test_method = TestMethod(
            name=method_info["name"],
            return_type=method_info["return_type"],
            annotations=method_info["annotations"],
            assertions=assertions,
            mock_calls=mock_calls,
            test_data=test_data,
            expected_exceptions=method_info["expected_exceptions"],
            timeout=method_info["timeout"],
            display_name=method_info["display_name"]
        )
        test_methods.append(test_method)
    
    return test_methods


def generate_lombok_methods(properties: list[Field], class_name: str, package_name: str) -> list[Method]:
    """Generate Lombok @Data methods (getters, setters, equals, hashCode, toString) for properties."""
    methods = []
    
    # Generate getters and setters for each property
    for prop in properties:
        # Getter
        getter_name = f"get{prop.name[0].upper()}{prop.name[1:]}"
        if prop.type == "Boolean" and prop.name.startswith("is"):
            # For boolean fields starting with 'is', use the field name as getter
            getter_name = prop.name
        
        getter = Method(
            name=getter_name,
            logical_name=f"{package_name}.{class_name}.{getter_name}",
            return_type=prop.type,
            parameters=[],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[],
            description=f"Generated getter for {prop.name} field",  # Generated method description
            ai_description=""  # TODO: Generate AI description using LLM
        )
        methods.append(getter)
        
        # Setter
        setter_name = f"set{prop.name[0].upper()}{prop.name[1:]}"
        setter_param = Field(
            name=prop.name,
            logical_name=f"{package_name}.{class_name}.{prop.name}",
            type=prop.type,
            package_name=package_name,
            class_name=class_name
        )
        
        setter = Method(
            name=setter_name,
            logical_name=f"{package_name}.{class_name}.{setter_name}",
            return_type="void",
            parameters=[setter_param],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[],
            description=f"Generated setter for {prop.name} field",  # Generated method description
            ai_description=""  # TODO: Generate AI description using LLM
        )
        methods.append(setter)
    
    # Generate equals method
    equals_method = Method(
        name="equals",
        logical_name=f"{package_name}.{class_name}.equals",
        return_type="boolean",
        parameters=[Field(name="obj", logical_name=f"{package_name}.{class_name}.obj", type="Object", package_name=package_name, class_name=class_name)],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated equals method for object comparison",  # Generated method description
        ai_description=""  # TODO: Generate AI description using LLM
    )
    methods.append(equals_method)
    
    # Generate hashCode method
    hashcode_method = Method(
        name="hashCode",
        logical_name=f"{package_name}.{class_name}.hashCode",
        return_type="int",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated hashCode method for object hashing",  # Generated method description
        ai_description=""  # TODO: Generate AI description using LLM
    )
    methods.append(hashcode_method)
    
    # Generate toString method
    tostring_method = Method(
        name="toString",
        logical_name=f"{package_name}.{class_name}.toString",
        return_type="String",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated toString method for string representation",  # Generated method description
        ai_description=""  # TODO: Generate AI description using LLM
    )
    methods.append(tostring_method)
    
    return methods


def parse_java_project(directory: str) -> tuple[list[Package], list[Class], dict[str, str], list[Bean], list[BeanDependency], list[Endpoint], list[MyBatisMapper], list[JpaEntity], list[ConfigFile], list[TestClass], list[SqlStatement], str]:
    """Parse Java project and return parsed entities."""
    logger = get_logger(__name__)
    """Parses all Java files in a directory and returns a tuple of (packages, classes, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name)."""
    
    # Extract project name from directory path
    project_name = extract_project_name(directory)
    packages = {}
    classes = {}
    class_to_package_map = {}  # Maps class_key to package_name

    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith(".java"):
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    file_content = f.read() # Read file content once
                try:
                    tree = javalang.parse.parse(file_content)
                    package_name = tree.package.name if tree.package else ""
                    
                    # Create or update package node
                    if package_name and package_name not in packages:
                        packages[package_name] = Package(
                            name=package_name
                        )
                    elif not package_name:
                        # Handle classes without package (default package)
                        package_name = "default"
                        if package_name not in packages:
                            packages[package_name] = Package(
                                name=package_name
                            )
                    
                    import_map = {}
                    for imp in tree.imports:
                        class_name = imp.path.split('.')[-1]
                        import_map[class_name] = imp.path

                    for _, class_declaration in tree.filter(
                        javalang.tree.ClassDeclaration
                    ):
                        class_name = class_declaration.name
                        class_key = f"{package_name}.{class_name}"
                        
                        # Debug: Check if this is the User class
                        if "User" in class_name:
                            logger.debug(f"Found User class - {class_key}")
                            logger.debug(f"Methods count: {len(class_declaration.methods)}")
                            logger.debug(f"Constructors count: {len(class_declaration.constructors)}")
                        
                        # Extract class source code - use the entire file content
                        class_source = file_content


                        if class_key not in classes:
                            # Parse class annotations
                            class_annotations = parse_annotations(class_declaration.annotations, "class") if hasattr(class_declaration, 'annotations') else []
                            
                            classes[class_key] = Class(
                                name=class_name,
                                logical_name=class_key,  # Add logical_name
                                file_path=file_path,
                                type="class", # Simplified for now
                                source=class_source, # Add class source
                                annotations=class_annotations,
                                package_name=package_name,
                                description=""  # TODO: Extract description from comments or annotations
                            )
                            class_to_package_map[class_key] = package_name
                        
                        # --- Start of new import logic ---
                        for imp in tree.imports:
                            classes[class_key].imports.append(imp.path)
                        # --- End of new import logic ---

                        # --- Start of new inheritance logic ---
                        # Handle 'extends'
                        if class_declaration.extends:
                            superclass_name = class_declaration.extends.name
                            # Try to resolve fully qualified name for superclass
                            if superclass_name in import_map:
                                classes[class_key].superclass = import_map[superclass_name]
                            else:
                                # Assume same package or fully qualified if not in import_map
                                classes[class_key].superclass = f"{package_name}.{superclass_name}" if package_name else superclass_name

                        # Handle 'implements'
                        if class_declaration.implements: # Add this check
                            for impl_ref in class_declaration.implements:
                                interface_name = impl_ref.name
                                # Try to resolve fully qualified name for interface
                                if interface_name in import_map:
                                    classes[class_key].interfaces.append(import_map[interface_name])
                                else:
                                    # Assume same package or fully qualified if not in import_map
                                    classes[class_key].interfaces.append(f"{package_name}.{interface_name}" if package_name else interface_name)
                        # --- End of new inheritance logic ---

                        field_map = {}
                        for field_declaration in class_declaration.fields:
                            for declarator in field_declaration.declarators:
                                field_map[declarator.name] = field_declaration.type.name
                                
                                # Parse field annotations
                                field_annotations = parse_annotations(field_declaration.annotations, "field") if hasattr(field_declaration, 'annotations') else []
                                
                                # Extract initial value if present
                                initial_value = ""
                                if hasattr(declarator, 'initializer') and declarator.initializer:
                                    # Convert the initializer to string representation
                                    if hasattr(declarator.initializer, 'value'):
                                        initial_value = str(declarator.initializer.value)
                                    elif hasattr(declarator.initializer, 'type'):
                                        initial_value = str(declarator.initializer.type)
                                    else:
                                        initial_value = str(declarator.initializer)
                                
                                prop = Field(
                                    name=declarator.name,
                                    logical_name=f"{package_name}.{class_name}.{declarator.name}",
                                    type=field_declaration.type.name,
                                    modifiers=list(field_declaration.modifiers), # Add modifiers
                                    package_name=package_name,
                                    class_name=class_name,
                                    annotations=field_annotations,
                                    initial_value=initial_value,
                                    description="",  # TODO: Extract description from comments or annotations
                                    ai_description=""  # TODO: Generate AI description using LLM
                                )
                                classes[class_key].properties.append(prop)

                        all_declarations = class_declaration.methods + class_declaration.constructors
                        
                        # Debug: Check User class method processing
                        if "User" in class_name:
                            logger.debug(f"Processing User class methods - total declarations: {len(all_declarations)}")
                            for i, decl in enumerate(all_declarations):
                                logger.debug(f"Declaration {i}: {type(decl).__name__} - {decl.name}")
                        
                        for declaration in all_declarations:
                            local_var_map = field_map.copy()
                            params = []
                            for param in declaration.parameters:
                                param_type_name = 'Unknown'
                                if hasattr(param.type, 'name'):
                                    param_type_name = param.type.name
                                local_var_map[param.name] = param_type_name
                                params.append(Field(name=param.name, logical_name=f"{package_name}.{class_name}.{param.name}", type=param_type_name, package_name=package_name, class_name=class_name))

                            if declaration.body:
                                for _, var_decl in declaration.filter(javalang.tree.LocalVariableDeclaration):
                                    for declarator in var_decl.declarators:
                                        local_var_map[declarator.name] = var_decl.type.name
                            
                            if isinstance(declaration, javalang.tree.MethodDeclaration):
                                return_type = declaration.return_type.name if declaration.return_type else "void"
                            else: # ConstructorDeclaration
                                return_type = "constructor"

                            # Extract modifiers
                            modifiers = list(declaration.modifiers)
                            
                            # Parse method annotations
                            method_annotations = parse_annotations(declaration.annotations, "method") if hasattr(declaration, 'annotations') else []

                            # Extract method source code
                            method_source = ""
                            if declaration.position:
                                lines = file_content.splitlines(keepends=True) # Keep line endings
                                start_line = declaration.position.line - 1
                                
                                # Find the end of the method by matching braces
                                brace_count = 0
                                end_line = start_line
                                for i in range(start_line, len(lines)):
                                    line = lines[i]
                                    for char in line:
                                        if char == '{':
                                            brace_count += 1
                                        elif char == '}':
                                            brace_count -= 1
                                            if brace_count == 0:
                                                end_line = i
                                                break
                                    if brace_count == 0:
                                        break
                                
                                method_source = "".join(lines[start_line:end_line + 1])

                            method = Method(
                                name=declaration.name,
                                logical_name=f"{class_key}.{declaration.name}",  # Add logical_name
                                return_type=return_type,
                                parameters=params,
                                modifiers=modifiers,
                                source=method_source, # Add method source
                                package_name=package_name,
                                annotations=method_annotations,
                                description=""  # TODO: Extract description from comments or annotations
                            )
                            classes[class_key].methods.append(method)

                            # Extract method calls with order information
                            call_order = 0
                            for _, invocation in declaration.filter(javalang.tree.MethodInvocation):
                                target_class_name = None
                                resolved_target_package = ""
                                resolved_target_class_name = ""
                                
                                if invocation.qualifier:
                                    # External method call
                                    if invocation.qualifier in local_var_map:
                                        target_class_name = local_var_map[invocation.qualifier]
                                    else:
                                        target_class_name = invocation.qualifier
                                    
                                    if target_class_name:
                                        if target_class_name == "System.out":
                                            resolved_target_package = "java.io"
                                            resolved_target_class_name = "PrintStream"
                                        else:
                                            if target_class_name in import_map:
                                                resolved_target_package = ".".join(import_map[target_class_name].split(".")[:-1])
                                            else:
                                                resolved_target_package = package_name
                                                resolved_target_class_name = target_class_name
                                else:
                                    # Same class method call
                                    resolved_target_package = package_name
                                    resolved_target_class_name = class_name

                                if resolved_target_class_name:
                                    # Get line number from invocation position
                                    line_number = invocation.position.line if invocation.position else 0

                                    call = MethodCall(
                                        source_package=package_name,
                                        source_class=class_name,
                                        source_method=declaration.name,
                                        target_package=resolved_target_package,
                                        target_class=resolved_target_class_name,
                                        target_method=invocation.member,
                                        call_order=call_order,
                                        line_number=line_number,
                                        return_type="void"  # Default return type, can be enhanced later
                                    )
                                    classes[class_key].calls.append(call)
                                    call_order += 1
                        
                        # Check for Lombok @Data annotation and generate methods
                        has_data_annotation = any(ann.name == "Data" for ann in classes[class_key].annotations)
                        if has_data_annotation:
                            logger.debug(f"Found @Data annotation on {class_name}, generating Lombok methods")
                            lombok_methods = generate_lombok_methods(classes[class_key].properties, class_name, package_name)
                            classes[class_key].methods.extend(lombok_methods)
                            logger.debug(f"Generated {len(lombok_methods)} Lombok methods for {class_name}")
                except javalang.parser.JavaSyntaxError as e:
                    print(f"Syntax error in {file_path}: {e}")
                    continue
                except Exception as e:
                    print(f"Error parsing {file_path}: {e}")
                    continue
    
    # Extract beans, analyze dependencies, extract endpoints, extract MyBatis mappers, extract JPA entities, extract config files, and extract test classes
    classes_list = list(classes.values())
    beans = extract_beans_from_classes(classes_list)
    dependencies = analyze_bean_dependencies(classes_list, beans)
    endpoints = extract_endpoints_from_classes(classes_list)
    mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
    jpa_entities = extract_jpa_entities_from_classes(classes_list)
    config_files = extract_config_files(directory)
    test_classes = extract_test_classes_from_classes(classes_list)
    
    # Also extract XML mappers
    xml_mappers = extract_mybatis_xml_mappers(directory)
    mybatis_mappers.extend(xml_mappers)
    
    # Extract SQL statements from MyBatis mappers
    sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
    
    return list(packages.values()), classes_list, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name
```

이제 실제 메서드 파싱 부분에서도 ai_description을 추가하겠습니다.


```python
import os
import yaml
import re
from pathlib import Path

import javalang

from src.models.graph_entities import Class, Method, MethodCall, Field, Package, Annotation, Bean, BeanDependency, Endpoint, MyBatisMapper, MyBatisSqlStatement, MyBatisResultMap, SqlStatement, JpaEntity, JpaColumn, JpaRelationship, ConfigFile, DatabaseConfig, ServerConfig, SecurityConfig, LoggingConfig, TestClass, TestMethod, TestConfiguration
from src.utils.logger import get_logger
from typing import Optional, List, Literal


def extract_project_name(java_source_folder: str) -> str:
    """
    JAVA_SOURCE_FOLDER 경로에서 프로젝트 이름을 추출합니다.
    
    Args:
        java_source_folder: Java 소스 폴더 경로
        
    Returns:
        프로젝트 이름 (마지막 디렉토리명)
    """
    # 경로를 정규화하고 마지막 디렉토리명 추출
    path = Path(java_source_folder).resolve()
    return path.name


def extract_sql_statements_from_mappers(mybatis_mappers: list[MyBatisMapper], project_name: str) -> list[SqlStatement]:
    """
    MyBatis mappers에서 SQL statements를 추출합니다.
    
    Args:
        mybatis_mappers: MyBatis mapper 객체들의 리스트
        project_name: 프로젝트 이름
        
    Returns:
        SqlStatement 객체들의 리스트
    """
    sql_statements = []
    
    for mapper in mybatis_mappers:
        for sql_dict in mapper.sql_statements:
            # MyBatisSqlStatement를 SqlStatement로 변환
            sql_statement = SqlStatement(
                id=sql_dict.get('id', ''),
                sql_type=sql_dict.get('sql_type', ''),
                sql_content=sql_dict.get('sql_content', ''),
                parameter_type=sql_dict.get('parameter_type', ''),
                result_type=sql_dict.get('result_type', ''),
                result_map=sql_dict.get('result_map', ''),
                mapper_name=mapper.name,
                annotations=[],  # TODO: annotations를 파싱하여 추가
                project_name=project_name
            )
            sql_statements.append(sql_statement)
    
    return sql_statements


def parse_annotations(annotations, target_type: str = "class") -> list[Annotation]:
    """Parse Java annotations into Annotation objects.
    
    Args:
        annotations: List of annotation nodes from javalang
        target_type: Type of target ("class", "method", "field")
    """
    result = []
    for annotation in annotations:
        annotation_name = annotation.name
        parameters = {}
        
        # Parse annotation parameters if they exist
        if hasattr(annotation, 'element') and annotation.element:
            for element in annotation.element:
                if hasattr(element, 'name') and hasattr(element, 'value'):
                    parameters[element.name] = element.value.value if hasattr(element.value, 'value') else str(element.value)
        
        result.append(Annotation(
            name=annotation_name,
            parameters=parameters,
            target_type=target_type,
            category=classify_springboot_annotation(annotation_name)
        ))
    
    return result


def classify_springboot_annotation(annotation_name: str) -> str:
    """Classify SpringBoot annotations into categories.
    
    Args:
        annotation_name: Name of the annotation (e.g., "@Component", "@Service")
        
    Returns:
        Category of the annotation
    """
    # Component annotations
    component_annotations = {
        "Component", "Service", "Repository", "Controller", 
        "RestController", "Configuration", "Bean"
    }
    
    # Injection annotations
    injection_annotations = {
        "Autowired", "Resource", "Value", "Qualifier", "Primary"
    }
    
    # Web annotations
    web_annotations = {
        "RequestMapping", "GetMapping", "PostMapping", "PutMapping", 
        "DeleteMapping", "PatchMapping", "RequestParam", "PathVariable",
        "RequestBody", "ResponseBody", "ResponseStatus"
    }
    
    # JPA annotations
    jpa_annotations = {
        "Entity", "Table", "Id", "Column", "OneToMany", "ManyToOne",
        "OneToOne", "ManyToMany", "JoinColumn", "GeneratedValue"
    }
    
    # Test annotations
    test_annotations = {
        "Test", "SpringBootTest", "DataJpaTest", "WebMvcTest",
        "MockBean", "SpyBean", "TestPropertySource"
    }
    
    # Security annotations
    security_annotations = {
        "PreAuthorize", "PostAuthorize", "Secured", "RolesAllowed",
        "EnableWebSecurity", "EnableGlobalMethodSecurity"
    }
    
    # Validation annotations
    validation_annotations = {
        "Valid", "NotNull", "NotBlank", "NotEmpty", "Size", "Min", "Max",
        "Pattern", "Email", "AssertTrue", "AssertFalse"
    }
    
    # MyBatis annotations
    mybatis_annotations = {
        "Mapper", "Select", "Insert", "Update", "Delete", "SelectProvider",
        "InsertProvider", "UpdateProvider", "DeleteProvider", "Results",
        "Result", "One", "Many", "MapKey", "Options", "SelectKey"
    }
    
    if annotation_name in component_annotations:
        return "component"
    elif annotation_name in injection_annotations:
        return "injection"
    elif annotation_name in web_annotations:
        return "web"
    elif annotation_name in jpa_annotations:
        return "jpa"
    elif annotation_name in test_annotations:
        return "test"
    elif annotation_name in security_annotations:
        return "security"
    elif annotation_name in validation_annotations:
        return "validation"
    elif annotation_name in mybatis_annotations:
        return "mybatis"
    else:
        return "other"


def classify_test_annotation(annotation_name: str) -> str:
    """Classify test annotations into categories.
    
    Args:
        annotation_name: Name of the annotation
        
    Returns:
        Category of the test annotation
    """
    # JUnit annotations
    junit_annotations = {
        "Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll",
        "DisplayName", "ParameterizedTest", "ValueSource", "CsvSource",
        "MethodSource", "Timeout", "Disabled", "Nested", "RepeatedTest",
        "Order", "TestMethodOrder", "TestInstance", "TestClassOrder"
    }
    
    # Spring Boot Test annotations
    spring_test_annotations = {
        "SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest",
        "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest",
        "MockBean", "SpyBean", "TestConfiguration", "ActiveProfiles",
        "TestPropertySource", "DirtiesContext", "Transactional",
        "Rollback", "Commit", "Sql", "SqlGroup", "AutoConfigureTestDatabase",
        "AutoConfigureMockMvc", "AutoConfigureWebMvc", "AutoConfigureWebClient",
        "MockMvc", "TestEntityManager", "TestContainers", "DynamicPropertySource"
    }
    
    # TestNG annotations
    testng_annotations = {
        "TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass",
        "BeforeSuite", "AfterSuite", "BeforeGroups", "AfterGroups",
        "DataProvider", "Parameters", "Groups", "Priority", "DependsOnMethods",
        "DependsOnGroups", "ExpectedExceptions", "InvocationCount",
        "SuccessPercentage", "TimeOut"
    }
    
    # Mockito annotations
    mockito_annotations = {
        "Mock", "Spy", "InjectMocks", "Captor", "MockedStatic"
    }
    
    # AssertJ annotations
    assertj_annotations = {
        "AssertJ"
    }
    
    # Other test annotations
    other_test_annotations = {
        "Ignore", "Category", "RunWith", "ExtendWith", "ContextConfiguration"
    }
    
    if annotation_name in junit_annotations:
        return "junit"
    elif annotation_name in spring_test_annotations:
        return "spring_test"
    elif annotation_name in testng_annotations:
        return "testng"
    elif annotation_name in mockito_annotations:
        return "mockito"
    elif annotation_name in assertj_annotations:
        return "assertj"
    elif annotation_name in other_test_annotations:
        return "other_test"
    else:
        return "other"


def extract_beans_from_classes(classes: list[Class]) -> list[Bean]:
    """Extract Spring Beans from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Bean objects
    """
    beans = []
    
    for cls in classes:
        # Check if class has Spring component annotations
        component_annotations = [ann for ann in cls.annotations if ann.category == "component"]
        
        # Also check for @Repository on interfaces
        has_repository_annotation = any(ann.name == "Repository" for ann in cls.annotations)
        
        if component_annotations or has_repository_annotation:
            # Determine bean type based on annotations
            bean_type = "component"  # default
            if any(ann.name in ["Service", "Service"] for ann in cls.annotations):
                bean_type = "service"
            elif any(ann.name in ["Repository", "Repository"] for ann in cls.annotations):
                bean_type = "repository"
            elif any(ann.name in ["Controller", "RestController"] for ann in cls.annotations):
                bean_type = "controller"
            elif any(ann.name in ["Configuration", "Configuration"] for ann in cls.annotations):
                bean_type = "configuration"
            
            # Determine scope (default is singleton)
            scope = "singleton"
            for ann in cls.annotations:
                if ann.name == "Scope":
                    if "value" in ann.parameters:
                        scope = ann.parameters["value"]
                    elif "prototype" in str(ann.parameters):
                        scope = "prototype"
                    elif "request" in str(ann.parameters):
                        scope = "request"
                    elif "session" in str(ann.parameters):
                        scope = "session"
            
            # Create bean name (use class name with first letter lowercase)
            bean_name = cls.name[0].lower() + cls.name[1:] if cls.name else cls.name
            
            # Check for @Bean methods in configuration classes
            bean_methods = []
            if bean_type == "configuration":
                for method in cls.methods:
                    if any(ann.name == "Bean" for ann in method.annotations):
                        bean_methods.append(method)
            
            bean = Bean(
                name=bean_name,
                type=bean_type,
                scope=scope,
                class_name=cls.name,
                package_name=cls.package_name,
                annotation_names=[ann.name for ann in cls.annotations] if cls.annotations else [],
                method_count=len(bean_methods) if bean_type == "configuration" else len(cls.methods) if cls.methods else 0,
                property_count=len(cls.properties) if cls.properties else 0
            )
            beans.append(bean)
    
    return beans


def analyze_bean_dependencies(classes: list[Class], beans: list[Bean]) -> list[BeanDependency]:
    """Analyze dependencies between Spring Beans.
    
    Args:
        classes: List of parsed Class objects
        beans: List of Bean objects
        
    Returns:
        List of BeanDependency objects
    """
    dependencies = []
    
    # Create a mapping from class names to bean names
    class_to_bean = {}
    for bean in beans:
        class_to_bean[bean.class_name] = bean.name
    
    for cls in classes:
        # Check if this class is a bean
        if cls.name not in class_to_bean:
            continue
            
        source_bean = class_to_bean[cls.name]
        
        # Analyze field injections (@Autowired, @Resource, @Value)
        for prop in cls.properties:
            if any(ann.category == "injection" for ann in prop.annotations):
                # Try to determine target bean from field type
                target_bean = None
                field_type = prop.type
                
                # Look for exact class name match
                if field_type in class_to_bean:
                    target_bean = class_to_bean[field_type]
                else:
                    # Look for interface implementations (simplified - just check if type matches any bean class name)
                    for bean in beans:
                        if field_type == bean.class_name:
                            target_bean = bean.name
                            break
                
                if target_bean:
                    injection_type = "field"
                    for ann in prop.annotations:
                        if ann.name == "Autowired":
                            injection_type = "field"
                        elif ann.name == "Resource":
                            injection_type = "field"
                        elif ann.name == "Value":
                            injection_type = "field"
                    
                    dependency = BeanDependency(
                        source_bean=source_bean,
                        target_bean=target_bean,
                        injection_type=injection_type,
                        field_name=prop.name
                    )
                    dependencies.append(dependency)
        
        # Analyze constructor injections
        for method in cls.methods:
            if method.name == cls.name:  # Constructor
                for param in method.parameters:
                    if any(ann.category == "injection" for ann in param.annotations):
                        target_bean = None
                        param_type = param.type
                        
                        if param_type in class_to_bean:
                            target_bean = class_to_bean[param_type]
                        else:
                            # Look for interface implementations (simplified)
                            for bean in beans:
                                if param_type == bean.class_name:
                                    target_bean = bean.name
                                    break
                        
                        if target_bean:
                            dependency = BeanDependency(
                                source_bean=source_bean,
                                target_bean=target_bean,
                                injection_type="constructor",
                                parameter_name=param.name
                            )
                            dependencies.append(dependency)
        
        # Analyze setter injections
        for method in cls.methods:
            if method.name.startswith("set") and len(method.parameters) == 1:
                if any(ann.category == "injection" for ann in method.annotations):
                    param = method.parameters[0]
                    target_bean = None
                    param_type = param.type
                    
                    if param_type in class_to_bean:
                        target_bean = class_to_bean[param_type]
                    else:
                        # Look for interface implementations (simplified)
                        for bean in beans:
                            if param_type == bean.class_name:
                                target_bean = bean.name
                                break
                    
                    if target_bean:
                        dependency = BeanDependency(
                            source_bean=source_bean,
                            target_bean=target_bean,
                            injection_type="setter",
                            method_name=method.name,
                            parameter_name=param.name
                        )
                        dependencies.append(dependency)
    
    return dependencies


def extract_endpoints_from_classes(classes: list[Class]) -> list[Endpoint]:
    """Extract REST API endpoints from controller classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Endpoint objects
    """
    endpoints = []
    
    for cls in classes:
        # Check if class is a controller
        is_controller = any(ann.name in ["Controller", "RestController"] for ann in cls.annotations)
        
        if not is_controller:
            continue
            
        # Get class-level path mapping
        class_path = ""
        for ann in cls.annotations:
            if ann.name == "RequestMapping":
                if "value" in ann.parameters:
                    class_path = ann.parameters["value"]
                break
        
        # Process each method in the controller
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
                
            # Check if method has web mapping annotations
            web_annotations = [ann for ann in method.annotations if ann.category == "web"]
            
            if not web_annotations:
                continue
            
            # Extract endpoint information
            endpoint_path = ""
            http_method = "GET"  # default
            
            for ann in web_annotations:
                if ann.name in ["RequestMapping", "GetMapping", "PostMapping", "PutMapping", "DeleteMapping", "PatchMapping"]:
                    # Extract path
                    if "value" in ann.parameters:
                        endpoint_path = ann.parameters["value"]
                    elif "path" in ann.parameters:
                        endpoint_path = ann.parameters["path"]
                    
                    # Extract HTTP method
                    if ann.name == "GetMapping":
                        http_method = "GET"
                    elif ann.name == "PostMapping":
                        http_method = "POST"
                    elif ann.name == "PutMapping":
                        http_method = "PUT"
                    elif ann.name == "DeleteMapping":
                        http_method = "DELETE"
                    elif ann.name == "PatchMapping":
                        http_method = "PATCH"
                    elif ann.name == "RequestMapping":
                        if "method" in ann.parameters:
                            method_value = ann.parameters["method"]
                            if isinstance(method_value, list) and len(method_value) > 0:
                                http_method = method_value[0]
                            else:
                                http_method = str(method_value)
                        else:
                            http_method = "GET"  # default for RequestMapping
                    break
            
            # Build full path
            full_path = class_path
            if endpoint_path:
                if full_path and not full_path.endswith("/") and not endpoint_path.startswith("/"):
                    full_path += "/"
                full_path += endpoint_path
            elif not full_path:
                full_path = "/"
            
            # Extract method parameters
            parameters = []
            for param in method.parameters:
                param_info = {
                    "name": param.name,
                    "type": param.type,
                    "annotations": [ann.name for ann in param.annotations if ann.category == "web"]
                }
                parameters.append(param_info)
            
            # Extract return type
            return_type = method.return_type if method.return_type != "constructor" else "void"
            
            # Create endpoint
            endpoint = Endpoint(
                path=endpoint_path or "/",
                method=http_method,
                controller_class=cls.name,
                handler_method=method.name,
                parameters=parameters,
                return_type=return_type,
                annotations=[ann.name for ann in web_annotations],
                full_path=full_path
            )
            endpoints.append(endpoint)
    
    return endpoints


def extract_mybatis_mappers_from_classes(classes: list[Class]) -> list[MyBatisMapper]:
    """Extract MyBatis Mappers from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for cls in classes:
        # Check if class is a MyBatis Mapper interface
        is_mapper = any(ann.name == "Mapper" for ann in cls.annotations)
        
        if not is_mapper:
            continue
        
        # Extract mapper methods with MyBatis annotations
        mapper_methods = []
        sql_statements = []
        
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
            
            # Check if method has MyBatis annotations
            mybatis_annotations = [ann for ann in method.annotations if ann.category == "mybatis"]
            
            if not mybatis_annotations:
                continue
            
            # Extract SQL statement information
            sql_type = "SELECT"  # default
            sql_content = ""
            parameter_type = ""
            result_type = ""
            result_map = ""
            
            for ann in mybatis_annotations:
                if ann.name in ["Select", "SelectProvider"]:
                    sql_type = "SELECT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Insert", "InsertProvider"]:
                    sql_type = "INSERT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Update", "UpdateProvider"]:
                    sql_type = "UPDATE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Delete", "DeleteProvider"]:
                    sql_type = "DELETE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                
                # Extract parameter and result type information
                if "parameterType" in ann.parameters:
                    parameter_type = ann.parameters["parameterType"]
                if "resultType" in ann.parameters:
                    result_type = ann.parameters["resultType"]
                if "resultMap" in ann.parameters:
                    result_map = ann.parameters["resultMap"]
            
            # Create method info
            method_info = {
                "name": method.name,
                "return_type": method.return_type,
                "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            mapper_methods.append(method_info)
            
            # Create SQL statement info
            sql_statement = {
                "id": method.name,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            sql_statements.append(sql_statement)
        
        # Create mapper
        mapper = MyBatisMapper(
            name=cls.name,
            type="interface",
            namespace=f"{cls.package_name}.{cls.name}",
            methods=mapper_methods,
            sql_statements=sql_statements,
            file_path=cls.file_path,
            package_name=cls.package_name
        )
        mappers.append(mapper)
    
    return mappers


def parse_mybatis_xml_file(file_path: str) -> MyBatisMapper:
    """Parse MyBatis XML mapper file.
    
    Args:
        file_path: Path to the XML mapper file
        
    Returns:
        MyBatisMapper object
    """
    import xml.etree.ElementTree as ET
    
    try:
        tree = ET.parse(file_path)
        root = tree.getroot()
        
        # Extract namespace
        namespace = root.get("namespace", "")
        
        # Extract SQL statements
        sql_statements = []
        for statement in root.findall(".//*[@id]"):
            statement_id = statement.get("id")
            tag_name = statement.tag.lower()
            
            # Determine SQL type
            sql_type = "SELECT"
            if tag_name == "insert":
                sql_type = "INSERT"
            elif tag_name == "update":
                sql_type = "UPDATE"
            elif tag_name == "delete":
                sql_type = "DELETE"
            
            # Extract SQL content
            sql_content = statement.text.strip() if statement.text else ""
            
            # Extract parameter and result information
            parameter_type = statement.get("parameterType", "")
            result_type = statement.get("resultType", "")
            result_map = statement.get("resultMap", "")
            
            sql_statement = {
                "id": statement_id,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": []
            }
            sql_statements.append(sql_statement)
        
        # Extract ResultMaps
        result_maps = []
        for result_map in root.findall(".//resultMap"):
            result_map_id = result_map.get("id")
            result_map_type = result_map.get("type", "")
            
            properties = []
            for property_elem in result_map.findall(".//result"):
                prop = {
                    "property": property_elem.get("property", ""),
                    "column": property_elem.get("column", ""),
                    "jdbc_type": property_elem.get("jdbcType", "")
                }
                properties.append(prop)
            
            result_map_info = {
                "id": result_map_id,
                "type": result_map_type,
                "properties": properties,
                "associations": [],
                "collections": []
            }
            result_maps.append(result_map_info)
        
        # Create mapper
        mapper_name = namespace.split(".")[-1] if namespace else os.path.basename(file_path).replace(".xml", "")
        package_name = ".".join(namespace.split(".")[:-1]) if namespace else ""
        
        mapper = MyBatisMapper(
            name=mapper_name,
            type="xml",
            namespace=namespace,
            methods=[],  # XML mappers don't have Java methods
            sql_statements=sql_statements,
            file_path=file_path,
            package_name=package_name
        )
        
        return mapper
        
    except ET.ParseError as e:
        print(f"Error parsing XML file {file_path}: {e}")
        return None
    except Exception as e:
        print(f"Error reading XML file {file_path}: {e}")
        return None


def extract_mybatis_xml_mappers(directory: str) -> list[MyBatisMapper]:
    """Extract MyBatis XML mappers from directory.
    
    Args:
        directory: Directory to search for XML mapper files
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith("Mapper.xml") or file.endswith("Dao.xml"):
                file_path = os.path.join(root, file)
                mapper = parse_mybatis_xml_file(file_path)
                if mapper:
                    mappers.append(mapper)
    
    return mappers


def extract_jpa_entities_from_classes(classes: list[Class]) -> list[JpaEntity]:
    """Extract JPA Entities from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of JpaEntity objects
    """
    entities = []
    
    for cls in classes:
        # Check if class is a JPA Entity
        is_entity = any(ann.name == "Entity" for ann in cls.annotations)
        
        if not is_entity:
            continue
        
        # Extract table name
        table_name = cls.name.lower()  # default table name
        for ann in cls.annotations:
            if ann.name == "Table":
                if "name" in ann.parameters:
                    table_name = ann.parameters["name"]
                break
        
        # Extract columns from properties
        columns = []
        relationships = []
        
        for prop in cls.properties:
            # Check if property has JPA column annotations
            jpa_annotations = [ann for ann in prop.annotations if ann.category == "jpa"]
            
            if jpa_annotations:
                # Extract column information
                column_name = prop.name  # default column name
                nullable = True
                unique = False
                length = 0
                precision = 0
                scale = 0
                
                for ann in jpa_annotations:
                    if ann.name == "Column":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                        if "nullable" in ann.parameters:
                            nullable = ann.parameters["nullable"]
                        if "unique" in ann.parameters:
                            unique = ann.parameters["unique"]
                        if "length" in ann.parameters:
                            length = ann.parameters["length"]
                        if "precision" in ann.parameters:
                            precision = ann.parameters["precision"]
                        if "scale" in ann.parameters:
                            scale = ann.parameters["scale"]
                    elif ann.name == "Id":
                        column_name = "id"  # Primary key column
                        nullable = False
                        unique = True
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                
                # Check for relationship annotations
                relationship_type = None
                target_entity = ""
                mapped_by = ""
                join_column = ""
                join_table = ""
                cascade = []
                fetch = "LAZY"
                
                for ann in jpa_annotations:
                    if ann.name in ["OneToOne", "OneToMany", "ManyToOne", "ManyToMany"]:
                        relationship_type = ann.name
                        if "targetEntity" in ann.parameters:
                            target_entity = ann.parameters["targetEntity"]
                        if "mappedBy" in ann.parameters:
                            mapped_by = ann.parameters["mappedBy"]
                        if "cascade" in ann.parameters:
                            cascade = ann.parameters["cascade"] if isinstance(ann.parameters["cascade"], list) else [ann.parameters["cascade"]]
                        if "fetch" in ann.parameters:
                            fetch = ann.parameters["fetch"]
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            join_column = ann.parameters["name"]
                    elif ann.name == "JoinTable":
                        if "name" in ann.parameters:
                            join_table = ann.parameters["name"]
                
                # Create column info
                column_info = {
                    "property_name": prop.name,
                    "column_name": column_name,
                    "data_type": prop.type,
                    "nullable": nullable,
                    "unique": unique,
                    "length": length,
                    "precision": precision,
                    "scale": scale,
                    "annotations": [ann.name for ann in jpa_annotations]
                }
                columns.append(column_info)
                
                # Create relationship info if it's a relationship
                if relationship_type:
                    relationship_info = {
                        "type": relationship_type,
                        "target_entity": target_entity,
                        "mapped_by": mapped_by,
                        "join_column": join_column,
                        "join_table": join_table,
                        "cascade": cascade,
                        "fetch": fetch,
                        "annotations": [ann.name for ann in jpa_annotations]
                    }
                    relationships.append(relationship_info)
        
        # Create entity
        entity = JpaEntity(
            name=cls.name,
            table_name=table_name,
            columns=columns,
            relationships=relationships,
            annotations=[ann.name for ann in cls.annotations if ann.category == "jpa"],
            package_name=cls.package_name,
            file_path=cls.file_path
        )
        entities.append(entity)
    
    return entities


def parse_yaml_config(file_path: str) -> ConfigFile:
    """Parse YAML configuration file.
    
    Args:
        file_path: Path to the YAML file
        
    Returns:
        ConfigFile object
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = yaml.safe_load(f)
        
        if not content:
            content = {}
        
        # Extract file info
        file_name = os.path.basename(file_path)
        file_type = "yaml" if file_path.endswith('.yaml') else "yml"
        
        # Extract profiles
        profiles = []
        if 'spring' in content and 'profiles' in content['spring']:
            if 'active' in content['spring']['profiles']:
                profiles = content['spring']['profiles']['active']
                if isinstance(profiles, str):
                    profiles = [profiles]
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        # Extract sections
        sections = []
        for key, value in content.items():
            if isinstance(value, dict):
                sections.append({
                    "name": key,
                    "properties": value,
                    "type": "section"
                })
        
        return ConfigFile(
            name=file_name,
            file_path=file_path,
            file_type=file_type,
            properties=content,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing YAML file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="yaml",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def parse_properties_config(file_path: str) -> ConfigFile:
    """Parse Properties configuration file.
    
    Args:
        file_path: Path to the properties file
        
    Returns:
        ConfigFile object
    """
    try:
        properties = {}
        sections = []
        profiles = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                
                # Skip empty lines and comments
                if not line or line.startswith('#'):
                    continue
                
                # Parse key=value pairs
                if '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    
                    # Remove quotes if present
                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]
                    elif value.startswith("'") and value.endswith("'"):
                        value = value[1:-1]
                    
                    properties[key] = value
                    
                    # Check for profiles
                    if key == 'spring.profiles.active':
                        profiles = [p.strip() for p in value.split(',')]
        
        # Group properties by section
        section_map = {}
        for key, value in properties.items():
            if '.' in key:
                section = key.split('.')[0]
                if section not in section_map:
                    section_map[section] = {}
                section_map[section][key] = value
            else:
                if 'root' not in section_map:
                    section_map['root'] = {}
                section_map['root'][key] = value
        
        for section_name, section_props in section_map.items():
            sections.append({
                "name": section_name,
                "properties": section_props,
                "type": "section"
            })
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties=properties,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing Properties file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def extract_database_config(config_file: ConfigFile) -> DatabaseConfig:
    """Extract database configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        DatabaseConfig object
    """
    db_config = DatabaseConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        spring_config = config_file.properties.get('spring', {})
        datasource_config = spring_config.get('datasource', {})
        jpa_config = spring_config.get('jpa', {})
        
        db_config.driver = datasource_config.get('driver-class-name', '')
        db_config.url = datasource_config.get('url', '')
        db_config.username = datasource_config.get('username', '')
        db_config.password = datasource_config.get('password', '')
        db_config.dialect = jpa_config.get('database-platform', '')
        db_config.hibernate_ddl_auto = jpa_config.get('hibernate', {}).get('ddl-auto', '')
        db_config.show_sql = jpa_config.get('show-sql', False)
        db_config.format_sql = jpa_config.get('properties', {}).get('hibernate', {}).get('format_sql', False)
        
        # Store additional JPA properties
        if 'properties' in jpa_config:
            db_config.jpa_properties = jpa_config['properties']
    
    else:
        # Properties format
        props = config_file.properties
        
        db_config.driver = props.get('spring.datasource.driver-class-name', '')
        db_config.url = props.get('spring.datasource.url', '')
        db_config.username = props.get('spring.datasource.username', '')
        db_config.password = props.get('spring.datasource.password', '')
        db_config.dialect = props.get('spring.jpa.database-platform', '')
        db_config.hibernate_ddl_auto = props.get('spring.jpa.hibernate.ddl-auto', '')
        db_config.show_sql = props.get('spring.jpa.show-sql', 'false').lower() == 'true'
        db_config.format_sql = props.get('spring.jpa.properties.hibernate.format_sql', 'false').lower() == 'true'
        
        # Store additional JPA properties
        jpa_props = {}
        for key, value in props.items():
            if key.startswith('spring.jpa.properties.'):
                jpa_props[key] = value
        db_config.jpa_properties = jpa_props
    
    return db_config


def extract_server_config(config_file: ConfigFile) -> ServerConfig:
    """Extract server configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        ServerConfig object
    """
    server_config = ServerConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        server_props = config_file.properties.get('server', {})
        
        server_config.port = server_props.get('port', 8080)
        server_config.context_path = server_props.get('servlet', {}).get('context-path', '')
        server_config.servlet_path = server_props.get('servlet', {}).get('path', '')
        
        # SSL configuration
        ssl_config = server_props.get('ssl', {})
        server_config.ssl_enabled = bool(ssl_config)
        server_config.ssl_key_store = ssl_config.get('key-store', '')
        server_config.ssl_key_store_password = ssl_config.get('key-store-password', '')
        server_config.ssl_key_store_type = ssl_config.get('key-store-type', '')
    
    else:
        # Properties format
        props = config_file.properties
        
        server_config.port = int(props.get('server.port', '8080'))
        server_config.context_path = props.get('server.servlet.context-path', '')
        server_config.servlet_path = props.get('server.servlet.path', '')
        
        # SSL configuration
        server_config.ssl_enabled = any(key.startswith('server.ssl.') for key in props.keys())
        server_config.ssl_key_store = props.get('server.ssl.key-store', '')
        server_config.ssl_key_store_password = props.get('server.ssl.key-store-password', '')
        server_config.ssl_key_store_type = props.get('server.ssl.key-store-type', '')
    
    return server_config


def extract_security_config(config_file: ConfigFile) -> SecurityConfig:
    """Extract security configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        SecurityConfig object
    """
    security_config = SecurityConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        security_props = config_file.properties.get('security', {})
        jwt_props = security_props.get('jwt', {})
        cors_props = security_props.get('cors', {})
        
        security_config.enabled = bool(security_props)
        security_config.authentication_type = security_props.get('authentication-type', '')
        security_config.jwt_secret = jwt_props.get('secret', '')
        security_config.jwt_expiration = jwt_props.get('expiration', 0)
        security_config.cors_allowed_origins = cors_props.get('allowed-origins', [])
        security_config.cors_allowed_methods = cors_props.get('allowed-methods', [])
        security_config.cors_allowed_headers = cors_props.get('allowed-headers', [])
    
    else:
        # Properties format
        props = config_file.properties
        
        security_config.enabled = any(key.startswith('security.') for key in props.keys())
        security_config.authentication_type = props.get('security.authentication-type', '')
        security_config.jwt_secret = props.get('security.jwt.secret', '')
        security_config.jwt_expiration = int(props.get('security.jwt.expiration', '0'))
        
        # CORS configuration
        origins = props.get('security.cors.allowed-origins', '')
        if origins:
            security_config.cors_allowed_origins = [o.strip() for o in origins.split(',')]
        
        methods = props.get('security.cors.allowed-methods', '')
        if methods:
            security_config.cors_allowed_methods = [m.strip() for m in methods.split(',')]
        
        headers = props.get('security.cors.allowed-headers', '')
        if headers:
            security_config.cors_allowed_headers = [h.strip() for h in headers.split(',')]
    
    return security_config


def extract_logging_config(config_file: ConfigFile) -> LoggingConfig:
    """Extract logging configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        LoggingConfig object
    """
    logging_config = LoggingConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        logging_props = config_file.properties.get('logging', {})
        
        logging_config.level = logging_props.get('level', {}).get('root', 'INFO')
        logging_config.pattern = logging_props.get('pattern', {}).get('console', '')
        logging_config.file_path = logging_props.get('file', {}).get('name', '')
        logging_config.max_file_size = logging_props.get('file', {}).get('max-size', '')
        logging_config.max_history = logging_props.get('file', {}).get('max-history', 0)
        logging_config.console_output = logging_props.get('console', {}).get('enabled', True)
    
    else:
        # Properties format
        props = config_file.properties
        
        logging_config.level = props.get('logging.level.root', 'INFO')
        logging_config.pattern = props.get('logging.pattern.console', '')
        logging_config.file_path = props.get('logging.file.name', '')
        logging_config.max_file_size = props.get('logging.file.max-size', '')
        logging_config.max_history = int(props.get('logging.file.max-history', '0'))
        logging_config.console_output = props.get('logging.console.enabled', 'true').lower() == 'true'
    
    return logging_config


def extract_config_files(directory: str) -> list[ConfigFile]:
    """Extract configuration files from directory.
    
    Args:
        directory: Directory to search for config files
        
    Returns:
        List of ConfigFile objects
    """
    config_files = []
    
    # Common config file patterns
    config_patterns = [
        "application.yml",
        "application.yaml", 
        "application.properties",
        "application-*.properties",
        "bootstrap.yml",
        "bootstrap.yaml",
        "bootstrap.properties"
    ]
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            # Check if file matches any config pattern
            is_config_file = False
            for pattern in config_patterns:
                if pattern == file or (pattern.endswith('*') and file.startswith(pattern[:-1])):
                    is_config_file = True
                    break
            
            if is_config_file:
                file_path = os.path.join(root, file)
                
                if file.endswith(('.yml', '.yaml')):
                    config_file = parse_yaml_config(file_path)
                elif file.endswith('.properties'):
                    config_file = parse_properties_config(file_path)
                else:
                    continue
                
                config_files.append(config_file)
    
    return config_files


def extract_test_classes_from_classes(classes: list[Class]) -> list[TestClass]:
    """Extract test classes from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of TestClass objects
    """
    test_classes = []
    
    for cls in classes:
        # Check if class is a test class
        test_annotations = [ann for ann in cls.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
        
        if not test_annotations:
            continue
        
        # Determine test framework and type
        test_framework = "junit"  # default
        test_type = "unit"  # default
        
        for ann in test_annotations:
            if ann.name in ["SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest", "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest"]:
                test_framework = "spring_test"
                if ann.name == "SpringBootTest":
                    test_type = "integration"
                else:
                    test_type = "slice"
            elif ann.name in ["TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass"]:
                test_framework = "testng"
            elif ann.name in ["Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll"]:
                test_framework = "junit"
        
        # Extract test methods
        test_methods = []
        setup_methods = []
        
        for method in cls.methods:
            method_annotations = [ann.name for ann in method.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
            
            if method_annotations:
                # Check if it's a setup/teardown method
                if any(ann in method_annotations for ann in ["BeforeEach", "AfterEach", "BeforeAll", "AfterAll", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass", "BeforeSuite", "AfterSuite"]):
                    setup_methods.append({
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters]
                    })
                else:
                    # Regular test method
                    test_method_info = {
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                        "assertions": [],
                        "mock_calls": [],
                        "test_data": [],
                        "expected_exceptions": [],
                        "timeout": 0,
                        "display_name": ""
                    }
                    
                    # Extract display name
                    for ann in method.annotations:
                        if ann.name == "DisplayName" and "value" in ann.parameters:
                            test_method_info["display_name"] = ann.parameters["value"]
                        elif ann.name == "Timeout" and "value" in ann.parameters:
                            test_method_info["timeout"] = ann.parameters["value"]
                    
                    # Extract expected exceptions
                    for ann in method.annotations:
                        if ann.name == "ExpectedExceptions" and "value" in ann.parameters:
                            test_method_info["expected_exceptions"] = ann.parameters["value"] if isinstance(ann.parameters["value"], list) else [ann.parameters["value"]]
                    
                    test_methods.append(test_method_info)
        
        # Extract mock dependencies
        mock_dependencies = []
        for prop in cls.properties:
            prop_annotations = [ann.name for ann in prop.annotations if classify_test_annotation(ann.name) in ["mockito", "spring_test"]]
            if prop_annotations:
                mock_dependencies.append({
                    "name": prop.name,
                    "type": prop.type,
                    "annotations": prop_annotations,
                    "mock_type": "mock" if "Mock" in prop_annotations else "spy" if "Spy" in prop_annotations else "bean"
                })
        
        # Extract test configurations
        test_configurations = []
        for ann in cls.annotations:
            if ann.name in ["TestConfiguration", "ActiveProfiles", "TestPropertySource"]:
                config_info = {
                    "name": ann.name,
                    "type": "configuration" if ann.name == "TestConfiguration" else "profile" if ann.name == "ActiveProfiles" else "property",
                    "properties": ann.parameters,
                    "active_profiles": ann.parameters.get("value", []) if ann.name == "ActiveProfiles" else [],
                    "test_slices": [],
                    "mock_beans": [],
                    "spy_beans": []
                }
                test_configurations.append(config_info)
        
        # Create test class
        test_class = TestClass(
            name=cls.name,
            package_name=cls.package_name,
            test_framework=test_framework,
            test_type=test_type,
            annotations=[ann.name for ann in test_annotations],
            test_methods=test_methods,
            setup_methods=setup_methods,
            mock_dependencies=mock_dependencies,
            test_configurations=test_configurations,
            file_path=cls.file_path
        )
        test_classes.append(test_class)
    
    return test_classes


def analyze_test_methods(test_class: TestClass, class_obj: Class) -> list[TestMethod]:
    """Analyze test methods for assertions, mock calls, and test data.
    
    Args:
        test_class: TestClass object
        class_obj: Original Class object
        
    Returns:
        List of analyzed TestMethod objects
    """
    test_methods = []
    
    for method_info in test_class.test_methods:
        # Find the corresponding method in the class
        method_obj = None
        for method in class_obj.methods:
            if method.name == method_info["name"]:
                method_obj = method
                break
        
        if not method_obj:
            continue
        
        # Analyze method source code for assertions and mock calls
        assertions = []
        mock_calls = []
        test_data = []
        
        if method_obj.source:
            source_code = method_obj.source
            
            # Find assertions (JUnit, AssertJ, etc.)
            assertion_patterns = [
                r'assert\w+\(',  # JUnit assertions
                r'assertThat\(',  # AssertJ
                r'assertEquals\(',  # JUnit
                r'assertTrue\(',  # JUnit
                r'assertFalse\(',  # JUnit
                r'assertNotNull\(',  # JUnit
                r'assertNull\(',  # JUnit
                r'assertThrows\(',  # JUnit 5
                r'assertDoesNotThrow\(',  # JUnit 5
                r'verify\(',  # Mockito verify
                r'when\(',  # Mockito when
                r'then\(',  # Mockito then
                r'given\(',  # BDDMockito given
                r'willReturn\(',  # Mockito willReturn
                r'willThrow\(',  # Mockito willThrow
            ]
            
            for pattern in assertion_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    assertions.append({
                        "type": match,
                        "line": source_code.find(match) + 1
                    })
            
            # Find mock calls
            mock_call_patterns = [
                r'(\w+)\.(\w+)\(',  # Method calls on objects
                r'mock\(',  # Mockito mock creation
                r'spy\(',  # Mockito spy creation
                r'@Mock\s+(\w+)',  # @Mock annotation
                r'@Spy\s+(\w+)',  # @Spy annotation
                r'@InjectMocks\s+(\w+)',  # @InjectMocks annotation
            ]
            
            for pattern in mock_call_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        mock_calls.append({
                            "object": match[0],
                            "method": match[1],
                            "type": "method_call"
                        })
                    else:
                        mock_calls.append({
                            "type": match,
                            "line": source_code.find(match) + 1
                        })
            
            # Find test data setup
            test_data_patterns = [
                r'new\s+(\w+)\(',  # Object creation
                r'(\w+)\s*=\s*new\s+(\w+)\(',  # Variable assignment with new
                r'@ValueSource\(',  # JUnit 5 @ValueSource
                r'@CsvSource\(',  # JUnit 5 @CsvSource
                r'@MethodSource\(',  # JUnit 5 @MethodSource
            ]
            
            for pattern in test_data_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        test_data.append({
                            "variable": match[0],
                            "type": match[1],
                            "pattern": "object_creation"
                        })
                    else:
                        test_data.append({
                            "type": match,
                            "pattern": "annotation"
                        })
        
        # Create TestMethod object
        test_method = TestMethod(
            name=method_info["name"],
            return_type=method_info["return_type"],
            annotations=method_info["annotations"],
            assertions=assertions,
            mock_calls=mock_calls,
            test_data=test_data,
            expected_exceptions=method_info["expected_exceptions"],
            timeout=method_info["timeout"],
            display_name=method_info["display_name"]
        )
        test_methods.append(test_method)
    
    return test_methods


def generate_lombok_methods(properties: list[Field], class_name: str, package_name: str) -> list[Method]:
    """Generate Lombok @Data methods (getters, setters, equals, hashCode, toString) for properties."""
    methods = []
    
    # Generate getters and setters for each property
    for prop in properties:
        # Getter
        getter_name = f"get{prop.name[0].upper()}{prop.name[1:]}"
        if prop.type == "Boolean" and prop.name.startswith("is"):
            # For boolean fields starting with 'is', use the field name as getter
            getter_name = prop.name
        
        getter = Method(
            name=getter_name,
            logical_name=f"{package_name}.{class_name}.{getter_name}",
            return_type=prop.type,
            parameters=[],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[],
            description=f"Generated getter for {prop.name} field",  # Generated method description
            ai_description=""  # TODO: Generate AI description using LLM
        )
        methods.append(getter)
        
        # Setter
        setter_name = f"set{prop.name[0].upper()}{prop.name[1:]}"
        setter_param = Field(
            name=prop.name,
            logical_name=f"{package_name}.{class_name}.{prop.name}",
            type=prop.type,
            package_name=package_name,
            class_name=class_name
        )
        
        setter = Method(
            name=setter_name,
            logical_name=f"{package_name}.{class_name}.{setter_name}",
            return_type="void",
            parameters=[setter_param],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[],
            description=f"Generated setter for {prop.name} field",  # Generated method description
            ai_description=""  # TODO: Generate AI description using LLM
        )
        methods.append(setter)
    
    # Generate equals method
    equals_method = Method(
        name="equals",
        logical_name=f"{package_name}.{class_name}.equals",
        return_type="boolean",
        parameters=[Field(name="obj", logical_name=f"{package_name}.{class_name}.obj", type="Object", package_name=package_name, class_name=class_name)],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated equals method for object comparison",  # Generated method description
        ai_description=""  # TODO: Generate AI description using LLM
    )
    methods.append(equals_method)
    
    # Generate hashCode method
    hashcode_method = Method(
        name="hashCode",
        logical_name=f"{package_name}.{class_name}.hashCode",
        return_type="int",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated hashCode method for object hashing",  # Generated method description
        ai_description=""  # TODO: Generate AI description using LLM
    )
    methods.append(hashcode_method)
    
    # Generate toString method
    tostring_method = Method(
        name="toString",
        logical_name=f"{package_name}.{class_name}.toString",
        return_type="String",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated toString method for string representation",  # Generated method description
        ai_description=""  # TODO: Generate AI description using LLM
    )
    methods.append(tostring_method)
    
    return methods


def parse_java_project(directory: str) -> tuple[list[Package], list[Class], dict[str, str], list[Bean], list[BeanDependency], list[Endpoint], list[MyBatisMapper], list[JpaEntity], list[ConfigFile], list[TestClass], list[SqlStatement], str]:
    """Parse Java project and return parsed entities."""
    logger = get_logger(__name__)
    """Parses all Java files in a directory and returns a tuple of (packages, classes, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name)."""
    
    # Extract project name from directory path
    project_name = extract_project_name(directory)
    packages = {}
    classes = {}
    class_to_package_map = {}  # Maps class_key to package_name

    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith(".java"):
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    file_content = f.read() # Read file content once
                try:
                    tree = javalang.parse.parse(file_content)
                    package_name = tree.package.name if tree.package else ""
                    
                    # Create or update package node
                    if package_name and package_name not in packages:
                        packages[package_name] = Package(
                            name=package_name
                        )
                    elif not package_name:
                        # Handle classes without package (default package)
                        package_name = "default"
                        if package_name not in packages:
                            packages[package_name] = Package(
                                name=package_name
                            )
                    
                    import_map = {}
                    for imp in tree.imports:
                        class_name = imp.path.split('.')[-1]
                        import_map[class_name] = imp.path

                    for _, class_declaration in tree.filter(
                        javalang.tree.ClassDeclaration
                    ):
                        class_name = class_declaration.name
                        class_key = f"{package_name}.{class_name}"
                        
                        # Debug: Check if this is the User class
                        if "User" in class_name:
                            logger.debug(f"Found User class - {class_key}")
                            logger.debug(f"Methods count: {len(class_declaration.methods)}")
                            logger.debug(f"Constructors count: {len(class_declaration.constructors)}")
                        
                        # Extract class source code - use the entire file content
                        class_source = file_content


                        if class_key not in classes:
                            # Parse class annotations
                            class_annotations = parse_annotations(class_declaration.annotations, "class") if hasattr(class_declaration, 'annotations') else []
                            
                            classes[class_key] = Class(
                                name=class_name,
                                logical_name=class_key,  # Add logical_name
                                file_path=file_path,
                                type="class", # Simplified for now
                                source=class_source, # Add class source
                                annotations=class_annotations,
                                package_name=package_name,
                                description=""  # TODO: Extract description from comments or annotations
                            )
                            class_to_package_map[class_key] = package_name
                        
                        # --- Start of new import logic ---
                        for imp in tree.imports:
                            classes[class_key].imports.append(imp.path)
                        # --- End of new import logic ---

                        # --- Start of new inheritance logic ---
                        # Handle 'extends'
                        if class_declaration.extends:
                            superclass_name = class_declaration.extends.name
                            # Try to resolve fully qualified name for superclass
                            if superclass_name in import_map:
                                classes[class_key].superclass = import_map[superclass_name]
                            else:
                                # Assume same package or fully qualified if not in import_map
                                classes[class_key].superclass = f"{package_name}.{superclass_name}" if package_name else superclass_name

                        # Handle 'implements'
                        if class_declaration.implements: # Add this check
                            for impl_ref in class_declaration.implements:
                                interface_name = impl_ref.name
                                # Try to resolve fully qualified name for interface
                                if interface_name in import_map:
                                    classes[class_key].interfaces.append(import_map[interface_name])
                                else:
                                    # Assume same package or fully qualified if not in import_map
                                    classes[class_key].interfaces.append(f"{package_name}.{interface_name}" if package_name else interface_name)
                        # --- End of new inheritance logic ---

                        field_map = {}
                        for field_declaration in class_declaration.fields:
                            for declarator in field_declaration.declarators:
                                field_map[declarator.name] = field_declaration.type.name
                                
                                # Parse field annotations
                                field_annotations = parse_annotations(field_declaration.annotations, "field") if hasattr(field_declaration, 'annotations') else []
                                
                                # Extract initial value if present
                                initial_value = ""
                                if hasattr(declarator, 'initializer') and declarator.initializer:
                                    # Convert the initializer to string representation
                                    if hasattr(declarator.initializer, 'value'):
                                        initial_value = str(declarator.initializer.value)
                                    elif hasattr(declarator.initializer, 'type'):
                                        initial_value = str(declarator.initializer.type)
                                    else:
                                        initial_value = str(declarator.initializer)
                                
                                prop = Field(
                                    name=declarator.name,
                                    logical_name=f"{package_name}.{class_name}.{declarator.name}",
                                    type=field_declaration.type.name,
                                    modifiers=list(field_declaration.modifiers), # Add modifiers
                                    package_name=package_name,
                                    class_name=class_name,
                                    annotations=field_annotations,
                                    initial_value=initial_value,
                                    description="",  # TODO: Extract description from comments or annotations
                                    ai_description=""  # TODO: Generate AI description using LLM
                                )
                                classes[class_key].properties.append(prop)

                        all_declarations = class_declaration.methods + class_declaration.constructors
                        
                        # Debug: Check User class method processing
                        if "User" in class_name:
                            logger.debug(f"Processing User class methods - total declarations: {len(all_declarations)}")
                            for i, decl in enumerate(all_declarations):
                                logger.debug(f"Declaration {i}: {type(decl).__name__} - {decl.name}")
                        
                        for declaration in all_declarations:
                            local_var_map = field_map.copy()
                            params = []
                            for param in declaration.parameters:
                                param_type_name = 'Unknown'
                                if hasattr(param.type, 'name'):
                                    param_type_name = param.type.name
                                local_var_map[param.name] = param_type_name
                                params.append(Field(name=param.name, logical_name=f"{package_name}.{class_name}.{param.name}", type=param_type_name, package_name=package_name, class_name=class_name))

                            if declaration.body:
                                for _, var_decl in declaration.filter(javalang.tree.LocalVariableDeclaration):
                                    for declarator in var_decl.declarators:
                                        local_var_map[declarator.name] = var_decl.type.name
                            
                            if isinstance(declaration, javalang.tree.MethodDeclaration):
                                return_type = declaration.return_type.name if declaration.return_type else "void"
                            else: # ConstructorDeclaration
                                return_type = "constructor"

                            # Extract modifiers
                            modifiers = list(declaration.modifiers)
                            
                            # Parse method annotations
                            method_annotations = parse_annotations(declaration.annotations, "method") if hasattr(declaration, 'annotations') else []

                            # Extract method source code
                            method_source = ""
                            if declaration.position:
                                lines = file_content.splitlines(keepends=True) # Keep line endings
                                start_line = declaration.position.line - 1
                                
                                # Find the end of the method by matching braces
                                brace_count = 0
                                end_line = start_line
                                for i in range(start_line, len(lines)):
                                    line = lines[i]
                                    for char in line:
                                        if char == '{':
                                            brace_count += 1
                                        elif char == '}':
                                            brace_count -= 1
                                            if brace_count == 0:
                                                end_line = i
                                                break
                                    if brace_count == 0:
                                        break
                                
                                method_source = "".join(lines[start_line:end_line + 1])

                            method = Method(
                                name=declaration.name,
                                logical_name=f"{class_key}.{declaration.name}",  # Add logical_name
                                return_type=return_type,
                                parameters=params,
                                modifiers=modifiers,
                                source=method_source, # Add method source
                                package_name=package_name,
                                annotations=method_annotations,
                                description="",  # TODO: Extract description from comments or annotations
                                ai_description=""  # TODO: Generate AI description using LLM
                            )
                            classes[class_key].methods.append(method)

                            # Extract method calls with order information
                            call_order = 0
                            for _, invocation in declaration.filter(javalang.tree.MethodInvocation):
                                target_class_name = None
                                resolved_target_package = ""
                                resolved_target_class_name = ""
                                
                                if invocation.qualifier:
                                    # External method call
                                    if invocation.qualifier in local_var_map:
                                        target_class_name = local_var_map[invocation.qualifier]
                                    else:
                                        target_class_name = invocation.qualifier
                                    
                                    if target_class_name:
                                        if target_class_name == "System.out":
                                            resolved_target_package = "java.io"
                                            resolved_target_class_name = "PrintStream"
                                        else:
                                            if target_class_name in import_map:
                                                resolved_target_package = ".".join(import_map[target_class_name].split(".")[:-1])
                                            else:
                                                resolved_target_package = package_name
                                                resolved_target_class_name = target_class_name
                                else:
                                    # Same class method call
                                    resolved_target_package = package_name
                                    resolved_target_class_name = class_name

                                if resolved_target_class_name:
                                    # Get line number from invocation position
                                    line_number = invocation.position.line if invocation.position else 0

                                    call = MethodCall(
                                        source_package=package_name,
                                        source_class=class_name,
                                        source_method=declaration.name,
                                        target_package=resolved_target_package,
                                        target_class=resolved_target_class_name,
                                        target_method=invocation.member,
                                        call_order=call_order,
                                        line_number=line_number,
                                        return_type="void"  # Default return type, can be enhanced later
                                    )
                                    classes[class_key].calls.append(call)
                                    call_order += 1
                        
                        # Check for Lombok @Data annotation and generate methods
                        has_data_annotation = any(ann.name == "Data" for ann in classes[class_key].annotations)
                        if has_data_annotation:
                            logger.debug(f"Found @Data annotation on {class_name}, generating Lombok methods")
                            lombok_methods = generate_lombok_methods(classes[class_key].properties, class_name, package_name)
                            classes[class_key].methods.extend(lombok_methods)
                            logger.debug(f"Generated {len(lombok_methods)} Lombok methods for {class_name}")
                except javalang.parser.JavaSyntaxError as e:
                    print(f"Syntax error in {file_path}: {e}")
                    continue
                except Exception as e:
                    print(f"Error parsing {file_path}: {e}")
                    continue
    
    # Extract beans, analyze dependencies, extract endpoints, extract MyBatis mappers, extract JPA entities, extract config files, and extract test classes
    classes_list = list(classes.values())
    beans = extract_beans_from_classes(classes_list)
    dependencies = analyze_bean_dependencies(classes_list, beans)
    endpoints = extract_endpoints_from_classes(classes_list)
    mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
    jpa_entities = extract_jpa_entities_from_classes(classes_list)
    config_files = extract_config_files(directory)
    test_classes = extract_test_classes_from_classes(classes_list)
    
    # Also extract XML mappers
    xml_mappers = extract_mybatis_xml_mappers(directory)
    mybatis_mappers.extend(xml_mappers)
    
    # Extract SQL statements from MyBatis mappers
    sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
    
    return list(packages.values()), classes_list, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name
```

이제 Class 생성 부분에서도 ai_description을 추가하겠습니다.


```python
import os
import yaml
import re
from pathlib import Path

import javalang

from src.models.graph_entities import Class, Method, MethodCall, Field, Package, Annotation, Bean, BeanDependency, Endpoint, MyBatisMapper, MyBatisSqlStatement, MyBatisResultMap, SqlStatement, JpaEntity, JpaColumn, JpaRelationship, ConfigFile, DatabaseConfig, ServerConfig, SecurityConfig, LoggingConfig, TestClass, TestMethod, TestConfiguration
from src.utils.logger import get_logger
from typing import Optional, List, Literal


def extract_project_name(java_source_folder: str) -> str:
    """
    JAVA_SOURCE_FOLDER 경로에서 프로젝트 이름을 추출합니다.
    
    Args:
        java_source_folder: Java 소스 폴더 경로
        
    Returns:
        프로젝트 이름 (마지막 디렉토리명)
    """
    # 경로를 정규화하고 마지막 디렉토리명 추출
    path = Path(java_source_folder).resolve()
    return path.name


def extract_sql_statements_from_mappers(mybatis_mappers: list[MyBatisMapper], project_name: str) -> list[SqlStatement]:
    """
    MyBatis mappers에서 SQL statements를 추출합니다.
    
    Args:
        mybatis_mappers: MyBatis mapper 객체들의 리스트
        project_name: 프로젝트 이름
        
    Returns:
        SqlStatement 객체들의 리스트
    """
    sql_statements = []
    
    for mapper in mybatis_mappers:
        for sql_dict in mapper.sql_statements:
            # MyBatisSqlStatement를 SqlStatement로 변환
            sql_statement = SqlStatement(
                id=sql_dict.get('id', ''),
                sql_type=sql_dict.get('sql_type', ''),
                sql_content=sql_dict.get('sql_content', ''),
                parameter_type=sql_dict.get('parameter_type', ''),
                result_type=sql_dict.get('result_type', ''),
                result_map=sql_dict.get('result_map', ''),
                mapper_name=mapper.name,
                annotations=[],  # TODO: annotations를 파싱하여 추가
                project_name=project_name
            )
            sql_statements.append(sql_statement)
    
    return sql_statements


def parse_annotations(annotations, target_type: str = "class") -> list[Annotation]:
    """Parse Java annotations into Annotation objects.
    
    Args:
        annotations: List of annotation nodes from javalang
        target_type: Type of target ("class", "method", "field")
    """
    result = []
    for annotation in annotations:
        annotation_name = annotation.name
        parameters = {}
        
        # Parse annotation parameters if they exist
        if hasattr(annotation, 'element') and annotation.element:
            for element in annotation.element:
                if hasattr(element, 'name') and hasattr(element, 'value'):
                    parameters[element.name] = element.value.value if hasattr(element.value, 'value') else str(element.value)
        
        result.append(Annotation(
            name=annotation_name,
            parameters=parameters,
            target_type=target_type,
            category=classify_springboot_annotation(annotation_name)
        ))
    
    return result


def classify_springboot_annotation(annotation_name: str) -> str:
    """Classify SpringBoot annotations into categories.
    
    Args:
        annotation_name: Name of the annotation (e.g., "@Component", "@Service")
        
    Returns:
        Category of the annotation
    """
    # Component annotations
    component_annotations = {
        "Component", "Service", "Repository", "Controller", 
        "RestController", "Configuration", "Bean"
    }
    
    # Injection annotations
    injection_annotations = {
        "Autowired", "Resource", "Value", "Qualifier", "Primary"
    }
    
    # Web annotations
    web_annotations = {
        "RequestMapping", "GetMapping", "PostMapping", "PutMapping", 
        "DeleteMapping", "PatchMapping", "RequestParam", "PathVariable",
        "RequestBody", "ResponseBody", "ResponseStatus"
    }
    
    # JPA annotations
    jpa_annotations = {
        "Entity", "Table", "Id", "Column", "OneToMany", "ManyToOne",
        "OneToOne", "ManyToMany", "JoinColumn", "GeneratedValue"
    }
    
    # Test annotations
    test_annotations = {
        "Test", "SpringBootTest", "DataJpaTest", "WebMvcTest",
        "MockBean", "SpyBean", "TestPropertySource"
    }
    
    # Security annotations
    security_annotations = {
        "PreAuthorize", "PostAuthorize", "Secured", "RolesAllowed",
        "EnableWebSecurity", "EnableGlobalMethodSecurity"
    }
    
    # Validation annotations
    validation_annotations = {
        "Valid", "NotNull", "NotBlank", "NotEmpty", "Size", "Min", "Max",
        "Pattern", "Email", "AssertTrue", "AssertFalse"
    }
    
    # MyBatis annotations
    mybatis_annotations = {
        "Mapper", "Select", "Insert", "Update", "Delete", "SelectProvider",
        "InsertProvider", "UpdateProvider", "DeleteProvider", "Results",
        "Result", "One", "Many", "MapKey", "Options", "SelectKey"
    }
    
    if annotation_name in component_annotations:
        return "component"
    elif annotation_name in injection_annotations:
        return "injection"
    elif annotation_name in web_annotations:
        return "web"
    elif annotation_name in jpa_annotations:
        return "jpa"
    elif annotation_name in test_annotations:
        return "test"
    elif annotation_name in security_annotations:
        return "security"
    elif annotation_name in validation_annotations:
        return "validation"
    elif annotation_name in mybatis_annotations:
        return "mybatis"
    else:
        return "other"


def classify_test_annotation(annotation_name: str) -> str:
    """Classify test annotations into categories.
    
    Args:
        annotation_name: Name of the annotation
        
    Returns:
        Category of the test annotation
    """
    # JUnit annotations
    junit_annotations = {
        "Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll",
        "DisplayName", "ParameterizedTest", "ValueSource", "CsvSource",
        "MethodSource", "Timeout", "Disabled", "Nested", "RepeatedTest",
        "Order", "TestMethodOrder", "TestInstance", "TestClassOrder"
    }
    
    # Spring Boot Test annotations
    spring_test_annotations = {
        "SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest",
        "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest",
        "MockBean", "SpyBean", "TestConfiguration", "ActiveProfiles",
        "TestPropertySource", "DirtiesContext", "Transactional",
        "Rollback", "Commit", "Sql", "SqlGroup", "AutoConfigureTestDatabase",
        "AutoConfigureMockMvc", "AutoConfigureWebMvc", "AutoConfigureWebClient",
        "MockMvc", "TestEntityManager", "TestContainers", "DynamicPropertySource"
    }
    
    # TestNG annotations
    testng_annotations = {
        "TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass",
        "BeforeSuite", "AfterSuite", "BeforeGroups", "AfterGroups",
        "DataProvider", "Parameters", "Groups", "Priority", "DependsOnMethods",
        "DependsOnGroups", "ExpectedExceptions", "InvocationCount",
        "SuccessPercentage", "TimeOut"
    }
    
    # Mockito annotations
    mockito_annotations = {
        "Mock", "Spy", "InjectMocks", "Captor", "MockedStatic"
    }
    
    # AssertJ annotations
    assertj_annotations = {
        "AssertJ"
    }
    
    # Other test annotations
    other_test_annotations = {
        "Ignore", "Category", "RunWith", "ExtendWith", "ContextConfiguration"
    }
    
    if annotation_name in junit_annotations:
        return "junit"
    elif annotation_name in spring_test_annotations:
        return "spring_test"
    elif annotation_name in testng_annotations:
        return "testng"
    elif annotation_name in mockito_annotations:
        return "mockito"
    elif annotation_name in assertj_annotations:
        return "assertj"
    elif annotation_name in other_test_annotations:
        return "other_test"
    else:
        return "other"


def extract_beans_from_classes(classes: list[Class]) -> list[Bean]:
    """Extract Spring Beans from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Bean objects
    """
    beans = []
    
    for cls in classes:
        # Check if class has Spring component annotations
        component_annotations = [ann for ann in cls.annotations if ann.category == "component"]
        
        # Also check for @Repository on interfaces
        has_repository_annotation = any(ann.name == "Repository" for ann in cls.annotations)
        
        if component_annotations or has_repository_annotation:
            # Determine bean type based on annotations
            bean_type = "component"  # default
            if any(ann.name in ["Service", "Service"] for ann in cls.annotations):
                bean_type = "service"
            elif any(ann.name in ["Repository", "Repository"] for ann in cls.annotations):
                bean_type = "repository"
            elif any(ann.name in ["Controller", "RestController"] for ann in cls.annotations):
                bean_type = "controller"
            elif any(ann.name in ["Configuration", "Configuration"] for ann in cls.annotations):
                bean_type = "configuration"
            
            # Determine scope (default is singleton)
            scope = "singleton"
            for ann in cls.annotations:
                if ann.name == "Scope":
                    if "value" in ann.parameters:
                        scope = ann.parameters["value"]
                    elif "prototype" in str(ann.parameters):
                        scope = "prototype"
                    elif "request" in str(ann.parameters):
                        scope = "request"
                    elif "session" in str(ann.parameters):
                        scope = "session"
            
            # Create bean name (use class name with first letter lowercase)
            bean_name = cls.name[0].lower() + cls.name[1:] if cls.name else cls.name
            
            # Check for @Bean methods in configuration classes
            bean_methods = []
            if bean_type == "configuration":
                for method in cls.methods:
                    if any(ann.name == "Bean" for ann in method.annotations):
                        bean_methods.append(method)
            
            bean = Bean(
                name=bean_name,
                type=bean_type,
                scope=scope,
                class_name=cls.name,
                package_name=cls.package_name,
                annotation_names=[ann.name for ann in cls.annotations] if cls.annotations else [],
                method_count=len(bean_methods) if bean_type == "configuration" else len(cls.methods) if cls.methods else 0,
                property_count=len(cls.properties) if cls.properties else 0
            )
            beans.append(bean)
    
    return beans


def analyze_bean_dependencies(classes: list[Class], beans: list[Bean]) -> list[BeanDependency]:
    """Analyze dependencies between Spring Beans.
    
    Args:
        classes: List of parsed Class objects
        beans: List of Bean objects
        
    Returns:
        List of BeanDependency objects
    """
    dependencies = []
    
    # Create a mapping from class names to bean names
    class_to_bean = {}
    for bean in beans:
        class_to_bean[bean.class_name] = bean.name
    
    for cls in classes:
        # Check if this class is a bean
        if cls.name not in class_to_bean:
            continue
            
        source_bean = class_to_bean[cls.name]
        
        # Analyze field injections (@Autowired, @Resource, @Value)
        for prop in cls.properties:
            if any(ann.category == "injection" for ann in prop.annotations):
                # Try to determine target bean from field type
                target_bean = None
                field_type = prop.type
                
                # Look for exact class name match
                if field_type in class_to_bean:
                    target_bean = class_to_bean[field_type]
                else:
                    # Look for interface implementations (simplified - just check if type matches any bean class name)
                    for bean in beans:
                        if field_type == bean.class_name:
                            target_bean = bean.name
                            break
                
                if target_bean:
                    injection_type = "field"
                    for ann in prop.annotations:
                        if ann.name == "Autowired":
                            injection_type = "field"
                        elif ann.name == "Resource":
                            injection_type = "field"
                        elif ann.name == "Value":
                            injection_type = "field"
                    
                    dependency = BeanDependency(
                        source_bean=source_bean,
                        target_bean=target_bean,
                        injection_type=injection_type,
                        field_name=prop.name
                    )
                    dependencies.append(dependency)
        
        # Analyze constructor injections
        for method in cls.methods:
            if method.name == cls.name:  # Constructor
                for param in method.parameters:
                    if any(ann.category == "injection" for ann in param.annotations):
                        target_bean = None
                        param_type = param.type
                        
                        if param_type in class_to_bean:
                            target_bean = class_to_bean[param_type]
                        else:
                            # Look for interface implementations (simplified)
                            for bean in beans:
                                if param_type == bean.class_name:
                                    target_bean = bean.name
                                    break
                        
                        if target_bean:
                            dependency = BeanDependency(
                                source_bean=source_bean,
                                target_bean=target_bean,
                                injection_type="constructor",
                                parameter_name=param.name
                            )
                            dependencies.append(dependency)
        
        # Analyze setter injections
        for method in cls.methods:
            if method.name.startswith("set") and len(method.parameters) == 1:
                if any(ann.category == "injection" for ann in method.annotations):
                    param = method.parameters[0]
                    target_bean = None
                    param_type = param.type
                    
                    if param_type in class_to_bean:
                        target_bean = class_to_bean[param_type]
                    else:
                        # Look for interface implementations (simplified)
                        for bean in beans:
                            if param_type == bean.class_name:
                                target_bean = bean.name
                                break
                    
                    if target_bean:
                        dependency = BeanDependency(
                            source_bean=source_bean,
                            target_bean=target_bean,
                            injection_type="setter",
                            method_name=method.name,
                            parameter_name=param.name
                        )
                        dependencies.append(dependency)
    
    return dependencies


def extract_endpoints_from_classes(classes: list[Class]) -> list[Endpoint]:
    """Extract REST API endpoints from controller classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of Endpoint objects
    """
    endpoints = []
    
    for cls in classes:
        # Check if class is a controller
        is_controller = any(ann.name in ["Controller", "RestController"] for ann in cls.annotations)
        
        if not is_controller:
            continue
            
        # Get class-level path mapping
        class_path = ""
        for ann in cls.annotations:
            if ann.name == "RequestMapping":
                if "value" in ann.parameters:
                    class_path = ann.parameters["value"]
                break
        
        # Process each method in the controller
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
                
            # Check if method has web mapping annotations
            web_annotations = [ann for ann in method.annotations if ann.category == "web"]
            
            if not web_annotations:
                continue
            
            # Extract endpoint information
            endpoint_path = ""
            http_method = "GET"  # default
            
            for ann in web_annotations:
                if ann.name in ["RequestMapping", "GetMapping", "PostMapping", "PutMapping", "DeleteMapping", "PatchMapping"]:
                    # Extract path
                    if "value" in ann.parameters:
                        endpoint_path = ann.parameters["value"]
                    elif "path" in ann.parameters:
                        endpoint_path = ann.parameters["path"]
                    
                    # Extract HTTP method
                    if ann.name == "GetMapping":
                        http_method = "GET"
                    elif ann.name == "PostMapping":
                        http_method = "POST"
                    elif ann.name == "PutMapping":
                        http_method = "PUT"
                    elif ann.name == "DeleteMapping":
                        http_method = "DELETE"
                    elif ann.name == "PatchMapping":
                        http_method = "PATCH"
                    elif ann.name == "RequestMapping":
                        if "method" in ann.parameters:
                            method_value = ann.parameters["method"]
                            if isinstance(method_value, list) and len(method_value) > 0:
                                http_method = method_value[0]
                            else:
                                http_method = str(method_value)
                        else:
                            http_method = "GET"  # default for RequestMapping
                    break
            
            # Build full path
            full_path = class_path
            if endpoint_path:
                if full_path and not full_path.endswith("/") and not endpoint_path.startswith("/"):
                    full_path += "/"
                full_path += endpoint_path
            elif not full_path:
                full_path = "/"
            
            # Extract method parameters
            parameters = []
            for param in method.parameters:
                param_info = {
                    "name": param.name,
                    "type": param.type,
                    "annotations": [ann.name for ann in param.annotations if ann.category == "web"]
                }
                parameters.append(param_info)
            
            # Extract return type
            return_type = method.return_type if method.return_type != "constructor" else "void"
            
            # Create endpoint
            endpoint = Endpoint(
                path=endpoint_path or "/",
                method=http_method,
                controller_class=cls.name,
                handler_method=method.name,
                parameters=parameters,
                return_type=return_type,
                annotations=[ann.name for ann in web_annotations],
                full_path=full_path
            )
            endpoints.append(endpoint)
    
    return endpoints


def extract_mybatis_mappers_from_classes(classes: list[Class]) -> list[MyBatisMapper]:
    """Extract MyBatis Mappers from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for cls in classes:
        # Check if class is a MyBatis Mapper interface
        is_mapper = any(ann.name == "Mapper" for ann in cls.annotations)
        
        if not is_mapper:
            continue
        
        # Extract mapper methods with MyBatis annotations
        mapper_methods = []
        sql_statements = []
        
        for method in cls.methods:
            # Skip constructors
            if method.name == cls.name:
                continue
            
            # Check if method has MyBatis annotations
            mybatis_annotations = [ann for ann in method.annotations if ann.category == "mybatis"]
            
            if not mybatis_annotations:
                continue
            
            # Extract SQL statement information
            sql_type = "SELECT"  # default
            sql_content = ""
            parameter_type = ""
            result_type = ""
            result_map = ""
            
            for ann in mybatis_annotations:
                if ann.name in ["Select", "SelectProvider"]:
                    sql_type = "SELECT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Insert", "InsertProvider"]:
                    sql_type = "INSERT"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Update", "UpdateProvider"]:
                    sql_type = "UPDATE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                elif ann.name in ["Delete", "DeleteProvider"]:
                    sql_type = "DELETE"
                    if "value" in ann.parameters:
                        sql_content = ann.parameters["value"]
                
                # Extract parameter and result type information
                if "parameterType" in ann.parameters:
                    parameter_type = ann.parameters["parameterType"]
                if "resultType" in ann.parameters:
                    result_type = ann.parameters["resultType"]
                if "resultMap" in ann.parameters:
                    result_map = ann.parameters["resultMap"]
            
            # Create method info
            method_info = {
                "name": method.name,
                "return_type": method.return_type,
                "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            mapper_methods.append(method_info)
            
            # Create SQL statement info
            sql_statement = {
                "id": method.name,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": [ann.name for ann in mybatis_annotations]
            }
            sql_statements.append(sql_statement)
        
        # Create mapper
        mapper = MyBatisMapper(
            name=cls.name,
            type="interface",
            namespace=f"{cls.package_name}.{cls.name}",
            methods=mapper_methods,
            sql_statements=sql_statements,
            file_path=cls.file_path,
            package_name=cls.package_name
        )
        mappers.append(mapper)
    
    return mappers


def parse_mybatis_xml_file(file_path: str) -> MyBatisMapper:
    """Parse MyBatis XML mapper file.
    
    Args:
        file_path: Path to the XML mapper file
        
    Returns:
        MyBatisMapper object
    """
    import xml.etree.ElementTree as ET
    
    try:
        tree = ET.parse(file_path)
        root = tree.getroot()
        
        # Extract namespace
        namespace = root.get("namespace", "")
        
        # Extract SQL statements
        sql_statements = []
        for statement in root.findall(".//*[@id]"):
            statement_id = statement.get("id")
            tag_name = statement.tag.lower()
            
            # Determine SQL type
            sql_type = "SELECT"
            if tag_name == "insert":
                sql_type = "INSERT"
            elif tag_name == "update":
                sql_type = "UPDATE"
            elif tag_name == "delete":
                sql_type = "DELETE"
            
            # Extract SQL content
            sql_content = statement.text.strip() if statement.text else ""
            
            # Extract parameter and result information
            parameter_type = statement.get("parameterType", "")
            result_type = statement.get("resultType", "")
            result_map = statement.get("resultMap", "")
            
            sql_statement = {
                "id": statement_id,
                "sql_type": sql_type,
                "sql_content": sql_content,
                "parameter_type": parameter_type,
                "result_type": result_type,
                "result_map": result_map,
                "annotations": []
            }
            sql_statements.append(sql_statement)
        
        # Extract ResultMaps
        result_maps = []
        for result_map in root.findall(".//resultMap"):
            result_map_id = result_map.get("id")
            result_map_type = result_map.get("type", "")
            
            properties = []
            for property_elem in result_map.findall(".//result"):
                prop = {
                    "property": property_elem.get("property", ""),
                    "column": property_elem.get("column", ""),
                    "jdbc_type": property_elem.get("jdbcType", "")
                }
                properties.append(prop)
            
            result_map_info = {
                "id": result_map_id,
                "type": result_map_type,
                "properties": properties,
                "associations": [],
                "collections": []
            }
            result_maps.append(result_map_info)
        
        # Create mapper
        mapper_name = namespace.split(".")[-1] if namespace else os.path.basename(file_path).replace(".xml", "")
        package_name = ".".join(namespace.split(".")[:-1]) if namespace else ""
        
        mapper = MyBatisMapper(
            name=mapper_name,
            type="xml",
            namespace=namespace,
            methods=[],  # XML mappers don't have Java methods
            sql_statements=sql_statements,
            file_path=file_path,
            package_name=package_name
        )
        
        return mapper
        
    except ET.ParseError as e:
        print(f"Error parsing XML file {file_path}: {e}")
        return None
    except Exception as e:
        print(f"Error reading XML file {file_path}: {e}")
        return None


def extract_mybatis_xml_mappers(directory: str) -> list[MyBatisMapper]:
    """Extract MyBatis XML mappers from directory.
    
    Args:
        directory: Directory to search for XML mapper files
        
    Returns:
        List of MyBatisMapper objects
    """
    mappers = []
    
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith("Mapper.xml") or file.endswith("Dao.xml"):
                file_path = os.path.join(root, file)
                mapper = parse_mybatis_xml_file(file_path)
                if mapper:
                    mappers.append(mapper)
    
    return mappers


def extract_jpa_entities_from_classes(classes: list[Class]) -> list[JpaEntity]:
    """Extract JPA Entities from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of JpaEntity objects
    """
    entities = []
    
    for cls in classes:
        # Check if class is a JPA Entity
        is_entity = any(ann.name == "Entity" for ann in cls.annotations)
        
        if not is_entity:
            continue
        
        # Extract table name
        table_name = cls.name.lower()  # default table name
        for ann in cls.annotations:
            if ann.name == "Table":
                if "name" in ann.parameters:
                    table_name = ann.parameters["name"]
                break
        
        # Extract columns from properties
        columns = []
        relationships = []
        
        for prop in cls.properties:
            # Check if property has JPA column annotations
            jpa_annotations = [ann for ann in prop.annotations if ann.category == "jpa"]
            
            if jpa_annotations:
                # Extract column information
                column_name = prop.name  # default column name
                nullable = True
                unique = False
                length = 0
                precision = 0
                scale = 0
                
                for ann in jpa_annotations:
                    if ann.name == "Column":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                        if "nullable" in ann.parameters:
                            nullable = ann.parameters["nullable"]
                        if "unique" in ann.parameters:
                            unique = ann.parameters["unique"]
                        if "length" in ann.parameters:
                            length = ann.parameters["length"]
                        if "precision" in ann.parameters:
                            precision = ann.parameters["precision"]
                        if "scale" in ann.parameters:
                            scale = ann.parameters["scale"]
                    elif ann.name == "Id":
                        column_name = "id"  # Primary key column
                        nullable = False
                        unique = True
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            column_name = ann.parameters["name"]
                
                # Check for relationship annotations
                relationship_type = None
                target_entity = ""
                mapped_by = ""
                join_column = ""
                join_table = ""
                cascade = []
                fetch = "LAZY"
                
                for ann in jpa_annotations:
                    if ann.name in ["OneToOne", "OneToMany", "ManyToOne", "ManyToMany"]:
                        relationship_type = ann.name
                        if "targetEntity" in ann.parameters:
                            target_entity = ann.parameters["targetEntity"]
                        if "mappedBy" in ann.parameters:
                            mapped_by = ann.parameters["mappedBy"]
                        if "cascade" in ann.parameters:
                            cascade = ann.parameters["cascade"] if isinstance(ann.parameters["cascade"], list) else [ann.parameters["cascade"]]
                        if "fetch" in ann.parameters:
                            fetch = ann.parameters["fetch"]
                    elif ann.name == "JoinColumn":
                        if "name" in ann.parameters:
                            join_column = ann.parameters["name"]
                    elif ann.name == "JoinTable":
                        if "name" in ann.parameters:
                            join_table = ann.parameters["name"]
                
                # Create column info
                column_info = {
                    "property_name": prop.name,
                    "column_name": column_name,
                    "data_type": prop.type,
                    "nullable": nullable,
                    "unique": unique,
                    "length": length,
                    "precision": precision,
                    "scale": scale,
                    "annotations": [ann.name for ann in jpa_annotations]
                }
                columns.append(column_info)
                
                # Create relationship info if it's a relationship
                if relationship_type:
                    relationship_info = {
                        "type": relationship_type,
                        "target_entity": target_entity,
                        "mapped_by": mapped_by,
                        "join_column": join_column,
                        "join_table": join_table,
                        "cascade": cascade,
                        "fetch": fetch,
                        "annotations": [ann.name for ann in jpa_annotations]
                    }
                    relationships.append(relationship_info)
        
        # Create entity
        entity = JpaEntity(
            name=cls.name,
            table_name=table_name,
            columns=columns,
            relationships=relationships,
            annotations=[ann.name for ann in cls.annotations if ann.category == "jpa"],
            package_name=cls.package_name,
            file_path=cls.file_path
        )
        entities.append(entity)
    
    return entities


def parse_yaml_config(file_path: str) -> ConfigFile:
    """Parse YAML configuration file.
    
    Args:
        file_path: Path to the YAML file
        
    Returns:
        ConfigFile object
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = yaml.safe_load(f)
        
        if not content:
            content = {}
        
        # Extract file info
        file_name = os.path.basename(file_path)
        file_type = "yaml" if file_path.endswith('.yaml') else "yml"
        
        # Extract profiles
        profiles = []
        if 'spring' in content and 'profiles' in content['spring']:
            if 'active' in content['spring']['profiles']:
                profiles = content['spring']['profiles']['active']
                if isinstance(profiles, str):
                    profiles = [profiles]
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        # Extract sections
        sections = []
        for key, value in content.items():
            if isinstance(value, dict):
                sections.append({
                    "name": key,
                    "properties": value,
                    "type": "section"
                })
        
        return ConfigFile(
            name=file_name,
            file_path=file_path,
            file_type=file_type,
            properties=content,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing YAML file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="yaml",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def parse_properties_config(file_path: str) -> ConfigFile:
    """Parse Properties configuration file.
    
    Args:
        file_path: Path to the properties file
        
    Returns:
        ConfigFile object
    """
    try:
        properties = {}
        sections = []
        profiles = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                
                # Skip empty lines and comments
                if not line or line.startswith('#'):
                    continue
                
                # Parse key=value pairs
                if '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    
                    # Remove quotes if present
                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]
                    elif value.startswith("'") and value.endswith("'"):
                        value = value[1:-1]
                    
                    properties[key] = value
                    
                    # Check for profiles
                    if key == 'spring.profiles.active':
                        profiles = [p.strip() for p in value.split(',')]
        
        # Group properties by section
        section_map = {}
        for key, value in properties.items():
            if '.' in key:
                section = key.split('.')[0]
                if section not in section_map:
                    section_map[section] = {}
                section_map[section][key] = value
            else:
                if 'root' not in section_map:
                    section_map['root'] = {}
                section_map['root'][key] = value
        
        for section_name, section_props in section_map.items():
            sections.append({
                "name": section_name,
                "properties": section_props,
                "type": "section"
            })
        
        # Determine environment
        environment = "dev"  # default
        if profiles:
            environment = profiles[0]
        
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties=properties,
            sections=sections,
            profiles=profiles,
            environment=environment
        )
    
    except Exception as e:
        print(f"Error parsing Properties file {file_path}: {e}")
        return ConfigFile(
            name=os.path.basename(file_path),
            file_path=file_path,
            file_type="properties",
            properties={},
            sections=[],
            profiles=[],
            environment=""
        )


def extract_database_config(config_file: ConfigFile) -> DatabaseConfig:
    """Extract database configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        DatabaseConfig object
    """
    db_config = DatabaseConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        spring_config = config_file.properties.get('spring', {})
        datasource_config = spring_config.get('datasource', {})
        jpa_config = spring_config.get('jpa', {})
        
        db_config.driver = datasource_config.get('driver-class-name', '')
        db_config.url = datasource_config.get('url', '')
        db_config.username = datasource_config.get('username', '')
        db_config.password = datasource_config.get('password', '')
        db_config.dialect = jpa_config.get('database-platform', '')
        db_config.hibernate_ddl_auto = jpa_config.get('hibernate', {}).get('ddl-auto', '')
        db_config.show_sql = jpa_config.get('show-sql', False)
        db_config.format_sql = jpa_config.get('properties', {}).get('hibernate', {}).get('format_sql', False)
        
        # Store additional JPA properties
        if 'properties' in jpa_config:
            db_config.jpa_properties = jpa_config['properties']
    
    else:
        # Properties format
        props = config_file.properties
        
        db_config.driver = props.get('spring.datasource.driver-class-name', '')
        db_config.url = props.get('spring.datasource.url', '')
        db_config.username = props.get('spring.datasource.username', '')
        db_config.password = props.get('spring.datasource.password', '')
        db_config.dialect = props.get('spring.jpa.database-platform', '')
        db_config.hibernate_ddl_auto = props.get('spring.jpa.hibernate.ddl-auto', '')
        db_config.show_sql = props.get('spring.jpa.show-sql', 'false').lower() == 'true'
        db_config.format_sql = props.get('spring.jpa.properties.hibernate.format_sql', 'false').lower() == 'true'
        
        # Store additional JPA properties
        jpa_props = {}
        for key, value in props.items():
            if key.startswith('spring.jpa.properties.'):
                jpa_props[key] = value
        db_config.jpa_properties = jpa_props
    
    return db_config


def extract_server_config(config_file: ConfigFile) -> ServerConfig:
    """Extract server configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        ServerConfig object
    """
    server_config = ServerConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        server_props = config_file.properties.get('server', {})
        
        server_config.port = server_props.get('port', 8080)
        server_config.context_path = server_props.get('servlet', {}).get('context-path', '')
        server_config.servlet_path = server_props.get('servlet', {}).get('path', '')
        
        # SSL configuration
        ssl_config = server_props.get('ssl', {})
        server_config.ssl_enabled = bool(ssl_config)
        server_config.ssl_key_store = ssl_config.get('key-store', '')
        server_config.ssl_key_store_password = ssl_config.get('key-store-password', '')
        server_config.ssl_key_store_type = ssl_config.get('key-store-type', '')
    
    else:
        # Properties format
        props = config_file.properties
        
        server_config.port = int(props.get('server.port', '8080'))
        server_config.context_path = props.get('server.servlet.context-path', '')
        server_config.servlet_path = props.get('server.servlet.path', '')
        
        # SSL configuration
        server_config.ssl_enabled = any(key.startswith('server.ssl.') for key in props.keys())
        server_config.ssl_key_store = props.get('server.ssl.key-store', '')
        server_config.ssl_key_store_password = props.get('server.ssl.key-store-password', '')
        server_config.ssl_key_store_type = props.get('server.ssl.key-store-type', '')
    
    return server_config


def extract_security_config(config_file: ConfigFile) -> SecurityConfig:
    """Extract security configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        SecurityConfig object
    """
    security_config = SecurityConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        security_props = config_file.properties.get('security', {})
        jwt_props = security_props.get('jwt', {})
        cors_props = security_props.get('cors', {})
        
        security_config.enabled = bool(security_props)
        security_config.authentication_type = security_props.get('authentication-type', '')
        security_config.jwt_secret = jwt_props.get('secret', '')
        security_config.jwt_expiration = jwt_props.get('expiration', 0)
        security_config.cors_allowed_origins = cors_props.get('allowed-origins', [])
        security_config.cors_allowed_methods = cors_props.get('allowed-methods', [])
        security_config.cors_allowed_headers = cors_props.get('allowed-headers', [])
    
    else:
        # Properties format
        props = config_file.properties
        
        security_config.enabled = any(key.startswith('security.') for key in props.keys())
        security_config.authentication_type = props.get('security.authentication-type', '')
        security_config.jwt_secret = props.get('security.jwt.secret', '')
        security_config.jwt_expiration = int(props.get('security.jwt.expiration', '0'))
        
        # CORS configuration
        origins = props.get('security.cors.allowed-origins', '')
        if origins:
            security_config.cors_allowed_origins = [o.strip() for o in origins.split(',')]
        
        methods = props.get('security.cors.allowed-methods', '')
        if methods:
            security_config.cors_allowed_methods = [m.strip() for m in methods.split(',')]
        
        headers = props.get('security.cors.allowed-headers', '')
        if headers:
            security_config.cors_allowed_headers = [h.strip() for h in headers.split(',')]
    
    return security_config


def extract_logging_config(config_file: ConfigFile) -> LoggingConfig:
    """Extract logging configuration from config file.
    
    Args:
        config_file: ConfigFile object
        
    Returns:
        LoggingConfig object
    """
    logging_config = LoggingConfig()
    
    if config_file.file_type in ["yaml", "yml"]:
        # YAML format
        logging_props = config_file.properties.get('logging', {})
        
        logging_config.level = logging_props.get('level', {}).get('root', 'INFO')
        logging_config.pattern = logging_props.get('pattern', {}).get('console', '')
        logging_config.file_path = logging_props.get('file', {}).get('name', '')
        logging_config.max_file_size = logging_props.get('file', {}).get('max-size', '')
        logging_config.max_history = logging_props.get('file', {}).get('max-history', 0)
        logging_config.console_output = logging_props.get('console', {}).get('enabled', True)
    
    else:
        # Properties format
        props = config_file.properties
        
        logging_config.level = props.get('logging.level.root', 'INFO')
        logging_config.pattern = props.get('logging.pattern.console', '')
        logging_config.file_path = props.get('logging.file.name', '')
        logging_config.max_file_size = props.get('logging.file.max-size', '')
        logging_config.max_history = int(props.get('logging.file.max-history', '0'))
        logging_config.console_output = props.get('logging.console.enabled', 'true').lower() == 'true'
    
    return logging_config


def extract_config_files(directory: str) -> list[ConfigFile]:
    """Extract configuration files from directory.
    
    Args:
        directory: Directory to search for config files
        
    Returns:
        List of ConfigFile objects
    """
    config_files = []
    
    # Common config file patterns
    config_patterns = [
        "application.yml",
        "application.yaml", 
        "application.properties",
        "application-*.properties",
        "bootstrap.yml",
        "bootstrap.yaml",
        "bootstrap.properties"
    ]
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            # Check if file matches any config pattern
            is_config_file = False
            for pattern in config_patterns:
                if pattern == file or (pattern.endswith('*') and file.startswith(pattern[:-1])):
                    is_config_file = True
                    break
            
            if is_config_file:
                file_path = os.path.join(root, file)
                
                if file.endswith(('.yml', '.yaml')):
                    config_file = parse_yaml_config(file_path)
                elif file.endswith('.properties'):
                    config_file = parse_properties_config(file_path)
                else:
                    continue
                
                config_files.append(config_file)
    
    return config_files


def extract_test_classes_from_classes(classes: list[Class]) -> list[TestClass]:
    """Extract test classes from parsed classes.
    
    Args:
        classes: List of parsed Class objects
        
    Returns:
        List of TestClass objects
    """
    test_classes = []
    
    for cls in classes:
        # Check if class is a test class
        test_annotations = [ann for ann in cls.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
        
        if not test_annotations:
            continue
        
        # Determine test framework and type
        test_framework = "junit"  # default
        test_type = "unit"  # default
        
        for ann in test_annotations:
            if ann.name in ["SpringBootTest", "WebMvcTest", "DataJpaTest", "DataJdbcTest", "JdbcTest", "JsonTest", "RestClientTest", "WebFluxTest"]:
                test_framework = "spring_test"
                if ann.name == "SpringBootTest":
                    test_type = "integration"
                else:
                    test_type = "slice"
            elif ann.name in ["TestNG", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass"]:
                test_framework = "testng"
            elif ann.name in ["Test", "BeforeEach", "AfterEach", "BeforeAll", "AfterAll"]:
                test_framework = "junit"
        
        # Extract test methods
        test_methods = []
        setup_methods = []
        
        for method in cls.methods:
            method_annotations = [ann.name for ann in method.annotations if classify_test_annotation(ann.name) in ["junit", "spring_test", "testng"]]
            
            if method_annotations:
                # Check if it's a setup/teardown method
                if any(ann in method_annotations for ann in ["BeforeEach", "AfterEach", "BeforeAll", "AfterAll", "BeforeMethod", "AfterMethod", "BeforeClass", "AfterClass", "BeforeSuite", "AfterSuite"]):
                    setup_methods.append({
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters]
                    })
                else:
                    # Regular test method
                    test_method_info = {
                        "name": method.name,
                        "annotations": method_annotations,
                        "return_type": method.return_type,
                        "parameters": [{"name": p.name, "type": p.type} for p in method.parameters],
                        "assertions": [],
                        "mock_calls": [],
                        "test_data": [],
                        "expected_exceptions": [],
                        "timeout": 0,
                        "display_name": ""
                    }
                    
                    # Extract display name
                    for ann in method.annotations:
                        if ann.name == "DisplayName" and "value" in ann.parameters:
                            test_method_info["display_name"] = ann.parameters["value"]
                        elif ann.name == "Timeout" and "value" in ann.parameters:
                            test_method_info["timeout"] = ann.parameters["value"]
                    
                    # Extract expected exceptions
                    for ann in method.annotations:
                        if ann.name == "ExpectedExceptions" and "value" in ann.parameters:
                            test_method_info["expected_exceptions"] = ann.parameters["value"] if isinstance(ann.parameters["value"], list) else [ann.parameters["value"]]
                    
                    test_methods.append(test_method_info)
        
        # Extract mock dependencies
        mock_dependencies = []
        for prop in cls.properties:
            prop_annotations = [ann.name for ann in prop.annotations if classify_test_annotation(ann.name) in ["mockito", "spring_test"]]
            if prop_annotations:
                mock_dependencies.append({
                    "name": prop.name,
                    "type": prop.type,
                    "annotations": prop_annotations,
                    "mock_type": "mock" if "Mock" in prop_annotations else "spy" if "Spy" in prop_annotations else "bean"
                })
        
        # Extract test configurations
        test_configurations = []
        for ann in cls.annotations:
            if ann.name in ["TestConfiguration", "ActiveProfiles", "TestPropertySource"]:
                config_info = {
                    "name": ann.name,
                    "type": "configuration" if ann.name == "TestConfiguration" else "profile" if ann.name == "ActiveProfiles" else "property",
                    "properties": ann.parameters,
                    "active_profiles": ann.parameters.get("value", []) if ann.name == "ActiveProfiles" else [],
                    "test_slices": [],
                    "mock_beans": [],
                    "spy_beans": []
                }
                test_configurations.append(config_info)
        
        # Create test class
        test_class = TestClass(
            name=cls.name,
            package_name=cls.package_name,
            test_framework=test_framework,
            test_type=test_type,
            annotations=[ann.name for ann in test_annotations],
            test_methods=test_methods,
            setup_methods=setup_methods,
            mock_dependencies=mock_dependencies,
            test_configurations=test_configurations,
            file_path=cls.file_path
        )
        test_classes.append(test_class)
    
    return test_classes


def analyze_test_methods(test_class: TestClass, class_obj: Class) -> list[TestMethod]:
    """Analyze test methods for assertions, mock calls, and test data.
    
    Args:
        test_class: TestClass object
        class_obj: Original Class object
        
    Returns:
        List of analyzed TestMethod objects
    """
    test_methods = []
    
    for method_info in test_class.test_methods:
        # Find the corresponding method in the class
        method_obj = None
        for method in class_obj.methods:
            if method.name == method_info["name"]:
                method_obj = method
                break
        
        if not method_obj:
            continue
        
        # Analyze method source code for assertions and mock calls
        assertions = []
        mock_calls = []
        test_data = []
        
        if method_obj.source:
            source_code = method_obj.source
            
            # Find assertions (JUnit, AssertJ, etc.)
            assertion_patterns = [
                r'assert\w+\(',  # JUnit assertions
                r'assertThat\(',  # AssertJ
                r'assertEquals\(',  # JUnit
                r'assertTrue\(',  # JUnit
                r'assertFalse\(',  # JUnit
                r'assertNotNull\(',  # JUnit
                r'assertNull\(',  # JUnit
                r'assertThrows\(',  # JUnit 5
                r'assertDoesNotThrow\(',  # JUnit 5
                r'verify\(',  # Mockito verify
                r'when\(',  # Mockito when
                r'then\(',  # Mockito then
                r'given\(',  # BDDMockito given
                r'willReturn\(',  # Mockito willReturn
                r'willThrow\(',  # Mockito willThrow
            ]
            
            for pattern in assertion_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    assertions.append({
                        "type": match,
                        "line": source_code.find(match) + 1
                    })
            
            # Find mock calls
            mock_call_patterns = [
                r'(\w+)\.(\w+)\(',  # Method calls on objects
                r'mock\(',  # Mockito mock creation
                r'spy\(',  # Mockito spy creation
                r'@Mock\s+(\w+)',  # @Mock annotation
                r'@Spy\s+(\w+)',  # @Spy annotation
                r'@InjectMocks\s+(\w+)',  # @InjectMocks annotation
            ]
            
            for pattern in mock_call_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        mock_calls.append({
                            "object": match[0],
                            "method": match[1],
                            "type": "method_call"
                        })
                    else:
                        mock_calls.append({
                            "type": match,
                            "line": source_code.find(match) + 1
                        })
            
            # Find test data setup
            test_data_patterns = [
                r'new\s+(\w+)\(',  # Object creation
                r'(\w+)\s*=\s*new\s+(\w+)\(',  # Variable assignment with new
                r'@ValueSource\(',  # JUnit 5 @ValueSource
                r'@CsvSource\(',  # JUnit 5 @CsvSource
                r'@MethodSource\(',  # JUnit 5 @MethodSource
            ]
            
            for pattern in test_data_patterns:
                matches = re.findall(pattern, source_code)
                for match in matches:
                    if isinstance(match, tuple):
                        test_data.append({
                            "variable": match[0],
                            "type": match[1],
                            "pattern": "object_creation"
                        })
                    else:
                        test_data.append({
                            "type": match,
                            "pattern": "annotation"
                        })
        
        # Create TestMethod object
        test_method = TestMethod(
            name=method_info["name"],
            return_type=method_info["return_type"],
            annotations=method_info["annotations"],
            assertions=assertions,
            mock_calls=mock_calls,
            test_data=test_data,
            expected_exceptions=method_info["expected_exceptions"],
            timeout=method_info["timeout"],
            display_name=method_info["display_name"]
        )
        test_methods.append(test_method)
    
    return test_methods


def generate_lombok_methods(properties: list[Field], class_name: str, package_name: str) -> list[Method]:
    """Generate Lombok @Data methods (getters, setters, equals, hashCode, toString) for properties."""
    methods = []
    
    # Generate getters and setters for each property
    for prop in properties:
        # Getter
        getter_name = f"get{prop.name[0].upper()}{prop.name[1:]}"
        if prop.type == "Boolean" and prop.name.startswith("is"):
            # For boolean fields starting with 'is', use the field name as getter
            getter_name = prop.name
        
        getter = Method(
            name=getter_name,
            logical_name=f"{package_name}.{class_name}.{getter_name}",
            return_type=prop.type,
            parameters=[],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[],
            description=f"Generated getter for {prop.name} field",  # Generated method description
            ai_description=""  # TODO: Generate AI description using LLM
        )
        methods.append(getter)
        
        # Setter
        setter_name = f"set{prop.name[0].upper()}{prop.name[1:]}"
        setter_param = Field(
            name=prop.name,
            logical_name=f"{package_name}.{class_name}.{prop.name}",
            type=prop.type,
            package_name=package_name,
            class_name=class_name
        )
        
        setter = Method(
            name=setter_name,
            logical_name=f"{package_name}.{class_name}.{setter_name}",
            return_type="void",
            parameters=[setter_param],
            modifiers=["public"],
            source="",  # Generated method, no source
            package_name=package_name,
            annotations=[],
            description=f"Generated setter for {prop.name} field",  # Generated method description
            ai_description=""  # TODO: Generate AI description using LLM
        )
        methods.append(setter)
    
    # Generate equals method
    equals_method = Method(
        name="equals",
        logical_name=f"{package_name}.{class_name}.equals",
        return_type="boolean",
        parameters=[Field(name="obj", logical_name=f"{package_name}.{class_name}.obj", type="Object", package_name=package_name, class_name=class_name)],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated equals method for object comparison",  # Generated method description
        ai_description=""  # TODO: Generate AI description using LLM
    )
    methods.append(equals_method)
    
    # Generate hashCode method
    hashcode_method = Method(
        name="hashCode",
        logical_name=f"{package_name}.{class_name}.hashCode",
        return_type="int",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated hashCode method for object hashing",  # Generated method description
        ai_description=""  # TODO: Generate AI description using LLM
    )
    methods.append(hashcode_method)
    
    # Generate toString method
    tostring_method = Method(
        name="toString",
        logical_name=f"{package_name}.{class_name}.toString",
        return_type="String",
        parameters=[],
        modifiers=["public"],
        source="",  # Generated method, no source
        package_name=package_name,
        annotations=[],
        description="Generated toString method for string representation",  # Generated method description
        ai_description=""  # TODO: Generate AI description using LLM
    )
    methods.append(tostring_method)
    
    return methods


def parse_java_project(directory: str) -> tuple[list[Package], list[Class], dict[str, str], list[Bean], list[BeanDependency], list[Endpoint], list[MyBatisMapper], list[JpaEntity], list[ConfigFile], list[TestClass], list[SqlStatement], str]:
    """Parse Java project and return parsed entities."""
    logger = get_logger(__name__)
    """Parses all Java files in a directory and returns a tuple of (packages, classes, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name)."""
    
    # Extract project name from directory path
    project_name = extract_project_name(directory)
    packages = {}
    classes = {}
    class_to_package_map = {}  # Maps class_key to package_name

    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith(".java"):
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    file_content = f.read() # Read file content once
                try:
                    tree = javalang.parse.parse(file_content)
                    package_name = tree.package.name if tree.package else ""
                    
                    # Create or update package node
                    if package_name and package_name not in packages:
                        packages[package_name] = Package(
                            name=package_name
                        )
                    elif not package_name:
                        # Handle classes without package (default package)
                        package_name = "default"
                        if package_name not in packages:
                            packages[package_name] = Package(
                                name=package_name
                            )
                    
                    import_map = {}
                    for imp in tree.imports:
                        class_name = imp.path.split('.')[-1]
                        import_map[class_name] = imp.path

                    for _, class_declaration in tree.filter(
                        javalang.tree.ClassDeclaration
                    ):
                        class_name = class_declaration.name
                        class_key = f"{package_name}.{class_name}"
                        
                        # Debug: Check if this is the User class
                        if "User" in class_name:
                            logger.debug(f"Found User class - {class_key}")
                            logger.debug(f"Methods count: {len(class_declaration.methods)}")
                            logger.debug(f"Constructors count: {len(class_declaration.constructors)}")
                        
                        # Extract class source code - use the entire file content
                        class_source = file_content


                        if class_key not in classes:
                            # Parse class annotations
                            class_annotations = parse_annotations(class_declaration.annotations, "class") if hasattr(class_declaration, 'annotations') else []
                            
                            classes[class_key] = Class(
                                name=class_name,
                                logical_name=class_key,  # Add logical_name
                                file_path=file_path,
                                type="class", # Simplified for now
                                source=class_source, # Add class source
                                annotations=class_annotations,
                                package_name=package_name,
                                description="",  # TODO: Extract description from comments or annotations
                                ai_description=""  # TODO: Generate AI description using LLM
                            )
                            class_to_package_map[class_key] = package_name
                        
                        # --- Start of new import logic ---
                        for imp in tree.imports:
                            classes[class_key].imports.append(imp.path)
                        # --- End of new import logic ---

                        # --- Start of new inheritance logic ---
                        # Handle 'extends'
                        if class_declaration.extends:
                            superclass_name = class_declaration.extends.name
                            # Try to resolve fully qualified name for superclass
                            if superclass_name in import_map:
                                classes[class_key].superclass = import_map[superclass_name]
                            else:
                                # Assume same package or fully qualified if not in import_map
                                classes[class_key].superclass = f"{package_name}.{superclass_name}" if package_name else superclass_name

                        # Handle 'implements'
                        if class_declaration.implements: # Add this check
                            for impl_ref in class_declaration.implements:
                                interface_name = impl_ref.name
                                # Try to resolve fully qualified name for interface
                                if interface_name in import_map:
                                    classes[class_key].interfaces.append(import_map[interface_name])
                                else:
                                    # Assume same package or fully qualified if not in import_map
                                    classes[class_key].interfaces.append(f"{package_name}.{interface_name}" if package_name else interface_name)
                        # --- End of new inheritance logic ---

                        field_map = {}
                        for field_declaration in class_declaration.fields:
                            for declarator in field_declaration.declarators:
                                field_map[declarator.name] = field_declaration.type.name
                                
                                # Parse field annotations
                                field_annotations = parse_annotations(field_declaration.annotations, "field") if hasattr(field_declaration, 'annotations') else []
                                
                                # Extract initial value if present
                                initial_value = ""
                                if hasattr(declarator, 'initializer') and declarator.initializer:
                                    # Convert the initializer to string representation
                                    if hasattr(declarator.initializer, 'value'):
                                        initial_value = str(declarator.initializer.value)
                                    elif hasattr(declarator.initializer, 'type'):
                                        initial_value = str(declarator.initializer.type)
                                    else:
                                        initial_value = str(declarator.initializer)
                                
                                prop = Field(
                                    name=declarator.name,
                                    logical_name=f"{package_name}.{class_name}.{declarator.name}",
                                    type=field_declaration.type.name,
                                    modifiers=list(field_declaration.modifiers), # Add modifiers
                                    package_name=package_name,
                                    class_name=class_name,
                                    annotations=field_annotations,
                                    initial_value=initial_value,
                                    description="",  # TODO: Extract description from comments or annotations
                                    ai_description=""  # TODO: Generate AI description using LLM
                                )
                                classes[class_key].properties.append(prop)

                        all_declarations = class_declaration.methods + class_declaration.constructors
                        
                        # Debug: Check User class method processing
                        if "User" in class_name:
                            logger.debug(f"Processing User class methods - total declarations: {len(all_declarations)}")
                            for i, decl in enumerate(all_declarations):
                                logger.debug(f"Declaration {i}: {type(decl).__name__} - {decl.name}")
                        
                        for declaration in all_declarations:
                            local_var_map = field_map.copy()
                            params = []
                            for param in declaration.parameters:
                                param_type_name = 'Unknown'
                                if hasattr(param.type, 'name'):
                                    param_type_name = param.type.name
                                local_var_map[param.name] = param_type_name
                                params.append(Field(name=param.name, logical_name=f"{package_name}.{class_name}.{param.name}", type=param_type_name, package_name=package_name, class_name=class_name))

                            if declaration.body:
                                for _, var_decl in declaration.filter(javalang.tree.LocalVariableDeclaration):
                                    for declarator in var_decl.declarators:
                                        local_var_map[declarator.name] = var_decl.type.name
                            
                            if isinstance(declaration, javalang.tree.MethodDeclaration):
                                return_type = declaration.return_type.name if declaration.return_type else "void"
                            else: # ConstructorDeclaration
                                return_type = "constructor"

                            # Extract modifiers
                            modifiers = list(declaration.modifiers)
                            
                            # Parse method annotations
                            method_annotations = parse_annotations(declaration.annotations, "method") if hasattr(declaration, 'annotations') else []

                            # Extract method source code
                            method_source = ""
                            if declaration.position:
                                lines = file_content.splitlines(keepends=True) # Keep line endings
                                start_line = declaration.position.line - 1
                                
                                # Find the end of the method by matching braces
                                brace_count = 0
                                end_line = start_line
                                for i in range(start_line, len(lines)):
                                    line = lines[i]
                                    for char in line:
                                        if char == '{':
                                            brace_count += 1
                                        elif char == '}':
                                            brace_count -= 1
                                            if brace_count == 0:
                                                end_line = i
                                                break
                                    if brace_count == 0:
                                        break
                                
                                method_source = "".join(lines[start_line:end_line + 1])

                            method = Method(
                                name=declaration.name,
                                logical_name=f"{class_key}.{declaration.name}",  # Add logical_name
                                return_type=return_type,
                                parameters=params,
                                modifiers=modifiers,
                                source=method_source, # Add method source
                                package_name=package_name,
                                annotations=method_annotations,
                                description="",  # TODO: Extract description from comments or annotations
                                ai_description=""  # TODO: Generate AI description using LLM
                            )
                            classes[class_key].methods.append(method)

                            # Extract method calls with order information
                            call_order = 0
                            for _, invocation in declaration.filter(javalang.tree.MethodInvocation):
                                target_class_name = None
                                resolved_target_package = ""
                                resolved_target_class_name = ""
                                
                                if invocation.qualifier:
                                    # External method call
                                    if invocation.qualifier in local_var_map:
                                        target_class_name = local_var_map[invocation.qualifier]
                                    else:
                                        target_class_name = invocation.qualifier
                                    
                                    if target_class_name:
                                        if target_class_name == "System.out":
                                            resolved_target_package = "java.io"
                                            resolved_target_class_name = "PrintStream"
                                        else:
                                            if target_class_name in import_map:
                                                resolved_target_package = ".".join(import_map[target_class_name].split(".")[:-1])
                                            else:
                                                resolved_target_package = package_name
                                                resolved_target_class_name = target_class_name
                                else:
                                    # Same class method call
                                    resolved_target_package = package_name
                                    resolved_target_class_name = class_name

                                if resolved_target_class_name:
                                    # Get line number from invocation position
                                    line_number = invocation.position.line if invocation.position else 0

                                    call = MethodCall(
                                        source_package=package_name,
                                        source_class=class_name,
                                        source_method=declaration.name,
                                        target_package=resolved_target_package,
                                        target_class=resolved_target_class_name,
                                        target_method=invocation.member,
                                        call_order=call_order,
                                        line_number=line_number,
                                        return_type="void"  # Default return type, can be enhanced later
                                    )
                                    classes[class_key].calls.append(call)
                                    call_order += 1
                        
                        # Check for Lombok @Data annotation and generate methods
                        has_data_annotation = any(ann.name == "Data" for ann in classes[class_key].annotations)
                        if has_data_annotation:
                            logger.debug(f"Found @Data annotation on {class_name}, generating Lombok methods")
                            lombok_methods = generate_lombok_methods(classes[class_key].properties, class_name, package_name)
                            classes[class_key].methods.extend(lombok_methods)
                            logger.debug(f"Generated {len(lombok_methods)} Lombok methods for {class_name}")
                except javalang.parser.JavaSyntaxError as e:
                    print(f"Syntax error in {file_path}: {e}")
                    continue
                except Exception as e:
                    print(f"Error parsing {file_path}: {e}")
                    continue
    
    # Extract beans, analyze dependencies, extract endpoints, extract MyBatis mappers, extract JPA entities, extract config files, and extract test classes
    classes_list = list(classes.values())
    beans = extract_beans_from_classes(classes_list)
    dependencies = analyze_bean_dependencies(classes_list, beans)
    endpoints = extract_endpoints_from_classes(classes_list)
    mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
    jpa_entities = extract_jpa_entities_from_classes(classes_list)
    config_files = extract_config_files(directory)
    test_classes = extract_test_classes_from_classes(classes_list)
    
    # Also extract XML mappers
    xml_mappers = extract_mybatis_xml_mappers(directory)
    mybatis_mappers.extend(xml_mappers)
    
    # Extract SQL statements from MyBatis mappers
    sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
    
    return list(packages.values()), classes_list, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, config_files, test_classes, sql_statements, project_name
```

이제 파서 서비스에서 ai_description 처리 로직 추가가 완료되었습니다.


이제 테스트 코드를 업데이트하겠습니다.


```python
import pytest
from unittest.mock import MagicMock, patch
import json # Added import for json

from src.services.graph_db import GraphDB
from src.models.graph_entities import Class, Field, Method, MethodCall # Import Method and Field

@pytest.fixture
def mock_db():
    with patch('neo4j.GraphDatabase.driver') as mock_driver_constructor:
        mock_driver_instance = MagicMock()
        mock_driver_constructor.return_value = mock_driver_instance
        db_service = GraphDB("uri", "user", "pass")
        yield db_service, mock_driver_instance
        db_service.close()

def test_add_class(mock_db):
    # Given
    db_service, mock_driver = mock_db
    mock_session = MagicMock()
    mock_tx = MagicMock()
    mock_driver.session.return_value.__enter__.return_value = mock_session
    mock_session.write_transaction.side_effect = lambda func, *args: func(mock_tx, *args)

    test_class = Class(
        name="TestClass",
        package="com.test",
        file_path="/path/to/TestClass.java",
        type="class",
        properties=[Field(name="testProp", type="int", description="Test property")],
        calls=[
            MethodCall(
                source_package="com.test",
                source_class="TestClass",
                source_method="myCallingMethod",
                target_package="com.another",
                target_class="AnotherClass",
                target_method="someCalledMethod"
            )
        ]
    )

    # When
    db_service.add_class(test_class)

    # Then
    assert mock_session.write_transaction.called
    
    # Collect all executed queries
    executed_queries = [call[0][0] for call in mock_tx.run.call_args_list]
    executed_params = [call[1] for call in mock_tx.run.call_args_list]

    # Check the MERGE query for the class itself
    class_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (c:Class {name: $name, package: $package})" in query:
            assert executed_params[i]['name'] == "TestClass"
            assert executed_params[i]['package'] == "com.test"
            class_query_found = True
            break
    assert class_query_found

    # Check the MERGE query for the property
    prop_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name})" in query:
            assert executed_params[i]['prop_name'] == "testProp"
            prop_query_found = True
            break
    assert prop_query_found

    # Check the MERGE query for the call relationship
    call_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (sm)-[r:CALLS]->(tm)" in query: # Changed to match the actual query in graph_db.py
            assert executed_params[i]['source_package'] == "com.test"
            assert executed_params[i]['source_class'] == "TestClass"
            assert executed_params[i]['source_method'] == "myCallingMethod"
            assert executed_params[i]['target_package'] == "com.another"
            assert executed_params[i]['target_class'] == "AnotherClass"
            assert executed_params[i]['target_method'] == "someCalledMethod"
            call_query_found = True
            break
    assert call_query_found


def test_add_class_with_fields(mock_db):
    # Given
    db_service, mock_driver = mock_db
    mock_session = MagicMock()
    mock_tx = MagicMock()
    mock_driver.session.return_value.__enter__.return_value = mock_session
    mock_session.write_transaction.side_effect = lambda func, *args: func(mock_tx, *args)

    test_field_private = Field(
        name="greeting", type="String", modifiers=["private"], description="Private greeting field", ai_description="AI-generated description for greeting field"
    )
    test_field_public_static_final = Field(
        name="MAX_VALUE", type="int", modifiers=["public", "static", "final"], description="Public static final constant"
    )
    test_class = Class(
        name="Greeter",
        package="com.example",
        file_path="/path/to/Greeter.java",
        source="class Greeter { private String greeting; }",
        properties=[test_field_private, test_field_public_static_final],
    )

    # When
    db_service.add_class(test_class)

    # Then
    # Check the MERGE query for the class itself
    class_merge_call = mock_tx.run.call_args_list[0]
    assert "MERGE (c:Class {name: $name, package: $package})" in class_merge_call[0][0]
    assert class_merge_call[1]['name'] == "Greeter"

    # Check the MERGE query for the first property (greeting)
    prop1_merge_call = mock_tx.run.call_args_list[1]
    assert (
        "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
        "SET p.modifiers = $prop_modifiers "
        "MERGE (c)-[:HAS_FIELD]->(p)"
    ) in prop1_merge_call[0][0]
    assert prop1_merge_call[1]['prop_name'] == "greeting"
    assert prop1_merge_call[1]['prop_type'] == "String"
    assert prop1_merge_call[1]['prop_modifiers'] == ["private"]

    # Check the MERGE query for the second property (MAX_VALUE)
    prop2_merge_call = mock_tx.run.call_args_list[2]
    assert (
        "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
        "SET p.modifiers = $prop_modifiers "
        "MERGE (c)-[:HAS_FIELD]->(p)"
    ) in prop2_merge_call[0][0]
    assert prop2_merge_call[1]['prop_name'] == "MAX_VALUE"
    assert prop2_merge_call[1]['prop_type'] == "int"
    assert prop2_merge_call[1]['prop_modifiers'] == ["public", "static", "final"]

```

```python
import pytest
from unittest.mock import MagicMock, patch
import json # Added import for json

from src.services.graph_db import GraphDB
from src.models.graph_entities import Class, Field, Method, MethodCall # Import Method and Field

@pytest.fixture
def mock_db():
    with patch('neo4j.GraphDatabase.driver') as mock_driver_constructor:
        mock_driver_instance = MagicMock()
        mock_driver_constructor.return_value = mock_driver_instance
        db_service = GraphDB("uri", "user", "pass")
        yield db_service, mock_driver_instance
        db_service.close()

def test_add_class(mock_db):
    # Given
    db_service, mock_driver = mock_db
    mock_session = MagicMock()
    mock_tx = MagicMock()
    mock_driver.session.return_value.__enter__.return_value = mock_session
    mock_session.write_transaction.side_effect = lambda func, *args: func(mock_tx, *args)

    test_class = Class(
        name="TestClass",
        package="com.test",
        file_path="/path/to/TestClass.java",
        type="class",
        properties=[Field(name="testProp", type="int", description="Test property")],
        calls=[
            MethodCall(
                source_package="com.test",
                source_class="TestClass",
                source_method="myCallingMethod",
                target_package="com.another",
                target_class="AnotherClass",
                target_method="someCalledMethod"
            )
        ]
    )

    # When
    db_service.add_class(test_class)

    # Then
    assert mock_session.write_transaction.called
    
    # Collect all executed queries
    executed_queries = [call[0][0] for call in mock_tx.run.call_args_list]
    executed_params = [call[1] for call in mock_tx.run.call_args_list]

    # Check the MERGE query for the class itself
    class_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (c:Class {name: $name, package: $package})" in query:
            assert executed_params[i]['name'] == "TestClass"
            assert executed_params[i]['package'] == "com.test"
            class_query_found = True
            break
    assert class_query_found

    # Check the MERGE query for the property
    prop_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name})" in query:
            assert executed_params[i]['prop_name'] == "testProp"
            prop_query_found = True
            break
    assert prop_query_found

    # Check the MERGE query for the call relationship
    call_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (sm)-[r:CALLS]->(tm)" in query: # Changed to match the actual query in graph_db.py
            assert executed_params[i]['source_package'] == "com.test"
            assert executed_params[i]['source_class'] == "TestClass"
            assert executed_params[i]['source_method'] == "myCallingMethod"
            assert executed_params[i]['target_package'] == "com.another"
            assert executed_params[i]['target_class'] == "AnotherClass"
            assert executed_params[i]['target_method'] == "someCalledMethod"
            call_query_found = True
            break
    assert call_query_found


def test_add_class_with_fields(mock_db):
    # Given
    db_service, mock_driver = mock_db
    mock_session = MagicMock()
    mock_tx = MagicMock()
    mock_driver.session.return_value.__enter__.return_value = mock_session
    mock_session.write_transaction.side_effect = lambda func, *args: func(mock_tx, *args)

    test_field_private = Field(
        name="greeting", type="String", modifiers=["private"], description="Private greeting field", ai_description="AI-generated description for greeting field"
    )
    test_field_public_static_final = Field(
        name="MAX_VALUE", type="int", modifiers=["public", "static", "final"], description="Public static final constant", ai_description="AI-generated description for MAX_VALUE constant"
    )
    test_class = Class(
        name="Greeter",
        package="com.example",
        file_path="/path/to/Greeter.java",
        source="class Greeter { private String greeting; }",
        properties=[test_field_private, test_field_public_static_final],
    )

    # When
    db_service.add_class(test_class)

    # Then
    # Check the MERGE query for the class itself
    class_merge_call = mock_tx.run.call_args_list[0]
    assert "MERGE (c:Class {name: $name, package: $package})" in class_merge_call[0][0]
    assert class_merge_call[1]['name'] == "Greeter"

    # Check the MERGE query for the first property (greeting)
    prop1_merge_call = mock_tx.run.call_args_list[1]
    assert (
        "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
        "SET p.modifiers = $prop_modifiers "
        "MERGE (c)-[:HAS_FIELD]->(p)"
    ) in prop1_merge_call[0][0]
    assert prop1_merge_call[1]['prop_name'] == "greeting"
    assert prop1_merge_call[1]['prop_type'] == "String"
    assert prop1_merge_call[1]['prop_modifiers'] == ["private"]

    # Check the MERGE query for the second property (MAX_VALUE)
    prop2_merge_call = mock_tx.run.call_args_list[2]
    assert (
        "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
        "SET p.modifiers = $prop_modifiers "
        "MERGE (c)-[:HAS_FIELD]->(p)"
    ) in prop2_merge_call[0][0]
    assert prop2_merge_call[1]['prop_name'] == "MAX_VALUE"
    assert prop2_merge_call[1]['prop_type'] == "int"
    assert prop2_merge_call[1]['prop_modifiers'] == ["public", "static", "final"]

```

```python
import pytest
from unittest.mock import MagicMock, patch
import json # Added import for json

from src.services.graph_db import GraphDB
from src.models.graph_entities import Class, Field, Method, MethodCall # Import Method and Field

@pytest.fixture
def mock_db():
    with patch('neo4j.GraphDatabase.driver') as mock_driver_constructor:
        mock_driver_instance = MagicMock()
        mock_driver_constructor.return_value = mock_driver_instance
        db_service = GraphDB("uri", "user", "pass")
        yield db_service, mock_driver_instance
        db_service.close()

def test_add_class(mock_db):
    # Given
    db_service, mock_driver = mock_db
    mock_session = MagicMock()
    mock_tx = MagicMock()
    mock_driver.session.return_value.__enter__.return_value = mock_session
    mock_session.write_transaction.side_effect = lambda func, *args: func(mock_tx, *args)

    test_class = Class(
        name="TestClass",
        package="com.test",
        file_path="/path/to/TestClass.java",
        type="class",
        properties=[Field(name="testProp", type="int", description="Test property", ai_description="AI-generated description for testProp")],
        calls=[
            MethodCall(
                source_package="com.test",
                source_class="TestClass",
                source_method="myCallingMethod",
                target_package="com.another",
                target_class="AnotherClass",
                target_method="someCalledMethod"
            )
        ]
    )

    # When
    db_service.add_class(test_class)

    # Then
    assert mock_session.write_transaction.called
    
    # Collect all executed queries
    executed_queries = [call[0][0] for call in mock_tx.run.call_args_list]
    executed_params = [call[1] for call in mock_tx.run.call_args_list]

    # Check the MERGE query for the class itself
    class_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (c:Class {name: $name, package: $package})" in query:
            assert executed_params[i]['name'] == "TestClass"
            assert executed_params[i]['package'] == "com.test"
            class_query_found = True
            break
    assert class_query_found

    # Check the MERGE query for the property
    prop_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name})" in query:
            assert executed_params[i]['prop_name'] == "testProp"
            prop_query_found = True
            break
    assert prop_query_found

    # Check the MERGE query for the call relationship
    call_query_found = False
    for i, query in enumerate(executed_queries):
        if "MERGE (sm)-[r:CALLS]->(tm)" in query: # Changed to match the actual query in graph_db.py
            assert executed_params[i]['source_package'] == "com.test"
            assert executed_params[i]['source_class'] == "TestClass"
            assert executed_params[i]['source_method'] == "myCallingMethod"
            assert executed_params[i]['target_package'] == "com.another"
            assert executed_params[i]['target_class'] == "AnotherClass"
            assert executed_params[i]['target_method'] == "someCalledMethod"
            call_query_found = True
            break
    assert call_query_found


def test_add_class_with_fields(mock_db):
    # Given
    db_service, mock_driver = mock_db
    mock_session = MagicMock()
    mock_tx = MagicMock()
    mock_driver.session.return_value.__enter__.return_value = mock_session
    mock_session.write_transaction.side_effect = lambda func, *args: func(mock_tx, *args)

    test_field_private = Field(
        name="greeting", type="String", modifiers=["private"], description="Private greeting field", ai_description="AI-generated description for greeting field"
    )
    test_field_public_static_final = Field(
        name="MAX_VALUE", type="int", modifiers=["public", "static", "final"], description="Public static final constant", ai_description="AI-generated description for MAX_VALUE constant"
    )
    test_class = Class(
        name="Greeter",
        package="com.example",
        file_path="/path/to/Greeter.java",
        source="class Greeter { private String greeting; }",
        properties=[test_field_private, test_field_public_static_final],
    )

    # When
    db_service.add_class(test_class)

    # Then
    # Check the MERGE query for the class itself
    class_merge_call = mock_tx.run.call_args_list[0]
    assert "MERGE (c:Class {name: $name, package: $package})" in class_merge_call[0][0]
    assert class_merge_call[1]['name'] == "Greeter"

    # Check the MERGE query for the first property (greeting)
    prop1_merge_call = mock_tx.run.call_args_list[1]
    assert (
        "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
        "SET p.modifiers = $prop_modifiers "
        "MERGE (c)-[:HAS_FIELD]->(p)"
    ) in prop1_merge_call[0][0]
    assert prop1_merge_call[1]['prop_name'] == "greeting"
    assert prop1_merge_call[1]['prop_type'] == "String"
    assert prop1_merge_call[1]['prop_modifiers'] == ["private"]

    # Check the MERGE query for the second property (MAX_VALUE)
    prop2_merge_call = mock_tx.run.call_args_list[2]
    assert (
        "MERGE (p:Field {name: $prop_name, class_name: $class_name, project_name: $project_name}) "
        "SET p.modifiers = $prop_modifiers "
        "MERGE (c)-[:HAS_FIELD]->(p)"
    ) in prop2_merge_call[0][0]
    assert prop2_merge_call[1]['prop_name'] == "MAX_VALUE"
    assert prop2_merge_call[1]['prop_type'] == "int"
    assert prop2_merge_call[1]['prop_modifiers'] == ["public", "static", "final"]

```

이제 테스트 코드 업데이트가 완료되었습니다.


이제 모든 변경사항에 대해 린터 오류가 있는지 확인하겠습니다.


완벽합니다! 모든 노드에 `ai_description` 속성을 성공적으로 추가했습니다.

## 완료된 작업 요약

모든 노드에 `ai_description` 속성을 추가하는 작업이 완료되었습니다:

### 1. 모델 클래스 업데이트 (`src/models/graph_entities.py`)
- 모든 모델 클래스에 `ai_description: str = ""` 필드 추가
- 총 25개의 클래스에 ai_description 속성 추가:
  - Annotation, Package, Field, Method, MethodCall
  - Bean, BeanDependency, Endpoint
  - MyBatisMapper, MyBatisSqlStatement, SqlStatement, MyBatisResultMap
  - JpaEntity, JpaColumn, JpaRelationship
  - ConfigFile, DatabaseConfig, ServerConfig, SecurityConfig, LoggingConfig
  - TestClass, TestMethod, TestConfiguration
  - Class

### 2. 데이터베이스 스키마 업데이트 (`src/services/graph_db.py`)
- 모든 노드 생성 쿼리에 `ai_description` 필드 추가
- Package, Class, Method, Field, Bean, Endpoint, MyBatisMapper, JpaEntity, ConfigFile, TestClass, SqlStatement 노드에 ai_description 속성 추가
- 각 노드 생성 시 ai_description 값을 데이터베이스에 저장하도록 수정

### 3. 파서 서비스 업데이트 (`src/services/java_parser.py`)
- Field, Method, Class 생성 시 ai_description 필드 추가
- Lombok 생성 메서드들에 ai_description 필드 추가
- 실제 파싱된 메서드와 클래스에는 빈 문자열로 설정 (추후 AI LLM을 사용한 생성 예정)

### 4. 테스트 코드 업데이트 (`tests/unit/test_graph_db.py`)
- 테스트에서 사용하는 Field 객체들에 ai_description 추가
- 테스트 데이터에 의미있는 ai_description 값 설정

### 향후 AI LLM 통합 가능성
이제 모든 노드가 `ai_description` 속성을 가지며, 추후 다음과 같은 방식으로 AI LLM을 통합할 수 있습니다:

- **소스 코드 분석**: 각 노드의 소스 코드를 분석하여 AI가 설명 생성
- **컨텍스트 기반**: 클래스의 역할, 메서드의 기능, 필드의 용도를 AI가 파악하여 설명 생성
- **어노테이션 기반**: Spring, JPA 등의 어노테이션을 분석하여 AI가 설명 생성
- **관계 분석**: 노드 간의 관계를 분석하여 AI가 설명 생성

이제 AI LLM을 사용해서 각 노드의 특징을 자동으로 분석하고 설명을 생성하여 `ai_description` 필드에 저장할 수 있는 완전한 기반이 마련되었습니다.

