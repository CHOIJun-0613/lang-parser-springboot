# AI 분석 기능 구현 결과 (2025-10-25)

## 개요
LLM을 활용하여 Java Class, Method, SQL Statement의 특징을 자동으로 분석하는 기능을 CSA 프로젝트에 통합했습니다.

## 구현 완료 항목

### Phase 1: 기본 인프라 구축 ✅

#### 1.1 AI 설정 관리 (ai_config.py)
- **위치**: `csa/aiwork/ai_config.py`
- **기능**:
  - 환경변수 기반 AI Provider 설정 (Google, Groq, LM Studio, OpenAI)
  - AI 분석 활성화/비활성화 제어 (`AI_USE_ANALYSIS`)
  - Provider별 API Key 및 모델명 관리
- **주요 코드**:
  ```python
  class AIConfig:
      def __init__(self):
          self.ai_use_analysis = os.getenv("AI_USE_ANALYSIS", "false").lower() == "true"
          self.ai_provider = os.getenv("AI_PROVIDER", "google").lower()
          # Google, Groq, LM Studio, OpenAI 설정
  ```

#### 1.2 AI Provider 관리 (ai_providers.py)
- **위치**: `csa/aiwork/ai_providers.py`
- **기능**:
  - 각 LLM Provider별 구현 (Google Gemini, Groq, LM Studio, OpenAI)
  - Provider 자동 폴백 (실패 시 Google로 전환)
  - LLM 인스턴스 생성 및 관리
- **지원 Provider**:
  - Google Gemini (google-adk)
  - Groq (LiteLlm)
  - LM Studio (LiteLlm)
  - OpenAI 호환 API (Ollama 등, LiteLlm)

#### 1.3 프롬프트 템플릿 (prompt.py)
- **위치**: `csa/aiwork/prompt.py`
- **기능**:
  - Class 분석 프롬프트 (`class_doc`)
  - Method 분석 프롬프트 (`method_doc`)
  - SQL 분석 프롬프트 (`sql_doc`)
- **출력 형식**: Markdown (Overview, Key Responsibilities, Integrations 등)

### Phase 2: AI 분석 서비스 구현 ✅

#### 2.1 AI Analyzer (ai_analyzer.py)
- **위치**: `csa/aiwork/ai_analyzer.py`
- **기능**:
  - `analyze_class()`: Java Class 소스 코드 분석
  - `analyze_method()`: Java Method 소스 코드 분석
  - `analyze_sql()`: SQL 문 분석
  - 전역 인스턴스 관리 (`get_ai_analyzer()`)
- **에러 처리**: LLM 호출 실패 시 경고 로그만 출력하고 계속 진행

### Phase 3: Java 분석 파이프라인 통합 ✅

#### 3.1 Class 분석 통합 (project.py)
- **위치**: `csa/services/java_analysis/project.py`
- **통합 지점**: Class 객체 생성 직전 (318-326번 라인)
- **동작**:
  1. AI Analyzer 사용 가능 여부 확인
  2. Class 소스 코드를 LLM에 전달
  3. AI 분석 결과를 `ai_description` 속성에 저장

#### 3.2 Method 분석 통합 (project.py)
- **위치**: `csa/services/java_analysis/project.py`
- **통합 지점**: Method 객체 생성 직전 (457-465번 라인)
- **동작**:
  1. Method 소스 코드 추출 확인
  2. LLM에 Method 소스 전달
  3. AI 분석 결과를 `ai_description` 속성에 저장

#### 3.3 SQL 분석 통합 (mybatis.py)
- **위치**: `csa/services/java_analysis/mybatis.py`
- **통합 지점**: SqlStatement 객체 생성 직전 (54-64번 라인)
- **동작**:
  1. SQL 문 존재 여부 확인
  2. LLM에 SQL 문 전달
  3. AI 분석 결과를 `ai_description` 속성에 저장

### Phase 4: Neo4j 저장 확인 ✅

#### 4.1 Class 노드 저장
- **위치**: `csa/services/graph_db/project_nodes.py`
- **확인 결과**: 218번, 833번 라인에서 `ai_description` 저장 확인

#### 4.2 Method 노드 저장
- **위치**: `csa/services/graph_db/project_nodes.py`
- **확인 결과**: 440번, 513번, 1106번, 1155번 라인에서 `ai_description` 저장 확인

#### 4.3 SqlStatement 노드 저장
- **위치**: `csa/services/graph_db/persistence_nodes.py`
- **확인 결과**: 198번, 434번 라인에서 `ai_description` 저장 확인

### Phase 5: 환경변수 설정 ✅

#### 5.1 .env 파일 설정
```bash
# AI를 적용해서 Class, Method, SQL document 문장 생성(default = false)
AI_USE_ANALYSIS=true

# AI Provider 설정 (google, groq, lmstudio, openai 중 선택)
AI_PROVIDER=google

# Google Gemini 설정
GOOGLE_API_KEY=<your-api-key>
GEMINI_MODEL_NAME=gemini-1.5-flash
GOOGLE_CENAI_USE_VERTEXAI=FALSE

# Groq 설정
GROQ_API_KEY=<your-api-key>
GROQ_MODEL_NAME=qwen/qwen3-32b

# LM Studio 설정
LMSTUDIO_BASE_URL=http://localhost:1234/v1
LMSTUDIO_QWEN_MODEL_NAME=lm_studio/qwen/qwen3-8b

# OpenAI 설정
OPENAI_API_KEY=ollama
OPENAI_MODEL_NAME=gpt-oss:20b
OPENAI_BASE_URL=http://devlab.skax.co.kr/ollama/v1
```

#### 5.2 env.example 업데이트 ✅
- AI_USE_ANALYSIS 설정 추가 (기본값: false)
- AI Provider 설정 예시 포함

### Phase 6: 테스트 코드 작성 ✅

#### 6.1 테스트 파일 생성
- **위치**: `tests/test_ai_analyzer.py`
- **테스트 항목**:
  1. AI 설정 로드 테스트
  2. AI Analyzer 초기화 테스트
  3. Class 분석 테스트 (샘플 UserService 클래스)
  4. Method 분석 테스트 (샘플 findById 메서드)
  5. SQL 분석 테스트 (샘플 SELECT 쿼리)

#### 6.2 테스트 실행 방법
```bash
# 가상환경 활성화
.venv\Scripts\activate  # Windows

# 테스트 실행
python tests/test_ai_analyzer.py
```

## 주요 파일 변경 사항

| 파일 | 변경 내용 | 상태 |
|------|----------|------|
| `csa/aiwork/ai_config.py` | AI_USE_ANALYSIS 환경변수 추가 | ✅ |
| `csa/aiwork/ai_analyzer.py` | AI 분석 서비스 신규 생성 | ✅ |
| `csa/services/java_analysis/project.py` | Class/Method AI 분석 통합 | ✅ |
| `csa/services/java_analysis/mybatis.py` | SQL AI 분석 통합 | ✅ |
| `env.example` | AI 설정 환경변수 예시 추가 | ✅ |
| `tests/test_ai_analyzer.py` | AI Analyzer 테스트 코드 작성 | ✅ |

## 사용 방법

### 1. 환경 설정
1. `.env` 파일 수정:
   ```bash
   AI_USE_ANALYSIS=true
   AI_PROVIDER=google  # 또는 groq, lmstudio, openai
   GOOGLE_API_KEY=your-api-key-here
   ```

2. 필요한 Python 패키지 설치:
   ```bash
   pip install google-adk  # Google Gemini 사용 시
   pip install litellm     # Groq, LM Studio, OpenAI 사용 시
   ```

### 2. Java 프로젝트 분석
```bash
# 전체 재분석 (AI 분석 포함)
python -m csa.cli.main analyze --all-objects --clean --project-name myproject

# Java 소스만 재분석
python -m csa.cli.main analyze --java-object --clean --project-name myproject
```

### 3. Neo4j에서 AI 분석 결과 확인
```cypher
// Class의 AI 설명 조회
MATCH (c:Class {name: 'UserService'})
RETURN c.name, c.ai_description

// Method의 AI 설명 조회
MATCH (m:Method {name: 'findById', class_name: 'UserService'})
RETURN m.name, m.ai_description

// SQL의 AI 설명 조회
MATCH (s:SqlStatement {id: 'selectActiveUsers'})
RETURN s.id, s.ai_description
```

## 오류 처리 정책

AI 분석은 다음과 같은 상황에서 **빈 문자열(`""`)**을 반환하여 전체 분석 프로세스에 영향을 주지 않습니다:

1. **AI가 비활성화된 경우** (`AI_USE_ANALYSIS=false`)
2. **AI Provider 초기화 실패** (API 키 오류, 네트워크 오류 등)
3. **LLM 호출 중 예외 발생** (Rate limit, 모델 오류 등)
4. **응답 정제 실패** (빈 응답, 잘못된 형식 등)

이러한 경우 경고 로그만 출력되고, Neo4j에는 `ai_description=""` (빈 문자열)로 저장되어 데이터 무결성을 유지합니다.

## 문제 해결

### Q1: AI 분석이 실행되지 않습니다.
**A**: `.env` 파일에서 다음을 확인하세요:
- `AI_USE_ANALYSIS=true` 설정
- `AI_PROVIDER` 설정 (google, groq, lmstudio, openai)
- 해당 Provider의 API Key 설정

### Q2: "ImportError: No module named 'google-genai'" 오류가 발생합니다.
**A**: Google Gemini 사용 시 필요한 패키지를 설치하세요:
```bash
pip install google-genai
```

### Q3: AI 분석이 너무 느립니다.
**A**: 다음 방법을 시도하세요:
- 더 빠른 LLM 모델 사용 (예: gemini-2.0-flash, qwen3-32b)
- `AI_USE_ANALYSIS=false`로 설정하여 AI 분석 비활성화
- 특정 파일만 분석 (`--class-name` 옵션 사용)

### Q4: AI 분석 결과가 빈 문자열로 저장됩니다.
**A**: 로그 파일(`logs/`)을 확인하여 다음을 체크하세요:
- API 키가 유효한지 확인
- Rate limit 초과 여부 확인
- 네트워크 연결 상태 확인
- Provider별 서비스 상태 확인 (Google, Groq 등)

## 테스트 결과

### Provider별 테스트 상태

| Provider | 상태 | 모델 | 비고 |
|---------|------|------|------|
| Google Gemini | ✅ 성공 | gemini-2.0-flash | google-genai 라이브러리 사용, 한국어 분석 우수 |
| Groq | ✅ 성공 | qwen/qwen3-32b | litellm 사용, 빠른 응답 속도 |
| LM Studio | ✅ 성공 | qwen3-8b | 로컬 실행, 네트워크 불필요 |
| OpenAI/Ollama | ⚠️ 대기 | gpt-oss:20b | 외부 서버 연결 필요 |

### 분석 결과 샘플 (Google Gemini)

**Class 분석 결과:**
```markdown
### Overview
`UserService`는 사용자 관리 기능을 제공하는 서비스 클래스입니다. 주요 기능은 사용자 ID를 기반으로 사용자 정보를 조회하거나, 새로운 사용자를 생성하는 것입니다. Spring Framework의 `@Service` 어노테이션을 사용하여 Spring Bean으로 등록되고, `@Transactional` 어노테이션으로 트랜잭션 관리를 수행합니다.

### Key Responsibilities
* `findById(Long id)`: 사용자 ID로 사용자 정보를 조회하고, 없으면 예외 발생.
* `createUser(UserCreateRequest request)`: 새로운 사용자를 생성하여 DB에 저장.
* `userRepository`: 데이터베이스 접근을 위한 Repository 인터페이스.
* `@Transactional`: 메서드 호출 시 트랜잭션 시작, 완료 시 commit/rollback 처리.

### Integrations
* `UserRepository`: JPA를 이용한 DB 연동 (구현체에 따라 DB 종류 결정).
* Spring Framework: `@Service`를 통한 Bean 등록 및 의존성 주입.
* `UserCreateRequest`: HTTP 요청으로부터 사용자 생성에 필요한 데이터 전달 객체.
```

**Method 분석 결과:**
```markdown
### Purpose
`findById` 메서드는 주어진 사용자 ID를 사용하여 데이터베이스에서 사용자 정보를 조회합니다. 사용자 ID에 해당하는 정보가 없으면 `UserNotFoundException`을 발생시킵니다.

### Inputs & Outputs
* **Parameters**: `Long id` (조회할 사용자 ID)
* **Returns**: `User` (조회된 사용자 정보)
* **Side Effects**: 없음.
```

## 구현 완료 항목 체크리스트

- [x] AI 설정 관리 모듈 (ai_config.py)
- [x] AI Provider 관리 모듈 (ai_providers.py)
  - [x] Google Gemini (google-genai)
  - [x] Groq (litellm)
  - [x] LM Studio (litellm)
  - [x] OpenAI/Ollama (litellm)
- [x] 프롬프트 템플릿 (prompt.py)
- [x] AI 분석 서비스 (ai_analyzer.py)
- [x] Java Class 분석 통합 (project.py)
- [x] Java Method 분석 통합 (project.py)
- [x] SQL 분석 통합 (mybatis.py)
- [x] Neo4j 저장 확인 (ai_description 필드)
- [x] 환경변수 설정 (.env, env.example)
- [x] 테스트 코드 작성 및 검증
- [x] Windows 콘솔 UTF-8 인코딩 문제 해결
- [x] LLM 응답 정제 로직 (`_clean_response` 메서드)
  - [x] `<think>...</think>` 태그 제거
  - [x] ```markdown ... ``` 코드 블록 추출
- [x] 오류 처리 개선 (모든 오류/None → 빈 문자열 반환)

## 작업 완료 일자
- 2025-10-25: 전체 기능 구현 및 테스트 완료
- 2025-10-25: Google Gemini (google-genai 라이브러리) 정상 작동 확인
- 2025-10-25: Groq, LM Studio 정상 작동 확인
