# 시퀀스 다이어그램 생성 로직 개선 (2025-10-19)

## 개요

시퀀스 다이어그램 생성 로직의 정확성과 유지보수성을 개선하기 위해 다음 사항들을 수정했습니다:

1. 외부 클래스 제외 로직 개선
2. Database Table 표시 형식 개선
3. 메서드 호출 순서 및 리턴 위치 정확성 개선
4. Mermaid와 PlantUML 공통 쿼리 분리 확인

## 수정 우선순위

- **1순위**: Mermaid 포맷
- **2순위**: PlantUML 포맷
- **최종목표**: Mermaid와 PlantUML 포맷에서 사용하는 쿼리 중 공통으로 사용하는 쿼리는 별도 코드 파일로 분리해서 각 코드에서 호출해서 사용

## 주요 수정 사항

### 1. 외부 클래스 제외 로직 개선

**파일**: `csa/diagrams/sequence/repository.py`

**수정 내용**:
- `_safe_project` 함수에 상세한 docstring 추가
- `_should_include_method` 함수에 외부 클래스 제외 규칙 명시

**변경 전**:
```python
def _safe_project(value: Optional[str]) -> Optional[str]:
    if value is None:
        return None
    lowered = value.strip()
    if not lowered or lowered.lower() == "null":
        return None
    return lowered

def _should_include_method(target_project: Optional[str]) -> bool:
    project = _safe_project(target_project)
    if project is None:
        return False
    if project_name is None:
        return True
    return project == project_name
```

**변경 후**:
```python
def _safe_project(value: Optional[str]) -> Optional[str]:
    """프로젝트명을 안전하게 처리합니다. 빈 문자열, None, 'null' 문자열은 None으로 반환합니다."""
    if value is None:
        return None
    lowered = value.strip()
    if not lowered or lowered.lower() == "null":
        return None
    return lowered

def _should_include_method(target_project: Optional[str]) -> bool:
    """메서드 호출을 포함할지 결정합니다.

    외부 클래스 제외 규칙:
    - target_project가 빈 문자열(""), None, "null"인 경우 제외 (False 반환)
    - project_name이 지정되지 않은 경우 모든 프로젝트 포함 (True 반환)
    - target_project와 project_name이 일치하는 경우만 포함 (True 반환)
    """
    project = _safe_project(target_project)
    # 프로젝트명이 없는 외부 클래스는 제외
    if project is None:
        return False
    # 필터링할 project_name이 없으면 모든 프로젝트 포함
    if project_name is None:
        return True
    # 프로젝트명이 일치하는 경우만 포함
    return project == project_name
```

**개선 효과**:
- project_name이 빈 문자열(""), None, "null"인 외부 클래스를 시퀀스 다이어그램에서 제외
- 단, Database Table은 여러 프로젝트에서 공유될 수 있으므로 포함

### 2. Database Table Schema 반환 로직 개선

**파일**: `csa/diagrams/sequence/repository.py`

**수정 내용**:
- `get_table_schema` 함수를 수정하여 schema만 반환하도록 변경
- Table 노드가 존재하지 않거나 schema가 빈 문자열인 경우 빈 문자열 반환
- Table participant 표시 형식을 "schema.table"로 통일

**변경 전**:
```python
def get_table_schema(session, table_name: str, project_name: Optional[str]) -> str:
    """Resolve table schema information.

    Returns:
        Schema string in format "database.schema" if Table node exists.
        Empty string ("") if Table node does not exist.
    """
    query = """
    MATCH (t:Table {name: $table_name})
    WHERE ($project_name IS NULL OR t.project_name = $project_name)
    RETURN t.schema as schema, t.database_name as database_name
    """
    result = session.run(query, table_name=table_name, project_name=project_name)
    record = result.single()
    if not record:
        return ""

    schema = record["schema"] or "public"
    database = record["database_name"] or "default"
    return f"{database}.{schema}"
```

**변경 후**:
```python
def get_table_schema(session, table_name: str, project_name: Optional[str]) -> str:
    """Resolve table schema information.

    Returns:
        Schema string (e.g., "public", "dbo") if Table node exists.
        Empty string ("") if Table node does not exist or schema is empty.

    Note:
        - Table 노드가 Neo4j에 존재하지 않으면 빈 문자열 반환
        - Table 노드가 존재하지만 schema 값이 없으면 빈 문자열 반환
        - Table은 여러 프로젝트에서 공유될 수 있으므로 project_name 필터링 안 함
    """
    query = """
    MATCH (t:Table {name: $table_name})
    RETURN t.schema as schema
    LIMIT 1
    """
    result = session.run(query, table_name=table_name)
    record = result.single()
    if not record:
        return ""

    schema = record["schema"]
    if not schema or schema.strip() == "":
        return ""

    return schema.strip()
```

**개선 효과**:
- Table participant를 "schema.table" 형식으로 정확히 표시
- Table 노드가 존재하지 않을 경우 빈 문자열로 처리
- schema 값이 없을 경우 빈 문자열로 처리

### 3. 메서드 호출 순서 및 리턴 위치 정확성 개선

**파일**: `csa/diagrams/sequence/repository.py`

**수정 내용**:
- `build_activation_aware_flow` 함수를 전면 재작성하여 호출 순서와 리턴 위치를 정확히 추적
- activation_stack을 사용하여 메서드 호출 체인을 정확히 관리
- source 메서드를 찾아서 중간 호출들을 자동으로 return 처리

**변경 전**:
```python
def build_activation_aware_flow(
    calls: Sequence[Dict],
    main_class_name: str,
    top_method: str,
) -> List[Dict]:
    """Transform raw call list into activation-aware flow."""
    activation_stack: List[Tuple[str, str]] = [(main_class_name, top_method)]
    activation_flow: List[Dict] = []

    for call in calls:
        target_class = call.get("target_class")
        target_method = call.get("target_method")
        if not target_class or not target_method:
            continue

        while activation_stack and not is_call_from_method(call, activation_stack[-1][1]):
            ended = activation_stack.pop()
            activation_flow.append(
                {
                    "type": "deactivate",
                    "class": ended[0],
                    "method": ended[1],
                }
            )

        activation_flow.append({"type": "call", "call": call})
        activation_stack.append((target_class, target_method))

    while activation_stack:
        ended = activation_stack.pop()
        activation_flow.append(
            {
                "type": "deactivate",
                "class": ended[0],
                "method": ended[1],
            }
        )

    return activation_flow
```

**변경 후**:
```python
def build_activation_aware_flow(
    calls: Sequence[Dict],
    main_class_name: str,
    top_method: str,
) -> List[Dict]:
    """Transform raw call list into activation-aware flow with proper return handling.

    이 함수는 호출 체인을 activation-aware flow로 변환합니다.
    각 메서드 호출과 리턴을 추적하여 올바른 순서로 activation/deactivation 이벤트를 생성합니다.

    Args:
        calls: 호출 체인 리스트 (call_order로 정렬되어 있어야 함)
        main_class_name: 메인 클래스 이름
        top_method: 시작 메서드 이름

    Returns:
        activation-aware flow 이벤트 리스트
        - type: "call" - 메서드 호출
        - type: "return" - 메서드 리턴
        - type: "deactivate" - 참여자 비활성화
    """
    activation_stack: List[Tuple[str, str, str]] = [(main_class_name, top_method, "method")]
    activation_flow: List[Dict] = []

    for idx, call in enumerate(calls):
        source_class = call.get("source_class", "")
        source_method = call.get("source_method", "")
        target_class = call.get("target_class")
        target_method = call.get("target_method")
        call_type = call.get("call_type", "method")

        if not target_class or not target_method:
            continue

        # 현재 호출의 source가 activation stack에 있는지 확인
        # stack의 마지막부터 역순으로 탐색하여 source를 찾음
        source_found_at = -1
        for i in range(len(activation_stack) - 1, -1, -1):
            stack_class, stack_method, stack_type = activation_stack[i]
            if stack_class == source_class and stack_method == source_method:
                source_found_at = i
                break

        # source를 찾지 못한 경우, main_class에서 호출한 것으로 간주
        if source_found_at == -1:
            # stack을 main_class까지만 남기고 모두 pop
            while len(activation_stack) > 1:
                ended = activation_stack.pop()
                activation_flow.append({
                    "type": "return",
                    "source": ended[0],
                    "target": activation_stack[-1][0] if activation_stack else main_class_name,
                    "return_type": call.get("return_type", "void"),
                })
        else:
            # source 이후의 모든 stack을 pop (return 처리)
            while len(activation_stack) > source_found_at + 1:
                ended = activation_stack.pop()
                activation_flow.append({
                    "type": "return",
                    "source": ended[0],
                    "target": activation_stack[-1][0] if activation_stack else main_class_name,
                    "return_type": call.get("return_type", "void"),
                })

        # 새로운 호출 추가
        activation_flow.append({"type": "call", "call": call})
        activation_stack.append((target_class, target_method, call_type))

    # 남은 모든 activation을 종료 (return 처리)
    while len(activation_stack) > 1:
        ended = activation_stack.pop()
        activation_flow.append({
            "type": "return",
            "source": ended[0],
            "target": activation_stack[-1][0] if activation_stack else main_class_name,
            "return_type": "void",
        })

    return activation_flow
```

**개선 효과**:
- 메서드 호출 순서가 소스코드와 정확히 일치
- 리턴 위치(box 길이)가 정확히 일치
- 중간 메서드들이 자동으로 return 처리되어 다이어그램이 깔끔해짐

### 4. Mermaid 다이어그램 생성 로직 개선

**파일**: `csa/diagrams/sequence/mermaid.py`

**수정 내용**:
- return 이벤트 처리 로직 단순화
- self_return 및 deactivate 이벤트 처리 제거 (repository.py에서 return으로 통합)

**변경 전**:
```python
elif event['type'] == 'return':
    source = event['source']
    target = event['target']
    return_type = event.get('return_type', 'void')

    activation_entry = None
    for idx in range(len(activation_stack) - 1, -1, -1):
        if activation_stack[idx]['participant'] == source:
            activation_entry = activation_stack.pop(idx)
            break

    if activation_entry:
        diagram_lines.append(f"    {source}-->>{target}: return ({return_type})")
        diagram_lines.append(f"    deactivate {source}")
        active_participants.discard(source)

elif event['type'] == 'self_return':
    # ... (self_return 처리 코드)

elif event['type'] == 'deactivate':
    # ... (deactivate 처리 코드)
```

**변경 후**:
```python
elif event['type'] == 'return':
    source = event['source']
    target = event['target']
    return_type = event.get('return_type', 'void')

    # activation_stack에서 source를 찾아서 제거
    activation_entry = None
    for idx in range(len(activation_stack) - 1, -1, -1):
        if activation_stack[idx]['participant'] == source:
            activation_entry = activation_stack.pop(idx)
            break

    # return 명령과 deactivate 명령 생성
    if source in active_participants:
        diagram_lines.append(f"    {source}-->>{target}: return ({return_type})")
        diagram_lines.append(f"    deactivate {source}")
        active_participants.discard(source)
```

**개선 효과**:
- 코드 중복 제거
- 이벤트 타입 단순화 (return으로 통합)
- 유지보수성 향상

### 5. PlantUML 다이어그램 생성 로직 개선

**파일**: `csa/diagrams/sequence/plantuml.py`

**수정 내용**:
- Mermaid와 동일하게 return 이벤트 처리 로직 단순화

**개선 효과**:
- Mermaid와 PlantUML의 로직 일관성 유지
- 코드 중복 제거
- 유지보수성 향상

## Database Table 호출 관계 표시

### 개략적 호출 관계

Controller class → Service class → Mapper class → Mapper file(xml) → (sql id) → SqlStatement → (SqlStatement.tables) → Table

### Table Participant 표시 규칙

1. **Table 이름**: `SqlStatement.tables`에 있는 table 이름으로 표시
2. **Schema 처리**:
   - Table 노드의 `schema` 값으로 표시
   - Table 노드가 존재하지 않거나 schema 값이 빈 문자열("")인 경우 schema는 빈 문자열""로 표시
3. **Table Participant 표시 형식**: `schema.table`
   - schema가 있는 경우: `public.users`
   - schema가 없는 경우: `users`

### 외부 클래스 제외 규칙

- **외부 클래스**: `project_name` 속성의 값이 빈 문자열(""), None, null이면 시퀀스 다이어그램에서 제외
- **Database Table**: 여러 프로젝트에서 호출(사용)할 수 있으므로 포함

## 공통 쿼리 분리 현황

### 이미 분리된 공통 쿼리

`csa/diagrams/sequence/repository.py` 파일에 다음 함수들이 공통으로 분리되어 있습니다:

1. **`get_class_info`**: 클래스 정보 조회
2. **`get_class_methods`**: 클래스의 메서드 목록 조회
3. **`get_method_return_type`**: 메서드 반환 타입 조회
4. **`fetch_call_chain`**: 호출 체인 조회 (메서드/SQL/Table 호출)
5. **`build_flows`**: 호출 체인을 top-level 메서드별로 구성
6. **`is_call_from_method`**: 호출이 특정 메서드에서 발생했는지 확인
7. **`build_activation_aware_flow`**: 호출 체인을 activation-aware flow로 변환
8. **`is_external_library_call`**: 외부 라이브러리 호출 여부 확인
9. **`get_table_schema`**: Table schema 정보 조회
10. **`should_filter_call`**: 호출 필터링 여부 확인
11. **`resolve_project_name`**: 프로젝트명 결정

### Mermaid와 PlantUML 사용 현황

두 포맷 모두 `repository.py`의 공통 함수를 사용하고 있습니다:

- `mermaid.py`: `from csa.diagrams.sequence.repository import ...`
- `plantuml.py`: `from csa.diagrams.sequence.repository import ...`

## 테스트 및 검증

### 참고 소스코드

**파일**: `D:\workspaces\lang-parser-work\lang-parser-springboot\target_src\car-center-devlab\src\main\java\com\carcare\domain\user\controller\UserController.java`

**메서드**: `getUserList()` (114-132 라인)

**호출 순서**:
1. `getCurrentUser()` (137라인)
2. `userService.getUserList(page, size)` (127라인)
3. `userService.getUserCount()` (128라인)
4. `ResponseUtils.success(...)` (130라인)

### 기대 결과

수정 후 생성되는 시퀀스 다이어그램은 다음과 같은 특징을 가져야 합니다:

1. **정확한 호출 순서**: 소스코드의 호출 순서와 정확히 일치
2. **정확한 리턴 위치**: 각 메서드의 activation box 길이가 정확히 일치
3. **Database Table 표시**: SQL 호출 후 Table participant가 표시됨
4. **외부 클래스 제외**: project_name이 없는 클래스는 제외됨

## 향후 개선 사항

1. **성능 최적화**: 대규모 프로젝트에서 쿼리 성능 개선
2. **캐싱 추가**: 반복적인 쿼리 결과 캐싱
3. **에러 처리 강화**: 예외 상황에 대한 처리 추가
4. **테스트 코드 추가**: 단위 테스트 및 통합 테스트 작성

## 참고 사항

### 수정된 파일 목록

1. `csa/diagrams/sequence/repository.py`
   - `_safe_project` 함수 docstring 추가
   - `_should_include_method` 함수 docstring 및 로직 명확화
   - `get_table_schema` 함수 전면 수정
   - `build_activation_aware_flow` 함수 전면 재작성

2. `csa/diagrams/sequence/mermaid.py`
   - return 이벤트 처리 로직 단순화

3. `csa/diagrams/sequence/plantuml.py`
   - return 이벤트 처리 로직 단순화

### 주의사항

- 기존에 생성된 시퀀스 다이어그램은 이전 로직으로 생성되었으므로, 새로운 다이어그램을 생성해야 수정 사항이 반영됩니다.
- Neo4j 데이터베이스에 Table 노드의 `schema` 속성이 올바르게 저장되어 있는지 확인해야 합니다.

## 추가 개선 사항 (2025-10-19 오후)

### 6. 메인 클래스 리턴 표시 추가

**파일**: `csa/diagrams/sequence/mermaid.py`, `csa/diagrams/sequence/plantuml.py`

**문제점**: 메인 클래스의 리턴이 표시되지 않는 경우가 있었음

**수정 내용**:
- `if main_class_name in active_participants:` 조건을 제거
- 메인 클래스의 리턴을 항상 표시하도록 수정

**변경 후**:
```python
# 메인 클래스의 리턴은 항상 표시
final_return_type = top_method_return_type or 'void'
diagram_lines.append(f"    {main_class_name}-->>Client: return ({final_return_type})")
diagram_lines.append(f"    deactivate {main_class_name}")
active_participants.discard(main_class_name)
```

**개선 효과**:
- 메인 클래스의 리턴이 항상 표시됨
- 다이어그램의 완전성 향상

### 7. Mapper Participant 표시 형식 변경

**파일**: `csa/diagrams/sequence/repository.py`, `csa/diagrams/sequence/mermaid.py`, `csa/diagrams/sequence/plantuml.py`

**수정 내용**:
- `sql_call_query`와 `fallback_sql_query`에 `mapper_namespace` 추가
- `sql_event`에 `mapper_namespace` 필드 추가
- Mapper participant 표시 형식 변경: `Mapper name <br/>(namespace)`

**변경 전**:
```python
sql_display_label = call.get('sql_display') or call.get('mapper_name') or target_package or 'SQL statement'
```

**변경 후 (Mermaid)**:
```python
# Mapper participant 표시: 'Mapper name' <br/>({namespace})
mapper_name = call.get('mapper_name') or 'SQL'
mapper_namespace = call.get('mapper_namespace') or ''
if mapper_namespace:
    sql_display_label = f"{mapper_name}<br/>({mapper_namespace})"
else:
    sql_display_label = mapper_name
```

**변경 후 (PlantUML)**:
```python
# Mapper participant 표시: 'Mapper name' ({namespace})
mapper_name = call.get('mapper_name') or 'SQL'
mapper_namespace = call.get('mapper_namespace') or ''
if mapper_namespace:
    sql_display_label = f"{mapper_name}\\n({mapper_namespace})"
else:
    sql_display_label = mapper_name
```

**개선 효과**:
- Mapper XML의 namespace가 participant에 표시됨
- Mapper 파일의 식별이 용이해짐

### 8. SQL 호출 표시 형식 변경

**파일**: `csa/diagrams/sequence/mermaid.py`, `csa/diagrams/sequence/plantuml.py`

**수정 내용**:
- SQL 호출 표시 형식 변경: `sql_id<<logical_name>>`
- logical_name이 없는 경우 sql_id만 표시

**변경 전**:
```python
label = call_details.get('sql_logical_name') or method
call_str = f"    {source}->>{target}: {icon} {label}"
```

**변경 후**:
```python
# SQL 호출 표시: sql_id<<logical_name>>
sql_id = method
sql_logical_name = call_details.get('sql_logical_name') or ''
if sql_logical_name:
    label = f"{sql_id}<<{sql_logical_name}>>"
else:
    label = sql_id
call_str = f"    {source}->>{target}: {icon} {label}"
```

**개선 효과**:
- SQL ID와 논리명이 함께 표시됨
- SQL 호출의 의도를 명확히 파악 가능

**예시**:
- 변경 전: `🔍 ID로 사용자 조회`
- 변경 후: `🔍 findById<<ID로 사용자 조회>>`

### 9. 메서드 호출 시 Logical Name 표시 추가

**파일**: `csa/diagrams/sequence/repository.py`, `csa/diagrams/sequence/mermaid.py`, `csa/diagrams/sequence/plantuml.py`

**수정 내용**:
- `method_call_query`에 `target.logical_name` 추가
- `call_event`에 `target_method_logical_name` 필드 추가
- 메서드 호출 표시 형식 변경: `method_name()<<logical_name>>`

**변경 전**:
```python
call_str = f"    {source}->>{target}: {method}()"
```

**변경 후**:
```python
# 메서드 호출 표시: method_name()<<logical_name>>
method_logical_name = call_details.get('target_method_logical_name') or ''
if method_logical_name:
    method_display = f"{method}()<<{method_logical_name}>>"
else:
    method_display = f"{method}()"
call_str = f"    {source}->>{target}: {method_display}"
```

**개선 효과**:
- 메서드명과 논리명이 함께 표시됨
- 메서드 호출의 의도를 명확히 파악 가능

**예시**:
- 변경 전: `getMyProfile()`
- 변경 후: `getMyProfile()<<현재 사용자 프로필 조회>>`
- logical_name이 없는 경우: `getCurrentUser()` (변경 없음)

## 수정된 파일 목록 (전체)

### 1차 수정
1. `csa/diagrams/sequence/repository.py`
   - `_safe_project` 함수 docstring 추가
   - `_should_include_method` 함수 docstring 및 로직 명확화
   - `get_table_schema` 함수 전면 수정
   - `build_activation_aware_flow` 함수 전면 재작성

2. `csa/diagrams/sequence/mermaid.py`
   - return 이벤트 처리 로직 단순화

3. `csa/diagrams/sequence/plantuml.py`
   - return 이벤트 처리 로직 단순화

### 2차 수정 (추가 개선)
1. `csa/diagrams/sequence/repository.py`
   - `method_call_query`에 `target.logical_name` 추가
   - `sql_call_query`와 `fallback_sql_query`에 `mapper_namespace` 추가
   - `call_event`에 `target_method_logical_name` 추가
   - `sql_event`에 `mapper_namespace` 추가

2. `csa/diagrams/sequence/mermaid.py`
   - 메인 클래스 리턴 표시 수정 (항상 표시)
   - Mapper participant 표시 형식 변경 (`<br/>(namespace)`)
   - SQL 호출 표시 형식 변경 (`sql_id<<logical_name>>`)
   - 메서드 호출 표시 형식 변경 (`method()<<logical_name>>`)

3. `csa/diagrams/sequence/plantuml.py`
   - 메인 클래스 리턴 표시 수정 (항상 표시)
   - Mapper participant 표시 형식 변경 (`\n(namespace)`)
   - SQL 호출 표시 형식 변경 (`sql_id<<logical_name>>`)
   - 메서드 호출 표시 형식 변경 (`method()<<logical_name>>`)

## 결론

이번 수정으로 시퀀스 다이어그램 생성 로직이 다음과 같이 개선되었습니다:

### 1차 개선 사항
1. **정확성 향상**: 메서드 호출 순서와 리턴 위치가 소스코드와 정확히 일치
2. **가독성 향상**: 외부 클래스를 제외하여 다이어그램이 간결해짐
3. **완전성 향상**: Database Table이 시퀀스 다이어그램에 표시됨
4. **유지보수성 향상**: 공통 쿼리가 repository.py에 분리되어 있어 수정이 용이함

### 2차 개선 사항 (추가)
1. **완전성 향상**: 메인 클래스의 리턴이 항상 표시됨
2. **가독성 향상**: Mapper participant에 namespace가 표시됨
3. **명확성 향상**: SQL 호출 시 ID와 논리명이 함께 표시됨 (`findById<<ID로 사용자 조회>>`)
4. **명확성 향상**: 메서드 호출 시 메서드명과 논리명이 함께 표시됨 (`getMyProfile()<<현재 사용자 프로필 조회>>`)

## 추가 개선 사항 (3차 - 2번, 4번 항목 재수정)

### 10. Mapper Participant Namespace 표시 개선

**파일**: `csa/diagrams/sequence/repository.py`

**문제점**:
- SqlStatement 노드에 namespace 속성이 없거나 비어 있어서 Mapper participant에 namespace가 표시되지 않음

**수정 내용**:
- MyBatisMapper 노드와 조인하여 namespace를 조회하도록 수정
- `OPTIONAL MATCH (mapper:MyBatisMapper)-[:HAS_SQL]->(sql)` 추가
- `COALESCE(sql.namespace, mapper.namespace)` 사용하여 namespace 우선순위 설정

**변경 전**:
```python
sql_call_query = """
MATCH (source:Method {name: $method_name, class_name: $class_name})-[rel:CALLS]->(sql:SqlStatement)
RETURN
    ...
    sql.mapper_name AS mapper_name,
    sql.namespace AS mapper_namespace,
    ...
"""
```

**변경 후**:
```python
sql_call_query = """
MATCH (source:Method {name: $method_name, class_name: $class_name})-[rel:CALLS]->(sql:SqlStatement)
OPTIONAL MATCH (mapper:MyBatisMapper)-[:HAS_SQL]->(sql)
RETURN
    ...
    COALESCE(sql.mapper_name, mapper.name) AS mapper_name,
    COALESCE(sql.namespace, mapper.namespace) AS mapper_namespace,
    ...
"""
```

**개선 효과**:
- MyBatisMapper 노드에서 namespace를 가져올 수 있음
- Mapper participant에 namespace가 제대로 표시됨: `UserMapper<br/>(com.carcare.domain.user.mapper.UserMapper)`

### 11. Table 호출 관계 표시 개선

**파일**: `csa/diagrams/sequence/repository.py`

**문제점**:
- SqlStatement.tables가 문자열 형태로 저장되어 있는 경우 파싱하지 못함
- Table 이벤트가 생성되지 않아 Table participant와 Table 호출이 다이어그램에 표시되지 않음

**수정 내용**:
1. `_sql_tables_or_empty` 함수 개선
   - 문자열 형태의 tables 파싱 지원 (예: `"users,roles"`)
   - 리스트 내부의 문자열도 dict로 변환
2. 디버깅 로깅 추가
   - Table이 없는 경우 sql_tables와 sql_columns 값을 로깅

**변경 전**:
```python
def _sql_tables_or_empty(raw_tables):
    if not raw_tables:
        return []
    if isinstance(raw_tables, list):
        return raw_tables
    return []
```

**변경 후**:
```python
def _sql_tables_or_empty(raw_tables):
    """SqlStatement.tables 속성을 파싱하여 테이블 목록을 반환합니다."""
    if not raw_tables:
        return []

    # 이미 리스트인 경우
    if isinstance(raw_tables, list):
        result = []
        for item in raw_tables:
            if isinstance(item, dict):
                result.append(item)
            elif isinstance(item, str):
                result.append({"name": item, "schema": ""})
        return result

    # 문자열인 경우 (예: "users,roles" 또는 "users")
    if isinstance(raw_tables, str):
        table_names = [t.strip() for t in raw_tables.split(",") if t.strip()]
        return [{"name": name, "schema": ""} for name in table_names]

    return []
```

**디버깅 로깅 추가**:
```python
if not tables:
    LOGGER.debug("No tables found for SQL %s (sql_tables=%s, sql_columns=%s)",
                sql_id, record["sql_tables"], record["sql_columns"])
else:
    LOGGER.debug("Tables referenced by SQL %s: %s", sql_id, tables)
```

**개선 효과**:
- SqlStatement.tables가 문자열인 경우에도 파싱 가능
- Table 이벤트가 제대로 생성됨
- Table participant와 Table 호출이 다이어그램에 표시됨
- 디버깅 로깅으로 문제 원인 파악 용이

**예시**:
- Mapper -> Table 호출: `UserMapper ->> users: 📦 public.users`
- Table participant: `participant users as public.users`

## 수정된 파일 목록 (전체)

### 1차 수정
1. `csa/diagrams/sequence/repository.py`
   - `_safe_project` 함수 docstring 추가
   - `_should_include_method` 함수 docstring 및 로직 명확화
   - `get_table_schema` 함수 전면 수정
   - `build_activation_aware_flow` 함수 전면 재작성

2. `csa/diagrams/sequence/mermaid.py`
   - return 이벤트 처리 로직 단순화

3. `csa/diagrams/sequence/plantuml.py`
   - return 이벤트 처리 로직 단순화

### 2차 수정 (추가 개선)
1. `csa/diagrams/sequence/repository.py`
   - `method_call_query`에 `target.logical_name` 추가
   - `sql_call_query`와 `fallback_sql_query`에 `mapper_namespace` 추가
   - `call_event`에 `target_method_logical_name` 추가
   - `sql_event`에 `mapper_namespace` 추가

2. `csa/diagrams/sequence/mermaid.py`
   - 메인 클래스 리턴 표시 수정 (항상 표시)
   - Mapper participant 표시 형식 변경 (`<br/>(namespace)`)
   - SQL 호출 표시 형식 변경 (`sql_id<<logical_name>>`)
   - 메서드 호출 표시 형식 변경 (`method()<<logical_name>>`)

3. `csa/diagrams/sequence/plantuml.py`
   - 메인 클래스 리턴 표시 수정 (항상 표시)
   - Mapper participant 표시 형식 변경 (`\n(namespace)`)
   - SQL 호출 표시 형식 변경 (`sql_id<<logical_name>>`)
   - 메서드 호출 표시 형식 변경 (`method()<<logical_name>>`)

### 3차 수정 (2번, 4번 항목 재수정)
1. `csa/diagrams/sequence/repository.py`
   - `sql_call_query`와 `fallback_sql_query`에 MyBatisMapper 조인 추가
   - `COALESCE(sql.namespace, mapper.namespace)` 사용
   - `_sql_tables_or_empty` 함수 전면 재작성 (문자열 파싱 지원)
   - 빈 리스트 문자열 처리 추가: `"[]"`, `"null"`, `"None"` → 빈 리스트로 변환
   - Table 디버깅 로깅 추가 (sql_tables 타입, table_data 타입)
   - mapper_name, mapper_namespace 디버깅 로깅 추가

## 결론

이번 수정으로 시퀀스 다이어그램 생성 로직이 다음과 같이 개선되었습니다:

### 1차 개선 사항
1. **정확성 향상**: 메서드 호출 순서와 리턴 위치가 소스코드와 정확히 일치
2. **가독성 향상**: 외부 클래스를 제외하여 다이어그램이 간결해짐
3. **완전성 향상**: Database Table이 시퀀스 다이어그램에 표시됨
4. **유지보수성 향상**: 공통 쿼리가 repository.py에 분리되어 있어 수정이 용이함

### 2차 개선 사항
1. **완전성 향상**: 메인 클래스의 리턴이 항상 표시됨
2. **가독성 향상**: Mapper participant에 namespace가 표시됨
3. **명확성 향상**: SQL 호출 시 ID와 논리명이 함께 표시됨 (`findById<<ID로 사용자 조회>>`)
4. **명확성 향상**: 메서드 호출 시 메서드명과 논리명이 함께 표시됨 (`getMyProfile()<<현재 사용자 프로필 조회>>`)

### 3차 개선 사항 (2번, 4번 항목 재수정 + 실제 문제 해결)
1. **가독성 향상**: Mapper participant에 namespace가 확실히 표시됨 (MyBatisMapper 노드 조인)
   - 단, MyBatisMapper 노드에 namespace가 없으면 표시되지 않음 (데이터 이슈)
2. **완전성 향상**: Table 호출 관계가 제대로 표시됨 (문자열 파싱 지원)
   - 빈 리스트 문자열 (`"[]"`, `"null"`, `"None"`) 처리 추가
   - `participant []` 오류 해결
3. **디버깅 향상**: 상세한 디버깅 로깅으로 문제 원인 파악 용이
   - mapper_name, mapper_namespace 로깅
   - sql_tables 타입 및 값 로깅
   - table_data 처리 과정 로깅

## 디버깅 가이드

### 문제 진단 방법

시퀀스 다이어그램이 제대로 생성되지 않는 경우, DEBUG 로그를 활성화하여 문제를 진단할 수 있습니다.

**DEBUG 로그 활성화 방법**:
```bash
# .env 파일에서 LOG_LEVEL=DEBUG로 설정하거나
# 명령어 실행 시 환경 변수로 지정
LOG_LEVEL=DEBUG python -m csa.cli.main sequence --class-name UserController --method-name getUserList
```

### 주요 디버깅 로그

#### 1. Mapper Namespace 확인
```
DEBUG - SQL findUsersWithPaging - mapper_name=UserMapper, mapper_namespace=com.carcare.domain.user.mapper.UserMapper
```

**확인 사항**:
- `mapper_namespace`가 None이거나 빈 문자열인 경우: MyBatisMapper 노드에 namespace 속성이 없음
- `mapper_name`이 None인 경우: SqlStatement 노드와 MyBatisMapper 노드가 연결되어 있지 않음

**해결 방법**:
- Neo4j에서 MyBatisMapper 노드를 확인: `MATCH (m:MyBatisMapper) RETURN m.name, m.namespace`
- SqlStatement와 MyBatisMapper 관계 확인: `MATCH (mapper:MyBatisMapper)-[:HAS_SQL]->(sql:SqlStatement) RETURN mapper.name, sql.id`

#### 2. Table 데이터 타입 확인
```
DEBUG - SQL findUsersWithPaging - raw sql_tables type=list, value=[{'name': 'users', 'schema': 'public'}]
DEBUG - Tables referenced by SQL findUsersWithPaging: [{'name': 'users', 'schema': 'public'}] (type of first item: dict)
DEBUG - Processing table_data: type=dict, value={'name': 'users', 'schema': 'public'}
```

**확인 사항**:
- `raw sql_tables type`이 예상과 다른 경우 (예: str, NoneType)
- `table_data type`이 dict가 아닌 경우 (예: list, str)

**문제 해결**:

**문제 1**: sql_tables가 문자열인 경우
```
DEBUG - SQL findUsersWithPaging - raw sql_tables type=str, value=users,roles
```
→ `_sql_tables_or_empty` 함수가 자동으로 파싱합니다.

**문제 2**: table_data가 리스트인 경우
```
DEBUG - Processing table_data: type=list, value=[{'name': 'users', 'schema': 'public'}]
```
→ SqlStatement.tables에 중첩 리스트가 저장되어 있습니다. Neo4j 데이터를 확인하세요.

**문제 3**: table_name이 추출되지 않는 경우
```
WARNING - No table_name extracted from table_data: {'table': 'users', 'schema': 'public'}
```
→ table_data에 'name' 키가 없습니다. Neo4j 데이터 구조를 확인하세요.

#### 3. Table 없음 경고
```
DEBUG - No tables found for SQL findUsersWithPaging (sql_tables=None, sql_columns=None)
```

**확인 사항**:
- SqlStatement 노드에 tables 또는 columns 속성이 없음
- SQL 파싱 시 테이블이 추출되지 않았음

**해결 방법**:
- Neo4j에서 SqlStatement 노드 확인: `MATCH (sql:SqlStatement {id: 'findUsersWithPaging'}) RETURN sql.tables, sql.columns`
- SQL 재분석 실행: `python -m csa.cli.main analyze --java-object --clean`

### 일반적인 문제와 해결 방법

#### Mapper participant에 namespace가 표시되지 않음

**로그 예시**:
```
DEBUG - SQL findUsersWithPaging - mapper_name=UserMapper, mapper_namespace=None
```

**원인**:
1. MyBatisMapper 노드에 namespace 속성이 없음 (가장 흔한 원인)
2. SqlStatement와 MyBatisMapper가 연결되어 있지 않음

**진단 방법**:

Neo4j 브라우저에서 다음 쿼리로 확인:

```cypher
// 1. MyBatisMapper 노드의 namespace 확인
MATCH (m:MyBatisMapper {name: 'UserMapper'})
RETURN m.name, m.namespace

// 2. SqlStatement와 MyBatisMapper 연결 확인
MATCH (mapper:MyBatisMapper)-[:HAS_SQL]->(sql:SqlStatement {id: 'findUsersWithPaging'})
RETURN mapper.name, mapper.namespace, sql.id

// 3. 모든 MyBatisMapper의 namespace 확인
MATCH (m:MyBatisMapper)
RETURN m.name, m.namespace
ORDER BY m.name
```

**해결 방법**:

**방법 1: Java 재분석 (권장)**
```bash
# 전체 재분석
python -m csa.cli.main analyze --java-object --clean --project-name myproject
```

**방법 2: Neo4j에서 직접 namespace 업데이트**

MyBatisMapper XML 파일에서 namespace를 확인하고 직접 업데이트:

```cypher
// UserMapper.xml에서 namespace 확인 후 업데이트
// <mapper namespace="com.carcare.domain.user.mapper.UserMapper">
MATCH (m:MyBatisMapper {name: 'UserMapper'})
SET m.namespace = 'com.carcare.domain.user.mapper.UserMapper'
RETURN m.name, m.namespace
```

**방법 3: 모든 MyBatisMapper에 namespace 일괄 업데이트**

프로젝트의 패키지 구조를 알고 있는 경우:

```cypher
// 예: com.carcare.domain.{domain}.mapper.{MapperName}
MATCH (m:MyBatisMapper)
WHERE m.namespace IS NULL OR m.namespace = ''
// 실제 프로젝트에 맞게 수정 필요
SET m.namespace = 'com.carcare.domain.user.mapper.' + m.name
RETURN m.name, m.namespace
```

#### Table participant가 표시되지 않음

**로그 예시**:
```
DEBUG - SQL findUsersWithPaging - raw sql_tables type=str, value=[]
DEBUG - Tables referenced by SQL findUsersWithPaging: [{'name': '[]', 'schema': ''}]
DEBUG - Processing table_data: type=dict, value={'name': '[]', 'schema': ''}
```

**원인**:
1. SqlStatement.tables에 빈 리스트의 문자열 표현 (`"[]"`)이 저장됨 (가장 흔한 원인)
2. SqlStatement.tables가 None 또는 실제 빈 배열
3. SqlStatement.columns도 None 또는 빈 배열
4. SQL 파싱 시 테이블이 제대로 추출되지 않음

**진단 방법**:

Neo4j 브라우저에서 다음 쿼리로 확인:

```cypher
// 1. SqlStatement의 tables와 columns 확인
MATCH (sql:SqlStatement {id: 'findUsersWithPaging'})
RETURN sql.id, sql.tables, sql.columns, sql.sql_type

// 2. 모든 SqlStatement의 tables 확인
MATCH (sql:SqlStatement)
RETURN sql.id, sql.tables, sql.columns
LIMIT 10
```

**해결 방법**:

**문제 1: sql_tables가 `"[]"` 문자열인 경우**

이 문제는 코드로 이미 수정되었습니다 (`_sql_tables_or_empty` 함수). 다시 시퀀스 다이어그램을 생성하면 해결됩니다.

**문제 2: sql_tables가 실제로 비어 있는 경우**

Java 재분석이 필요합니다:

```bash
# 전체 재분석 (Java + DB)
python -m csa.cli.main analyze --all-objects --clean --project-name myproject
```

**문제 3: SQL 파싱 로직 문제**

특정 SQL 문만 테이블이 추출되지 않는 경우, SQL 파서를 디버깅해야 합니다:

```cypher
// 문제가 있는 SQL문 확인
MATCH (sql:SqlStatement {id: 'findUsersWithPaging'})
RETURN sql.sql_text
```

SQL 파서가 제대로 동작하지 않는 경우, 수동으로 업데이트:

```cypher
// 수동으로 tables 업데이트
MATCH (sql:SqlStatement {id: 'findUsersWithPaging'})
SET sql.tables = [
  {name: 'users', schema: 'public'},
  {name: 'roles', schema: 'public'}
]
RETURN sql.id, sql.tables
```

#### participant [] as [] 오류 (수정 완료)

**로그 예시**:
```
participant [] as []
SQL->>[]: 📦 []
```

**원인**:
- SqlStatement.tables에 빈 리스트의 문자열 표현 (`"[]"`)이 저장됨
- `_sql_tables_or_empty` 함수가 `"[]"` 문자열을 테이블 이름으로 파싱함
- 결과: `table_name = "[]"`

**해결 완료**:

이 문제는 `_sql_tables_or_empty` 함수를 수정하여 해결되었습니다:

```python
# 빈 리스트/None의 문자열 표현 제거
if stripped in ('[]', 'null', 'None', '""', "''"):
    return []
```

**재실행**:
```bash
# 시퀀스 다이어그램 재생성
python -m csa.cli.main sequence --class-name UserController --method-name getUserList
```

이를 통해 시퀀스 다이어그램이 실제 코드 동작을 더욱 정확하게 반영하고, 개발자가 코드의 의도를 쉽게 파악할 수 있게 되었습니다.
