# 클래스 명세서 생성 기능 구현 계획

**작성일**: 2025-10-20
**작성자**: Claude Code
**작업 유형**: 신규 기능 추가

---

## 1. 개요

Spring Boot 프로젝트의 Java 클래스를 분석하여 표준화된 클래스 명세서를 자동으로 생성하는 기능을 추가합니다.

### 목적
- Neo4j에 저장된 클래스 정보를 기반으로 표준 명세서 자동 생성
- 문서 작성 시간 단축 및 일관성 유지
- 한국 SI 프로젝트에서 요구되는 표준 문서 형식 준수

---

## 2. 클래스 명세서 템플릿 (한국 표준 포맷)

### 2.1 템플릿 구조

```markdown
# 클래스 명세서

## 1. 기본 정보

| 항목 | 내용 |
|------|------|
| **클래스명** | {class_name} |
| **논리명** | {logical_name} |
| **패키지** | {package_name} |
| **클래스 유형** | {type} (class/interface/enum) |
| **세부 유형** | {sub_type} (controller/service/repository 등) |
| **작성일자** | YYYY-MM-DD HH:MI:SS |
| **프로젝트명** | {project_name} |

## 2. 클래스 개요

### 2.1 설명
{description}

### 2.2 클래스 특성
- **상위 클래스**: {superclass}
- **구현 인터페이스**: {interfaces}
- **어노테이션**: {annotations}

### 2.3 Spring Bean 정보
- **Bean 이름**: {bean_name}
- **Bean 타입**: {bean_type}
- **Scope**: {scope}

### 2.4 REST Endpoint 정보 (Controller인 경우)
- **Base Path**: {base_path}
- **매핑 정보**: 하단 메서드 목록 참조

## 3. 속성(필드) 목록

| No | 속성명 | 논리명 | 타입 | 접근제어자 | 어노테이션 | 초기값 | 설명 |
|----|--------|--------|------|------------|------------|--------|------|
| 1 | {field_name} | {logical_name} | {type} | {modifiers} | {annotations} | {initial_value} | {description} |
| ... | ... | ... | ... | ... | ... | ... | ... |

## 4. 메서드 목록

### 4.1 Public 메서드

| No | 메서드명 | 논리명 | 반환타입 | 파라미터 | 어노테이션 | 설명 |
|----|----------|--------|----------|----------|------------|------|
| 1 | {method_name} | {logical_name} | {return_type} | {parameters} | {annotations} | {description} |
| ... | ... | ... | ... | ... | ... | ... |

#### 4.1.1 {method_name}
**개요**: {description}

**파라미터**:
| No | 파라미터명 | 논리명 | 타입 | 필수여부 | 설명 |
|----|------------|--------|------|----------|------|
| 1 | {param_name} | {logical_name} | {type} | Y/N | {description} |

**반환값**:
- **타입**: {return_type}
- **설명**: {return_description}

**예외**:
- {exception_type}: {exception_description}

**HTTP 매핑** (REST Endpoint인 경우):
- **Method**: {http_method}
- **Path**: {path}
- **Request Body**: {request_body_type}
- **Response**: {response_type}

### 4.2 Protected/Private 메서드

| No | 메서드명 | 논리명 | 반환타입 | 파라미터 | 접근제어자 | 설명 |
|----|----------|--------|----------|----------|------------|------|
| ... | ... | ... | ... | ... | ... | ... |

## 5. 의존성 정보

### 5.1 주입받는 의존성 (Injected Dependencies)
| No | Bean 이름 | 타입 | 주입 방식 | 설명 |
|----|-----------|------|-----------|------|
| 1 | {bean_name} | {type} | Constructor/Field/Setter | {description} |

### 5.2 호출하는 메서드 (Method Calls)
| No | 대상 클래스 | 메서드명 | 호출 위치 | 설명 |
|----|-------------|----------|-----------|------|
| 1 | {target_class} | {method_name} | {calling_method} | {description} |

## 6. 데이터베이스 연관 정보

### 6.1 사용 테이블
| No | 테이블명 | 스키마 | CRUD 작업 | 설명 |
|----|----------|--------|-----------|------|
| 1 | {table_name} | {schema} | C/R/U/D | {description} |

### 6.2 실행 SQL 목록
| No | SQL ID | SQL 유형 | 테이블 | 복잡도 | 설명 |
|----|--------|----------|--------|--------|------|
| 1 | {sql_id} | SELECT/INSERT/UPDATE/DELETE | {tables} | {complexity} | {description} |

## 7. 관계도

### 7.1 클래스 다이어그램
```
[클래스 관계 다이어그램 - PlantUML 또는 Mermaid]
```

### 7.2 시퀀스 다이어그램 참조
- 상세한 메서드 호출 흐름은 시퀀스 다이어그램 참조
- 파일 위치: `output/sequence-diagram/{project_name}/{package_path}/`

## 8. 비고

### 8.1 특이사항
{특이사항}

### 8.2 주의사항
{주의사항}

### 8.3 변경 이력
| 일자 | 변경자 | 변경 내용 |
|------|--------|-----------|
| YYYY-MM-DD | {author} | 최초 작성 |

---
**문서 생성 정보**
- 생성 도구: CSA (Code Static Analyzer)
- 생성 일시: {generated_at}
- 데이터 출처: Neo4j Database (Project: {project_name})
```

### 2.2 템플릿 특징

1. **한국 SI 표준 준수**
   - 기본 정보, 개요, 속성, 메서드, 의존성, 비고 섹션 포함
   - 표 형식의 구조화된 정보 표현
   - 번호 체계 및 계층 구조 명확화

2. **Neo4j 데이터 활용**
   - Class, Method, Field, Annotation 정보
   - Bean 및 Endpoint 정보
   - 의존성 및 호출 관계 정보
   - CRUD 매트릭스 정보

3. **확장 가능성**
   - 시퀀스 다이어그램 연계
   - 클래스 다이어그램 포함 가능
   - 커스터마이징 여지 제공

---

## 3. CLI 명령어 설계

### 3.1 명령어 구조

```bash
python -m csa.cli.main class-spec \
  --project-name car-center-devlab \
  --class-name UserController \
  [--output-dir ./output/class-spec] \
  [--include-diagram] \
  [--include-crud-info]
```

### 3.2 옵션 설명

| 옵션 | 필수 | 기본값 | 설명 |
|------|------|--------|------|
| `--project-name` | Y | - | Neo4j에서 조회할 프로젝트명 |
| `--class-name` | Y | - | 명세서를 생성할 클래스명 (단순 클래스명 또는 FQCN) |
| `--output-dir` | N | env: CLASS_SPEC_OUTPUT_DIR | 출력 디렉토리 경로 |
| `--include-diagram` | N | False | 클래스 다이어그램 포함 여부 |
| `--include-crud-info` | N | True | CRUD 정보 포함 여부 |

### 3.3 환경 변수

**.env 파일에 추가**:
```bash
# Class Specification Output Directory
CLASS_SPEC_OUTPUT_DIR=./output/class-spec
```

---

## 4. 파일 저장 구조

### 4.1 폴더 구조

시퀀스 다이어그램과 동일한 패턴 사용:

```
{CLASS_SPEC_OUTPUT_DIR}/
└── {project_name}/
    └── {package_path}/          # package name을 디렉토리 경로로 변환
        └── CLASS_SPEC_{class_name}_{timestamp}.md
```

**예시**:
```
output/class-spec/
└── car-center-devlab/
    └── com/carcare/domain/user/controller/
        └── CLASS_SPEC_UserController_20251020-143022.md
```

### 4.2 파일명 패턴

```
CLASS_SPEC_{class_name}_{timestamp}.md
```

- `{class_name}`: 클래스 단순명 (예: UserController)
- `{timestamp}`: YYYYMMDD-HH24MiSS 형식 (예: 20251020-143022)

### 4.3 패키지 경로 변환

- 패키지명: `com.carcare.domain.user.controller`
- 디렉토리 경로: `com/carcare/domain/user/controller/`
- 변환 로직: `package_name.replace('.', os.sep)`

---

## 5. 구현 계획

### 5.1 파일 구조

```
csa/
├── cli/
│   └── commands/
│       └── class_spec.py          # 신규 생성
│
├── services/
│   └── class_spec/                # 신규 생성
│       ├── __init__.py
│       ├── generator.py           # 명세서 생성 오케스트레이터
│       ├── template.py            # 템플릿 렌더링
│       └── repository.py          # Neo4j 쿼리
│
└── models/
    └── class_spec.py              # 신규 생성 (명세서 데이터 모델)
```

### 5.2 주요 컴포넌트

#### 5.2.1 CLI Command (`csa/cli/commands/class_spec.py`)
```python
@click.command(name="class-spec")
@click.option("--project-name", required=True)
@click.option("--class-name", required=True)
@click.option("--output-dir", default=os.getenv("CLASS_SPEC_OUTPUT_DIR", "./output/class-spec"))
@click.option("--include-diagram", is_flag=True, default=False)
@click.option("--include-crud-info", is_flag=True, default=True)
@with_command_lifecycle("class-spec")
def class_spec_command(...):
    """Generate class specification document."""
    # 1. Neo4j 연결
    # 2. ClassSpecGenerator 초기화
    # 3. 명세서 생성
    # 4. 파일 저장
    # 5. 결과 출력
```

#### 5.2.2 Generator (`csa/services/class_spec/generator.py`)
```python
class ClassSpecGenerator:
    def __init__(self, driver, database):
        self.repository = ClassSpecRepository(driver, database)
        self.template = ClassSpecTemplate()

    def generate_spec(self, project_name, class_name, options):
        # 1. 클래스 정보 조회
        class_info = self.repository.get_class_info(project_name, class_name)

        # 2. 메서드 정보 조회
        methods = self.repository.get_methods(project_name, class_name)

        # 3. 필드 정보 조회
        fields = self.repository.get_fields(project_name, class_name)

        # 4. 의존성 정보 조회
        dependencies = self.repository.get_dependencies(project_name, class_name)

        # 5. CRUD 정보 조회 (옵션)
        crud_info = self.repository.get_crud_info(project_name, class_name) if options.include_crud_info else None

        # 6. 템플릿 렌더링
        spec_content = self.template.render(class_info, methods, fields, dependencies, crud_info)

        # 7. 파일 저장
        file_path = self._save_spec(spec_content, class_info, options.output_dir)

        return file_path
```

#### 5.2.3 Repository (`csa/services/class_spec/repository.py`)
```python
class ClassSpecRepository:
    def get_class_info(self, project_name, class_name):
        """클래스 기본 정보 조회"""
        query = """
        MATCH (c:Class {name: $class_name, project_name: $project_name})
        OPTIONAL MATCH (c)<-[:PROVIDES]-(b:Bean)
        OPTIONAL MATCH (c)<-[:EXPOSES]-(e:Endpoint)
        RETURN c, b, e
        """

    def get_methods(self, project_name, class_name):
        """메서드 목록 조회"""
        query = """
        MATCH (c:Class {name: $class_name, project_name: $project_name})
        MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS]->(sql:SqlStatement)
        OPTIONAL MATCH (m)<-[:EXPOSES]-(e:Endpoint)
        RETURN m, collect(sql) as sqls, e
        ORDER BY m.name
        """

    def get_fields(self, project_name, class_name):
        """필드 목록 조회"""
        query = """
        MATCH (c:Class {name: $class_name, project_name: $project_name})
        MATCH (c)-[:HAS_FIELD]->(f:Field)
        RETURN f
        ORDER BY f.name
        """

    def get_dependencies(self, project_name, class_name):
        """의존성 정보 조회"""
        query = """
        MATCH (c:Class {name: $class_name, project_name: $project_name})
        MATCH (c)-[:INJECTS]->(dep:Bean)
        RETURN dep
        """

    def get_crud_info(self, project_name, class_name):
        """CRUD 정보 조회"""
        query = """
        MATCH (c:Class {name: $class_name, project_name: $project_name})
        MATCH (c)-[:HAS_METHOD]->(m:Method)
        MATCH (m)-[:CALLS]->(sql:SqlStatement)
        WHERE sql.tables IS NOT NULL
        RETURN sql.tables as tables, sql.sql_type as operation
        """
```

#### 5.2.4 Template (`csa/services/class_spec/template.py`)
```python
class ClassSpecTemplate:
    def render(self, class_info, methods, fields, dependencies, crud_info):
        """템플릿에 데이터를 적용하여 마크다운 생성"""
        # Jinja2 템플릿 또는 문자열 포맷팅 사용
        # 2.1의 템플릿 구조 적용
        return markdown_content
```

### 5.3 Neo4j 쿼리 설계

#### 5.3.1 클래스 기본 정보 조회
```cypher
MATCH (c:Class {name: $class_name, project_name: $project_name})
OPTIONAL MATCH (c)<-[:PROVIDES]-(b:Bean)
OPTIONAL MATCH (c)<-[:EXPOSES]-(e:Endpoint)
RETURN c.name as class_name,
       c.logical_name as logical_name,
       c.package_name as package_name,
       c.type as type,
       c.sub_type as sub_type,
       c.description as description,
       c.superclass as superclass,
       c.interfaces as interfaces,
       c.annotations as annotations,
       b.bean_name as bean_name,
       b.bean_type as bean_type,
       e.path as base_path
```

#### 5.3.2 메서드 목록 조회
```cypher
MATCH (c:Class {name: $class_name, project_name: $project_name})
MATCH (c)-[:HAS_METHOD]->(m:Method)
OPTIONAL MATCH (m)-[:CALLS]->(sql:SqlStatement)
OPTIONAL MATCH (m)<-[:EXPOSES]-(e:Endpoint)
RETURN m.name as method_name,
       m.logical_name as logical_name,
       m.return_type as return_type,
       m.parameters as parameters,
       m.modifiers as modifiers,
       m.annotations as annotations,
       m.description as description,
       collect(DISTINCT sql) as sql_statements,
       e.path as endpoint_path,
       e.http_method as http_method
ORDER BY
  CASE WHEN 'public' IN m.modifiers THEN 1
       WHEN 'protected' IN m.modifiers THEN 2
       WHEN 'private' IN m.modifiers THEN 3
       ELSE 4 END,
  m.name
```

#### 5.3.3 필드 목록 조회
```cypher
MATCH (c:Class {name: $class_name, project_name: $project_name})
MATCH (c)-[:HAS_FIELD]->(f:Field)
RETURN f.name as field_name,
       f.logical_name as logical_name,
       f.type as type,
       f.modifiers as modifiers,
       f.annotations as annotations,
       f.initial_value as initial_value,
       f.description as description
ORDER BY f.name
```

#### 5.3.4 의존성 조회
```cypher
MATCH (c:Class {name: $class_name, project_name: $project_name})
MATCH (c)-[r:INJECTS]->(dep:Class)
OPTIONAL MATCH (dep)<-[:PROVIDES]-(b:Bean)
RETURN dep.name as dependency_class,
       b.bean_name as bean_name,
       b.bean_type as bean_type,
       r.injection_type as injection_type,
       r.field_name as field_name
```

#### 5.3.5 CRUD 정보 조회
```cypher
MATCH (c:Class {name: $class_name, project_name: $project_name})
MATCH (c)-[:HAS_METHOD]->(m:Method)
MATCH (m)-[:CALLS]->(sql:SqlStatement)
WHERE sql.tables IS NOT NULL AND sql.tables <> '[]'
RETURN DISTINCT
       sql.tables as tables_json,
       sql.sql_type as operation,
       sql.id as sql_id,
       sql.complexity_score as complexity
```

---

## 6. 구현 순서

### Phase 1: 기본 구조 구현 (1일차)
1. ✅ 파일/폴더 구조 생성
2. ✅ CLI 명령어 스켈레톤 구현
3. ✅ Repository 클래스 구현 (Neo4j 쿼리)
4. ✅ 기본 데이터 모델 정의

### Phase 2: 템플릿 구현 (2일차)
1. ✅ 템플릿 클래스 구현
2. ✅ Markdown 렌더링 로직
3. ✅ 섹션별 데이터 매핑
4. ✅ 파일 저장 로직

### Phase 3: Generator 구현 (3일차)
1. ✅ ClassSpecGenerator 구현
2. ✅ 데이터 수집 및 통합
3. ✅ 폴더 구조 생성 (패키지 경로 변환)
4. ✅ 타임스탬프 파일명 생성

### Phase 4: 테스트 및 검증 (4일차)
1. ✅ 단위 테스트 작성
2. ✅ 통합 테스트 (실제 프로젝트 데이터)
3. ✅ 출력 문서 품질 검증
4. ✅ 버그 수정 및 개선

### Phase 5: 문서화 및 배포 (5일차)
1. ✅ 사용자 가이드 작성
2. ✅ README 업데이트
3. ✅ CLAUDE.md 업데이트
4. ✅ 배포 및 공유

---

## 7. 테스트 시나리오

### 7.1 기본 테스트
```bash
# 단순 Controller 클래스
python -m csa.cli.main class-spec \
  --project-name car-center-devlab \
  --class-name UserController

# Service 클래스
python -m csa.cli.main class-spec \
  --project-name car-center-devlab \
  --class-name UserService

# Repository 클래스
python -m csa.cli.main class-spec \
  --project-name car-center-devlab \
  --class-name UserRepository
```

### 7.2 옵션 테스트
```bash
# 다이어그램 포함
python -m csa.cli.main class-spec \
  --project-name car-center-devlab \
  --class-name UserController \
  --include-diagram

# CRUD 정보 제외
python -m csa.cli.main class-spec \
  --project-name car-center-devlab \
  --class-name UserService \
  --no-include-crud-info
```

### 7.3 검증 항목
- [ ] 파일이 올바른 경로에 생성되는가?
- [ ] 패키지 경로가 올바르게 변환되는가?
- [ ] 파일명 패턴이 올바른가?
- [ ] 모든 섹션이 정상적으로 렌더링되는가?
- [ ] Neo4j 데이터가 정확하게 매핑되는가?
- [ ] 테이블 형식이 올바르게 표시되는가?
- [ ] 누락된 데이터가 있을 때 오류 없이 처리되는가?

---

## 8. 예상 결과물

### 8.1 생성 파일 예시
```
output/class-spec/car-center-devlab/com/carcare/domain/user/controller/CLASS_SPEC_UserController_20251020-143022.md
```

### 8.2 콘솔 출력 예시
```
Generating class specification for: UserController
Project: car-center-devlab
Package: com.carcare.domain.user.controller

✓ Class information retrieved
✓ Methods retrieved: 12
✓ Fields retrieved: 3
✓ Dependencies retrieved: 2
✓ CRUD information retrieved

Specification saved to:
  output/class-spec/car-center-devlab/com/carcare/domain/user/controller/CLASS_SPEC_UserController_20251020-143022.md

Summary:
  - Class Type: controller
  - Public Methods: 8
  - Private Methods: 4
  - Fields: 3
  - Dependencies: 2
  - Tables Used: 1 (users)
```

---

## 9. 향후 개선 계획

### 9.1 단기 개선 (1-2주)
- [ ] PDF 출력 지원
- [ ] Excel 형식 지원
- [ ] 클래스 다이어그램 자동 생성
- [ ] 배치 생성 (여러 클래스 동시 생성)

### 9.2 중기 개선 (1-2개월)
- [ ] 템플릿 커스터마이징 기능
- [ ] 다국어 지원 (영문 명세서)
- [ ] AI 기반 설명 자동 생성
- [ ] 변경 이력 추적

### 9.3 장기 개선 (3개월 이상)
- [ ] 웹 UI 제공
- [ ] 협업 기능 (리뷰, 승인)
- [ ] 버전 관리 통합
- [ ] 문서 품질 점검 자동화

---

## 10. 참고 사항

### 10.1 참조 파일
- `csa/cli/commands/sequence.py` - 폴더 구조 참조
- `csa/diagrams/sequence/mermaid.py` - 파일 저장 로직 참조
- `csa/services/graph_db/analytics.py` - Neo4j 쿼리 참조
- `csa/cli/commands/crud.py` - 템플릿 렌더링 참조

### 10.2 관련 문서
- `CLAUDE.md` - 프로젝트 전체 구조
- `docs/CRUD-Martix_수정_Claude(20251020).md` - 최근 개선 사례

### 10.3 주의사항
- 시퀀스 다이어그램과 동일한 폴더 구조 패턴 사용
- 파일명에 특수문자 사용 금지 (클래스명에 포함될 수 있음)
- 대용량 클래스(메서드 100개 이상) 처리 고려
- Neo4j 쿼리 성능 최적화 필요

---

## 11. 결론

클래스 명세서 생성 기능은 CSA의 핵심 기능을 확장하여 문서 자동화를 구현하는 중요한 기능입니다.

**기대 효과**:
- 📝 문서 작성 시간 80% 이상 단축
- 📊 일관된 품질의 표준 문서 생성
- 🔄 코드 변경 시 자동 업데이트 가능
- 🎯 한국 SI 프로젝트 표준 준수

**성공 기준**:
- ✅ 모든 클래스 타입(Controller, Service, Repository 등)에 대해 명세서 생성 가능
- ✅ 생성된 문서가 한국 표준 포맷 준수
- ✅ Neo4j 데이터의 95% 이상 정확한 매핑
- ✅ 사용자 피드백 긍정적 (만족도 4/5 이상)

---

**검토 요청**:
이 계획을 검토하신 후, 구현을 진행하겠습니다.
수정 또는 추가 요구사항이 있으시면 말씀해주세요.
