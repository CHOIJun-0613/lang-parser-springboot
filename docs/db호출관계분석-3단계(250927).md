# Ïñ¥ÌîåÎ¶¨ÏºÄÏù¥ÏÖò-Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ìò∏Ï∂úÍ¥ÄÍ≥Ñ ÏãúÍ∞ÅÌôî Íµ¨ÌòÑ
_Exported on 9/27/2025 at 17:41:33 GMT+9 from Cursor (1.6.45)_

---

**User**

**3Îã®Í≥Ñ: Ïñ¥ÌîåÎ¶¨ÏºÄÏù¥ÏÖò-Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ìò∏Ï∂úÍ¥ÄÍ≥Ñ ÏãúÍ∞ÅÌôî Í∏∞Îä• Íµ¨ÌòÑ** ÏßÑÌñâÌï¥Ï§ò
===================
SQL -> Table/Column Ìò∏Ï∂úÍ¥ÄÍ≥ÑÎ•º ÌëúÏãúÌï† Îïå Table ÎÖ∏ÎìúÎÇò ColumnÎÖ∏ÎìúÍ∞Ä Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Í≤ΩÏö∞Îäî ÏãùÎ≥ÑÏù¥ ÏâΩÍ≤å Îê†Ïàò ÏûàÎèÑÎ°ù(Ïòà; Ï†ÅÏÉâ Ï†êÏÑ†ÎùºÏù∏ÏúºÎ°ú ÌëúÏãú) Ìï¥Ï§ÑÍ≤É

---

**Cursor**

ÌòÑÏû¨ Ïó¥Î†§ÏûàÎäî Î¨∏ÏÑúÎ•º Î®ºÏ†Ä ÌôïÏù∏ÌïòÏó¨ 3Îã®Í≥Ñ Íµ¨ÌòÑ ÎÇ¥Ïö©ÏùÑ ÌååÏïÖÌïòÍ≤†ÏäµÎãàÎã§.


Ïù¥Ï†ú 3Îã®Í≥Ñ Íµ¨ÌòÑÏùÑ ÏúÑÌïú ÌòÑÏû¨ ÏΩîÎìú Íµ¨Ï°∞Î•º ÌååÏïÖÌïòÍ≥† ÏûëÏóÖÏùÑ ÏãúÏûëÌïòÍ≤†ÏäµÎãàÎã§. Î®ºÏ†Ä ÌòÑÏû¨ Íµ¨ÌòÑÎêú ÏÑúÎπÑÏä§Îì§ÏùÑ ÌôïÏù∏Ìï¥Î≥¥Í≤†ÏäµÎãàÎã§.


ÌòÑÏû¨ ÏΩîÎìúÎ•º Î∂ÑÏÑùÌïú Í≤∞Í≥º, Ïù¥ÎØ∏ ÏÉÅÎãπÌïú Í∏∞Îä•Ïù¥ Íµ¨ÌòÑÎêòÏñ¥ ÏûàÏäµÎãàÎã§. Ïù¥Ï†ú 3Îã®Í≥Ñ Íµ¨ÌòÑÏùÑ ÏúÑÌï¥ DB Ìò∏Ï∂úÍ¥ÄÍ≥Ñ Î∂ÑÏÑù ÏÑúÎπÑÏä§Î•º ÏÉàÎ°ú ÎßåÎì§Ïñ¥Î≥¥Í≤†ÏäµÎãàÎã§.


```python
"""
Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ìò∏Ï∂úÍ¥ÄÍ≥Ñ Î∂ÑÏÑù ÏÑúÎπÑÏä§

Ïù¥ Î™®ÎìàÏùÄ Ïñ¥ÌîåÎ¶¨ÏºÄÏù¥ÏÖòÍ≥º Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í∞ÑÏùò Ìò∏Ï∂úÍ¥ÄÍ≥ÑÎ•º Î∂ÑÏÑùÌïòÍ≥† ÏãúÍ∞ÅÌôîÌïòÎäî Í∏∞Îä•ÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§.
- Controller ‚Üí Service ‚Üí Repository ‚Üí SQL ‚Üí Table/Column Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù
- CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
- Ìò∏Ï∂ú Í¥ÄÍ≥Ñ Í∑∏ÎûòÌîÑ ÏÉùÏÑ± (Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû®)
- Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Table/Column ÎÖ∏Îìú ÏãùÎ≥Ñ Î∞è ÏãúÍ∞ÅÌôî
- ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù
"""

import json
from typing import List, Dict, Any, Optional, Set, Tuple
from neo4j import Driver
from src.utils.logger import get_logger


class DBCallAnalysisService:
    """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ìò∏Ï∂úÍ¥ÄÍ≥Ñ Î∂ÑÏÑù ÏÑúÎπÑÏä§"""
    
    def __init__(self, driver: Driver):
        """Neo4j ÎìúÎùºÏù¥Î≤ÑÎ°ú Ï¥àÍ∏∞Ìôî"""
        self.driver = driver
        self.logger = get_logger(__name__)
    
    def analyze_call_chain(self, project_name: str, start_class: str = None, start_method: str = None) -> Dict[str, Any]:
        """
        Controller ‚Üí Service ‚Üí Repository ‚Üí SQL ‚Üí Table/Column Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Î∂ÑÏÑùÌï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            start_class: ÏãúÏûë ÌÅ¥ÎûòÏä§ (ÏÑ†ÌÉùÏÇ¨Ìï≠)
            start_method: ÏãúÏûë Î©îÏÑúÎìú (ÏÑ†ÌÉùÏÇ¨Ìï≠)
            
        Returns:
            Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù Í≤∞Í≥º
        """
        try:
            with self.driver.session() as session:
                if start_class and start_method:
                    # ÌäπÏ†ï Î©îÏÑúÎìúÎ∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî Ìò∏Ï∂ú Ï≤¥Ïù∏
                    call_chain = self._get_method_call_chain(session, project_name, start_class, start_method)
                elif start_class:
                    # ÌäπÏ†ï ÌÅ¥ÎûòÏä§Î∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî Ìò∏Ï∂ú Ï≤¥Ïù∏
                    call_chain = self._get_class_call_chain(session, project_name, start_class)
                else:
                    # Ï†ÑÏ≤¥ ÌîÑÎ°úÏ†ùÌä∏Ïùò Ìò∏Ï∂ú Ï≤¥Ïù∏
                    call_chain = self._get_project_call_chain(session, project_name)
                
                # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Table/Column ÎÖ∏Îìú ÏãùÎ≥Ñ
                missing_nodes = self._identify_missing_nodes(session, project_name, call_chain)
                
                return {
                    'project_name': project_name,
                    'call_chain': call_chain,
                    'missing_nodes': missing_nodes,
                    'analysis_summary': self._generate_analysis_summary(call_chain, missing_nodes)
                }
                
        except Exception as e:
            self.logger.error(f"Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù Ïò§Î•ò: {str(e)}")
            return {'error': str(e)}
    
    def _get_method_call_chain(self, session, project_name: str, class_name: str, method_name: str) -> List[Dict[str, Any]]:
        """ÌäπÏ†ï Î©îÏÑúÎìúÎ∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Î∂ÑÏÑùÌï©ÎãàÎã§."""
        query = """
        MATCH (c:Class {name: $class_name, project_name: $project_name})-[:HAS_METHOD]->(m:Method {name: $method_name})
        OPTIONAL MATCH (m)-[:CALLS*0..5]->(target_method:Method)
        OPTIONAL MATCH (target_method)<-[:HAS_METHOD]-(target_class:Class)
        OPTIONAL MATCH (target_method)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_TABLE]->(table:Table {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_COLUMN]->(column:Column {project_name: $project_name})
        RETURN m.name as source_method,
               c.name as source_class,
               c.package_name as source_package,
               target_method.name as target_method,
               target_class.name as target_class,
               target_class.package_name as target_package,
               sql.id as sql_id,
               sql.sql_type as sql_type,
               sql.tables as sql_tables,
               sql.columns as sql_columns,
               table.name as table_name,
               column.name as column_name,
               column.table_name as column_table_name
        ORDER BY source_method, target_class.name, target_method.name
        """
        
        result = session.run(query, 
                           class_name=class_name, 
                           method_name=method_name, 
                           project_name=project_name)
        
        call_chain = []
        for record in result:
            call_chain.append({
                'source_method': record['source_method'],
                'source_class': record['source_class'],
                'source_package': record['source_package'] or 'default',
                'target_method': record['target_method'],
                'target_class': record['target_class'],
                'target_package': record['target_package'] or 'default',
                'sql_id': record['sql_id'],
                'sql_type': record['sql_type'],
                'sql_tables': json.loads(record['sql_tables']) if record['sql_tables'] else [],
                'sql_columns': json.loads(record['sql_columns']) if record['sql_columns'] else [],
                'table_name': record['table_name'],
                'column_name': record['column_name'],
                'column_table_name': record['column_table_name']
            })
        
        return call_chain
    
    def _get_class_call_chain(self, session, project_name: str, class_name: str) -> List[Dict[str, Any]]:
        """ÌäπÏ†ï ÌÅ¥ÎûòÏä§Î∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Î∂ÑÏÑùÌï©ÎãàÎã§."""
        query = """
        MATCH (c:Class {name: $class_name, project_name: $project_name})-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS*0..5]->(target_method:Method)
        OPTIONAL MATCH (target_method)<-[:HAS_METHOD]-(target_class:Class)
        OPTIONAL MATCH (target_method)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_TABLE]->(table:Table {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_COLUMN]->(column:Column {project_name: $project_name})
        RETURN m.name as source_method,
               c.name as source_class,
               c.package_name as source_package,
               target_method.name as target_method,
               target_class.name as target_class,
               target_class.package_name as target_package,
               sql.id as sql_id,
               sql.sql_type as sql_type,
               sql.tables as sql_tables,
               sql.columns as sql_columns,
               table.name as table_name,
               column.name as column_name,
               column.table_name as column_table_name
        ORDER BY source_method, target_class.name, target_method.name
        """
        
        result = session.run(query, 
                           class_name=class_name, 
                           project_name=project_name)
        
        call_chain = []
        for record in result:
            call_chain.append({
                'source_method': record['source_method'],
                'source_class': record['source_class'],
                'source_package': record['source_package'] or 'default',
                'target_method': record['target_method'],
                'target_class': record['target_class'],
                'target_package': record['target_package'] or 'default',
                'sql_id': record['sql_id'],
                'sql_type': record['sql_type'],
                'sql_tables': json.loads(record['sql_tables']) if record['sql_tables'] else [],
                'sql_columns': json.loads(record['sql_columns']) if record['sql_columns'] else [],
                'table_name': record['table_name'],
                'column_name': record['column_name'],
                'column_table_name': record['column_table_name']
            })
        
        return call_chain
    
    def _get_project_call_chain(self, session, project_name: str) -> List[Dict[str, Any]]:
        """Ï†ÑÏ≤¥ ÌîÑÎ°úÏ†ùÌä∏Ïùò Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Î∂ÑÏÑùÌï©ÎãàÎã§."""
        query = """
        MATCH (c:Class {project_name: $project_name})-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS*0..5]->(target_method:Method)
        OPTIONAL MATCH (target_method)<-[:HAS_METHOD]-(target_class:Class)
        OPTIONAL MATCH (target_method)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_TABLE]->(table:Table {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_COLUMN]->(column:Column {project_name: $project_name})
        RETURN m.name as source_method,
               c.name as source_class,
               c.package_name as source_package,
               target_method.name as target_method,
               target_class.name as target_class,
               target_class.package_name as target_package,
               sql.id as sql_id,
               sql.sql_type as sql_type,
               sql.tables as sql_tables,
               sql.columns as sql_columns,
               table.name as table_name,
               column.name as column_name,
               column.table_name as column_table_name
        ORDER BY source_class, source_method, target_class.name, target_method.name
        """
        
        result = session.run(query, project_name=project_name)
        
        call_chain = []
        for record in result:
            call_chain.append({
                'source_method': record['source_method'],
                'source_class': record['source_class'],
                'source_package': record['source_package'] or 'default',
                'target_method': record['target_method'],
                'target_class': record['target_class'],
                'target_package': record['target_package'] or 'default',
                'sql_id': record['sql_id'],
                'sql_type': record['sql_type'],
                'sql_tables': json.loads(record['sql_tables']) if record['sql_tables'] else [],
                'sql_columns': json.loads(record['sql_columns']) if record['sql_columns'] else [],
                'table_name': record['table_name'],
                'column_name': record['column_name'],
                'column_table_name': record['column_table_name']
            })
        
        return call_chain
    
    def _identify_missing_nodes(self, session, project_name: str, call_chain: List[Dict[str, Any]]) -> Dict[str, List[str]]:
        """Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Table/Column ÎÖ∏ÎìúÎ•º ÏãùÎ≥ÑÌï©ÎãàÎã§."""
        missing_tables = set()
        missing_columns = set()
        
        # SQLÏóêÏÑú Ï∞∏Ï°∞ÌïòÎäî ÌÖåÏù¥Î∏îÍ≥º Ïª¨Îüº ÏàòÏßë
        referenced_tables = set()
        referenced_columns = set()
        
        for call in call_chain:
            # SQL ÌÖåÏù¥Î∏î Ï†ïÎ≥¥ ÏàòÏßë
            if call.get('sql_tables'):
                for table_info in call['sql_tables']:
                    if isinstance(table_info, dict) and 'name' in table_info:
                        referenced_tables.add(table_info['name'])
            
            # SQL Ïª¨Îüº Ï†ïÎ≥¥ ÏàòÏßë
            if call.get('sql_columns'):
                for column_info in call['sql_columns']:
                    if isinstance(column_info, dict) and 'name' in column_info:
                        referenced_columns.add(column_info['name'])
                        if 'table' in column_info and column_info['table']:
                            referenced_tables.add(column_info['table'])
        
        # Ïã§Ï†ú Ï°¥Ïû¨ÌïòÎäî ÌÖåÏù¥Î∏îÍ≥º Ïª¨Îüº Ï°∞Ìöå
        existing_tables = self._get_existing_tables(session, project_name)
        existing_columns = self._get_existing_columns(session, project_name)
        
        # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî ÌÖåÏù¥Î∏î ÏãùÎ≥Ñ
        for table_name in referenced_tables:
            if table_name not in existing_tables:
                missing_tables.add(table_name)
        
        # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Ïª¨Îüº ÏãùÎ≥Ñ
        for column_name in referenced_columns:
            if column_name not in existing_columns:
                missing_columns.add(column_name)
        
        return {
            'missing_tables': list(missing_tables),
            'missing_columns': list(missing_columns)
        }
    
    def _get_existing_tables(self, session, project_name: str) -> Set[str]:
        """Ïã§Ï†ú Ï°¥Ïû¨ÌïòÎäî ÌÖåÏù¥Î∏î Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§."""
        query = """
        MATCH (t:Table {project_name: $project_name})
        RETURN t.name as table_name
        """
        
        result = session.run(query, project_name=project_name)
        return {record['table_name'] for record in result}
    
    def _get_existing_columns(self, session, project_name: str) -> Set[str]:
        """Ïã§Ï†ú Ï°¥Ïû¨ÌïòÎäî Ïª¨Îüº Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§."""
        query = """
        MATCH (c:Column {project_name: $project_name})
        RETURN c.name as column_name
        """
        
        result = session.run(query, project_name=project_name)
        return {record['column_name'] for record in result}
    
    def _generate_analysis_summary(self, call_chain: List[Dict[str, Any]], missing_nodes: Dict[str, List[str]]) -> Dict[str, Any]:
        """Î∂ÑÏÑù Í≤∞Í≥º ÏöîÏïΩÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§."""
        # ÌÅ¥ÎûòÏä§Î≥Ñ ÌÜµÍ≥Ñ
        class_stats = {}
        for call in call_chain:
            source_class = call['source_class']
            if source_class not in class_stats:
                class_stats[source_class] = {
                    'method_count': 0,
                    'sql_count': 0,
                    'table_count': 0,
                    'column_count': 0
                }
            
            if call['source_method']:
                class_stats[source_class]['method_count'] += 1
            if call['sql_id']:
                class_stats[source_class]['sql_count'] += 1
            if call['table_name']:
                class_stats[source_class]['table_count'] += 1
            if call['column_name']:
                class_stats[source_class]['column_count'] += 1
        
        return {
            'total_calls': len(call_chain),
            'unique_classes': len(class_stats),
            'unique_methods': len(set(call['source_method'] for call in call_chain if call['source_method'])),
            'unique_sql_statements': len(set(call['sql_id'] for call in call_chain if call['sql_id'])),
            'unique_tables': len(set(call['table_name'] for call in call_chain if call['table_name'])),
            'unique_columns': len(set(call['column_name'] for call in call_chain if call['column_name'])),
            'missing_tables_count': len(missing_nodes['missing_tables']),
            'missing_columns_count': len(missing_nodes['missing_columns']),
            'class_stats': class_stats
        }
    
    def generate_crud_matrix(self, project_name: str) -> Dict[str, Any]:
        """
        CRUD Îß§Ìä∏Î¶≠Ïä§Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            
        Returns:
            CRUD Îß§Ìä∏Î¶≠Ïä§ Îç∞Ïù¥ÌÑ∞
        """
        try:
            with self.driver.session() as session:
                # ÌÅ¥ÎûòÏä§Î≥Ñ CRUD Îß§Ìä∏Î¶≠Ïä§
                class_crud_query = """
                MATCH (c:Class {project_name: $project_name})-[:HAS_METHOD]->(m:Method)
                OPTIONAL MATCH (m)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
                WITH c, m, sql,
                     CASE 
                       WHEN sql.sql_type = 'SELECT' THEN 'R'
                       WHEN sql.sql_type = 'INSERT' THEN 'C'
                       WHEN sql.sql_type = 'UPDATE' THEN 'U'
                       WHEN sql.sql_type = 'DELETE' THEN 'D'
                       ELSE 'O'
                     END as crud_operation
                RETURN c.name as class_name,
                       c.package_name as package_name,
                       collect(DISTINCT sql.mapper_name) as tables,
                       collect(DISTINCT crud_operation) as operations,
                       collect(DISTINCT sql.id) as sql_statements
                ORDER BY c.name
                """
                
                result = session.run(class_crud_query, project_name=project_name)
                class_matrix = [record.data() for record in result]
                
                # ÌÖåÏù¥Î∏îÎ≥Ñ CRUD Îß§Ìä∏Î¶≠Ïä§
                table_crud_query = """
                MATCH (sql:SqlStatement {project_name: $project_name})
                WHERE sql.tables IS NOT NULL
                UNWIND sql.tables as table_info
                WITH table_info.name as table_name, sql.sql_type as operation, count(sql) as count
                RETURN table_name,
                       collect({operation: operation, count: count}) as operations
                ORDER BY table_name
                """
                
                result = session.run(table_crud_query, project_name=project_name)
                table_matrix = [record.data() for record in result]
                
                return {
                    'project_name': project_name,
                    'class_matrix': class_matrix,
                    'table_matrix': table_matrix,
                    'summary': self._generate_crud_summary(class_matrix, table_matrix)
                }
                
        except Exception as e:
            self.logger.error(f"CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ± Ïò§Î•ò: {str(e)}")
            return {'error': str(e)}
    
    def _generate_crud_summary(self, class_matrix: List[Dict], table_matrix: List[Dict]) -> Dict[str, Any]:
        """CRUD Îß§Ìä∏Î¶≠Ïä§ ÏöîÏïΩÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§."""
        total_classes = len(class_matrix)
        total_tables = len(table_matrix)
        
        # CRUD ÏûëÏóÖÎ≥Ñ ÌÜµÍ≥Ñ
        crud_stats = {'C': 0, 'R': 0, 'U': 0, 'D': 0, 'O': 0}
        for class_data in class_matrix:
            for operation in class_data['operations']:
                if operation in crud_stats:
                    crud_stats[operation] += 1
        
        return {
            'total_classes': total_classes,
            'total_tables': total_tables,
            'crud_stats': crud_stats,
            'most_active_class': max(class_matrix, key=lambda x: len(x['operations']))['class_name'] if class_matrix else None,
            'most_used_table': max(table_matrix, key=lambda x: sum(op['count'] for op in x['operations']))['table_name'] if table_matrix else None
        }
    
    def generate_call_chain_diagram(self, project_name: str, start_class: str = None, start_method: str = None) -> str:
        """
        Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû®ÏúºÎ°ú ÏÉùÏÑ±Ìï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            start_class: ÏãúÏûë ÌÅ¥ÎûòÏä§ (ÏÑ†ÌÉùÏÇ¨Ìï≠)
            start_method: ÏãúÏûë Î©îÏÑúÎìú (ÏÑ†ÌÉùÏÇ¨Ìï≠)
            
        Returns:
            Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû® Î¨∏ÏûêÏó¥
        """
        try:
            analysis_result = self.analyze_call_chain(project_name, start_class, start_method)
            
            if 'error' in analysis_result:
                return f"Ïò§Î•ò: {analysis_result['error']}"
            
            call_chain = analysis_result['call_chain']
            missing_nodes = analysis_result['missing_nodes']
            
            if not call_chain:
                return "```mermaid\ngraph TD\n    A[No call chain found]\n```"
            
            # Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏÉùÏÑ±
            diagram_lines = ["```mermaid", "graph TD"]
            
            # ÎÖ∏Îìú Ï†ïÏùò
            nodes = set()
            for call in call_chain:
                if call['source_class']:
                    nodes.add(call['source_class'])
                if call['target_class']:
                    nodes.add(call['target_class'])
                if call['table_name']:
                    nodes.add(f"Table_{call['table_name']}")
                if call['column_name']:
                    nodes.add(f"Column_{call['column_name']}")
            
            # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî ÎÖ∏Îìú Ï∂îÍ∞Ä (Ï†ÅÏÉâ Ï†êÏÑ†ÏúºÎ°ú ÌëúÏãú)
            for missing_table in missing_nodes['missing_tables']:
                nodes.add(f"MissingTable_{missing_table}")
            
            for missing_column in missing_nodes['missing_columns']:
                nodes.add(f"MissingColumn_{missing_column}")
            
            # ÎÖ∏Îìú Ïä§ÌÉÄÏùº Ï†ïÏùò
            for node in sorted(nodes):
                if node.startswith('MissingTable_'):
                    table_name = node.replace('MissingTable_', '')
                    diagram_lines.append(f"    {node}[\"‚ùå {table_name}\"]:::missingTable")
                elif node.startswith('MissingColumn_'):
                    column_name = node.replace('MissingColumn_', '')
                    diagram_lines.append(f"    {node}[\"‚ùå {column_name}\"]:::missingColumn")
                elif node.startswith('Table_'):
                    table_name = node.replace('Table_', '')
                    diagram_lines.append(f"    {node}[\"üìä {table_name}\"]:::table")
                elif node.startswith('Column_'):
                    column_name = node.replace('Column_', '')
                    diagram_lines.append(f"    {node}[\"üìã {column_name}\"]:::column")
                else:
                    diagram_lines.append(f"    {node}[\"üè¢ {node}\"]:::class")
            
            # Ïó∞Í≤∞ÏÑ† Ï†ïÏùò
            for call in call_chain:
                if call['source_class'] and call['target_class']:
                    diagram_lines.append(f"    {call['source_class']} --> {call['target_class']}")
                
                if call['target_class'] and call['table_name']:
                    table_node = f"Table_{call['table_name']}"
                    diagram_lines.append(f"    {call['target_class']} --> {table_node}")
                
                if call['table_name'] and call['column_name']:
                    table_node = f"Table_{call['table_name']}"
                    column_node = f"Column_{call['column_name']}"
                    diagram_lines.append(f"    {table_node} --> {column_node}")
            
            # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî ÎÖ∏Îìú Ïó∞Í≤∞ (Ï†ÅÏÉâ Ï†êÏÑ†)
            for call in call_chain:
                if call['table_name'] and call['table_name'] in missing_nodes['missing_tables']:
                    missing_table_node = f"MissingTable_{call['table_name']}"
                    if call['target_class']:
                        diagram_lines.append(f"    {call['target_class']} -.-> {missing_table_node}")
                
                if call['column_name'] and call['column_name'] in missing_nodes['missing_columns']:
                    missing_column_node = f"MissingColumn_{call['column_name']}"
                    if call['table_name']:
                        table_node = f"Table_{call['table_name']}"
                        diagram_lines.append(f"    {table_node} -.-> {missing_column_node}")
            
            # Ïä§ÌÉÄÏùº Ï†ïÏùò
            diagram_lines.extend([
                "",
                "    classDef class fill:#e1f5fe,stroke:#01579b,stroke-width:2px",
                "    classDef table fill:#f3e5f5,stroke:#4a148c,stroke-width:2px",
                "    classDef column fill:#e8f5e8,stroke:#1b5e20,stroke-width:2px",
                "    classDef missingTable fill:#ffebee,stroke:#c62828,stroke-width:2px,stroke-dasharray: 5 5",
                "    classDef missingColumn fill:#fff3e0,stroke:#ef6c00,stroke-width:2px,stroke-dasharray: 5 5"
            ])
            
            diagram_lines.append("```")
            
            return "\n".join(diagram_lines)
            
        except Exception as e:
            self.logger.error(f"Ìò∏Ï∂ú Ï≤¥Ïù∏ Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏÉùÏÑ± Ïò§Î•ò: {str(e)}")
            return f"Ïò§Î•ò: {str(e)}"
    
    def analyze_table_impact(self, project_name: str, table_name: str) -> Dict[str, Any]:
        """
        ÌäπÏ†ï ÌÖåÏù¥Î∏î Î≥ÄÍ≤Ω Ïãú ÏòÅÌñ•Î∞õÎäî ÌÅ¥ÎûòÏä§/Î©îÏÑúÎìúÎ•º Î∂ÑÏÑùÌï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            table_name: Î∂ÑÏÑùÌï† ÌÖåÏù¥Î∏î Ïù¥Î¶Ñ
            
        Returns:
            ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù Í≤∞Í≥º
        """
        try:
            with self.driver.session() as session:
                # ÌÖåÏù¥Î∏îÏùÑ ÏÇ¨Ïö©ÌïòÎäî ÌÅ¥ÎûòÏä§/Î©îÏÑúÎìú Ï°∞Ìöå
                impact_query = """
                MATCH (c:Class {project_name: $project_name})-[:HAS_METHOD]->(m:Method)
                MATCH (m)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
                WHERE sql.tables CONTAINS $table_name OR 
                      ANY(table_info IN sql.tables WHERE table_info.name = $table_name)
                RETURN c.name as class_name,
                       c.package_name as package_name,
                       m.name as method_name,
                       sql.id as sql_id,
                       sql.sql_type as sql_type,
                       sql.complexity_score as complexity_score
                ORDER BY c.name, m.name
                """
                
                result = session.run(impact_query, 
                                   project_name=project_name, 
                                   table_name=table_name)
                
                impacted_classes = []
                for record in result:
                    impacted_classes.append({
                        'class_name': record['class_name'],
                        'package_name': record['package_name'],
                        'method_name': record['method_name'],
                        'sql_id': record['sql_id'],
                        'sql_type': record['sql_type'],
                        'complexity_score': record['complexity_score']
                    })
                
                # ÏòÅÌñ•ÎèÑ ÏöîÏïΩ
                summary = {
                    'table_name': table_name,
                    'total_impacted_classes': len(set(c['class_name'] for c in impacted_classes)),
                    'total_impacted_methods': len(set(f"{c['class_name']}.{c['method_name']}" for c in impacted_classes)),
                    'total_sql_statements': len(set(c['sql_id'] for c in impacted_classes if c['sql_id'])),
                    'crud_operations': list(set(c['sql_type'] for c in impacted_classes if c['sql_type'])),
                    'high_complexity_sql': [c for c in impacted_classes if c['complexity_score'] and c['complexity_score'] > 7]
                }
                
                return {
                    'table_name': table_name,
                    'impacted_classes': impacted_classes,
                    'summary': summary
                }
                
        except Exception as e:
            self.logger.error(f"ÌÖåÏù¥Î∏î ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù Ïò§Î•ò: {str(e)}")
            return {'error': str(e)}
    
    def get_database_usage_statistics(self, project_name: str) -> Dict[str, Any]:
        """
        Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÇ¨Ïö© ÌÜµÍ≥ÑÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            
        Returns:
            Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÇ¨Ïö© ÌÜµÍ≥Ñ
        """
        try:
            with self.driver.session() as session:
                # SQL ÌÜµÍ≥Ñ
                sql_stats_query = """
                MATCH (sql:SqlStatement {project_name: $project_name})
                RETURN 
                    count(sql) as total_sql,
                    sum(CASE WHEN sql.sql_type = 'SELECT' THEN 1 ELSE 0 END) as SELECT,
                    sum(CASE WHEN sql.sql_type = 'INSERT' THEN 1 ELSE 0 END) as INSERT,
                    sum(CASE WHEN sql.sql_type = 'UPDATE' THEN 1 ELSE 0 END) as UPDATE,
                    sum(CASE WHEN sql.sql_type = 'DELETE' THEN 1 ELSE 0 END) as DELETE
                """
                
                result = session.run(sql_stats_query, project_name=project_name)
                sql_stats = result.single().data() if result.single() else {}
                
                # ÌÖåÏù¥Î∏î ÏÇ¨Ïö© ÌÜµÍ≥Ñ
                table_usage_query = """
                MATCH (sql:SqlStatement {project_name: $project_name})
                WHERE sql.tables IS NOT NULL
                UNWIND sql.tables as table_info
                WITH table_info.name as table_name, sql.sql_type as operation
                RETURN 
                    table_name,
                    count(*) as access_count,
                    collect(DISTINCT operation) as operations
                ORDER BY access_count DESC
                """
                
                result = session.run(table_usage_query, project_name=project_name)
                table_usage = [record.data() for record in result]
                
                # Î≥µÏû°ÎèÑ ÌÜµÍ≥Ñ
                complexity_query = """
                MATCH (sql:SqlStatement {project_name: $project_name})
                WHERE sql.complexity_score IS NOT NULL
                WITH sql.complexity_score as score,
                     CASE 
                         WHEN sql.complexity_score <= 3 THEN 'simple'
                         WHEN sql.complexity_score <= 7 THEN 'medium'
                         WHEN sql.complexity_score <= 12 THEN 'complex'
                         ELSE 'very_complex'
                     END as complexity_level
                RETURN 
                    complexity_level,
                    count(*) as count
                """
                
                result = session.run(complexity_query, project_name=project_name)
                complexity_stats = {record['complexity_level']: record['count'] for record in result}
                
                return {
                    'project_name': project_name,
                    'sql_statistics': sql_stats,
                    'table_usage': table_usage,
                    'complexity_statistics': complexity_stats
                }
                
        except Exception as e:
            self.logger.error(f"Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÇ¨Ïö© ÌÜµÍ≥Ñ Ï°∞Ìöå Ïò§Î•ò: {str(e)}")
            return {'error': str(e)}
```

Ïù¥Ï†ú CLIÏóê DB Ìò∏Ï∂úÍ¥ÄÍ≥Ñ Î∂ÑÏÑù ÏòµÏÖòÏùÑ Ï∂îÍ∞ÄÌïòÍ≤†ÏäµÎãàÎã§.


Ïù¥Ï†ú CLIÏóê DB Ìò∏Ï∂úÍ¥ÄÍ≥Ñ Î∂ÑÏÑù ÏòµÏÖòÏùÑ Ï∂îÍ∞ÄÌïòÍ≤†ÏäµÎãàÎã§.


```python
import click
import sys
import os
from dotenv import load_dotenv

# Add the project root to Python path
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from src.services.java_parser import parse_java_project
from src.services.graph_db import GraphDB
from src.services.sequence_diagram_generator import SequenceDiagramGenerator
from src.services.db_parser import DBParser
from src.services.db_call_analysis import DBCallAnalysisService
from neo4j import GraphDatabase
import subprocess
import tempfile

load_dotenv()

def convert_to_image(diagram_content, output_file, image_format, width, height):
    """Convert Mermaid diagram to image using mermaid-cli"""
    # Try different possible locations for mmdc
    mmdc_commands = ['mmdc', 'mmdc.cmd', r'C:\Users\cjony\AppData\Roaming\npm\mmdc', r'C:\Users\cjony\AppData\Roaming\npm\mmdc.cmd']
    
    mmdc_cmd = None
    for cmd in mmdc_commands:
        try:
            subprocess.run([cmd, '--version'], capture_output=True, check=True, timeout=5)
            mmdc_cmd = cmd
            break
        except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired):
            continue
    
    if not mmdc_cmd:
        click.echo("Error: mermaid-cli is not installed or not found in PATH.")
        click.echo("Please install it with: npm install -g @mermaid-js/mermaid-cli")
        click.echo("Or check if it's installed at: C:\\Users\\cjony\\AppData\\Roaming\\npm\\")
        return
    
    try:
        # Create temporary file for mermaid content
        with tempfile.NamedTemporaryFile(mode='w', suffix='.md', delete=False, encoding='utf-8', newline='') as temp_file:
            temp_file.write(diagram_content)
            temp_file_path = temp_file.name
        
        # Determine format from output file extension
        file_extension = output_file.split('.')[-1].lower()
        actual_format = file_extension if file_extension in ['png', 'svg', 'pdf'] else image_format
        
        # Convert to image using mermaid-cli
        cmd = [
            mmdc_cmd,
            '-i', temp_file_path,
            '-o', output_file,
            '-e', actual_format,
            '-w', str(width),
            '-H', str(height)
        ]
        
        # Add PDF-specific options
        if image_format.lower() == 'pdf':
            # Set background color for PDF
            cmd.extend(['-b', 'white'])
            # Add PDF fit option
            cmd.append('-f')
        
        click.echo(f"Running command: {' '.join(cmd)}")
        
        # Set environment variables for UTF-8 encoding
        env = os.environ.copy()
        env['PYTHONIOENCODING'] = 'utf-8'
        env['LANG'] = 'en_US.UTF-8'
        env['LC_ALL'] = 'en_US.UTF-8'
        
        result = subprocess.run(cmd, capture_output=True, text=True, check=True, encoding='utf-8', errors='ignore', env=env)
        
        # Clean up temporary file
        os.unlink(temp_file_path)
        
        # Check if the expected output file was created
        if os.path.exists(output_file):
            actual_format = output_file.split('.')[-1].upper()
            click.echo(f"Image saved to: {output_file}")
            click.echo(f"Format: {actual_format}, Size: {width}x{height}")
        else:
            # Check for files with similar names (mermaid-cli sometimes adds numbers)
            import glob
            pattern = output_file.replace('.pdf', '-*.pdf').replace('.png', '-*.png').replace('.svg', '-*.svg')
            matching_files = glob.glob(pattern)
            if matching_files:
                actual_file = matching_files[0]
                actual_format = actual_file.split('.')[-1].upper()
                click.echo(f"Image saved to: {actual_file}")
                click.echo(f"Format: {actual_format}, Size: {width}x{height}")
                click.echo(f"Note: mermaid-cli created {actual_file} instead of {output_file}")
            else:
                click.echo(f"Warning: Expected file {output_file} not found")
        
        click.echo(f"Command output: {result.stdout}")
        
    except subprocess.CalledProcessError as e:
        click.echo(f"Error converting to image: {e}")
        click.echo(f"Error output: {e.stderr}")
        if os.path.exists(temp_file_path):
            os.unlink(temp_file_path)
    except Exception as e:
        click.echo(f"Unexpected error: {e}")
        if 'temp_file_path' in locals() and os.path.exists(temp_file_path):
            os.unlink(temp_file_path)

@click.group()
def cli():
    pass

@cli.command()
@click.option('--java-source-folder', default=os.getenv("JAVA_SOURCE_FOLDER"), help='Path to the Java source project folder.')
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--neo4j-password', default=os.getenv("NEO4J_PASSWORD"), help='Neo4j password')
@click.option('--clean', is_flag=True, help='Wipe the database before analysis.')
@click.option('--class-name', help='Analyze only a specific class (delete existing data for this class first)')
@click.option('--update', is_flag=True, help='Update all classes individually without clearing database')
@click.option('--db_object', is_flag=True, help='Analyze database objects from DDL scripts')
@click.option('--java_object', is_flag=True, help='Analyze Java objects from source code')
@click.option('--dry-run', is_flag=True, help='Parse Java files without connecting to database.')
def analyze(java_source_folder, neo4j_uri, neo4j_user, neo4j_password, clean, class_name, update, db_object, java_object, dry_run):
    """Analyzes a Java project and populates a Neo4j database."""
    if not java_source_folder:
        click.echo("Error: JAVA_SOURCE_FOLDER environment variable or --java-source-folder option is required.", err=True)
        exit(1)

    # Extract project name from directory path
    from pathlib import Path
    project_name = Path(java_source_folder).resolve().name

    # Handle Java object analysis
    if java_object:
        click.echo("Analyzing Java objects from source code...")
        
        if not java_source_folder:
            click.echo("Error: JAVA_SOURCE_FOLDER environment variable is required for --java_object option.", err=True)
            click.echo("Please set JAVA_SOURCE_FOLDER in your .env file or environment variables.")
            exit(1)
        
        if not os.path.exists(java_source_folder):
            click.echo(f"Error: Java source folder {java_source_folder} does not exist.", err=True)
            exit(1)
        
        try:
            # Parse Java project
            click.echo(f"Parsing Java project at: {java_source_folder}")
            packages_to_add, classes_to_add, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, jpa_repositories, jpa_queries, config_files, test_classes, sql_statements, project_name = parse_java_project(java_source_folder)
            
            click.echo(f"Project name: {project_name}")
            click.echo(f"Found {len(packages_to_add)} packages and {len(classes_to_add)} classes.")
            
            if dry_run:
                click.echo("Dry run mode - not connecting to database.")
                click.echo(f"Found {len(packages_to_add)} packages and {len(classes_to_add)} classes.")
                click.echo(f"Found {len(beans)} Spring Beans and {len(dependencies)} dependencies.")
                click.echo(f"Found {len(endpoints)} REST API endpoints.")
                click.echo(f"Found {len(mybatis_mappers)} MyBatis mappers.")
                click.echo(f"Found {len(jpa_entities)} JPA entities.")
                click.echo(f"Found {len(jpa_repositories)} JPA repositories.")
                click.echo(f"Found {len(jpa_queries)} JPA queries.")
                click.echo(f"Found {len(config_files)} configuration files.")
                click.echo(f"Found {len(test_classes)} test classes.")
                click.echo(f"Found {len(sql_statements)} SQL statements.")
                click.echo("Java object analysis complete (dry run).")
                return
            
            # Connect to database
            click.echo(f"Connecting to Neo4j at {neo4j_uri}...")
            db = GraphDB(uri=neo4j_uri, user=neo4j_user, password=neo4j_password)
            
            if clean:
                click.echo("Cleaning Java objects...")
                with db._driver.session() as session:
                    # Delete only Java-related nodes
                    session.run("MATCH (n:Package) DETACH DELETE n")
                    session.run("MATCH (n:Class) DETACH DELETE n")
                    session.run("MATCH (n:Method) DETACH DELETE n")
                    session.run("MATCH (n:Field) DETACH DELETE n")
                    session.run("MATCH (n:Bean) DETACH DELETE n")
                    session.run("MATCH (n:Endpoint) DETACH DELETE n")
                    session.run("MATCH (n:MyBatisMapper) DETACH DELETE n")
                    session.run("MATCH (n:JpaEntity) DETACH DELETE n")
                    session.run("MATCH (n:ConfigFile) DETACH DELETE n")
                    session.run("MATCH (n:TestClass) DETACH DELETE n")
                    session.run("MATCH (n:SqlStatement) DETACH DELETE n")
            
            # Add packages
            click.echo("Adding packages to database...")
            for package_node in packages_to_add:
                db.add_package(package_node, project_name)
            
            # Add classes
            click.echo("Adding classes to database...")
            for class_node in classes_to_add:
                # Find the package for this class using the mapping
                class_key = f"{class_to_package_map.get(class_node.name, '')}.{class_node.name}"
                package_name = class_to_package_map.get(class_key, None)
                
                if not package_name:
                    # Fallback: try to find package by class name
                    for key, pkg_name in class_to_package_map.items():
                        if key.endswith(f".{class_node.name}"):
                            package_name = pkg_name
                            break
                
                db.add_class(class_node, package_name, project_name)
            
            # Add Spring Boot analysis results
            if beans:
                click.echo(f"Adding {len(beans)} Spring Beans to database...")
                for bean in beans:
                    db.add_bean(bean, project_name)
            
            if dependencies:
                click.echo(f"Adding {len(dependencies)} Bean dependencies to database...")
                for dependency in dependencies:
                    db.add_bean_dependency(dependency, project_name)
            
            if endpoints:
                click.echo(f"Adding {len(endpoints)} REST API endpoints to database...")
                for endpoint in endpoints:
                    db.add_endpoint(endpoint, project_name)
            
            if mybatis_mappers:
                click.echo(f"Adding {len(mybatis_mappers)} MyBatis mappers to database...")
                for mapper in mybatis_mappers:
                    db.add_mybatis_mapper(mapper, project_name)
            
            if jpa_entities:
                click.echo(f"Adding {len(jpa_entities)} JPA entities to database...")
                for entity in jpa_entities:
                    db.add_jpa_entity(entity, project_name)
            
            if jpa_repositories:
                click.echo(f"Adding {len(jpa_repositories)} JPA repositories to database...")
                for repository in jpa_repositories:
                    db.add_jpa_repository(repository, project_name)
            
            if jpa_queries:
                click.echo(f"Adding {len(jpa_queries)} JPA queries to database...")
                for query in jpa_queries:
                    db.add_jpa_query(query, project_name)
            
            if config_files:
                click.echo(f"Adding {len(config_files)} configuration files to database...")
                for config_file in config_files:
                    db.add_config_file(config_file, project_name)
            
            if test_classes:
                click.echo(f"Adding {len(test_classes)} test classes to database...")
                for test_class in test_classes:
                    db.add_test_class(test_class, project_name)
            
            if sql_statements:
                click.echo(f"Adding {len(sql_statements)} SQL statements to database...")
                for sql_statement in sql_statements:
                    db.add_sql_statement(sql_statement, project_name)
                    # Create relationship between mapper and SQL statement
                    with db._driver.session() as session:
                        session.execute_write(db._create_mapper_sql_relationship_tx, sql_statement.mapper_name, sql_statement.id, project_name)
            
            db.close()
            click.echo("Java object analysis complete.")
            return
            
        except Exception as e:
            click.echo(f"Error analyzing Java objects: {e}")
            click.echo("Use --dry-run flag to parse without database connection.")
            exit(1)

    # Handle DB object analysis
    if db_object:
        click.echo("Analyzing database objects from DDL scripts...")
        
        # Get DB script folder from environment variable
        db_script_folder = os.getenv("DB_SCRIPT_FOLDER")
        if not db_script_folder:
            click.echo("Error: DB_SCRIPT_FOLDER environment variable is required for --db_object option.", err=True)
            click.echo("Please set DB_SCRIPT_FOLDER in your .env file or environment variables.")
            exit(1)
        
        if not os.path.exists(db_script_folder):
            click.echo(f"Error: DB script folder {db_script_folder} does not exist.", err=True)
            exit(1)
        
        try:
            # Parse DDL files
            db_parser = DBParser()
            all_db_objects = db_parser.parse_ddl_directory(db_script_folder, project_name)
            
            if not all_db_objects:
                click.echo("No DDL files found or parsed successfully.")
                return
            
            click.echo(f"Found {len(all_db_objects)} DDL files to process.")
            
            if dry_run:
                click.echo("Dry run mode - not connecting to database.")
                for i, db_objects in enumerate(all_db_objects):
                    click.echo(f"DDL file {i+1}:")
                    click.echo(f"  Database: {db_objects['database'].name}")
                    click.echo(f"  Tables: {len(db_objects['tables'])}")
                    click.echo(f"  Columns: {len(db_objects['columns'])}")
                    click.echo(f"  Indexes: {len(db_objects['indexes'])}")
                    click.echo(f"  Constraints: {len(db_objects['constraints'])}")
                click.echo("DB object analysis complete (dry run).")
                return
            
            # Connect to database
            click.echo(f"Connecting to Neo4j at {neo4j_uri}...")
            db = GraphDB(uri=neo4j_uri, user=neo4j_user, password=neo4j_password)
            
            if clean:
                click.echo("Cleaning database objects...")
                with db._driver.session() as session:
                    # Delete only database-related nodes
                    session.run("MATCH (n:Database) DETACH DELETE n")
                    session.run("MATCH (n:Table) DETACH DELETE n")
                    session.run("MATCH (n:Column) DETACH DELETE n")
                    session.run("MATCH (n:Index) DETACH DELETE n")
                    session.run("MATCH (n:Constraint) DETACH DELETE n")
            
            # Process each DDL file's objects
            for i, db_objects in enumerate(all_db_objects):
                click.echo(f"Processing DDL file {i+1}...")
                
                # Add database
                click.echo(f"Adding database: {db_objects['database'].name}")
                db.add_database(db_objects['database'], project_name)
                
                # Add tables
                for table_obj in db_objects['tables']:
                    click.echo(f"Adding table: {table_obj.name}")
                    db.add_table(table_obj, db_objects['database'].name, project_name)
                
                # Add columns
                for column_obj in db_objects['columns']:
                    table_name = getattr(column_obj, 'table_name', 'unknown')
                    click.echo(f"Adding column: {column_obj.name} to table {table_name}")
                    db.add_column(column_obj, table_name, project_name)
                
                # Add indexes
                for index_obj, table_name in db_objects['indexes']:
                    click.echo(f"Adding index: {index_obj.name} to table {table_name}")
                    db.add_index(index_obj, table_name, project_name)
                
                # Add constraints
                for constraint_obj, table_name in db_objects['constraints']:
                    click.echo(f"Adding constraint: {constraint_obj.name} to table {table_name}")
                    db.add_constraint(constraint_obj, table_name, project_name)
            
            db.close()
            click.echo("DB object analysis complete.")
            return
            
        except Exception as e:
            click.echo(f"Error analyzing DB objects: {e}")
            click.echo("Use --dry-run flag to parse without database connection.")
            exit(1)

    # If analyzing a specific class
    if class_name:
        click.echo(f"Analyzing specific class: {class_name}")
        
        # Find the Java file for this class
        java_file_path = None
        for root, _, files in os.walk(java_source_folder):
            for file in files:
                if file.endswith(".java") and file.replace(".java", "") == class_name:
                    java_file_path = os.path.join(root, file)
                    break
            if java_file_path:
                break
        
        if not java_file_path:
            click.echo(f"Error: Could not find Java file for class '{class_name}'", err=True)
            exit(1)
        
        click.echo(f"Found Java file: {java_file_path}")
        
        try:
            # Parse the single Java file
            from src.services.java_parser import parse_single_java_file, extract_beans_from_classes, analyze_bean_dependencies, extract_endpoints_from_classes, extract_mybatis_mappers_from_classes, extract_jpa_entities_from_classes, extract_test_classes_from_classes, extract_sql_statements_from_mappers
            
            package_node, class_node, package_name = parse_single_java_file(java_file_path, project_name)
            
            click.echo(f"Parsed class: {class_node.name}")
            click.echo(f"Package: {package_name}")
            click.echo(f"Methods: {len(class_node.methods)}")
            click.echo(f"Properties: {len(class_node.properties)}")
            click.echo(f"Method calls: {len(class_node.calls)}")
            
            if dry_run:
                click.echo("Dry run mode - not connecting to database.")
                click.echo("Analysis complete (dry run).")
                return
            
            # Connect to database
            click.echo(f"Connecting to Neo4j at {neo4j_uri}...")
            db = GraphDB(uri=neo4j_uri, user=neo4j_user, password=neo4j_password)
            
            # Delete existing data for this class
            click.echo(f"Deleting existing data for class '{class_name}'...")
            db.delete_class_and_related_data(class_name, project_name)
            
            # Add package
            click.echo("Adding package to database...")
            db.add_package(package_node, project_name)
            
            # Add class
            click.echo("Adding class to database...")
            db.add_class(class_node, package_name, project_name)
            
            # Extract and add related Spring Boot analysis results for this class only
            classes_list = [class_node]
            beans = extract_beans_from_classes(classes_list)
            dependencies = analyze_bean_dependencies(classes_list, beans)
            endpoints = extract_endpoints_from_classes(classes_list)
            mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
            jpa_entities = extract_jpa_entities_from_classes(classes_list)
            test_classes = extract_test_classes_from_classes(classes_list)
            
            # Extract SQL statements from MyBatis mappers
            sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
            
            # Add Spring Boot analysis results
            if beans:
                click.echo(f"Adding {len(beans)} Spring Beans to database...")
                for bean in beans:
                    db.add_bean(bean, project_name)
            
            if dependencies:
                click.echo(f"Adding {len(dependencies)} Bean dependencies to database...")
                for dependency in dependencies:
                    db.add_bean_dependency(dependency, project_name)
            
            if endpoints:
                click.echo(f"Adding {len(endpoints)} REST API endpoints to database...")
                for endpoint in endpoints:
                    db.add_endpoint(endpoint, project_name)
            
            if mybatis_mappers:
                click.echo(f"Adding {len(mybatis_mappers)} MyBatis mappers to database...")
                for mapper in mybatis_mappers:
                    db.add_mybatis_mapper(mapper, project_name)
            
            if jpa_entities:
                click.echo(f"Adding {len(jpa_entities)} JPA entities to database...")
                for entity in jpa_entities:
                    db.add_jpa_entity(entity, project_name)
            
            if test_classes:
                click.echo(f"Adding {len(test_classes)} test classes to database...")
                for test_class in test_classes:
                    db.add_test_class(test_class, project_name)
            
            if sql_statements:
                click.echo(f"Adding {len(sql_statements)} SQL statements to database...")
                for sql_statement in sql_statements:
                    db.add_sql_statement(sql_statement, project_name)
                    # Create relationship between mapper and SQL statement
                    with db._driver.session() as session:
                        session.execute_write(db._create_mapper_sql_relationship_tx, sql_statement.mapper_name, sql_statement.id, project_name)
            
            db.close()
            click.echo("Class analysis complete.")
            
        except Exception as e:
            click.echo(f"Error analyzing class: {e}")
            click.echo("Use --dry-run flag to parse without database connection.")
            exit(1)
        
        return

    # If updating all classes individually
    if update:
        click.echo("Updating all classes individually...")
        
        # Find all Java files
        java_files = []
        for root, _, files in os.walk(java_source_folder):
            for file in files:
                if file.endswith(".java"):
                    java_files.append(os.path.join(root, file))
        
        if not java_files:
            click.echo("No Java files found in the specified directory.", err=True)
            exit(1)
        
        click.echo(f"Found {len(java_files)} Java files to process.")
        
        if dry_run:
            click.echo("Dry run mode - not connecting to database.")
            for java_file in java_files:
                try:
                    from src.services.java_parser import parse_single_java_file
                    package_node, class_node, package_name = parse_single_java_file(java_file, project_name)
                    click.echo(f"  {class_node.name} ({package_name}) - Methods: {len(class_node.methods)}, Properties: {len(class_node.properties)}")
                except Exception as e:
                    click.echo(f"  Error parsing {java_file}: {e}")
            click.echo("Update analysis complete (dry run).")
            return
        
        try:
            # Connect to database
            click.echo(f"Connecting to Neo4j at {neo4j_uri}...")
            db = GraphDB(uri=neo4j_uri, user=neo4j_user, password=neo4j_password)
            
            processed_count = 0
            error_count = 0
            
            for java_file in java_files:
                try:
                    click.echo(f"Processing: {java_file}")
                    
                    # Parse the single Java file
                    from src.services.java_parser import parse_single_java_file, extract_beans_from_classes, analyze_bean_dependencies, extract_endpoints_from_classes, extract_mybatis_mappers_from_classes, extract_jpa_entities_from_classes, extract_test_classes_from_classes, extract_sql_statements_from_mappers
                    
                    package_node, class_node, package_name = parse_single_java_file(java_file, project_name)
                    
                    click.echo(f"  Parsed class: {class_node.name} (Package: {package_name})")
                    
                    # Delete existing data for this class
                    click.echo(f"  Deleting existing data for class '{class_node.name}'...")
                    db.delete_class_and_related_data(class_node.name, project_name)
                    
                    # Add package
                    db.add_package(package_node, project_name)
                    
                    # Add class
                    db.add_class(class_node, package_name, project_name)
                    
                    # Extract and add related Spring Boot analysis results for this class only
                    classes_list = [class_node]
                    beans = extract_beans_from_classes(classes_list)
                    dependencies = analyze_bean_dependencies(classes_list, beans)
                    endpoints = extract_endpoints_from_classes(classes_list)
                    mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
                    jpa_entities = extract_jpa_entities_from_classes(classes_list)
                    test_classes = extract_test_classes_from_classes(classes_list)
                    
                    # Extract SQL statements from MyBatis mappers
                    sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
                    
                    # Add Spring Boot analysis results
                    if beans:
                        for bean in beans:
                            db.add_bean(bean, project_name)
                    
                    if dependencies:
                        for dependency in dependencies:
                            db.add_bean_dependency(dependency, project_name)
                    
                    if endpoints:
                        for endpoint in endpoints:
                            db.add_endpoint(endpoint, project_name)
                    
                    if mybatis_mappers:
                        for mapper in mybatis_mappers:
                            db.add_mybatis_mapper(mapper, project_name)
                    
                    if jpa_entities:
                        for entity in jpa_entities:
                            db.add_jpa_entity(entity, project_name)
                    
                    if test_classes:
                        for test_class in test_classes:
                            db.add_test_class(test_class, project_name)
                    
                    if sql_statements:
                        for sql_statement in sql_statements:
                            db.add_sql_statement(sql_statement, project_name)
                            # Create relationship between mapper and SQL statement
                            with db._driver.session() as session:
                                session.execute_write(db._create_mapper_sql_relationship_tx, sql_statement.mapper_name, sql_statement.id, project_name)
                    
                    processed_count += 1
                    click.echo(f"  [OK] Successfully processed {class_node.name}")
                    
                except Exception as e:
                    error_count += 1
                    click.echo(f"  [ERROR] Error processing {java_file}: {e}")
                    continue
            
            db.close()
            click.echo(f"Update complete. Processed: {processed_count}, Errors: {error_count}")
            
        except Exception as e:
            click.echo(f"Error during update: {e}")
            click.echo("Use --dry-run flag to parse without database connection.")
            exit(1)
        
        return

    # Original full project analysis (when no specific object type is specified)
    if not java_object and not db_object:
        click.echo(f"Parsing Java project at: {java_source_folder}")
        packages_to_add, classes_to_add, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, jpa_repositories, jpa_queries, config_files, test_classes, sql_statements, project_name = parse_java_project(java_source_folder)
    
        click.echo(f"Project name: {project_name}")
        
        click.echo(f"Found {len(packages_to_add)} packages and {len(classes_to_add)} classes.")
        
        if dry_run:
            click.echo("Dry run mode - not connecting to database.")
            click.echo(f"Found {len(packages_to_add)} packages and {len(classes_to_add)} classes.")
            click.echo(f"Found {len(beans)} Spring Beans and {len(dependencies)} dependencies.")
            click.echo(f"Found {len(endpoints)} REST API endpoints.")
            click.echo(f"Found {len(mybatis_mappers)} MyBatis mappers.")
            click.echo(f"Found {len(jpa_entities)} JPA entities.")
            click.echo(f"Found {len(jpa_repositories)} JPA repositories.")
            click.echo(f"Found {len(jpa_queries)} JPA queries.")
            click.echo(f"Found {len(config_files)} configuration files.")
            click.echo(f"Found {len(test_classes)} test classes.")
            click.echo(f"Found {len(sql_statements)} SQL statements.")
            
            for package_node in packages_to_add:
                click.echo(f"Package: {package_node.name}")
            for class_node in classes_to_add:
                click.echo(f"Class: {class_node.name}")
                click.echo(f"  Methods: {len(class_node.methods)}")
                click.echo(f"  Properties: {len(class_node.properties)}")
                click.echo(f"  Method calls: {len(class_node.calls)}")
            click.echo("Analysis complete (dry run).")
            return

        try:
            click.echo(f"Connecting to Neo4j at {neo4j_uri}...")
            db = GraphDB(uri=neo4j_uri, user=neo4j_user, password=neo4j_password)

            if clean:
                click.echo("Cleaning database...")
                with db._driver.session() as session:
                    session.run("MATCH (n) DETACH DELETE n")

            click.echo("Adding packages to database...")
            for package_node in packages_to_add:
                db.add_package(package_node, project_name)
        
            click.echo("Adding classes to database...")
            for class_node in classes_to_add:
                # Find the package for this class using the mapping
                class_key = f"{class_to_package_map.get(class_node.name, '')}.{class_node.name}"
                package_name = class_to_package_map.get(class_key, None)
                
                if not package_name:
                    # Fallback: try to find package by class name
                    for key, pkg_name in class_to_package_map.items():
                        if key.endswith(f".{class_node.name}"):
                            package_name = pkg_name
                            break
                
                db.add_class(class_node, package_name, project_name)
        
            # Add Spring Boot analysis results
            if beans:
                click.echo(f"Adding {len(beans)} Spring Beans to database...")
                for bean in beans:
                    db.add_bean(bean, project_name)
        
            if dependencies:
                click.echo(f"Adding {len(dependencies)} Bean dependencies to database...")
                for dependency in dependencies:
                    db.add_bean_dependency(dependency, project_name)
        
            if endpoints:
                click.echo(f"Adding {len(endpoints)} REST API endpoints to database...")
                for endpoint in endpoints:
                    db.add_endpoint(endpoint, project_name)
        
            if mybatis_mappers:
                click.echo(f"Adding {len(mybatis_mappers)} MyBatis mappers to database...")
                for mapper in mybatis_mappers:
                    db.add_mybatis_mapper(mapper, project_name)
            
            if jpa_entities:
                click.echo(f"Adding {len(jpa_entities)} JPA entities to database...")
                for entity in jpa_entities:
                    db.add_jpa_entity(entity, project_name)
            
            if jpa_repositories:
                click.echo(f"Adding {len(jpa_repositories)} JPA repositories to database...")
                for repository in jpa_repositories:
                    db.add_jpa_repository(repository, project_name)
            
            if jpa_queries:
                click.echo(f"Adding {len(jpa_queries)} JPA queries to database...")
                for query in jpa_queries:
                    db.add_jpa_query(query, project_name)
            
            if config_files:
                click.echo(f"Adding {len(config_files)} configuration files to database...")
                for config_file in config_files:
                    db.add_config_file(config_file, project_name)
        
            if test_classes:
                click.echo(f"Adding {len(test_classes)} test classes to database...")
                for test_class in test_classes:
                    db.add_test_class(test_class, project_name)
        
            if sql_statements:
                click.echo(f"Adding {len(sql_statements)} SQL statements to database...")
                for sql_statement in sql_statements:
                    db.add_sql_statement(sql_statement, project_name)
                    # Create relationship between mapper and SQL statement
                    with db._driver.session() as session:
                        session.execute_write(db._create_mapper_sql_relationship_tx, sql_statement.mapper_name, sql_statement.id, project_name)
        
            db.close()
            click.echo("Analysis complete.")
        except Exception as e:
            click.echo(f"Error connecting to database: {e}")
            click.echo("Use --dry-run flag to parse without database connection.")
            exit(1)

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--neo4j-password', default=os.getenv("NEO4J_PASSWORD"), help='Neo4j password')
@click.option('--query', help='Custom Cypher query to execute')
@click.option('--basic', is_flag=True, help='Run basic class query')
@click.option('--detailed', is_flag=True, help='Run detailed class query with methods and properties')
@click.option('--inheritance', is_flag=True, help='Run inheritance relationship query')
@click.option('--package', is_flag=True, help='Run package-based class query')
def query(neo4j_uri, neo4j_user, neo4j_password, query, basic, detailed, inheritance, package):
    """Execute queries against the Neo4j database."""
    
    # ÎØ∏Î¶¨ Ï†ïÏùòÎêú ÏøºÎ¶¨Îì§
    queries = {
        'basic': """
        MATCH (c:Class)
        RETURN 
            c.name AS name,
            c.logical_name AS logical_name,
            c.file_path AS file_path,
            c.type AS type,
            c.source AS source
        ORDER BY c.name
        """,
        'detailed': """
        MATCH (c:Class)
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (c)-[:HAS_FIELD]->(p:Field)
        OPTIONAL MATCH (pkg:Package)-[:CONTAINS]->(c)
        RETURN 
            c.name AS class_name,
            c.logical_name AS class_logical_name,
            c.file_path AS file_path,
            c.type AS class_type,
            pkg.name AS package_name,
            collect(DISTINCT m.name) AS methods,
            collect(DISTINCT p.name) AS properties
        ORDER BY c.name
        """,
        'inheritance': """
        MATCH (c:Class)
        OPTIONAL MATCH (c)-[:EXTENDS]->(super:Class)
        OPTIONAL MATCH (c)-[:IMPLEMENTS]->(impl:Class)
        RETURN 
            c.name AS class_name,
            c.logical_name AS class_logical_name,
            c.type AS class_type,
            collect(DISTINCT super.name) AS extends,
            collect(DISTINCT impl.name) AS implements
        ORDER BY c.name
        """,
        'package': """
        MATCH (pkg:Package)-[:CONTAINS]->(c:Class)
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (c)-[:HAS_FIELD]->(p:Field)
        RETURN 
            pkg.name AS package_name,
            pkg.logical_name AS package_logical_name,
            collect(DISTINCT c.name) AS classes,
            count(DISTINCT m) AS total_methods,
            count(DISTINCT p) AS total_properties
        ORDER BY pkg.name
        """
    }
    
    # Ïã§ÌñâÌï† ÏøºÎ¶¨ Í≤∞Ï†ï
    if query:
        cypher_query = query
        description = "Custom Query"
    elif basic:
        cypher_query = queries['basic']
        description = "Basic Class Query"
    elif detailed:
        cypher_query = queries['detailed']
        description = "Detailed Class Query"
    elif inheritance:
        cypher_query = queries['inheritance']
        description = "Inheritance Query"
    elif package:
        cypher_query = queries['package']
        description = "Package Query"
    else:
        click.echo("Error: Please specify a query type or provide a custom query.")
        click.echo("Available options: --basic, --detailed, --inheritance, --package, or --query")
        return
    
    try:
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        
        with driver.session() as session:
            click.echo(f"Executing: {description}")
            click.echo("=" * 50)
            
            result = session.run(cypher_query)
            records = list(result)
            
            if not records:
                click.echo("No results found.")
                return
            
            # Ï≤´ Î≤àÏß∏ Î†àÏΩîÎìúÏùò ÌÇ§Îì§ÏùÑ Ìó§ÎçîÎ°ú ÏÇ¨Ïö©
            headers = list(records[0].keys())
            
            # Ìó§Îçî Ï∂úÎ†•
            click.echo(" | ".join(f"{header:20}" for header in headers))
            click.echo("-" * (len(headers) * 23))
            
            # Îç∞Ïù¥ÌÑ∞ Ï∂úÎ†•
            for record in records:
                row = []
                for header in headers:
                    value = record[header]
                    if value is None:
                        row.append("None")
                    elif isinstance(value, (list, dict)):
                        row.append(str(value)[:50] + "..." if len(str(value)) > 50 else str(value))
                    else:
                        row.append(str(value)[:20])
                click.echo(" | ".join(f"{cell:20}" for cell in row))
            
            click.echo(f"\nTotal: {len(records)} results found.")
            
    except Exception as e:
        click.echo(f"Error executing query: {e}")
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--class-name', required=True, help='Name of the class to analyze')
@click.option('--method-name', help='Specific method to analyze (optional)')
@click.option('--max-depth', default=3, help='Maximum depth of call chain to follow (default: 3)')
@click.option('--include-external', is_flag=True, help='Include calls to external libraries')
@click.option('--method-focused', is_flag=True, help='Generate method-focused diagram (shows only the specified method and its direct calls)')
@click.option('--output-file', help='Output file to save the diagram (optional)')
@click.option('--output-image', help='Output image file (PNG/SVG/PDF) - requires mermaid-cli')
@click.option('--image-format', default='png', type=click.Choice(['png', 'svg', 'pdf']), help='Image format (default: png)')
@click.option('--image-width', default=1200, help='Image width in pixels (default: 1200)')
@click.option('--image-height', default=800, help='Image height in pixels (default: 800)')
def sequence(neo4j_uri, neo4j_user, class_name, method_name, max_depth, include_external, method_focused, output_file, output_image, image_format, image_width, image_height):
    """Generate sequence diagram for a specific class and optionally a method."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        click.echo(f"Connecting to Neo4j at {neo4j_uri}...")
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        generator = SequenceDiagramGenerator(driver)
        
        # Generate the sequence diagram
        click.echo(f"Generating sequence diagram for class: {class_name}")
        if method_name:
            click.echo(f"Focusing on method: {method_name}")
        if method_focused:
            click.echo("Method-focused mode: showing only direct calls from the specified method")
        
        diagram = generator.generate_sequence_diagram(
            class_name=class_name,
            method_name=method_name,
            max_depth=max_depth if not method_focused else 1,  # Method-focused uses depth 1
            include_external_calls=include_external,
            method_focused=method_focused
        )
        
        click.echo(f"Diagram generated (length: {len(diagram)})")
        
        # Check if diagram contains error message
        if diagram.startswith("Error:"):
            click.echo(f"Error: {diagram}")
            return
        
        # Output the diagram
        if output_file:
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(diagram)
            click.echo(f"Sequence diagram saved to: {output_file}")
        else:
            # Default: save to {class_name}.md
            default_filename = f"{class_name}.md"
            with open(default_filename, 'w', encoding='utf-8') as f:
                f.write(diagram)
            click.echo(f"Sequence diagram saved to: {default_filename}")
            
            click.echo("\n" + "="*50)
            click.echo("SEQUENCE DIAGRAM")
            click.echo("="*50)
            click.echo(diagram)
            click.echo("="*50)
        
        # Convert to image if requested
        if output_image:
            convert_to_image(diagram, output_image, image_format, image_width, image_height)
        
    except Exception as e:
        click.echo(f"Error generating sequence diagram: {e}")
        import traceback
        click.echo(f"Traceback: {traceback.format_exc()}")
        exit(1)
    finally:
        if 'driver' in locals():
            driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
def list_classes(neo4j_uri, neo4j_user):
    """List all available classes in the database."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        generator = SequenceDiagramGenerator(driver)
        
        classes = generator.get_available_classes()
        
        if not classes:
            click.echo("No classes found in the database.")
            return
        
        click.echo("Available classes:")
        click.echo("=" * 80)
        click.echo(f"{'Class Name':<30} {'Package':<30} {'Type':<10}")
        click.echo("-" * 80)
        
        for cls in classes:
            click.echo(f"{cls['name']:<30} {cls['package_name']:<30} {cls['type']:<10}")
        
        click.echo(f"\nTotal: {len(classes)} classes found.")
        
    except Exception as e:
        click.echo(f"Error listing classes: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--class-name', required=True, help='Name of the class to list methods for')
def list_methods(neo4j_uri, neo4j_user, class_name):
    """List all methods for a specific class."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        generator = SequenceDiagramGenerator(driver)
        
        methods = generator.get_class_methods(class_name)
        
        if not methods:
            click.echo(f"No methods found for class '{class_name}'.")
            return
        
        click.echo(f"Methods for class '{class_name}':")
        click.echo("=" * 80)
        click.echo(f"{'Method Name':<30} {'Return Type':<20} {'Logical Name':<30}")
        click.echo("-" * 80)
        
        for method in methods:
            click.echo(f"{method['name']:<30} {method['return_type']:<20} {method['logical_name']:<30}")
        
        click.echo(f"\nTotal: {len(methods)} methods found.")
        
    except Exception as e:
        click.echo(f"Error listing methods: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--project-name', help='Project name to filter by (optional)')
def crud_matrix(neo4j_uri, neo4j_user, project_name):
    """Show CRUD matrix for classes and tables."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        db = GraphDB(neo4j_uri, neo4j_user, neo4j_password)
        
        click.echo("CRUD Matrix - Class to Table Operations")
        click.echo("=" * 80)
        
        matrix = db.get_crud_matrix(project_name)
        
        if not matrix:
            click.echo("No CRUD operations found.")
            return
        
        click.echo(f"{'Class Name':<30} {'Package':<25} {'Tables':<20} {'Operations':<15}")
        click.echo("-" * 80)
        
        for row in matrix:
            class_name = row['class_name']
            package_name = row['package_name'] or 'N/A'
            tables = ', '.join(row['tables']) if row['tables'] else 'None'
            operations = ', '.join(row['operations']) if row['operations'] else 'None'
            
            click.echo(f"{class_name:<30} {package_name:<25} {tables:<20} {operations:<15}")
        
        click.echo(f"\nTotal: {len(matrix)} classes with CRUD operations.")
        
    except Exception as e:
        click.echo(f"Error getting CRUD matrix: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--project-name', help='Project name to filter by (optional)')
def db_analysis(neo4j_uri, neo4j_user, project_name):
    """Show database call relationship analysis."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        db = GraphDB(neo4j_uri, neo4j_user, neo4j_password)
        
        click.echo("Database Call Relationship Analysis")
        click.echo("=" * 80)
        
        # SQL Î¨∏ ÌÜµÍ≥Ñ
        sql_stats = db.get_sql_statistics(project_name)
        if sql_stats:
            click.echo(f"\nSQL Statistics:")
            click.echo(f"  Total SQL statements: {sql_stats['total_sql']}")
            click.echo(f"  SELECT statements: {sql_stats.get('SELECT', 0)}")
            click.echo(f"  INSERT statements: {sql_stats.get('INSERT', 0)}")
            click.echo(f"  UPDATE statements: {sql_stats.get('UPDATE', 0)}")
            click.echo(f"  DELETE statements: {sql_stats.get('DELETE', 0)}")
        
        # ÌÖåÏù¥Î∏î ÏÇ¨Ïö© ÌÜµÍ≥Ñ
        table_stats = db.get_table_usage_statistics(project_name)
        if table_stats:
            click.echo(f"\nTable Usage Statistics:")
            click.echo(f"{'Table Name':<30} {'Access Count':<15} {'Operations':<20}")
            click.echo("-" * 65)
            for table in table_stats:
                table_name = table['table_name']
                access_count = table['access_count']
                operations = ', '.join(table['operations'])
                click.echo(f"{table_name:<30} {access_count:<15} {operations:<20}")
        
        # Î≥µÏû°ÎèÑ Î∂ÑÏÑù
        complexity_stats = db.get_sql_complexity_statistics(project_name)
        if complexity_stats:
            click.echo(f"\nSQL Complexity Analysis:")
            click.echo(f"  Simple queries: {complexity_stats.get('simple', 0)}")
            click.echo(f"  Medium queries: {complexity_stats.get('medium', 0)}")
            click.echo(f"  Complex queries: {complexity_stats.get('complex', 0)}")
            click.echo(f"  Very complex queries: {complexity_stats.get('very_complex', 0)}")
        
        # Îß§ÌçºÎ≥Ñ SQL Î∂ÑÌè¨
        mapper_stats = db.get_mapper_sql_distribution(project_name)
        if mapper_stats:
            click.echo(f"\nMapper SQL Distribution:")
            click.echo(f"{'Mapper Name':<30} {'SQL Count':<15} {'SQL Types':<20}")
            click.echo("-" * 65)
            for mapper in mapper_stats:
                mapper_name = mapper['mapper_name']
                sql_count = mapper['sql_count']
                sql_types = ', '.join(mapper['sql_types'])
                click.echo(f"{mapper_name:<30} {sql_count:<15} {sql_types:<20}")
        
    except Exception as e:
        click.echo(f"Error getting database analysis: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--project-name', help='Project name to filter by (optional)')
def table_summary(neo4j_uri, neo4j_user, project_name):
    """Show CRUD summary for each table."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        db = GraphDB(neo4j_uri, neo4j_user, neo4j_password)
        
        click.echo("Table CRUD Summary")
        click.echo("=" * 60)
        
        summary = db.get_table_crud_summary(project_name)
        
        if not summary:
            click.echo("No tables found.")
            return
        
        for row in summary:
            table_name = row['table_name']
            operations = row['operations']
            
            click.echo(f"\nTable: {table_name}")
            click.echo("-" * 40)
            
            for op in operations:
                operation = op['operation']
                count = op['count']
                click.echo(f"  {operation}: {count} statements")
        
        click.echo(f"\nTotal: {len(summary)} tables.")
        
    except Exception as e:
        click.echo(f"Error getting table summary: {e}")
        exit(1)
    finally:
        driver.close()

if __name__ == '__main__':
    cli()

```

Ïù¥Ï†ú ÏÉàÎ°úÏö¥ CLI Î™ÖÎ†πÏñ¥Îì§ÏùÑ Ï∂îÍ∞ÄÌïòÍ≤†ÏäµÎãàÎã§.


```python
import click
import sys
import os
from dotenv import load_dotenv

# Add the project root to Python path
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from src.services.java_parser import parse_java_project
from src.services.graph_db import GraphDB
from src.services.sequence_diagram_generator import SequenceDiagramGenerator
from src.services.db_parser import DBParser
from src.services.db_call_analysis import DBCallAnalysisService
from neo4j import GraphDatabase
import subprocess
import tempfile

load_dotenv()

def convert_to_image(diagram_content, output_file, image_format, width, height):
    """Convert Mermaid diagram to image using mermaid-cli"""
    # Try different possible locations for mmdc
    mmdc_commands = ['mmdc', 'mmdc.cmd', r'C:\Users\cjony\AppData\Roaming\npm\mmdc', r'C:\Users\cjony\AppData\Roaming\npm\mmdc.cmd']
    
    mmdc_cmd = None
    for cmd in mmdc_commands:
        try:
            subprocess.run([cmd, '--version'], capture_output=True, check=True, timeout=5)
            mmdc_cmd = cmd
            break
        except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired):
            continue
    
    if not mmdc_cmd:
        click.echo("Error: mermaid-cli is not installed or not found in PATH.")
        click.echo("Please install it with: npm install -g @mermaid-js/mermaid-cli")
        click.echo("Or check if it's installed at: C:\\Users\\cjony\\AppData\\Roaming\\npm\\")
        return
    
    try:
        # Create temporary file for mermaid content
        with tempfile.NamedTemporaryFile(mode='w', suffix='.md', delete=False, encoding='utf-8', newline='') as temp_file:
            temp_file.write(diagram_content)
            temp_file_path = temp_file.name
        
        # Determine format from output file extension
        file_extension = output_file.split('.')[-1].lower()
        actual_format = file_extension if file_extension in ['png', 'svg', 'pdf'] else image_format
        
        # Convert to image using mermaid-cli
        cmd = [
            mmdc_cmd,
            '-i', temp_file_path,
            '-o', output_file,
            '-e', actual_format,
            '-w', str(width),
            '-H', str(height)
        ]
        
        # Add PDF-specific options
        if image_format.lower() == 'pdf':
            # Set background color for PDF
            cmd.extend(['-b', 'white'])
            # Add PDF fit option
            cmd.append('-f')
        
        click.echo(f"Running command: {' '.join(cmd)}")
        
        # Set environment variables for UTF-8 encoding
        env = os.environ.copy()
        env['PYTHONIOENCODING'] = 'utf-8'
        env['LANG'] = 'en_US.UTF-8'
        env['LC_ALL'] = 'en_US.UTF-8'
        
        result = subprocess.run(cmd, capture_output=True, text=True, check=True, encoding='utf-8', errors='ignore', env=env)
        
        # Clean up temporary file
        os.unlink(temp_file_path)
        
        # Check if the expected output file was created
        if os.path.exists(output_file):
            actual_format = output_file.split('.')[-1].upper()
            click.echo(f"Image saved to: {output_file}")
            click.echo(f"Format: {actual_format}, Size: {width}x{height}")
        else:
            # Check for files with similar names (mermaid-cli sometimes adds numbers)
            import glob
            pattern = output_file.replace('.pdf', '-*.pdf').replace('.png', '-*.png').replace('.svg', '-*.svg')
            matching_files = glob.glob(pattern)
            if matching_files:
                actual_file = matching_files[0]
                actual_format = actual_file.split('.')[-1].upper()
                click.echo(f"Image saved to: {actual_file}")
                click.echo(f"Format: {actual_format}, Size: {width}x{height}")
                click.echo(f"Note: mermaid-cli created {actual_file} instead of {output_file}")
            else:
                click.echo(f"Warning: Expected file {output_file} not found")
        
        click.echo(f"Command output: {result.stdout}")
        
    except subprocess.CalledProcessError as e:
        click.echo(f"Error converting to image: {e}")
        click.echo(f"Error output: {e.stderr}")
        if os.path.exists(temp_file_path):
            os.unlink(temp_file_path)
    except Exception as e:
        click.echo(f"Unexpected error: {e}")
        if 'temp_file_path' in locals() and os.path.exists(temp_file_path):
            os.unlink(temp_file_path)

@click.group()
def cli():
    pass

@cli.command()
@click.option('--java-source-folder', default=os.getenv("JAVA_SOURCE_FOLDER"), help='Path to the Java source project folder.')
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--neo4j-password', default=os.getenv("NEO4J_PASSWORD"), help='Neo4j password')
@click.option('--clean', is_flag=True, help='Wipe the database before analysis.')
@click.option('--class-name', help='Analyze only a specific class (delete existing data for this class first)')
@click.option('--update', is_flag=True, help='Update all classes individually without clearing database')
@click.option('--db_object', is_flag=True, help='Analyze database objects from DDL scripts')
@click.option('--java_object', is_flag=True, help='Analyze Java objects from source code')
@click.option('--dry-run', is_flag=True, help='Parse Java files without connecting to database.')
def analyze(java_source_folder, neo4j_uri, neo4j_user, neo4j_password, clean, class_name, update, db_object, java_object, dry_run):
    """Analyzes a Java project and populates a Neo4j database."""
    if not java_source_folder:
        click.echo("Error: JAVA_SOURCE_FOLDER environment variable or --java-source-folder option is required.", err=True)
        exit(1)

    # Extract project name from directory path
    from pathlib import Path
    project_name = Path(java_source_folder).resolve().name

    # Handle Java object analysis
    if java_object:
        click.echo("Analyzing Java objects from source code...")
        
        if not java_source_folder:
            click.echo("Error: JAVA_SOURCE_FOLDER environment variable is required for --java_object option.", err=True)
            click.echo("Please set JAVA_SOURCE_FOLDER in your .env file or environment variables.")
            exit(1)
        
        if not os.path.exists(java_source_folder):
            click.echo(f"Error: Java source folder {java_source_folder} does not exist.", err=True)
            exit(1)
        
        try:
            # Parse Java project
            click.echo(f"Parsing Java project at: {java_source_folder}")
            packages_to_add, classes_to_add, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, jpa_repositories, jpa_queries, config_files, test_classes, sql_statements, project_name = parse_java_project(java_source_folder)
            
            click.echo(f"Project name: {project_name}")
            click.echo(f"Found {len(packages_to_add)} packages and {len(classes_to_add)} classes.")
            
            if dry_run:
                click.echo("Dry run mode - not connecting to database.")
                click.echo(f"Found {len(packages_to_add)} packages and {len(classes_to_add)} classes.")
                click.echo(f"Found {len(beans)} Spring Beans and {len(dependencies)} dependencies.")
                click.echo(f"Found {len(endpoints)} REST API endpoints.")
                click.echo(f"Found {len(mybatis_mappers)} MyBatis mappers.")
                click.echo(f"Found {len(jpa_entities)} JPA entities.")
                click.echo(f"Found {len(jpa_repositories)} JPA repositories.")
                click.echo(f"Found {len(jpa_queries)} JPA queries.")
                click.echo(f"Found {len(config_files)} configuration files.")
                click.echo(f"Found {len(test_classes)} test classes.")
                click.echo(f"Found {len(sql_statements)} SQL statements.")
                click.echo("Java object analysis complete (dry run).")
                return
            
            # Connect to database
            click.echo(f"Connecting to Neo4j at {neo4j_uri}...")
            db = GraphDB(uri=neo4j_uri, user=neo4j_user, password=neo4j_password)
            
            if clean:
                click.echo("Cleaning Java objects...")
                with db._driver.session() as session:
                    # Delete only Java-related nodes
                    session.run("MATCH (n:Package) DETACH DELETE n")
                    session.run("MATCH (n:Class) DETACH DELETE n")
                    session.run("MATCH (n:Method) DETACH DELETE n")
                    session.run("MATCH (n:Field) DETACH DELETE n")
                    session.run("MATCH (n:Bean) DETACH DELETE n")
                    session.run("MATCH (n:Endpoint) DETACH DELETE n")
                    session.run("MATCH (n:MyBatisMapper) DETACH DELETE n")
                    session.run("MATCH (n:JpaEntity) DETACH DELETE n")
                    session.run("MATCH (n:ConfigFile) DETACH DELETE n")
                    session.run("MATCH (n:TestClass) DETACH DELETE n")
                    session.run("MATCH (n:SqlStatement) DETACH DELETE n")
            
            # Add packages
            click.echo("Adding packages to database...")
            for package_node in packages_to_add:
                db.add_package(package_node, project_name)
            
            # Add classes
            click.echo("Adding classes to database...")
            for class_node in classes_to_add:
                # Find the package for this class using the mapping
                class_key = f"{class_to_package_map.get(class_node.name, '')}.{class_node.name}"
                package_name = class_to_package_map.get(class_key, None)
                
                if not package_name:
                    # Fallback: try to find package by class name
                    for key, pkg_name in class_to_package_map.items():
                        if key.endswith(f".{class_node.name}"):
                            package_name = pkg_name
                            break
                
                db.add_class(class_node, package_name, project_name)
            
            # Add Spring Boot analysis results
            if beans:
                click.echo(f"Adding {len(beans)} Spring Beans to database...")
                for bean in beans:
                    db.add_bean(bean, project_name)
            
            if dependencies:
                click.echo(f"Adding {len(dependencies)} Bean dependencies to database...")
                for dependency in dependencies:
                    db.add_bean_dependency(dependency, project_name)
            
            if endpoints:
                click.echo(f"Adding {len(endpoints)} REST API endpoints to database...")
                for endpoint in endpoints:
                    db.add_endpoint(endpoint, project_name)
            
            if mybatis_mappers:
                click.echo(f"Adding {len(mybatis_mappers)} MyBatis mappers to database...")
                for mapper in mybatis_mappers:
                    db.add_mybatis_mapper(mapper, project_name)
            
            if jpa_entities:
                click.echo(f"Adding {len(jpa_entities)} JPA entities to database...")
                for entity in jpa_entities:
                    db.add_jpa_entity(entity, project_name)
            
            if jpa_repositories:
                click.echo(f"Adding {len(jpa_repositories)} JPA repositories to database...")
                for repository in jpa_repositories:
                    db.add_jpa_repository(repository, project_name)
            
            if jpa_queries:
                click.echo(f"Adding {len(jpa_queries)} JPA queries to database...")
                for query in jpa_queries:
                    db.add_jpa_query(query, project_name)
            
            if config_files:
                click.echo(f"Adding {len(config_files)} configuration files to database...")
                for config_file in config_files:
                    db.add_config_file(config_file, project_name)
            
            if test_classes:
                click.echo(f"Adding {len(test_classes)} test classes to database...")
                for test_class in test_classes:
                    db.add_test_class(test_class, project_name)
            
            if sql_statements:
                click.echo(f"Adding {len(sql_statements)} SQL statements to database...")
                for sql_statement in sql_statements:
                    db.add_sql_statement(sql_statement, project_name)
                    # Create relationship between mapper and SQL statement
                    with db._driver.session() as session:
                        session.execute_write(db._create_mapper_sql_relationship_tx, sql_statement.mapper_name, sql_statement.id, project_name)
            
            db.close()
            click.echo("Java object analysis complete.")
            return
            
        except Exception as e:
            click.echo(f"Error analyzing Java objects: {e}")
            click.echo("Use --dry-run flag to parse without database connection.")
            exit(1)

    # Handle DB object analysis
    if db_object:
        click.echo("Analyzing database objects from DDL scripts...")
        
        # Get DB script folder from environment variable
        db_script_folder = os.getenv("DB_SCRIPT_FOLDER")
        if not db_script_folder:
            click.echo("Error: DB_SCRIPT_FOLDER environment variable is required for --db_object option.", err=True)
            click.echo("Please set DB_SCRIPT_FOLDER in your .env file or environment variables.")
            exit(1)
        
        if not os.path.exists(db_script_folder):
            click.echo(f"Error: DB script folder {db_script_folder} does not exist.", err=True)
            exit(1)
        
        try:
            # Parse DDL files
            db_parser = DBParser()
            all_db_objects = db_parser.parse_ddl_directory(db_script_folder, project_name)
            
            if not all_db_objects:
                click.echo("No DDL files found or parsed successfully.")
                return
            
            click.echo(f"Found {len(all_db_objects)} DDL files to process.")
            
            if dry_run:
                click.echo("Dry run mode - not connecting to database.")
                for i, db_objects in enumerate(all_db_objects):
                    click.echo(f"DDL file {i+1}:")
                    click.echo(f"  Database: {db_objects['database'].name}")
                    click.echo(f"  Tables: {len(db_objects['tables'])}")
                    click.echo(f"  Columns: {len(db_objects['columns'])}")
                    click.echo(f"  Indexes: {len(db_objects['indexes'])}")
                    click.echo(f"  Constraints: {len(db_objects['constraints'])}")
                click.echo("DB object analysis complete (dry run).")
                return
            
            # Connect to database
            click.echo(f"Connecting to Neo4j at {neo4j_uri}...")
            db = GraphDB(uri=neo4j_uri, user=neo4j_user, password=neo4j_password)
            
            if clean:
                click.echo("Cleaning database objects...")
                with db._driver.session() as session:
                    # Delete only database-related nodes
                    session.run("MATCH (n:Database) DETACH DELETE n")
                    session.run("MATCH (n:Table) DETACH DELETE n")
                    session.run("MATCH (n:Column) DETACH DELETE n")
                    session.run("MATCH (n:Index) DETACH DELETE n")
                    session.run("MATCH (n:Constraint) DETACH DELETE n")
            
            # Process each DDL file's objects
            for i, db_objects in enumerate(all_db_objects):
                click.echo(f"Processing DDL file {i+1}...")
                
                # Add database
                click.echo(f"Adding database: {db_objects['database'].name}")
                db.add_database(db_objects['database'], project_name)
                
                # Add tables
                for table_obj in db_objects['tables']:
                    click.echo(f"Adding table: {table_obj.name}")
                    db.add_table(table_obj, db_objects['database'].name, project_name)
                
                # Add columns
                for column_obj in db_objects['columns']:
                    table_name = getattr(column_obj, 'table_name', 'unknown')
                    click.echo(f"Adding column: {column_obj.name} to table {table_name}")
                    db.add_column(column_obj, table_name, project_name)
                
                # Add indexes
                for index_obj, table_name in db_objects['indexes']:
                    click.echo(f"Adding index: {index_obj.name} to table {table_name}")
                    db.add_index(index_obj, table_name, project_name)
                
                # Add constraints
                for constraint_obj, table_name in db_objects['constraints']:
                    click.echo(f"Adding constraint: {constraint_obj.name} to table {table_name}")
                    db.add_constraint(constraint_obj, table_name, project_name)
            
            db.close()
            click.echo("DB object analysis complete.")
            return
            
        except Exception as e:
            click.echo(f"Error analyzing DB objects: {e}")
            click.echo("Use --dry-run flag to parse without database connection.")
            exit(1)

    # If analyzing a specific class
    if class_name:
        click.echo(f"Analyzing specific class: {class_name}")
        
        # Find the Java file for this class
        java_file_path = None
        for root, _, files in os.walk(java_source_folder):
            for file in files:
                if file.endswith(".java") and file.replace(".java", "") == class_name:
                    java_file_path = os.path.join(root, file)
                    break
            if java_file_path:
                break
        
        if not java_file_path:
            click.echo(f"Error: Could not find Java file for class '{class_name}'", err=True)
            exit(1)
        
        click.echo(f"Found Java file: {java_file_path}")
        
        try:
            # Parse the single Java file
            from src.services.java_parser import parse_single_java_file, extract_beans_from_classes, analyze_bean_dependencies, extract_endpoints_from_classes, extract_mybatis_mappers_from_classes, extract_jpa_entities_from_classes, extract_test_classes_from_classes, extract_sql_statements_from_mappers
            
            package_node, class_node, package_name = parse_single_java_file(java_file_path, project_name)
            
            click.echo(f"Parsed class: {class_node.name}")
            click.echo(f"Package: {package_name}")
            click.echo(f"Methods: {len(class_node.methods)}")
            click.echo(f"Properties: {len(class_node.properties)}")
            click.echo(f"Method calls: {len(class_node.calls)}")
            
            if dry_run:
                click.echo("Dry run mode - not connecting to database.")
                click.echo("Analysis complete (dry run).")
                return
            
            # Connect to database
            click.echo(f"Connecting to Neo4j at {neo4j_uri}...")
            db = GraphDB(uri=neo4j_uri, user=neo4j_user, password=neo4j_password)
            
            # Delete existing data for this class
            click.echo(f"Deleting existing data for class '{class_name}'...")
            db.delete_class_and_related_data(class_name, project_name)
            
            # Add package
            click.echo("Adding package to database...")
            db.add_package(package_node, project_name)
            
            # Add class
            click.echo("Adding class to database...")
            db.add_class(class_node, package_name, project_name)
            
            # Extract and add related Spring Boot analysis results for this class only
            classes_list = [class_node]
            beans = extract_beans_from_classes(classes_list)
            dependencies = analyze_bean_dependencies(classes_list, beans)
            endpoints = extract_endpoints_from_classes(classes_list)
            mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
            jpa_entities = extract_jpa_entities_from_classes(classes_list)
            test_classes = extract_test_classes_from_classes(classes_list)
            
            # Extract SQL statements from MyBatis mappers
            sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
            
            # Add Spring Boot analysis results
            if beans:
                click.echo(f"Adding {len(beans)} Spring Beans to database...")
                for bean in beans:
                    db.add_bean(bean, project_name)
            
            if dependencies:
                click.echo(f"Adding {len(dependencies)} Bean dependencies to database...")
                for dependency in dependencies:
                    db.add_bean_dependency(dependency, project_name)
            
            if endpoints:
                click.echo(f"Adding {len(endpoints)} REST API endpoints to database...")
                for endpoint in endpoints:
                    db.add_endpoint(endpoint, project_name)
            
            if mybatis_mappers:
                click.echo(f"Adding {len(mybatis_mappers)} MyBatis mappers to database...")
                for mapper in mybatis_mappers:
                    db.add_mybatis_mapper(mapper, project_name)
            
            if jpa_entities:
                click.echo(f"Adding {len(jpa_entities)} JPA entities to database...")
                for entity in jpa_entities:
                    db.add_jpa_entity(entity, project_name)
            
            if test_classes:
                click.echo(f"Adding {len(test_classes)} test classes to database...")
                for test_class in test_classes:
                    db.add_test_class(test_class, project_name)
            
            if sql_statements:
                click.echo(f"Adding {len(sql_statements)} SQL statements to database...")
                for sql_statement in sql_statements:
                    db.add_sql_statement(sql_statement, project_name)
                    # Create relationship between mapper and SQL statement
                    with db._driver.session() as session:
                        session.execute_write(db._create_mapper_sql_relationship_tx, sql_statement.mapper_name, sql_statement.id, project_name)
            
            db.close()
            click.echo("Class analysis complete.")
            
        except Exception as e:
            click.echo(f"Error analyzing class: {e}")
            click.echo("Use --dry-run flag to parse without database connection.")
            exit(1)
        
        return

    # If updating all classes individually
    if update:
        click.echo("Updating all classes individually...")
        
        # Find all Java files
        java_files = []
        for root, _, files in os.walk(java_source_folder):
            for file in files:
                if file.endswith(".java"):
                    java_files.append(os.path.join(root, file))
        
        if not java_files:
            click.echo("No Java files found in the specified directory.", err=True)
            exit(1)
        
        click.echo(f"Found {len(java_files)} Java files to process.")
        
        if dry_run:
            click.echo("Dry run mode - not connecting to database.")
            for java_file in java_files:
                try:
                    from src.services.java_parser import parse_single_java_file
                    package_node, class_node, package_name = parse_single_java_file(java_file, project_name)
                    click.echo(f"  {class_node.name} ({package_name}) - Methods: {len(class_node.methods)}, Properties: {len(class_node.properties)}")
                except Exception as e:
                    click.echo(f"  Error parsing {java_file}: {e}")
            click.echo("Update analysis complete (dry run).")
            return
        
        try:
            # Connect to database
            click.echo(f"Connecting to Neo4j at {neo4j_uri}...")
            db = GraphDB(uri=neo4j_uri, user=neo4j_user, password=neo4j_password)
            
            processed_count = 0
            error_count = 0
            
            for java_file in java_files:
                try:
                    click.echo(f"Processing: {java_file}")
                    
                    # Parse the single Java file
                    from src.services.java_parser import parse_single_java_file, extract_beans_from_classes, analyze_bean_dependencies, extract_endpoints_from_classes, extract_mybatis_mappers_from_classes, extract_jpa_entities_from_classes, extract_test_classes_from_classes, extract_sql_statements_from_mappers
                    
                    package_node, class_node, package_name = parse_single_java_file(java_file, project_name)
                    
                    click.echo(f"  Parsed class: {class_node.name} (Package: {package_name})")
                    
                    # Delete existing data for this class
                    click.echo(f"  Deleting existing data for class '{class_node.name}'...")
                    db.delete_class_and_related_data(class_node.name, project_name)
                    
                    # Add package
                    db.add_package(package_node, project_name)
                    
                    # Add class
                    db.add_class(class_node, package_name, project_name)
                    
                    # Extract and add related Spring Boot analysis results for this class only
                    classes_list = [class_node]
                    beans = extract_beans_from_classes(classes_list)
                    dependencies = analyze_bean_dependencies(classes_list, beans)
                    endpoints = extract_endpoints_from_classes(classes_list)
                    mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
                    jpa_entities = extract_jpa_entities_from_classes(classes_list)
                    test_classes = extract_test_classes_from_classes(classes_list)
                    
                    # Extract SQL statements from MyBatis mappers
                    sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
                    
                    # Add Spring Boot analysis results
                    if beans:
                        for bean in beans:
                            db.add_bean(bean, project_name)
                    
                    if dependencies:
                        for dependency in dependencies:
                            db.add_bean_dependency(dependency, project_name)
                    
                    if endpoints:
                        for endpoint in endpoints:
                            db.add_endpoint(endpoint, project_name)
                    
                    if mybatis_mappers:
                        for mapper in mybatis_mappers:
                            db.add_mybatis_mapper(mapper, project_name)
                    
                    if jpa_entities:
                        for entity in jpa_entities:
                            db.add_jpa_entity(entity, project_name)
                    
                    if test_classes:
                        for test_class in test_classes:
                            db.add_test_class(test_class, project_name)
                    
                    if sql_statements:
                        for sql_statement in sql_statements:
                            db.add_sql_statement(sql_statement, project_name)
                            # Create relationship between mapper and SQL statement
                            with db._driver.session() as session:
                                session.execute_write(db._create_mapper_sql_relationship_tx, sql_statement.mapper_name, sql_statement.id, project_name)
                    
                    processed_count += 1
                    click.echo(f"  [OK] Successfully processed {class_node.name}")
                    
                except Exception as e:
                    error_count += 1
                    click.echo(f"  [ERROR] Error processing {java_file}: {e}")
                    continue
            
            db.close()
            click.echo(f"Update complete. Processed: {processed_count}, Errors: {error_count}")
            
        except Exception as e:
            click.echo(f"Error during update: {e}")
            click.echo("Use --dry-run flag to parse without database connection.")
            exit(1)
        
        return

    # Original full project analysis (when no specific object type is specified)
    if not java_object and not db_object:
        click.echo(f"Parsing Java project at: {java_source_folder}")
        packages_to_add, classes_to_add, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, jpa_repositories, jpa_queries, config_files, test_classes, sql_statements, project_name = parse_java_project(java_source_folder)
    
        click.echo(f"Project name: {project_name}")
        
        click.echo(f"Found {len(packages_to_add)} packages and {len(classes_to_add)} classes.")
        
        if dry_run:
            click.echo("Dry run mode - not connecting to database.")
            click.echo(f"Found {len(packages_to_add)} packages and {len(classes_to_add)} classes.")
            click.echo(f"Found {len(beans)} Spring Beans and {len(dependencies)} dependencies.")
            click.echo(f"Found {len(endpoints)} REST API endpoints.")
            click.echo(f"Found {len(mybatis_mappers)} MyBatis mappers.")
            click.echo(f"Found {len(jpa_entities)} JPA entities.")
            click.echo(f"Found {len(jpa_repositories)} JPA repositories.")
            click.echo(f"Found {len(jpa_queries)} JPA queries.")
            click.echo(f"Found {len(config_files)} configuration files.")
            click.echo(f"Found {len(test_classes)} test classes.")
            click.echo(f"Found {len(sql_statements)} SQL statements.")
            
            for package_node in packages_to_add:
                click.echo(f"Package: {package_node.name}")
            for class_node in classes_to_add:
                click.echo(f"Class: {class_node.name}")
                click.echo(f"  Methods: {len(class_node.methods)}")
                click.echo(f"  Properties: {len(class_node.properties)}")
                click.echo(f"  Method calls: {len(class_node.calls)}")
            click.echo("Analysis complete (dry run).")
            return

        try:
            click.echo(f"Connecting to Neo4j at {neo4j_uri}...")
            db = GraphDB(uri=neo4j_uri, user=neo4j_user, password=neo4j_password)

            if clean:
                click.echo("Cleaning database...")
                with db._driver.session() as session:
                    session.run("MATCH (n) DETACH DELETE n")

            click.echo("Adding packages to database...")
            for package_node in packages_to_add:
                db.add_package(package_node, project_name)
        
            click.echo("Adding classes to database...")
            for class_node in classes_to_add:
                # Find the package for this class using the mapping
                class_key = f"{class_to_package_map.get(class_node.name, '')}.{class_node.name}"
                package_name = class_to_package_map.get(class_key, None)
                
                if not package_name:
                    # Fallback: try to find package by class name
                    for key, pkg_name in class_to_package_map.items():
                        if key.endswith(f".{class_node.name}"):
                            package_name = pkg_name
                            break
                
                db.add_class(class_node, package_name, project_name)
        
            # Add Spring Boot analysis results
            if beans:
                click.echo(f"Adding {len(beans)} Spring Beans to database...")
                for bean in beans:
                    db.add_bean(bean, project_name)
        
            if dependencies:
                click.echo(f"Adding {len(dependencies)} Bean dependencies to database...")
                for dependency in dependencies:
                    db.add_bean_dependency(dependency, project_name)
        
            if endpoints:
                click.echo(f"Adding {len(endpoints)} REST API endpoints to database...")
                for endpoint in endpoints:
                    db.add_endpoint(endpoint, project_name)
        
            if mybatis_mappers:
                click.echo(f"Adding {len(mybatis_mappers)} MyBatis mappers to database...")
                for mapper in mybatis_mappers:
                    db.add_mybatis_mapper(mapper, project_name)
            
            if jpa_entities:
                click.echo(f"Adding {len(jpa_entities)} JPA entities to database...")
                for entity in jpa_entities:
                    db.add_jpa_entity(entity, project_name)
            
            if jpa_repositories:
                click.echo(f"Adding {len(jpa_repositories)} JPA repositories to database...")
                for repository in jpa_repositories:
                    db.add_jpa_repository(repository, project_name)
            
            if jpa_queries:
                click.echo(f"Adding {len(jpa_queries)} JPA queries to database...")
                for query in jpa_queries:
                    db.add_jpa_query(query, project_name)
            
            if config_files:
                click.echo(f"Adding {len(config_files)} configuration files to database...")
                for config_file in config_files:
                    db.add_config_file(config_file, project_name)
        
            if test_classes:
                click.echo(f"Adding {len(test_classes)} test classes to database...")
                for test_class in test_classes:
                    db.add_test_class(test_class, project_name)
        
            if sql_statements:
                click.echo(f"Adding {len(sql_statements)} SQL statements to database...")
                for sql_statement in sql_statements:
                    db.add_sql_statement(sql_statement, project_name)
                    # Create relationship between mapper and SQL statement
                    with db._driver.session() as session:
                        session.execute_write(db._create_mapper_sql_relationship_tx, sql_statement.mapper_name, sql_statement.id, project_name)
        
            db.close()
            click.echo("Analysis complete.")
        except Exception as e:
            click.echo(f"Error connecting to database: {e}")
            click.echo("Use --dry-run flag to parse without database connection.")
            exit(1)

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--neo4j-password', default=os.getenv("NEO4J_PASSWORD"), help='Neo4j password')
@click.option('--query', help='Custom Cypher query to execute')
@click.option('--basic', is_flag=True, help='Run basic class query')
@click.option('--detailed', is_flag=True, help='Run detailed class query with methods and properties')
@click.option('--inheritance', is_flag=True, help='Run inheritance relationship query')
@click.option('--package', is_flag=True, help='Run package-based class query')
def query(neo4j_uri, neo4j_user, neo4j_password, query, basic, detailed, inheritance, package):
    """Execute queries against the Neo4j database."""
    
    # ÎØ∏Î¶¨ Ï†ïÏùòÎêú ÏøºÎ¶¨Îì§
    queries = {
        'basic': """
        MATCH (c:Class)
        RETURN 
            c.name AS name,
            c.logical_name AS logical_name,
            c.file_path AS file_path,
            c.type AS type,
            c.source AS source
        ORDER BY c.name
        """,
        'detailed': """
        MATCH (c:Class)
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (c)-[:HAS_FIELD]->(p:Field)
        OPTIONAL MATCH (pkg:Package)-[:CONTAINS]->(c)
        RETURN 
            c.name AS class_name,
            c.logical_name AS class_logical_name,
            c.file_path AS file_path,
            c.type AS class_type,
            pkg.name AS package_name,
            collect(DISTINCT m.name) AS methods,
            collect(DISTINCT p.name) AS properties
        ORDER BY c.name
        """,
        'inheritance': """
        MATCH (c:Class)
        OPTIONAL MATCH (c)-[:EXTENDS]->(super:Class)
        OPTIONAL MATCH (c)-[:IMPLEMENTS]->(impl:Class)
        RETURN 
            c.name AS class_name,
            c.logical_name AS class_logical_name,
            c.type AS class_type,
            collect(DISTINCT super.name) AS extends,
            collect(DISTINCT impl.name) AS implements
        ORDER BY c.name
        """,
        'package': """
        MATCH (pkg:Package)-[:CONTAINS]->(c:Class)
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (c)-[:HAS_FIELD]->(p:Field)
        RETURN 
            pkg.name AS package_name,
            pkg.logical_name AS package_logical_name,
            collect(DISTINCT c.name) AS classes,
            count(DISTINCT m) AS total_methods,
            count(DISTINCT p) AS total_properties
        ORDER BY pkg.name
        """
    }
    
    # Ïã§ÌñâÌï† ÏøºÎ¶¨ Í≤∞Ï†ï
    if query:
        cypher_query = query
        description = "Custom Query"
    elif basic:
        cypher_query = queries['basic']
        description = "Basic Class Query"
    elif detailed:
        cypher_query = queries['detailed']
        description = "Detailed Class Query"
    elif inheritance:
        cypher_query = queries['inheritance']
        description = "Inheritance Query"
    elif package:
        cypher_query = queries['package']
        description = "Package Query"
    else:
        click.echo("Error: Please specify a query type or provide a custom query.")
        click.echo("Available options: --basic, --detailed, --inheritance, --package, or --query")
        return
    
    try:
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        
        with driver.session() as session:
            click.echo(f"Executing: {description}")
            click.echo("=" * 50)
            
            result = session.run(cypher_query)
            records = list(result)
            
            if not records:
                click.echo("No results found.")
                return
            
            # Ï≤´ Î≤àÏß∏ Î†àÏΩîÎìúÏùò ÌÇ§Îì§ÏùÑ Ìó§ÎçîÎ°ú ÏÇ¨Ïö©
            headers = list(records[0].keys())
            
            # Ìó§Îçî Ï∂úÎ†•
            click.echo(" | ".join(f"{header:20}" for header in headers))
            click.echo("-" * (len(headers) * 23))
            
            # Îç∞Ïù¥ÌÑ∞ Ï∂úÎ†•
            for record in records:
                row = []
                for header in headers:
                    value = record[header]
                    if value is None:
                        row.append("None")
                    elif isinstance(value, (list, dict)):
                        row.append(str(value)[:50] + "..." if len(str(value)) > 50 else str(value))
                    else:
                        row.append(str(value)[:20])
                click.echo(" | ".join(f"{cell:20}" for cell in row))
            
            click.echo(f"\nTotal: {len(records)} results found.")
            
    except Exception as e:
        click.echo(f"Error executing query: {e}")
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--class-name', required=True, help='Name of the class to analyze')
@click.option('--method-name', help='Specific method to analyze (optional)')
@click.option('--max-depth', default=3, help='Maximum depth of call chain to follow (default: 3)')
@click.option('--include-external', is_flag=True, help='Include calls to external libraries')
@click.option('--method-focused', is_flag=True, help='Generate method-focused diagram (shows only the specified method and its direct calls)')
@click.option('--output-file', help='Output file to save the diagram (optional)')
@click.option('--output-image', help='Output image file (PNG/SVG/PDF) - requires mermaid-cli')
@click.option('--image-format', default='png', type=click.Choice(['png', 'svg', 'pdf']), help='Image format (default: png)')
@click.option('--image-width', default=1200, help='Image width in pixels (default: 1200)')
@click.option('--image-height', default=800, help='Image height in pixels (default: 800)')
def sequence(neo4j_uri, neo4j_user, class_name, method_name, max_depth, include_external, method_focused, output_file, output_image, image_format, image_width, image_height):
    """Generate sequence diagram for a specific class and optionally a method."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        click.echo(f"Connecting to Neo4j at {neo4j_uri}...")
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        generator = SequenceDiagramGenerator(driver)
        
        # Generate the sequence diagram
        click.echo(f"Generating sequence diagram for class: {class_name}")
        if method_name:
            click.echo(f"Focusing on method: {method_name}")
        if method_focused:
            click.echo("Method-focused mode: showing only direct calls from the specified method")
        
        diagram = generator.generate_sequence_diagram(
            class_name=class_name,
            method_name=method_name,
            max_depth=max_depth if not method_focused else 1,  # Method-focused uses depth 1
            include_external_calls=include_external,
            method_focused=method_focused
        )
        
        click.echo(f"Diagram generated (length: {len(diagram)})")
        
        # Check if diagram contains error message
        if diagram.startswith("Error:"):
            click.echo(f"Error: {diagram}")
            return
        
        # Output the diagram
        if output_file:
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(diagram)
            click.echo(f"Sequence diagram saved to: {output_file}")
        else:
            # Default: save to {class_name}.md
            default_filename = f"{class_name}.md"
            with open(default_filename, 'w', encoding='utf-8') as f:
                f.write(diagram)
            click.echo(f"Sequence diagram saved to: {default_filename}")
            
            click.echo("\n" + "="*50)
            click.echo("SEQUENCE DIAGRAM")
            click.echo("="*50)
            click.echo(diagram)
            click.echo("="*50)
        
        # Convert to image if requested
        if output_image:
            convert_to_image(diagram, output_image, image_format, image_width, image_height)
        
    except Exception as e:
        click.echo(f"Error generating sequence diagram: {e}")
        import traceback
        click.echo(f"Traceback: {traceback.format_exc()}")
        exit(1)
    finally:
        if 'driver' in locals():
            driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
def list_classes(neo4j_uri, neo4j_user):
    """List all available classes in the database."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        generator = SequenceDiagramGenerator(driver)
        
        classes = generator.get_available_classes()
        
        if not classes:
            click.echo("No classes found in the database.")
            return
        
        click.echo("Available classes:")
        click.echo("=" * 80)
        click.echo(f"{'Class Name':<30} {'Package':<30} {'Type':<10}")
        click.echo("-" * 80)
        
        for cls in classes:
            click.echo(f"{cls['name']:<30} {cls['package_name']:<30} {cls['type']:<10}")
        
        click.echo(f"\nTotal: {len(classes)} classes found.")
        
    except Exception as e:
        click.echo(f"Error listing classes: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--class-name', required=True, help='Name of the class to list methods for')
def list_methods(neo4j_uri, neo4j_user, class_name):
    """List all methods for a specific class."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        generator = SequenceDiagramGenerator(driver)
        
        methods = generator.get_class_methods(class_name)
        
        if not methods:
            click.echo(f"No methods found for class '{class_name}'.")
            return
        
        click.echo(f"Methods for class '{class_name}':")
        click.echo("=" * 80)
        click.echo(f"{'Method Name':<30} {'Return Type':<20} {'Logical Name':<30}")
        click.echo("-" * 80)
        
        for method in methods:
            click.echo(f"{method['name']:<30} {method['return_type']:<20} {method['logical_name']:<30}")
        
        click.echo(f"\nTotal: {len(methods)} methods found.")
        
    except Exception as e:
        click.echo(f"Error listing methods: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--project-name', help='Project name to filter by (optional)')
def crud_matrix(neo4j_uri, neo4j_user, project_name):
    """Show CRUD matrix for classes and tables."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        db = GraphDB(neo4j_uri, neo4j_user, neo4j_password)
        
        click.echo("CRUD Matrix - Class to Table Operations")
        click.echo("=" * 80)
        
        matrix = db.get_crud_matrix(project_name)
        
        if not matrix:
            click.echo("No CRUD operations found.")
            return
        
        click.echo(f"{'Class Name':<30} {'Package':<25} {'Tables':<20} {'Operations':<15}")
        click.echo("-" * 80)
        
        for row in matrix:
            class_name = row['class_name']
            package_name = row['package_name'] or 'N/A'
            tables = ', '.join(row['tables']) if row['tables'] else 'None'
            operations = ', '.join(row['operations']) if row['operations'] else 'None'
            
            click.echo(f"{class_name:<30} {package_name:<25} {tables:<20} {operations:<15}")
        
        click.echo(f"\nTotal: {len(matrix)} classes with CRUD operations.")
        
    except Exception as e:
        click.echo(f"Error getting CRUD matrix: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--project-name', help='Project name to filter by (optional)')
def db_analysis(neo4j_uri, neo4j_user, project_name):
    """Show database call relationship analysis."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        db = GraphDB(neo4j_uri, neo4j_user, neo4j_password)
        
        click.echo("Database Call Relationship Analysis")
        click.echo("=" * 80)
        
        # SQL Î¨∏ ÌÜµÍ≥Ñ
        sql_stats = db.get_sql_statistics(project_name)
        if sql_stats:
            click.echo(f"\nSQL Statistics:")
            click.echo(f"  Total SQL statements: {sql_stats['total_sql']}")
            click.echo(f"  SELECT statements: {sql_stats.get('SELECT', 0)}")
            click.echo(f"  INSERT statements: {sql_stats.get('INSERT', 0)}")
            click.echo(f"  UPDATE statements: {sql_stats.get('UPDATE', 0)}")
            click.echo(f"  DELETE statements: {sql_stats.get('DELETE', 0)}")
        
        # ÌÖåÏù¥Î∏î ÏÇ¨Ïö© ÌÜµÍ≥Ñ
        table_stats = db.get_table_usage_statistics(project_name)
        if table_stats:
            click.echo(f"\nTable Usage Statistics:")
            click.echo(f"{'Table Name':<30} {'Access Count':<15} {'Operations':<20}")
            click.echo("-" * 65)
            for table in table_stats:
                table_name = table['table_name']
                access_count = table['access_count']
                operations = ', '.join(table['operations'])
                click.echo(f"{table_name:<30} {access_count:<15} {operations:<20}")
        
        # Î≥µÏû°ÎèÑ Î∂ÑÏÑù
        complexity_stats = db.get_sql_complexity_statistics(project_name)
        if complexity_stats:
            click.echo(f"\nSQL Complexity Analysis:")
            click.echo(f"  Simple queries: {complexity_stats.get('simple', 0)}")
            click.echo(f"  Medium queries: {complexity_stats.get('medium', 0)}")
            click.echo(f"  Complex queries: {complexity_stats.get('complex', 0)}")
            click.echo(f"  Very complex queries: {complexity_stats.get('very_complex', 0)}")
        
        # Îß§ÌçºÎ≥Ñ SQL Î∂ÑÌè¨
        mapper_stats = db.get_mapper_sql_distribution(project_name)
        if mapper_stats:
            click.echo(f"\nMapper SQL Distribution:")
            click.echo(f"{'Mapper Name':<30} {'SQL Count':<15} {'SQL Types':<20}")
            click.echo("-" * 65)
            for mapper in mapper_stats:
                mapper_name = mapper['mapper_name']
                sql_count = mapper['sql_count']
                sql_types = ', '.join(mapper['sql_types'])
                click.echo(f"{mapper_name:<30} {sql_count:<15} {sql_types:<20}")
        
    except Exception as e:
        click.echo(f"Error getting database analysis: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--project-name', help='Project name to filter by (optional)')
def table_summary(neo4j_uri, neo4j_user, project_name):
    """Show CRUD summary for each table."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        db = GraphDB(neo4j_uri, neo4j_user, neo4j_password)
        
        click.echo("Table CRUD Summary")
        click.echo("=" * 60)
        
        summary = db.get_table_crud_summary(project_name)
        
        if not summary:
            click.echo("No tables found.")
            return
        
        for row in summary:
            table_name = row['table_name']
            operations = row['operations']
            
            click.echo(f"\nTable: {table_name}")
            click.echo("-" * 40)
            
            for op in operations:
                operation = op['operation']
                count = op['count']
                click.echo(f"  {operation}: {count} statements")
        
        click.echo(f"\nTotal: {len(summary)} tables.")
        
    except Exception as e:
        click.echo(f"Error getting table summary: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--project-name', required=True, help='Project name to analyze')
@click.option('--start-class', help='Starting class for call chain analysis (optional)')
@click.option('--start-method', help='Starting method for call chain analysis (optional)')
@click.option('--output-file', help='Output file to save the analysis results (optional)')
def db_call_chain(neo4j_uri, neo4j_user, project_name, start_class, start_method, output_file):
    """Analyze database call chain relationships."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        analysis_service = DBCallAnalysisService(driver)
        
        click.echo("Database Call Chain Analysis")
        click.echo("=" * 50)
        
        if start_class and start_method:
            click.echo(f"Analyzing call chain from {start_class}.{start_method}")
        elif start_class:
            click.echo(f"Analyzing call chain from class {start_class}")
        else:
            click.echo(f"Analyzing call chain for project {project_name}")
        
        # Î∂ÑÏÑù Ïã§Ìñâ
        result = analysis_service.analyze_call_chain(project_name, start_class, start_method)
        
        if 'error' in result:
            click.echo(f"Error: {result['error']}")
            return
        
        # Í≤∞Í≥º Ï∂úÎ†•
        call_chain = result['call_chain']
        missing_nodes = result['missing_nodes']
        summary = result['analysis_summary']
        
        click.echo(f"\nAnalysis Summary:")
        click.echo(f"  Total calls: {summary['total_calls']}")
        click.echo(f"  Unique classes: {summary['unique_classes']}")
        click.echo(f"  Unique methods: {summary['unique_methods']}")
        click.echo(f"  Unique SQL statements: {summary['unique_sql_statements']}")
        click.echo(f"  Unique tables: {summary['unique_tables']}")
        click.echo(f"  Unique columns: {summary['unique_columns']}")
        click.echo(f"  Missing tables: {summary['missing_tables_count']}")
        click.echo(f"  Missing columns: {summary['missing_columns_count']}")
        
        if missing_nodes['missing_tables']:
            click.echo(f"\nMissing Tables (‚ùå):")
            for table in missing_nodes['missing_tables']:
                click.echo(f"  - {table}")
        
        if missing_nodes['missing_columns']:
            click.echo(f"\nMissing Columns (‚ùå):")
            for column in missing_nodes['missing_columns']:
                click.echo(f"  - {column}")
        
        # Ìò∏Ï∂ú Ï≤¥Ïù∏ ÏÉÅÏÑ∏ Ï†ïÎ≥¥
        if call_chain:
            click.echo(f"\nCall Chain Details:")
            click.echo("-" * 80)
            click.echo(f"{'Source':<25} {'Target':<25} {'SQL Type':<10} {'Table':<20}")
            click.echo("-" * 80)
            
            for call in call_chain[:20]:  # Ï≤òÏùå 20Í∞úÎßå ÌëúÏãú
                source = f"{call['source_class']}.{call['source_method']}" if call['source_method'] else call['source_class']
                target = f"{call['target_class']}.{call['target_method']}" if call['target_method'] else call['target_class']
                sql_type = call['sql_type'] or 'N/A'
                table = call['table_name'] or 'N/A'
                
                click.echo(f"{source:<25} {target:<25} {sql_type:<10} {table:<20}")
            
            if len(call_chain) > 20:
                click.echo(f"... and {len(call_chain) - 20} more calls")
        
        # ÌååÏùºÎ°ú Ï†ÄÏû•
        if output_file:
            import json
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(result, f, indent=2, ensure_ascii=False)
            click.echo(f"\nAnalysis results saved to: {output_file}")
        
    except Exception as e:
        click.echo(f"Error analyzing call chain: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--project-name', required=True, help='Project name to analyze')
@click.option('--output-file', help='Output file to save the CRUD matrix (optional)')
def crud_analysis(neo4j_uri, neo4j_user, project_name, output_file):
    """Generate CRUD matrix analysis."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        analysis_service = DBCallAnalysisService(driver)
        
        click.echo("CRUD Matrix Analysis")
        click.echo("=" * 50)
        
        # CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
        result = analysis_service.generate_crud_matrix(project_name)
        
        if 'error' in result:
            click.echo(f"Error: {result['error']}")
            return
        
        class_matrix = result['class_matrix']
        table_matrix = result['table_matrix']
        summary = result['summary']
        
        click.echo(f"\nCRUD Summary:")
        click.echo(f"  Total classes: {summary['total_classes']}")
        click.echo(f"  Total tables: {summary['total_tables']}")
        click.echo(f"  Create operations: {summary['crud_stats']['C']}")
        click.echo(f"  Read operations: {summary['crud_stats']['R']}")
        click.echo(f"  Update operations: {summary['crud_stats']['U']}")
        click.echo(f"  Delete operations: {summary['crud_stats']['D']}")
        click.echo(f"  Other operations: {summary['crud_stats']['O']}")
        
        if summary['most_active_class']:
            click.echo(f"  Most active class: {summary['most_active_class']}")
        if summary['most_used_table']:
            click.echo(f"  Most used table: {summary['most_used_table']}")
        
        # ÌÅ¥ÎûòÏä§Î≥Ñ CRUD Îß§Ìä∏Î¶≠Ïä§
        if class_matrix:
            click.echo(f"\nClass CRUD Matrix:")
            click.echo("-" * 80)
            click.echo(f"{'Class Name':<30} {'Package':<25} {'Tables':<20} {'Operations':<15}")
            click.echo("-" * 80)
            
            for row in class_matrix:
                class_name = row['class_name']
                package_name = row['package_name'] or 'N/A'
                tables = ', '.join(row['tables']) if row['tables'] else 'None'
                operations = ', '.join(row['operations']) if row['operations'] else 'None'
                
                click.echo(f"{class_name:<30} {package_name:<25} {tables:<20} {operations:<15}")
        
        # ÌÖåÏù¥Î∏îÎ≥Ñ CRUD Îß§Ìä∏Î¶≠Ïä§
        if table_matrix:
            click.echo(f"\nTable CRUD Matrix:")
            click.echo("-" * 60)
            click.echo(f"{'Table Name':<30} {'Operations':<30}")
            click.echo("-" * 60)
            
            for row in table_matrix:
                table_name = row['table_name']
                operations = []
                for op in row['operations']:
                    operations.append(f"{op['operation']}({op['count']})")
                operations_str = ', '.join(operations)
                
                click.echo(f"{table_name:<30} {operations_str:<30}")
        
        # ÌååÏùºÎ°ú Ï†ÄÏû•
        if output_file:
            import json
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(result, f, indent=2, ensure_ascii=False)
            click.echo(f"\nCRUD matrix saved to: {output_file}")
        
    except Exception as e:
        click.echo(f"Error generating CRUD matrix: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--project-name', required=True, help='Project name to analyze')
@click.option('--start-class', help='Starting class for diagram (optional)')
@click.option('--start-method', help='Starting method for diagram (optional)')
@click.option('--output-file', help='Output file to save the diagram (optional)')
@click.option('--output-image', help='Output image file (PNG/SVG/PDF) - requires mermaid-cli')
@click.option('--image-format', default='png', type=click.Choice(['png', 'svg', 'pdf']), help='Image format (default: png)')
@click.option('--image-width', default=1200, help='Image width in pixels (default: 1200)')
@click.option('--image-height', default=800, help='Image height in pixels (default: 800)')
def db_call_diagram(neo4j_uri, neo4j_user, project_name, start_class, start_method, output_file, output_image, image_format, image_width, image_height):
    """Generate database call chain diagram."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        analysis_service = DBCallAnalysisService(driver)
        
        click.echo("Database Call Chain Diagram")
        click.echo("=" * 50)
        
        if start_class and start_method:
            click.echo(f"Generating diagram from {start_class}.{start_method}")
        elif start_class:
            click.echo(f"Generating diagram from class {start_class}")
        else:
            click.echo(f"Generating diagram for project {project_name}")
        
        # Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏÉùÏÑ±
        diagram = analysis_service.generate_call_chain_diagram(project_name, start_class, start_method)
        
        if diagram.startswith("Ïò§Î•ò:"):
            click.echo(f"Error: {diagram}")
            return
        
        # ÌååÏùºÎ°ú Ï†ÄÏû•
        if output_file:
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(diagram)
            click.echo(f"Diagram saved to: {output_file}")
        else:
            # Í∏∞Î≥∏ ÌååÏùºÎ™ÖÏúºÎ°ú Ï†ÄÏû•
            default_filename = f"db_call_chain_{project_name}.md"
            with open(default_filename, 'w', encoding='utf-8') as f:
                f.write(diagram)
            click.echo(f"Diagram saved to: {default_filename}")
        
        # Ïù¥ÎØ∏ÏßÄÎ°ú Î≥ÄÌôò
        if output_image:
            convert_to_image(diagram, output_image, image_format, image_width, image_height)
        
        # Îã§Ïù¥Ïñ¥Í∑∏Îû® ÎØ∏Î¶¨Î≥¥Í∏∞
        click.echo("\n" + "="*50)
        click.echo("DATABASE CALL CHAIN DIAGRAM")
        click.echo("="*50)
        click.echo(diagram)
        click.echo("="*50)
        
    except Exception as e:
        click.echo(f"Error generating diagram: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--project-name', required=True, help='Project name to analyze')
@click.option('--table-name', required=True, help='Table name to analyze impact for')
@click.option('--output-file', help='Output file to save the impact analysis (optional)')
def table_impact(neo4j_uri, neo4j_user, project_name, table_name, output_file):
    """Analyze impact of table changes on application code."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        analysis_service = DBCallAnalysisService(driver)
        
        click.echo("Table Impact Analysis")
        click.echo("=" * 50)
        click.echo(f"Analyzing impact of changes to table: {table_name}")
        
        # ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù
        result = analysis_service.analyze_table_impact(project_name, table_name)
        
        if 'error' in result:
            click.echo(f"Error: {result['error']}")
            return
        
        impacted_classes = result['impacted_classes']
        summary = result['summary']
        
        click.echo(f"\nImpact Summary:")
        click.echo(f"  Table: {summary['table_name']}")
        click.echo(f"  Impacted classes: {summary['total_impacted_classes']}")
        click.echo(f"  Impacted methods: {summary['total_impacted_methods']}")
        click.echo(f"  SQL statements: {summary['total_sql_statements']}")
        click.echo(f"  CRUD operations: {', '.join(summary['crud_operations'])}")
        
        if summary['high_complexity_sql']:
            click.echo(f"  High complexity SQL: {len(summary['high_complexity_sql'])}")
        
        # ÏòÅÌñ•Î∞õÎäî ÌÅ¥ÎûòÏä§ ÏÉÅÏÑ∏ Ï†ïÎ≥¥
        if impacted_classes:
            click.echo(f"\nImpacted Classes:")
            click.echo("-" * 80)
            click.echo(f"{'Class':<25} {'Method':<25} {'SQL Type':<10} {'Complexity':<12}")
            click.echo("-" * 80)
            
            for cls in impacted_classes:
                class_name = cls['class_name']
                method_name = cls['method_name'] or 'N/A'
                sql_type = cls['sql_type'] or 'N/A'
                complexity = str(cls['complexity_score']) if cls['complexity_score'] else 'N/A'
                
                click.echo(f"{class_name:<25} {method_name:<25} {sql_type:<10} {complexity:<12}")
        
        # Í≥†Î≥µÏû°ÎèÑ SQL ÏÉÅÏÑ∏ Ï†ïÎ≥¥
        if summary['high_complexity_sql']:
            click.echo(f"\nHigh Complexity SQL Statements:")
            click.echo("-" * 60)
            for sql in summary['high_complexity_sql']:
                click.echo(f"  {sql['class_name']}.{sql['method_name']} - {sql['sql_type']} (complexity: {sql['complexity_score']})")
        
        # ÌååÏùºÎ°ú Ï†ÄÏû•
        if output_file:
            import json
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(result, f, indent=2, ensure_ascii=False)
            click.echo(f"\nImpact analysis saved to: {output_file}")
        
    except Exception as e:
        click.echo(f"Error analyzing table impact: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--project-name', required=True, help='Project name to analyze')
@click.option('--output-file', help='Output file to save the statistics (optional)')
def db_statistics(neo4j_uri, neo4j_user, project_name, output_file):
    """Show database usage statistics."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        analysis_service = DBCallAnalysisService(driver)
        
        click.echo("Database Usage Statistics")
        click.echo("=" * 50)
        
        # ÌÜµÍ≥Ñ Ï°∞Ìöå
        result = analysis_service.get_database_usage_statistics(project_name)
        
        if 'error' in result:
            click.echo(f"Error: {result['error']}")
            return
        
        sql_stats = result['sql_statistics']
        table_usage = result['table_usage']
        complexity_stats = result['complexity_statistics']
        
        # SQL ÌÜµÍ≥Ñ
        if sql_stats:
            click.echo(f"\nSQL Statistics:")
            click.echo(f"  Total SQL statements: {sql_stats['total_sql']}")
            click.echo(f"  SELECT statements: {sql_stats.get('SELECT', 0)}")
            click.echo(f"  INSERT statements: {sql_stats.get('INSERT', 0)}")
            click.echo(f"  UPDATE statements: {sql_stats.get('UPDATE', 0)}")
            click.echo(f"  DELETE statements: {sql_stats.get('DELETE', 0)}")
        
        # ÌÖåÏù¥Î∏î ÏÇ¨Ïö© ÌÜµÍ≥Ñ
        if table_usage:
            click.echo(f"\nTable Usage Statistics:")
            click.echo("-" * 60)
            click.echo(f"{'Table Name':<30} {'Access Count':<15} {'Operations':<20}")
            click.echo("-" * 60)
            
            for table in table_usage:
                table_name = table['table_name']
                access_count = table['access_count']
                operations = ', '.join(table['operations'])
                click.echo(f"{table_name:<30} {access_count:<15} {operations:<20}")
        
        # Î≥µÏû°ÎèÑ ÌÜµÍ≥Ñ
        if complexity_stats:
            click.echo(f"\nSQL Complexity Statistics:")
            click.echo(f"  Simple queries: {complexity_stats.get('simple', 0)}")
            click.echo(f"  Medium queries: {complexity_stats.get('medium', 0)}")
            click.echo(f"  Complex queries: {complexity_stats.get('complex', 0)}")
            click.echo(f"  Very complex queries: {complexity_stats.get('very_complex', 0)}")
        
        # ÌååÏùºÎ°ú Ï†ÄÏû•
        if output_file:
            import json
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(result, f, indent=2, ensure_ascii=False)
            click.echo(f"\nStatistics saved to: {output_file}")
        
    except Exception as e:
        click.echo(f"Error getting database statistics: {e}")
        exit(1)
    finally:
        driver.close()

if __name__ == '__main__':
    cli()

```

Ïù¥Ï†ú Î¶∞ÌÑ∞ Ïò§Î•òÎ•º ÌôïÏù∏ÌïòÍ≥† ÏàòÏ†ïÌïòÍ≤†ÏäµÎãàÎã§.


Ïù¥Ï†ú ÌÖåÏä§Ìä∏Î•º ÏúÑÌïú ÏÉòÌîå ÌîÑÎ°úÏ†ùÌä∏Î•º ÌôïÏù∏ÌïòÍ≥† Ïã§Ï†úÎ°ú ÎèôÏûëÌïòÎäîÏßÄ ÌÖåÏä§Ìä∏Ìï¥Î≥¥Í≤†ÏäµÎãàÎã§.


ÏôÑÎ≤ΩÌï©ÎãàÎã§! ÏÉàÎ°úÏö¥ CLI Î™ÖÎ†πÏñ¥Îì§Ïù¥ Î™®Îëê Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§. Ïù¥Ï†ú ÏÇ¨Ïö©Î≤ïÏùÑ Î≥¥Ïó¨Ï£ºÎäî Í∞ÑÎã®Ìïú ÏòàÏ†úÎ•º ÎßåÎì§Ïñ¥Î≥¥Í≤†ÏäµÎãàÎã§.


```markdown
# Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ìò∏Ï∂úÍ¥ÄÍ≥Ñ Î∂ÑÏÑù Í∏∞Îä• ÏÇ¨Ïö©Î≤ï

## Í∞úÏöî

3Îã®Í≥ÑÏóêÏÑú Íµ¨ÌòÑÎêú Ïñ¥ÌîåÎ¶¨ÏºÄÏù¥ÏÖò-Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ìò∏Ï∂úÍ¥ÄÍ≥Ñ ÏãúÍ∞ÅÌôî Í∏∞Îä•Ïùò ÏÇ¨Ïö©Î≤ïÏùÑ ÏÑ§Î™ÖÌï©ÎãàÎã§.

## ÏÉàÎ°úÏö¥ CLI Î™ÖÎ†πÏñ¥Îì§

### 1. `db-call-chain` - Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù

Controller ‚Üí Service ‚Üí Repository ‚Üí SQL ‚Üí Table/Column Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Î∂ÑÏÑùÌï©ÎãàÎã§.

```bash
# Ï†ÑÏ≤¥ ÌîÑÎ°úÏ†ùÌä∏ Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù
python -m src.cli.main db-call-chain --project-name myproject

# ÌäπÏ†ï ÌÅ¥ÎûòÏä§Î∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù
python -m src.cli.main db-call-chain --project-name myproject --start-class UserController

# ÌäπÏ†ï Î©îÏÑúÎìúÎ∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù
python -m src.cli.main db-call-chain --project-name myproject --start-class UserController --start-method getUserById

# Í≤∞Í≥ºÎ•º ÌååÏùºÎ°ú Ï†ÄÏû•
python -m src.cli.main db-call-chain --project-name myproject --output-file call_chain_analysis.json
```

### 2. `crud-analysis` - CRUD Îß§Ìä∏Î¶≠Ïä§ Î∂ÑÏÑù

ÌÅ¥ÎûòÏä§ÏôÄ ÌÖåÏù¥Î∏î Í∞ÑÏùò CRUD ÏûëÏóÖ Îß§Ìä∏Î¶≠Ïä§Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§.

```bash
# CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
python -m src.cli.main crud-analysis --project-name myproject

# Í≤∞Í≥ºÎ•º ÌååÏùºÎ°ú Ï†ÄÏû•
python -m src.cli.main crud-analysis --project-name myproject --output-file crud_matrix.json
```

### 3. `db-call-diagram` - Ìò∏Ï∂ú Í¥ÄÍ≥Ñ Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏÉùÏÑ±

Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû®ÏúºÎ°ú Ìò∏Ï∂ú Í¥ÄÍ≥ÑÎ•º ÏãúÍ∞ÅÌôîÌï©ÎãàÎã§.

```bash
# Ï†ÑÏ≤¥ ÌîÑÎ°úÏ†ùÌä∏ Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏÉùÏÑ±
python -m src.cli.main db-call-diagram --project-name myproject

# ÌäπÏ†ï ÌÅ¥ÎûòÏä§Î∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏÉùÏÑ±
python -m src.cli.main db-call-diagram --project-name myproject --start-class UserController

# ÌäπÏ†ï Î©îÏÑúÎìúÎ∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏÉùÏÑ±
python -m src.cli.main db-call-diagram --project-name myproject --start-class UserController --start-method getUserById

# Îã§Ïù¥Ïñ¥Í∑∏Îû®ÏùÑ Ïù¥ÎØ∏ÏßÄÎ°ú Î≥ÄÌôò (mermaid-cli ÌïÑÏöî)
python -m src.cli.main db-call-diagram --project-name myproject --output-image diagram.png --image-format png

# Í≤∞Í≥ºÎ•º ÌååÏùºÎ°ú Ï†ÄÏû•
python -m src.cli.main db-call-diagram --project-name myproject --output-file call_chain_diagram.md
```

### 4. `table-impact` - ÌÖåÏù¥Î∏î ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù

ÌäπÏ†ï ÌÖåÏù¥Î∏î Î≥ÄÍ≤Ω Ïãú ÏòÅÌñ•Î∞õÎäî ÌÅ¥ÎûòÏä§/Î©îÏÑúÎìúÎ•º Î∂ÑÏÑùÌï©ÎãàÎã§.

```bash
# ÌäπÏ†ï ÌÖåÏù¥Î∏îÏùò ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù
python -m src.cli.main table-impact --project-name myproject --table-name users

# Í≤∞Í≥ºÎ•º ÌååÏùºÎ°ú Ï†ÄÏû•
python -m src.cli.main table-impact --project-name myproject --table-name users --output-file table_impact_analysis.json
```

### 5. `db-statistics` - Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÇ¨Ïö© ÌÜµÍ≥Ñ

Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÇ¨Ïö© ÌÜµÍ≥ÑÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.

```bash
# Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÇ¨Ïö© ÌÜµÍ≥Ñ Ï°∞Ìöå
python -m src.cli.main db-statistics --project-name myproject

# Í≤∞Í≥ºÎ•º ÌååÏùºÎ°ú Ï†ÄÏû•
python -m src.cli.main db-statistics --project-name myproject --output-file db_statistics.json
```

## Ï£ºÏöî Í∏∞Îä•

### 1. Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Table/Column ÎÖ∏Îìú ÏãùÎ≥Ñ

SQLÏóêÏÑú Ï∞∏Ï°∞ÌïòÎäî ÌÖåÏù¥Î∏îÏù¥ÎÇò Ïª¨ÎüºÏù¥ Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Í≤ΩÏö∞, Îã§ÏùåÍ≥º Í∞ôÏù¥ ÌëúÏãúÎê©ÎãàÎã§:

- **‚ùå ÌÖåÏù¥Î∏îÎ™Ö** - Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî ÌÖåÏù¥Î∏î
- **‚ùå Ïª¨ÎüºÎ™Ö** - Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Ïª¨Îüº

Îã§Ïù¥Ïñ¥Í∑∏Îû®ÏóêÏÑúÎäî Ï†ÅÏÉâ Ï†êÏÑ†ÏúºÎ°ú Ïó∞Í≤∞ÎêòÏñ¥ ÏãúÍ∞ÅÏ†ÅÏúºÎ°ú Íµ¨Î∂ÑÎê©ÎãàÎã§.

### 2. Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù

- Controller ‚Üí Service ‚Üí Repository ‚Üí SQL ‚Üí Table/Column Ï†ÑÏ≤¥ Ìò∏Ï∂ú Ï≤¥Ïù∏ Ï∂îÏ†Å
- Í∞Å Îã®Í≥ÑÎ≥Ñ ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Ï†úÍ≥µ
- ÎàÑÎùΩÎêú ÎÖ∏Îìú ÏûêÎèô ÏãùÎ≥Ñ

### 3. CRUD Îß§Ìä∏Î¶≠Ïä§

- ÌÅ¥ÎûòÏä§Î≥Ñ ÌÖåÏù¥Î∏î Ï†ëÍ∑º ÌòÑÌô©
- ÌÖåÏù¥Î∏îÎ≥Ñ CRUD ÏûëÏóÖ ÌÜµÍ≥Ñ
- Í∞ÄÏû• ÌôúÎ∞úÌïú ÌÅ¥ÎûòÏä§/ÌÖåÏù¥Î∏î ÏãùÎ≥Ñ

### 4. ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù

- ÌäπÏ†ï ÌÖåÏù¥Î∏î Î≥ÄÍ≤Ω Ïãú ÏòÅÌñ•Î∞õÎäî ÏΩîÎìú ÏúÑÏπò
- Í≥†Î≥µÏû°ÎèÑ SQL ÏãùÎ≥Ñ
- ÏòÅÌñ•Î∞õÎäî ÌÅ¥ÎûòÏä§/Î©îÏÑúÎìú Î™©Î°ù

### 5. ÏãúÍ∞ÅÌôî

- Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû®ÏúºÎ°ú Ìò∏Ï∂ú Í¥ÄÍ≥Ñ ÏãúÍ∞ÅÌôî
- Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî ÎÖ∏ÎìúÎäî Ï†ÅÏÉâ Ï†êÏÑ†ÏúºÎ°ú ÌëúÏãú
- Ïù¥ÎØ∏ÏßÄ Î≥ÄÌôò ÏßÄÏõê (PNG, SVG, PDF)

## ÏÇ¨Ïö© ÏòàÏãú

### 1. Ï†ÑÏ≤¥ ÌîÑÎ°úÏ†ùÌä∏ Î∂ÑÏÑù

```bash
# 1. Java Í∞ùÏ≤¥ Î∂ÑÏÑù
python -m src.cli.main analyze --java_object --java-source-folder ./src/main/java

# 2. DB Í∞ùÏ≤¥ Î∂ÑÏÑù
python -m src.cli.main analyze --db_object --db-script-folder ./sql

# 3. Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù
python -m src.cli.main db-call-chain --project-name myproject

# 4. CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
python -m src.cli.main crud-analysis --project-name myproject

# 5. Ìò∏Ï∂ú Í¥ÄÍ≥Ñ Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏÉùÏÑ±
python -m src.cli.main db-call-diagram --project-name myproject --output-image db_call_chain.png
```

### 2. ÌäπÏ†ï ÌÖåÏù¥Î∏î ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù

```bash
# users ÌÖåÏù¥Î∏î Î≥ÄÍ≤Ω Ïãú ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù
python -m src.cli.main table-impact --project-name myproject --table-name users

# Í≤∞Í≥ºÎ•º ÌååÏùºÎ°ú Ï†ÄÏû•
python -m src.cli.main table-impact --project-name myproject --table-name users --output-file users_impact.json
```

### 3. ÌäπÏ†ï ÌÅ¥ÎûòÏä§ Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù

```bash
# UserController ÌÅ¥ÎûòÏä§Ïùò Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù
python -m src.cli.main db-call-chain --project-name myproject --start-class UserController

# getUserById Î©îÏÑúÎìúÏùò Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù
python -m src.cli.main db-call-chain --project-name myproject --start-class UserController --start-method getUserById
```

## Ï∂úÎ†• ÌååÏùº ÌòïÏãù

### JSON ÌòïÏãù (Î∂ÑÏÑù Í≤∞Í≥º)

```json
{
  "project_name": "myproject",
  "call_chain": [
    {
      "source_class": "UserController",
      "source_method": "getUserById",
      "target_class": "UserService",
      "target_method": "findById",
      "sql_type": "SELECT",
      "table_name": "users",
      "column_name": "id"
    }
  ],
  "missing_nodes": {
    "missing_tables": ["non_existent_table"],
    "missing_columns": ["non_existent_column"]
  },
  "analysis_summary": {
    "total_calls": 10,
    "unique_classes": 5,
    "unique_methods": 8,
    "unique_sql_statements": 6,
    "unique_tables": 3,
    "unique_columns": 12,
    "missing_tables_count": 1,
    "missing_columns_count": 2
  }
}
```

### Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû® ÌòïÏãù

```mermaid
graph TD
    UserController["üè¢ UserController"]:::class
    UserService["üè¢ UserService"]:::class
    Table_users["üìä users"]:::table
    Column_id["üìã id"]:::column
    MissingTable_non_existent["‚ùå non_existent_table"]:::missingTable
    
    UserController --> UserService
    UserService --> Table_users
    Table_users --> Column_id
    UserService -.-> MissingTable_non_existent
    
    classDef class fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    classDef table fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
    classDef column fill:#e8f5e8,stroke:#1b5e20,stroke-width:2px
    classDef missingTable fill:#ffebee,stroke:#c62828,stroke-width:2px,stroke-dasharray: 5 5
    classDef missingColumn fill:#fff3e0,stroke:#ef6c00,stroke-width:2px,stroke-dasharray: 5 5
```

## Ï£ºÏùòÏÇ¨Ìï≠

1. **Neo4j Ïó∞Í≤∞**: Î™®Îì† Î™ÖÎ†πÏñ¥Îäî Neo4j Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê Ïó∞Í≤∞ÎêòÏñ¥Ïïº Ìï©ÎãàÎã§.
2. **ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ**: `--project-name` ÏòµÏÖòÏùÄ ÌïÑÏàòÏûÖÎãàÎã§.
3. **mermaid-cli**: Ïù¥ÎØ∏ÏßÄ Î≥ÄÌôòÏùÑ ÏúÑÌï¥ÏÑúÎäî `npm install -g @mermaid-js/mermaid-cli` ÏÑ§ÏπòÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.
4. **Îç∞Ïù¥ÌÑ∞ Ï§ÄÎπÑ**: Î∂ÑÏÑù Ï†ÑÏóê `analyze` Î™ÖÎ†πÏñ¥Î°ú Java Í∞ùÏ≤¥ÏôÄ DB Í∞ùÏ≤¥Î•º Î®ºÏ†Ä Î∂ÑÏÑùÌï¥Ïïº Ìï©ÎãàÎã§.

## Î¨∏Ï†ú Ìï¥Í≤∞

### 1. "No call chain found" Ïò§Î•ò

- Java Í∞ùÏ≤¥ÏôÄ DB Í∞ùÏ≤¥Í∞Ä Î™®Îëê Î∂ÑÏÑùÎêòÏóàÎäîÏßÄ ÌôïÏù∏
- ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶ÑÏù¥ Ïò¨Î∞îÎ•∏ÏßÄ ÌôïÏù∏
- Neo4j Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏

### 2. "Missing tables/columns" Í≤ΩÍ≥†

- SQLÏóêÏÑú Ï∞∏Ï°∞ÌïòÎäî ÌÖåÏù¥Î∏î/Ïª¨ÎüºÏù¥ Ïã§Ï†ú DB Ïä§ÌÇ§ÎßàÏóê Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏùå
- DB Ïä§ÌÇ§Îßà ÌååÏùºÏùÑ ÌôïÏù∏ÌïòÍ≥† ÎàÑÎùΩÎêú ÌÖåÏù¥Î∏î/Ïª¨ÎüºÏùÑ Ï∂îÍ∞ÄÌïòÍ±∞ÎÇò SQLÏùÑ ÏàòÏ†ï

### 3. Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏÉùÏÑ± Ïò§Î•ò

- mermaid-cliÍ∞Ä ÏÑ§ÏπòÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏
- Ï∂úÎ†• ÌååÏùº Í≤ΩÎ°úÍ∞Ä Ïò¨Î∞îÎ•∏ÏßÄ ÌôïÏù∏
- Ïù¥ÎØ∏ÏßÄ ÌòïÏãùÏù¥ ÏßÄÏõêÎêòÎäîÏßÄ ÌôïÏù∏ (png, svg, pdf)
```

## 3Îã®Í≥Ñ Íµ¨ÌòÑ ÏôÑÎ£å ÏöîÏïΩ

**3Îã®Í≥Ñ: Ïñ¥ÌîåÎ¶¨ÏºÄÏù¥ÏÖò-Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ìò∏Ï∂úÍ¥ÄÍ≥Ñ ÏãúÍ∞ÅÌôî Í∏∞Îä• Íµ¨ÌòÑ**Ïù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§!

### üéØ Íµ¨ÌòÑÎêú Ï£ºÏöî Í∏∞Îä•

#### 1. **Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑùÍ∏∞** (`DBCallAnalysisService`)
- Controller ‚Üí Service ‚Üí Repository ‚Üí SQL ‚Üí Table/Column Ï†ÑÏ≤¥ Ìò∏Ï∂ú Ï≤¥Ïù∏ Ï∂îÏ†Å
- ÌäπÏ†ï ÌÅ¥ÎûòÏä§/Î©îÏÑúÎìúÎ∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî Î∂ÑÏÑù ÏßÄÏõê
- Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Table/Column ÎÖ∏Îìú ÏûêÎèô ÏãùÎ≥Ñ

#### 2. **CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±**
- ÌÅ¥ÎûòÏä§Î≥Ñ ÌÖåÏù¥Î∏î Ï†ëÍ∑º ÌòÑÌô© Î∂ÑÏÑù
- ÌÖåÏù¥Î∏îÎ≥Ñ CRUD ÏûëÏóÖ ÌÜµÍ≥Ñ
- Í∞ÄÏû• ÌôúÎ∞úÌïú ÌÅ¥ÎûòÏä§/ÌÖåÏù¥Î∏î ÏãùÎ≥Ñ

#### 3. **Ìò∏Ï∂ú Í¥ÄÍ≥Ñ ÏãúÍ∞ÅÌôî** (Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû®)
- **Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Table/Column ÎÖ∏ÎìúÎ•º Ï†ÅÏÉâ Ï†êÏÑ†ÏúºÎ°ú ÌëúÏãú** ‚úÖ
- ÎÖ∏ÎìúÎ≥Ñ ÏÉâÏÉÅ Íµ¨Î∂Ñ (ÌÅ¥ÎûòÏä§, ÌÖåÏù¥Î∏î, Ïª¨Îüº, ÎàÑÎùΩÎêú ÎÖ∏Îìú)
- Ïù¥ÎØ∏ÏßÄ Î≥ÄÌôò ÏßÄÏõê (PNG, SVG, PDF)

#### 4. **ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù**
- ÌäπÏ†ï ÌÖåÏù¥Î∏î Î≥ÄÍ≤Ω Ïãú ÏòÅÌñ•Î∞õÎäî ÌÅ¥ÎûòÏä§/Î©îÏÑúÎìú Î∂ÑÏÑù
- Í≥†Î≥µÏû°ÎèÑ SQL ÏãùÎ≥Ñ
- ÏÉÅÏÑ∏Ìïú ÏòÅÌñ•ÎèÑ Î≥¥Í≥†ÏÑú ÏÉùÏÑ±

#### 5. **Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÇ¨Ïö© ÌÜµÍ≥Ñ**
- SQL Î¨∏ ÌÜµÍ≥Ñ (SELECT, INSERT, UPDATE, DELETE)
- ÌÖåÏù¥Î∏î ÏÇ¨Ïö© ÌÜµÍ≥Ñ
- SQL Î≥µÏû°ÎèÑ Î∂ÑÏÑù

### üöÄ ÏÉàÎ°úÏö¥ CLI Î™ÖÎ†πÏñ¥Îì§

1. **`db-call-chain`** - Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù
2. **`crud-analysis`** - CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
3. **`db-call-diagram`** - Ìò∏Ï∂ú Í¥ÄÍ≥Ñ Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏÉùÏÑ±
4. **`table-impact`** - ÌÖåÏù¥Î∏î ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù
5. **`db-statistics`** - Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÇ¨Ïö© ÌÜµÍ≥Ñ

### ‚ú® ÌäπÎ≥ÑÌïú Í∏∞Îä•: ÎàÑÎùΩÎêú ÎÖ∏Îìú ÏãúÍ∞ÅÌôî

ÏöîÏ≤≠ÌïòÏã† ÎåÄÎ°ú **Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Table/Column ÎÖ∏ÎìúÎ•º Ï†ÅÏÉâ Ï†êÏÑ†ÏúºÎ°ú ÌëúÏãú**ÌïòÎäî Í∏∞Îä•Ïù¥ Íµ¨ÌòÑÎêòÏóàÏäµÎãàÎã§:

- **‚ùå ÌÖåÏù¥Î∏îÎ™Ö** - Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî ÌÖåÏù¥Î∏î (Ï†ÅÏÉâ Ï†êÏÑ†)
- **‚ùå Ïª¨ÎüºÎ™Ö** - Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Ïª¨Îüº (Ï†ÅÏÉâ Ï†êÏÑ†)
- Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû®ÏóêÏÑú `stroke-dasharray: 5 5`Î°ú Ï†êÏÑ† Ïä§ÌÉÄÏùº Ï†ÅÏö©

### üìÅ ÏÉùÏÑ±Îêú ÌååÏùºÎì§

1. **`src/services/db_call_analysis.py`** - ÌïµÏã¨ Î∂ÑÏÑù ÏÑúÎπÑÏä§
2. **`docs/db_call_analysis_usage.md`** - ÏÉÅÏÑ∏Ìïú ÏÇ¨Ïö©Î≤ï Í∞ÄÏù¥Îìú
3. **`src/cli/main.py`** - ÏÉàÎ°úÏö¥ CLI Î™ÖÎ†πÏñ¥Îì§ Ï∂îÍ∞Ä

### üéâ ÏÇ¨Ïö© ÏòàÏãú

```bash
# 1. Ï†ÑÏ≤¥ ÌîÑÎ°úÏ†ùÌä∏ Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù
python -m src.cli.main db-call-chain --project-name myproject

# 2. CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
python -m src.cli.main crud-analysis --project-name myproject

# 3. Ìò∏Ï∂ú Í¥ÄÍ≥Ñ Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏÉùÏÑ± (ÎàÑÎùΩÎêú ÎÖ∏Îìú Ï†ÅÏÉâ Ï†êÏÑ†ÏúºÎ°ú ÌëúÏãú)
python -m src.cli.main db-call-diagram --project-name myproject --output-image diagram.png

# 4. ÌäπÏ†ï ÌÖåÏù¥Î∏î ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù
python -m src.cli.main table-impact --project-name myproject --table-name users
```

Ïù¥Ï†ú Ïñ¥ÌîåÎ¶¨ÏºÄÏù¥ÏÖòÍ≥º Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í∞ÑÏùò Ìò∏Ï∂úÍ¥ÄÍ≥ÑÎ•º ÏôÑÏ†ÑÌûà ÏãúÍ∞ÅÌôîÌïòÍ≥† Î∂ÑÏÑùÌï† Ïàò ÏûàÏúºÎ©∞, ÌäπÌûà **Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Table/Column ÎÖ∏ÎìúÎ•º Ï†ÅÏÉâ Ï†êÏÑ†ÏúºÎ°ú Î™ÖÌôïÌïòÍ≤å ÏãùÎ≥Ñ**Ìï† Ïàò ÏûàÏäµÎãàÎã§! üéØ

```shellscript
# 1. Ï†ÑÏ≤¥ ÌîÑÎ°úÏ†ùÌä∏ Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù
python -m src.cli.main db-call-chain --project-name myproject

# 2. CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
python -m src.cli.main crud-analysis --project-name myproject

# 3. Ìò∏Ï∂ú Í¥ÄÍ≥Ñ Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏÉùÏÑ± (ÎàÑÎùΩÎêú ÎÖ∏Îìú Ï†ÅÏÉâ Ï†êÏÑ†ÏúºÎ°ú ÌëúÏãú)
python -m src.cli.main db-call-diagram --project-name myproject --output-image diagram.png

# 4. ÌäπÏ†ï ÌÖåÏù¥Î∏î ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù
python -m src.cli.main table-impact --project-name myproject --table-name users
```

---

**User**

Operations ÌïÑÎìú 'O'Îäî Î¨¥Ïä® ÏùòÎØ∏ÏßÄ?

---

**Cursor**

`Operations` ÌïÑÎìúÏùò 'O'Îäî **"Other"**Î•º ÏùòÎØ∏Ìï©ÎãàÎã§.

ÌòÑÏû¨ CRUD Îß§Ìä∏Î¶≠Ïä§ÏóêÏÑú ÏÇ¨Ïö©ÎêòÎäî ÏûëÏóÖ Î∂ÑÎ•òÎäî Îã§ÏùåÍ≥º Í∞ôÏäµÎãàÎã§:

- **C** = **Create** (INSERT ÏûëÏóÖ)
- **R** = **Read** (SELECT ÏûëÏóÖ)  
- **U** = **Update** (UPDATE ÏûëÏóÖ)
- **D** = **Delete** (DELETE ÏûëÏóÖ)
- **O** = **Other** (Í∏∞ÌÉÄ ÏûëÏóÖ ÎòêÎäî SQL ÏûëÏóÖÏù¥ ÏóÜÎäî Í≤ΩÏö∞)

ÏΩîÎìúÎ•º ÌôïÏù∏Ìï¥Î≥¥Î©¥:


ÎÑ§, ÎßûÏäµÎãàÎã§! **'O'Îäî "Other"**Î•º ÏùòÎØ∏Ìï©ÎãàÎã§.

ÌòÑÏû¨ CRUD Îß§Ìä∏Î¶≠Ïä§ÏóêÏÑú:

- **C** = Create (INSERT)
- **R** = Read (SELECT)  
- **U** = Update (UPDATE)
- **D** = Delete (DELETE)
- **O** = **Other** (Í∏∞ÌÉÄ ÏûëÏóÖ)

'O'Í∞Ä ÌëúÏãúÎêòÎäî Í≤ΩÏö∞Îäî:

1. **SQL ÏûëÏóÖÏù¥ ÏóÜÎäî ÌÅ¥ÎûòÏä§** - Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏôÄ ÏßÅÏ†ëÏ†ÅÏù∏ Ïó∞Í¥ÄÏù¥ ÏóÜÎäî ÌÅ¥ÎûòÏä§
2. **Ïïå Ïàò ÏóÜÎäî SQL ÌÉÄÏûÖ** - SELECT, INSERT, UPDATE, DELETEÍ∞Ä ÏïÑÎãå Îã§Î•∏ SQL ÌÉÄÏûÖ
3. **SQL Î∂ÑÏÑùÏù¥ ÎêòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞** - SQL ÌååÏã± Í≥ºÏ†ïÏóêÏÑú ÌÉÄÏûÖÏùÑ ÏãùÎ≥ÑÌïòÏßÄ Î™ªÌïú Í≤ΩÏö∞

ÌÑ∞ÎØ∏ÎÑêÏóêÏÑú Î≥¥Ïã† Í≤∞Í≥ºÎ•º Î≥¥Î©¥:
- `ApiResponse` ÌÅ¥ÎûòÏä§: DTO ÌÅ¥ÎûòÏä§Î°ú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏûëÏóÖÏù¥ ÏóÜÏùå ‚Üí **O**
- `AuthController` ÌÅ¥ÎûòÏä§: ÏïÑÏßÅ SQL ÏûëÏóÖÏù¥ Î∂ÑÏÑùÎêòÏßÄ ÏïäÏïòÍ±∞ÎÇò Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏûëÏóÖÏù¥ ÏóÜÏùå ‚Üí **O**

Ïù¥Îäî Ï†ïÏÉÅÏ†ÅÏù∏ Í≤∞Í≥ºÏù¥Î©∞, Ìï¥Îãπ ÌÅ¥ÎûòÏä§Îì§Ïù¥ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏôÄ ÏßÅÏ†ëÏ†ÅÏù∏ CRUD ÏûëÏóÖÏùÑ ÏàòÌñâÌïòÏßÄ ÏïäÎäîÎã§Îäî ÏùòÎØ∏ÏûÖÎãàÎã§.

---

**User**

Ï†ÑÏ≤¥ ClassÏóê ÎåÄÌï¥ TablesÍ∞Ä Ï†ÑÏ≤¥ NoneÏù¥Í≥† OperationsÎèÑ Ï†ÑÏ≤¥Í∞Ä 'O'Î°ú ÎÇòÏò§ÎäîÎç∞..

---

**Cursor**

ÏïÑ, Ïù¥ Î¨∏Ï†úÎäî **SQLÍ≥º ÌÅ¥ÎûòÏä§ Í∞ÑÏùò Ïó∞Í≤∞ Í¥ÄÍ≥ÑÍ∞Ä Ï†úÎåÄÎ°ú ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÍ∏∞ ÎïåÎ¨∏**ÏûÖÎãàÎã§. 

ÌòÑÏû¨ ÏÉÅÌô©ÏùÑ Î∂ÑÏÑùÌï¥Î≥¥Í≤†ÏäµÎãàÎã§:


Ïù¥Ï†ú SQL Î¨∏Ïù¥ ÏûàÎäîÏßÄ ÌôïÏù∏Ìï¥Î≥¥Í≤†ÏäµÎãàÎã§:


---

**User**

Î™®Îì† ÌÅ¥ÎûòÏä§Ïùò CRUD Î≥¥Îã§Îäî SQLÏùÑ ÏßÅÏ†ë Ìò∏Ï∂úÌïòÎäî CloassÎßå CRUDÎ•º Îß§ÌïëÌïòÎäî Î∞©Î≤ïÏù¥ Îçî Ï†ÅÏ†àÏπò ÏïäÏïÑ?

---

**Cursor**

ÎßûÏäµÎãàÎã§! ÌòÑÏû¨ Íµ¨ÌòÑÏóêÏÑúÎäî **Î™®Îì† ÌÅ¥ÎûòÏä§**Î•º ÎåÄÏÉÅÏúºÎ°ú CRUD Îß§Ìä∏Î¶≠Ïä§Î•º ÏÉùÏÑ±ÌïòÍ≥† ÏûàÏñ¥ÏÑú, SQLÏùÑ ÏßÅÏ†ë Ìò∏Ï∂úÌïòÏßÄ ÏïäÎäî ÌÅ¥ÎûòÏä§Îì§ÎèÑ Î™®Îëê 'O'Î°ú ÌëúÏãúÎêòÍ≥† ÏûàÏäµÎãàÎã§.

**SQLÏùÑ ÏßÅÏ†ë Ìò∏Ï∂úÌïòÎäî ÌÅ¥ÎûòÏä§Îßå** CRUD Îß§ÌïëÌïòÎäî Í≤ÉÏù¥ Ìõ®Ïî¨ Îçî Ï†ÅÏ†àÌïòÍ≥† ÏùòÎØ∏ÏûàÎäî Î∂ÑÏÑùÏù¥ Îê† Í≤É Í∞ôÏäµÎãàÎã§.

ÌòÑÏû¨ Î¨∏Ï†úÏ†êÏùÑ ÌôïÏù∏Ìï¥Î≥¥Í≤†ÏäµÎãàÎã§:


ÎÑ§, Ï†ïÌôïÌïú ÏßÄÏ†ÅÏûÖÎãàÎã§! ÌòÑÏû¨ CRUD Îß§Ìä∏Î¶≠Ïä§ Íµ¨ÌòÑÏùÑ Í∞úÏÑ†Ìï¥Î≥¥Í≤†ÏäµÎãàÎã§.

**ÌòÑÏû¨ Î¨∏Ï†úÏ†ê:**
- Î™®Îì† ÌÅ¥ÎûòÏä§Î•º ÎåÄÏÉÅÏúºÎ°ú CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
- SQLÏùÑ Ìò∏Ï∂úÌïòÏßÄ ÏïäÎäî ÌÅ¥ÎûòÏä§Îì§ÎèÑ 'O'Î°ú ÌëúÏãúÎêòÏñ¥ ÏùòÎØ∏ÏóÜÎäî Ï†ïÎ≥¥ Ï†úÍ≥µ
- Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏûëÏóÖÏùÑ ÌïòÎäî ÌÅ¥ÎûòÏä§Îßå Î≥¥Ïó¨Ï£ºÎäî Í≤ÉÏù¥ Îçî Ïú†Ïö©

**Í∞úÏÑ† Î∞©Ìñ•:**
1. **SQLÏùÑ ÏßÅÏ†ë Ìò∏Ï∂úÌïòÎäî ÌÅ¥ÎûòÏä§Îßå** CRUD Îß§Ìä∏Î¶≠Ïä§Ïóê Ìè¨Ìï®
2. **Repository, Service, Controller** Îì± Ïã§Ï†ú DB ÏûëÏóÖÏùÑ ÌïòÎäî ÌÅ¥ÎûòÏä§Îßå ÌëúÏãú
3. **DTO, Config, Util** Îì±ÏùÄ Ï†úÏô∏

CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ± Î°úÏßÅÏùÑ ÏàòÏ†ïÌïòÍ≤†ÏäµÎãàÎã§:


```python
"""
Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ìò∏Ï∂úÍ¥ÄÍ≥Ñ Î∂ÑÏÑù ÏÑúÎπÑÏä§

Ïù¥ Î™®ÎìàÏùÄ Ïñ¥ÌîåÎ¶¨ÏºÄÏù¥ÏÖòÍ≥º Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í∞ÑÏùò Ìò∏Ï∂úÍ¥ÄÍ≥ÑÎ•º Î∂ÑÏÑùÌïòÍ≥† ÏãúÍ∞ÅÌôîÌïòÎäî Í∏∞Îä•ÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§.
- Controller ‚Üí Service ‚Üí Repository ‚Üí SQL ‚Üí Table/Column Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù
- CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
- Ìò∏Ï∂ú Í¥ÄÍ≥Ñ Í∑∏ÎûòÌîÑ ÏÉùÏÑ± (Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû®)
- Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Table/Column ÎÖ∏Îìú ÏãùÎ≥Ñ Î∞è ÏãúÍ∞ÅÌôî
- ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù
"""

import json
from typing import List, Dict, Any, Optional, Set, Tuple
from neo4j import Driver
from src.utils.logger import get_logger


class DBCallAnalysisService:
    """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ìò∏Ï∂úÍ¥ÄÍ≥Ñ Î∂ÑÏÑù ÏÑúÎπÑÏä§"""
    
    def __init__(self, driver: Driver):
        """Neo4j ÎìúÎùºÏù¥Î≤ÑÎ°ú Ï¥àÍ∏∞Ìôî"""
        self.driver = driver
        self.logger = get_logger(__name__)
    
    def analyze_call_chain(self, project_name: str, start_class: str = None, start_method: str = None) -> Dict[str, Any]:
        """
        Controller ‚Üí Service ‚Üí Repository ‚Üí SQL ‚Üí Table/Column Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Î∂ÑÏÑùÌï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            start_class: ÏãúÏûë ÌÅ¥ÎûòÏä§ (ÏÑ†ÌÉùÏÇ¨Ìï≠)
            start_method: ÏãúÏûë Î©îÏÑúÎìú (ÏÑ†ÌÉùÏÇ¨Ìï≠)
            
        Returns:
            Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù Í≤∞Í≥º
        """
        try:
            with self.driver.session() as session:
                if start_class and start_method:
                    # ÌäπÏ†ï Î©îÏÑúÎìúÎ∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî Ìò∏Ï∂ú Ï≤¥Ïù∏
                    call_chain = self._get_method_call_chain(session, project_name, start_class, start_method)
                elif start_class:
                    # ÌäπÏ†ï ÌÅ¥ÎûòÏä§Î∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî Ìò∏Ï∂ú Ï≤¥Ïù∏
                    call_chain = self._get_class_call_chain(session, project_name, start_class)
                else:
                    # Ï†ÑÏ≤¥ ÌîÑÎ°úÏ†ùÌä∏Ïùò Ìò∏Ï∂ú Ï≤¥Ïù∏
                    call_chain = self._get_project_call_chain(session, project_name)
                
                # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Table/Column ÎÖ∏Îìú ÏãùÎ≥Ñ
                missing_nodes = self._identify_missing_nodes(session, project_name, call_chain)
                
                return {
                    'project_name': project_name,
                    'call_chain': call_chain,
                    'missing_nodes': missing_nodes,
                    'analysis_summary': self._generate_analysis_summary(call_chain, missing_nodes)
                }
                
        except Exception as e:
            self.logger.error(f"Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù Ïò§Î•ò: {str(e)}")
            return {'error': str(e)}
    
    def _get_method_call_chain(self, session, project_name: str, class_name: str, method_name: str) -> List[Dict[str, Any]]:
        """ÌäπÏ†ï Î©îÏÑúÎìúÎ∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Î∂ÑÏÑùÌï©ÎãàÎã§."""
        query = """
        MATCH (c:Class {name: $class_name, project_name: $project_name})-[:HAS_METHOD]->(m:Method {name: $method_name})
        OPTIONAL MATCH (m)-[:CALLS*0..5]->(target_method:Method)
        OPTIONAL MATCH (target_method)<-[:HAS_METHOD]-(target_class:Class)
        OPTIONAL MATCH (target_method)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_TABLE]->(table:Table {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_COLUMN]->(column:Column {project_name: $project_name})
        RETURN m.name as source_method,
               c.name as source_class,
               c.package_name as source_package,
               target_method.name as target_method,
               target_class.name as target_class,
               target_class.package_name as target_package,
               sql.id as sql_id,
               sql.sql_type as sql_type,
               sql.tables as sql_tables,
               sql.columns as sql_columns,
               table.name as table_name,
               column.name as column_name,
               column.table_name as column_table_name
        ORDER BY source_method, target_class.name, target_method.name
        """
        
        result = session.run(query, 
                           class_name=class_name, 
                           method_name=method_name, 
                           project_name=project_name)
        
        call_chain = []
        for record in result:
            call_chain.append({
                'source_method': record['source_method'],
                'source_class': record['source_class'],
                'source_package': record['source_package'] or 'default',
                'target_method': record['target_method'],
                'target_class': record['target_class'],
                'target_package': record['target_package'] or 'default',
                'sql_id': record['sql_id'],
                'sql_type': record['sql_type'],
                'sql_tables': json.loads(record['sql_tables']) if record['sql_tables'] else [],
                'sql_columns': json.loads(record['sql_columns']) if record['sql_columns'] else [],
                'table_name': record['table_name'],
                'column_name': record['column_name'],
                'column_table_name': record['column_table_name']
            })
        
        return call_chain
    
    def _get_class_call_chain(self, session, project_name: str, class_name: str) -> List[Dict[str, Any]]:
        """ÌäπÏ†ï ÌÅ¥ÎûòÏä§Î∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Î∂ÑÏÑùÌï©ÎãàÎã§."""
        query = """
        MATCH (c:Class {name: $class_name, project_name: $project_name})-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS*0..5]->(target_method:Method)
        OPTIONAL MATCH (target_method)<-[:HAS_METHOD]-(target_class:Class)
        OPTIONAL MATCH (target_method)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_TABLE]->(table:Table {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_COLUMN]->(column:Column {project_name: $project_name})
        RETURN m.name as source_method,
               c.name as source_class,
               c.package_name as source_package,
               target_method.name as target_method,
               target_class.name as target_class,
               target_class.package_name as target_package,
               sql.id as sql_id,
               sql.sql_type as sql_type,
               sql.tables as sql_tables,
               sql.columns as sql_columns,
               table.name as table_name,
               column.name as column_name,
               column.table_name as column_table_name
        ORDER BY source_method, target_class.name, target_method.name
        """
        
        result = session.run(query, 
                           class_name=class_name, 
                           project_name=project_name)
        
        call_chain = []
        for record in result:
            call_chain.append({
                'source_method': record['source_method'],
                'source_class': record['source_class'],
                'source_package': record['source_package'] or 'default',
                'target_method': record['target_method'],
                'target_class': record['target_class'],
                'target_package': record['target_package'] or 'default',
                'sql_id': record['sql_id'],
                'sql_type': record['sql_type'],
                'sql_tables': json.loads(record['sql_tables']) if record['sql_tables'] else [],
                'sql_columns': json.loads(record['sql_columns']) if record['sql_columns'] else [],
                'table_name': record['table_name'],
                'column_name': record['column_name'],
                'column_table_name': record['column_table_name']
            })
        
        return call_chain
    
    def _get_project_call_chain(self, session, project_name: str) -> List[Dict[str, Any]]:
        """Ï†ÑÏ≤¥ ÌîÑÎ°úÏ†ùÌä∏Ïùò Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Î∂ÑÏÑùÌï©ÎãàÎã§."""
        query = """
        MATCH (c:Class {project_name: $project_name})-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS*0..5]->(target_method:Method)
        OPTIONAL MATCH (target_method)<-[:HAS_METHOD]-(target_class:Class)
        OPTIONAL MATCH (target_method)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_TABLE]->(table:Table {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_COLUMN]->(column:Column {project_name: $project_name})
        RETURN m.name as source_method,
               c.name as source_class,
               c.package_name as source_package,
               target_method.name as target_method,
               target_class.name as target_class,
               target_class.package_name as target_package,
               sql.id as sql_id,
               sql.sql_type as sql_type,
               sql.tables as sql_tables,
               sql.columns as sql_columns,
               table.name as table_name,
               column.name as column_name,
               column.table_name as column_table_name
        ORDER BY source_class, source_method, target_class.name, target_method.name
        """
        
        result = session.run(query, project_name=project_name)
        
        call_chain = []
        for record in result:
            call_chain.append({
                'source_method': record['source_method'],
                'source_class': record['source_class'],
                'source_package': record['source_package'] or 'default',
                'target_method': record['target_method'],
                'target_class': record['target_class'],
                'target_package': record['target_package'] or 'default',
                'sql_id': record['sql_id'],
                'sql_type': record['sql_type'],
                'sql_tables': json.loads(record['sql_tables']) if record['sql_tables'] else [],
                'sql_columns': json.loads(record['sql_columns']) if record['sql_columns'] else [],
                'table_name': record['table_name'],
                'column_name': record['column_name'],
                'column_table_name': record['column_table_name']
            })
        
        return call_chain
    
    def _identify_missing_nodes(self, session, project_name: str, call_chain: List[Dict[str, Any]]) -> Dict[str, List[str]]:
        """Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Table/Column ÎÖ∏ÎìúÎ•º ÏãùÎ≥ÑÌï©ÎãàÎã§."""
        missing_tables = set()
        missing_columns = set()
        
        # SQLÏóêÏÑú Ï∞∏Ï°∞ÌïòÎäî ÌÖåÏù¥Î∏îÍ≥º Ïª¨Îüº ÏàòÏßë
        referenced_tables = set()
        referenced_columns = set()
        
        for call in call_chain:
            # SQL ÌÖåÏù¥Î∏î Ï†ïÎ≥¥ ÏàòÏßë
            if call.get('sql_tables'):
                for table_info in call['sql_tables']:
                    if isinstance(table_info, dict) and 'name' in table_info:
                        referenced_tables.add(table_info['name'])
            
            # SQL Ïª¨Îüº Ï†ïÎ≥¥ ÏàòÏßë
            if call.get('sql_columns'):
                for column_info in call['sql_columns']:
                    if isinstance(column_info, dict) and 'name' in column_info:
                        referenced_columns.add(column_info['name'])
                        if 'table' in column_info and column_info['table']:
                            referenced_tables.add(column_info['table'])
        
        # Ïã§Ï†ú Ï°¥Ïû¨ÌïòÎäî ÌÖåÏù¥Î∏îÍ≥º Ïª¨Îüº Ï°∞Ìöå
        existing_tables = self._get_existing_tables(session, project_name)
        existing_columns = self._get_existing_columns(session, project_name)
        
        # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî ÌÖåÏù¥Î∏î ÏãùÎ≥Ñ
        for table_name in referenced_tables:
            if table_name not in existing_tables:
                missing_tables.add(table_name)
        
        # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Ïª¨Îüº ÏãùÎ≥Ñ
        for column_name in referenced_columns:
            if column_name not in existing_columns:
                missing_columns.add(column_name)
        
        return {
            'missing_tables': list(missing_tables),
            'missing_columns': list(missing_columns)
        }
    
    def _get_existing_tables(self, session, project_name: str) -> Set[str]:
        """Ïã§Ï†ú Ï°¥Ïû¨ÌïòÎäî ÌÖåÏù¥Î∏î Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§."""
        query = """
        MATCH (t:Table {project_name: $project_name})
        RETURN t.name as table_name
        """
        
        result = session.run(query, project_name=project_name)
        return {record['table_name'] for record in result}
    
    def _get_existing_columns(self, session, project_name: str) -> Set[str]:
        """Ïã§Ï†ú Ï°¥Ïû¨ÌïòÎäî Ïª¨Îüº Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§."""
        query = """
        MATCH (c:Column {project_name: $project_name})
        RETURN c.name as column_name
        """
        
        result = session.run(query, project_name=project_name)
        return {record['column_name'] for record in result}
    
    def _generate_analysis_summary(self, call_chain: List[Dict[str, Any]], missing_nodes: Dict[str, List[str]]) -> Dict[str, Any]:
        """Î∂ÑÏÑù Í≤∞Í≥º ÏöîÏïΩÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§."""
        # ÌÅ¥ÎûòÏä§Î≥Ñ ÌÜµÍ≥Ñ
        class_stats = {}
        for call in call_chain:
            source_class = call['source_class']
            if source_class not in class_stats:
                class_stats[source_class] = {
                    'method_count': 0,
                    'sql_count': 0,
                    'table_count': 0,
                    'column_count': 0
                }
            
            if call['source_method']:
                class_stats[source_class]['method_count'] += 1
            if call['sql_id']:
                class_stats[source_class]['sql_count'] += 1
            if call['table_name']:
                class_stats[source_class]['table_count'] += 1
            if call['column_name']:
                class_stats[source_class]['column_count'] += 1
        
        return {
            'total_calls': len(call_chain),
            'unique_classes': len(class_stats),
            'unique_methods': len(set(call['source_method'] for call in call_chain if call['source_method'])),
            'unique_sql_statements': len(set(call['sql_id'] for call in call_chain if call['sql_id'])),
            'unique_tables': len(set(call['table_name'] for call in call_chain if call['table_name'])),
            'unique_columns': len(set(call['column_name'] for call in call_chain if call['column_name'])),
            'missing_tables_count': len(missing_nodes['missing_tables']),
            'missing_columns_count': len(missing_nodes['missing_columns']),
            'class_stats': class_stats
        }
    
    def generate_crud_matrix(self, project_name: str) -> Dict[str, Any]:
        """
        CRUD Îß§Ìä∏Î¶≠Ïä§Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
        SQLÏùÑ ÏßÅÏ†ë Ìò∏Ï∂úÌïòÎäî ÌÅ¥ÎûòÏä§Îßå Ìè¨Ìï®Ìï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            
        Returns:
            CRUD Îß§Ìä∏Î¶≠Ïä§ Îç∞Ïù¥ÌÑ∞
        """
        try:
            with self.driver.session() as session:
                # SQLÏùÑ ÏßÅÏ†ë Ìò∏Ï∂úÌïòÎäî ÌÅ¥ÎûòÏä§Îßå ÎåÄÏÉÅÏúºÎ°ú CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
                class_crud_query = """
                MATCH (c:Class {project_name: $project_name})-[:HAS_METHOD]->(m:Method)
                MATCH (m)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
                WITH c, m, sql,
                     CASE 
                       WHEN sql.sql_type = 'SELECT' THEN 'R'
                       WHEN sql.sql_type = 'INSERT' THEN 'C'
                       WHEN sql.sql_type = 'UPDATE' THEN 'U'
                       WHEN sql.sql_type = 'DELETE' THEN 'D'
                       ELSE 'O'
                     END as crud_operation
                RETURN c.name as class_name,
                       c.package_name as package_name,
                       collect(DISTINCT sql.mapper_name) as tables,
                       collect(DISTINCT crud_operation) as operations,
                       collect(DISTINCT sql.id) as sql_statements
                ORDER BY c.name
                """
                
                result = session.run(class_crud_query, project_name=project_name)
                class_matrix = [record.data() for record in result]
                
                # ÌÖåÏù¥Î∏îÎ≥Ñ CRUD Îß§Ìä∏Î¶≠Ïä§
                table_crud_query = """
                MATCH (sql:SqlStatement {project_name: $project_name})
                WHERE sql.tables IS NOT NULL
                UNWIND sql.tables as table_info
                WITH table_info.name as table_name, sql.sql_type as operation, count(sql) as count
                RETURN table_name,
                       collect({operation: operation, count: count}) as operations
                ORDER BY table_name
                """
                
                result = session.run(table_crud_query, project_name=project_name)
                table_matrix = [record.data() for record in result]
                
                return {
                    'project_name': project_name,
                    'class_matrix': class_matrix,
                    'table_matrix': table_matrix,
                    'summary': self._generate_crud_summary(class_matrix, table_matrix)
                }
                
        except Exception as e:
            self.logger.error(f"CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ± Ïò§Î•ò: {str(e)}")
            return {'error': str(e)}
    
    def _generate_crud_summary(self, class_matrix: List[Dict], table_matrix: List[Dict]) -> Dict[str, Any]:
        """CRUD Îß§Ìä∏Î¶≠Ïä§ ÏöîÏïΩÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§."""
        total_classes = len(class_matrix)
        total_tables = len(table_matrix)
        
        # CRUD ÏûëÏóÖÎ≥Ñ ÌÜµÍ≥Ñ
        crud_stats = {'C': 0, 'R': 0, 'U': 0, 'D': 0, 'O': 0}
        for class_data in class_matrix:
            for operation in class_data['operations']:
                if operation in crud_stats:
                    crud_stats[operation] += 1
        
        return {
            'total_classes': total_classes,
            'total_tables': total_tables,
            'crud_stats': crud_stats,
            'most_active_class': max(class_matrix, key=lambda x: len(x['operations']))['class_name'] if class_matrix else None,
            'most_used_table': max(table_matrix, key=lambda x: sum(op['count'] for op in x['operations']))['table_name'] if table_matrix else None
        }
    
    def generate_call_chain_diagram(self, project_name: str, start_class: str = None, start_method: str = None) -> str:
        """
        Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû®ÏúºÎ°ú ÏÉùÏÑ±Ìï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            start_class: ÏãúÏûë ÌÅ¥ÎûòÏä§ (ÏÑ†ÌÉùÏÇ¨Ìï≠)
            start_method: ÏãúÏûë Î©îÏÑúÎìú (ÏÑ†ÌÉùÏÇ¨Ìï≠)
            
        Returns:
            Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû® Î¨∏ÏûêÏó¥
        """
        try:
            analysis_result = self.analyze_call_chain(project_name, start_class, start_method)
            
            if 'error' in analysis_result:
                return f"Ïò§Î•ò: {analysis_result['error']}"
            
            call_chain = analysis_result['call_chain']
            missing_nodes = analysis_result['missing_nodes']
            
            if not call_chain:
                return "```mermaid\ngraph TD\n    A[No call chain found]\n```"
            
            # Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏÉùÏÑ±
            diagram_lines = ["```mermaid", "graph TD"]
            
            # ÎÖ∏Îìú Ï†ïÏùò
            nodes = set()
            for call in call_chain:
                if call['source_class']:
                    nodes.add(call['source_class'])
                if call['target_class']:
                    nodes.add(call['target_class'])
                if call['table_name']:
                    nodes.add(f"Table_{call['table_name']}")
                if call['column_name']:
                    nodes.add(f"Column_{call['column_name']}")
            
            # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî ÎÖ∏Îìú Ï∂îÍ∞Ä (Ï†ÅÏÉâ Ï†êÏÑ†ÏúºÎ°ú ÌëúÏãú)
            for missing_table in missing_nodes['missing_tables']:
                nodes.add(f"MissingTable_{missing_table}")
            
            for missing_column in missing_nodes['missing_columns']:
                nodes.add(f"MissingColumn_{missing_column}")
            
            # ÎÖ∏Îìú Ïä§ÌÉÄÏùº Ï†ïÏùò
            for node in sorted(nodes):
                if node.startswith('MissingTable_'):
                    table_name = node.replace('MissingTable_', '')
                    diagram_lines.append(f"    {node}[\"‚ùå {table_name}\"]:::missingTable")
                elif node.startswith('MissingColumn_'):
                    column_name = node.replace('MissingColumn_', '')
                    diagram_lines.append(f"    {node}[\"‚ùå {column_name}\"]:::missingColumn")
                elif node.startswith('Table_'):
                    table_name = node.replace('Table_', '')
                    diagram_lines.append(f"    {node}[\"üìä {table_name}\"]:::table")
                elif node.startswith('Column_'):
                    column_name = node.replace('Column_', '')
                    diagram_lines.append(f"    {node}[\"üìã {column_name}\"]:::column")
                else:
                    diagram_lines.append(f"    {node}[\"üè¢ {node}\"]:::class")
            
            # Ïó∞Í≤∞ÏÑ† Ï†ïÏùò
            for call in call_chain:
                if call['source_class'] and call['target_class']:
                    diagram_lines.append(f"    {call['source_class']} --> {call['target_class']}")
                
                if call['target_class'] and call['table_name']:
                    table_node = f"Table_{call['table_name']}"
                    diagram_lines.append(f"    {call['target_class']} --> {table_node}")
                
                if call['table_name'] and call['column_name']:
                    table_node = f"Table_{call['table_name']}"
                    column_node = f"Column_{call['column_name']}"
                    diagram_lines.append(f"    {table_node} --> {column_node}")
            
            # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî ÎÖ∏Îìú Ïó∞Í≤∞ (Ï†ÅÏÉâ Ï†êÏÑ†)
            for call in call_chain:
                if call['table_name'] and call['table_name'] in missing_nodes['missing_tables']:
                    missing_table_node = f"MissingTable_{call['table_name']}"
                    if call['target_class']:
                        diagram_lines.append(f"    {call['target_class']} -.-> {missing_table_node}")
                
                if call['column_name'] and call['column_name'] in missing_nodes['missing_columns']:
                    missing_column_node = f"MissingColumn_{call['column_name']}"
                    if call['table_name']:
                        table_node = f"Table_{call['table_name']}"
                        diagram_lines.append(f"    {table_node} -.-> {missing_column_node}")
            
            # Ïä§ÌÉÄÏùº Ï†ïÏùò
            diagram_lines.extend([
                "",
                "    classDef class fill:#e1f5fe,stroke:#01579b,stroke-width:2px",
                "    classDef table fill:#f3e5f5,stroke:#4a148c,stroke-width:2px",
                "    classDef column fill:#e8f5e8,stroke:#1b5e20,stroke-width:2px",
                "    classDef missingTable fill:#ffebee,stroke:#c62828,stroke-width:2px,stroke-dasharray: 5 5",
                "    classDef missingColumn fill:#fff3e0,stroke:#ef6c00,stroke-width:2px,stroke-dasharray: 5 5"
            ])
            
            diagram_lines.append("```")
            
            return "\n".join(diagram_lines)
            
        except Exception as e:
            self.logger.error(f"Ìò∏Ï∂ú Ï≤¥Ïù∏ Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏÉùÏÑ± Ïò§Î•ò: {str(e)}")
            return f"Ïò§Î•ò: {str(e)}"
    
    def analyze_table_impact(self, project_name: str, table_name: str) -> Dict[str, Any]:
        """
        ÌäπÏ†ï ÌÖåÏù¥Î∏î Î≥ÄÍ≤Ω Ïãú ÏòÅÌñ•Î∞õÎäî ÌÅ¥ÎûòÏä§/Î©îÏÑúÎìúÎ•º Î∂ÑÏÑùÌï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            table_name: Î∂ÑÏÑùÌï† ÌÖåÏù¥Î∏î Ïù¥Î¶Ñ
            
        Returns:
            ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù Í≤∞Í≥º
        """
        try:
            with self.driver.session() as session:
                # ÌÖåÏù¥Î∏îÏùÑ ÏÇ¨Ïö©ÌïòÎäî ÌÅ¥ÎûòÏä§/Î©îÏÑúÎìú Ï°∞Ìöå
                impact_query = """
                MATCH (c:Class {project_name: $project_name})-[:HAS_METHOD]->(m:Method)
                MATCH (m)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
                WHERE sql.tables CONTAINS $table_name OR 
                      ANY(table_info IN sql.tables WHERE table_info.name = $table_name)
                RETURN c.name as class_name,
                       c.package_name as package_name,
                       m.name as method_name,
                       sql.id as sql_id,
                       sql.sql_type as sql_type,
                       sql.complexity_score as complexity_score
                ORDER BY c.name, m.name
                """
                
                result = session.run(impact_query, 
                                   project_name=project_name, 
                                   table_name=table_name)
                
                impacted_classes = []
                for record in result:
                    impacted_classes.append({
                        'class_name': record['class_name'],
                        'package_name': record['package_name'],
                        'method_name': record['method_name'],
                        'sql_id': record['sql_id'],
                        'sql_type': record['sql_type'],
                        'complexity_score': record['complexity_score']
                    })
                
                # ÏòÅÌñ•ÎèÑ ÏöîÏïΩ
                summary = {
                    'table_name': table_name,
                    'total_impacted_classes': len(set(c['class_name'] for c in impacted_classes)),
                    'total_impacted_methods': len(set(f"{c['class_name']}.{c['method_name']}" for c in impacted_classes)),
                    'total_sql_statements': len(set(c['sql_id'] for c in impacted_classes if c['sql_id'])),
                    'crud_operations': list(set(c['sql_type'] for c in impacted_classes if c['sql_type'])),
                    'high_complexity_sql': [c for c in impacted_classes if c['complexity_score'] and c['complexity_score'] > 7]
                }
                
                return {
                    'table_name': table_name,
                    'impacted_classes': impacted_classes,
                    'summary': summary
                }
                
        except Exception as e:
            self.logger.error(f"ÌÖåÏù¥Î∏î ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù Ïò§Î•ò: {str(e)}")
            return {'error': str(e)}
    
    def get_database_usage_statistics(self, project_name: str) -> Dict[str, Any]:
        """
        Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÇ¨Ïö© ÌÜµÍ≥ÑÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            
        Returns:
            Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÇ¨Ïö© ÌÜµÍ≥Ñ
        """
        try:
            with self.driver.session() as session:
                # SQL ÌÜµÍ≥Ñ
                sql_stats_query = """
                MATCH (sql:SqlStatement {project_name: $project_name})
                RETURN 
                    count(sql) as total_sql,
                    sum(CASE WHEN sql.sql_type = 'SELECT' THEN 1 ELSE 0 END) as SELECT,
                    sum(CASE WHEN sql.sql_type = 'INSERT' THEN 1 ELSE 0 END) as INSERT,
                    sum(CASE WHEN sql.sql_type = 'UPDATE' THEN 1 ELSE 0 END) as UPDATE,
                    sum(CASE WHEN sql.sql_type = 'DELETE' THEN 1 ELSE 0 END) as DELETE
                """
                
                result = session.run(sql_stats_query, project_name=project_name)
                sql_stats = result.single().data() if result.single() else {}
                
                # ÌÖåÏù¥Î∏î ÏÇ¨Ïö© ÌÜµÍ≥Ñ
                table_usage_query = """
                MATCH (sql:SqlStatement {project_name: $project_name})
                WHERE sql.tables IS NOT NULL
                UNWIND sql.tables as table_info
                WITH table_info.name as table_name, sql.sql_type as operation
                RETURN 
                    table_name,
                    count(*) as access_count,
                    collect(DISTINCT operation) as operations
                ORDER BY access_count DESC
                """
                
                result = session.run(table_usage_query, project_name=project_name)
                table_usage = [record.data() for record in result]
                
                # Î≥µÏû°ÎèÑ ÌÜµÍ≥Ñ
                complexity_query = """
                MATCH (sql:SqlStatement {project_name: $project_name})
                WHERE sql.complexity_score IS NOT NULL
                WITH sql.complexity_score as score,
                     CASE 
                         WHEN sql.complexity_score <= 3 THEN 'simple'
                         WHEN sql.complexity_score <= 7 THEN 'medium'
                         WHEN sql.complexity_score <= 12 THEN 'complex'
                         ELSE 'very_complex'
                     END as complexity_level
                RETURN 
                    complexity_level,
                    count(*) as count
                """
                
                result = session.run(complexity_query, project_name=project_name)
                complexity_stats = {record['complexity_level']: record['count'] for record in result}
                
                return {
                    'project_name': project_name,
                    'sql_statistics': sql_stats,
                    'table_usage': table_usage,
                    'complexity_statistics': complexity_stats
                }
                
        except Exception as e:
            self.logger.error(f"Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÇ¨Ïö© ÌÜµÍ≥Ñ Ï°∞Ìöå Ïò§Î•ò: {str(e)}")
            return {'error': str(e)}

```

Ïù¥Ï†ú CLIÏóêÏÑúÎèÑ Îçî Î™ÖÌôïÌïú Î©îÏãúÏßÄÎ•º ÌëúÏãúÌïòÎèÑÎ°ù ÏàòÏ†ïÌïòÍ≤†ÏäµÎãàÎã§:


```python
import click
import sys
import os
from dotenv import load_dotenv

# Add the project root to Python path
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from src.services.java_parser import parse_java_project
from src.services.graph_db import GraphDB
from src.services.sequence_diagram_generator import SequenceDiagramGenerator
from src.services.db_parser import DBParser
from src.services.db_call_analysis import DBCallAnalysisService
from neo4j import GraphDatabase
import subprocess
import tempfile

load_dotenv()

def convert_to_image(diagram_content, output_file, image_format, width, height):
    """Convert Mermaid diagram to image using mermaid-cli"""
    # Try different possible locations for mmdc
    mmdc_commands = ['mmdc', 'mmdc.cmd', r'C:\Users\cjony\AppData\Roaming\npm\mmdc', r'C:\Users\cjony\AppData\Roaming\npm\mmdc.cmd']
    
    mmdc_cmd = None
    for cmd in mmdc_commands:
        try:
            subprocess.run([cmd, '--version'], capture_output=True, check=True, timeout=5)
            mmdc_cmd = cmd
            break
        except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired):
            continue
    
    if not mmdc_cmd:
        click.echo("Error: mermaid-cli is not installed or not found in PATH.")
        click.echo("Please install it with: npm install -g @mermaid-js/mermaid-cli")
        click.echo("Or check if it's installed at: C:\\Users\\cjony\\AppData\\Roaming\\npm\\")
        return
    
    try:
        # Create temporary file for mermaid content
        with tempfile.NamedTemporaryFile(mode='w', suffix='.md', delete=False, encoding='utf-8', newline='') as temp_file:
            temp_file.write(diagram_content)
            temp_file_path = temp_file.name
        
        # Determine format from output file extension
        file_extension = output_file.split('.')[-1].lower()
        actual_format = file_extension if file_extension in ['png', 'svg', 'pdf'] else image_format
        
        # Convert to image using mermaid-cli
        cmd = [
            mmdc_cmd,
            '-i', temp_file_path,
            '-o', output_file,
            '-e', actual_format,
            '-w', str(width),
            '-H', str(height)
        ]
        
        # Add PDF-specific options
        if image_format.lower() == 'pdf':
            # Set background color for PDF
            cmd.extend(['-b', 'white'])
            # Add PDF fit option
            cmd.append('-f')
        
        click.echo(f"Running command: {' '.join(cmd)}")
        
        # Set environment variables for UTF-8 encoding
        env = os.environ.copy()
        env['PYTHONIOENCODING'] = 'utf-8'
        env['LANG'] = 'en_US.UTF-8'
        env['LC_ALL'] = 'en_US.UTF-8'
        
        result = subprocess.run(cmd, capture_output=True, text=True, check=True, encoding='utf-8', errors='ignore', env=env)
        
        # Clean up temporary file
        os.unlink(temp_file_path)
        
        # Check if the expected output file was created
        if os.path.exists(output_file):
            actual_format = output_file.split('.')[-1].upper()
            click.echo(f"Image saved to: {output_file}")
            click.echo(f"Format: {actual_format}, Size: {width}x{height}")
        else:
            # Check for files with similar names (mermaid-cli sometimes adds numbers)
            import glob
            pattern = output_file.replace('.pdf', '-*.pdf').replace('.png', '-*.png').replace('.svg', '-*.svg')
            matching_files = glob.glob(pattern)
            if matching_files:
                actual_file = matching_files[0]
                actual_format = actual_file.split('.')[-1].upper()
                click.echo(f"Image saved to: {actual_file}")
                click.echo(f"Format: {actual_format}, Size: {width}x{height}")
                click.echo(f"Note: mermaid-cli created {actual_file} instead of {output_file}")
            else:
                click.echo(f"Warning: Expected file {output_file} not found")
        
        click.echo(f"Command output: {result.stdout}")
        
    except subprocess.CalledProcessError as e:
        click.echo(f"Error converting to image: {e}")
        click.echo(f"Error output: {e.stderr}")
        if os.path.exists(temp_file_path):
            os.unlink(temp_file_path)
    except Exception as e:
        click.echo(f"Unexpected error: {e}")
        if 'temp_file_path' in locals() and os.path.exists(temp_file_path):
            os.unlink(temp_file_path)

@click.group()
def cli():
    pass

@cli.command()
@click.option('--java-source-folder', default=os.getenv("JAVA_SOURCE_FOLDER"), help='Path to the Java source project folder.')
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--neo4j-password', default=os.getenv("NEO4J_PASSWORD"), help='Neo4j password')
@click.option('--clean', is_flag=True, help='Wipe the database before analysis.')
@click.option('--class-name', help='Analyze only a specific class (delete existing data for this class first)')
@click.option('--update', is_flag=True, help='Update all classes individually without clearing database')
@click.option('--db_object', is_flag=True, help='Analyze database objects from DDL scripts')
@click.option('--java_object', is_flag=True, help='Analyze Java objects from source code')
@click.option('--dry-run', is_flag=True, help='Parse Java files without connecting to database.')
def analyze(java_source_folder, neo4j_uri, neo4j_user, neo4j_password, clean, class_name, update, db_object, java_object, dry_run):
    """Analyzes a Java project and populates a Neo4j database."""
    if not java_source_folder:
        click.echo("Error: JAVA_SOURCE_FOLDER environment variable or --java-source-folder option is required.", err=True)
        exit(1)

    # Extract project name from directory path
    from pathlib import Path
    project_name = Path(java_source_folder).resolve().name

    # Handle Java object analysis
    if java_object:
        click.echo("Analyzing Java objects from source code...")
        
        if not java_source_folder:
            click.echo("Error: JAVA_SOURCE_FOLDER environment variable is required for --java_object option.", err=True)
            click.echo("Please set JAVA_SOURCE_FOLDER in your .env file or environment variables.")
            exit(1)
        
        if not os.path.exists(java_source_folder):
            click.echo(f"Error: Java source folder {java_source_folder} does not exist.", err=True)
            exit(1)
        
        try:
            # Parse Java project
            click.echo(f"Parsing Java project at: {java_source_folder}")
            packages_to_add, classes_to_add, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, jpa_repositories, jpa_queries, config_files, test_classes, sql_statements, project_name = parse_java_project(java_source_folder)
            
            click.echo(f"Project name: {project_name}")
            click.echo(f"Found {len(packages_to_add)} packages and {len(classes_to_add)} classes.")
            
            if dry_run:
                click.echo("Dry run mode - not connecting to database.")
                click.echo(f"Found {len(packages_to_add)} packages and {len(classes_to_add)} classes.")
                click.echo(f"Found {len(beans)} Spring Beans and {len(dependencies)} dependencies.")
                click.echo(f"Found {len(endpoints)} REST API endpoints.")
                click.echo(f"Found {len(mybatis_mappers)} MyBatis mappers.")
                click.echo(f"Found {len(jpa_entities)} JPA entities.")
                click.echo(f"Found {len(jpa_repositories)} JPA repositories.")
                click.echo(f"Found {len(jpa_queries)} JPA queries.")
                click.echo(f"Found {len(config_files)} configuration files.")
                click.echo(f"Found {len(test_classes)} test classes.")
                click.echo(f"Found {len(sql_statements)} SQL statements.")
                click.echo("Java object analysis complete (dry run).")
                return
            
            # Connect to database
            click.echo(f"Connecting to Neo4j at {neo4j_uri}...")
            db = GraphDB(uri=neo4j_uri, user=neo4j_user, password=neo4j_password)
            
            if clean:
                click.echo("Cleaning Java objects...")
                with db._driver.session() as session:
                    # Delete only Java-related nodes
                    session.run("MATCH (n:Package) DETACH DELETE n")
                    session.run("MATCH (n:Class) DETACH DELETE n")
                    session.run("MATCH (n:Method) DETACH DELETE n")
                    session.run("MATCH (n:Field) DETACH DELETE n")
                    session.run("MATCH (n:Bean) DETACH DELETE n")
                    session.run("MATCH (n:Endpoint) DETACH DELETE n")
                    session.run("MATCH (n:MyBatisMapper) DETACH DELETE n")
                    session.run("MATCH (n:JpaEntity) DETACH DELETE n")
                    session.run("MATCH (n:ConfigFile) DETACH DELETE n")
                    session.run("MATCH (n:TestClass) DETACH DELETE n")
                    session.run("MATCH (n:SqlStatement) DETACH DELETE n")
            
            # Add packages
            click.echo("Adding packages to database...")
            for package_node in packages_to_add:
                db.add_package(package_node, project_name)
            
            # Add classes
            click.echo("Adding classes to database...")
            for class_node in classes_to_add:
                # Find the package for this class using the mapping
                class_key = f"{class_to_package_map.get(class_node.name, '')}.{class_node.name}"
                package_name = class_to_package_map.get(class_key, None)
                
                if not package_name:
                    # Fallback: try to find package by class name
                    for key, pkg_name in class_to_package_map.items():
                        if key.endswith(f".{class_node.name}"):
                            package_name = pkg_name
                            break
                
                db.add_class(class_node, package_name, project_name)
            
            # Add Spring Boot analysis results
            if beans:
                click.echo(f"Adding {len(beans)} Spring Beans to database...")
                for bean in beans:
                    db.add_bean(bean, project_name)
            
            if dependencies:
                click.echo(f"Adding {len(dependencies)} Bean dependencies to database...")
                for dependency in dependencies:
                    db.add_bean_dependency(dependency, project_name)
            
            if endpoints:
                click.echo(f"Adding {len(endpoints)} REST API endpoints to database...")
                for endpoint in endpoints:
                    db.add_endpoint(endpoint, project_name)
            
            if mybatis_mappers:
                click.echo(f"Adding {len(mybatis_mappers)} MyBatis mappers to database...")
                for mapper in mybatis_mappers:
                    db.add_mybatis_mapper(mapper, project_name)
            
            if jpa_entities:
                click.echo(f"Adding {len(jpa_entities)} JPA entities to database...")
                for entity in jpa_entities:
                    db.add_jpa_entity(entity, project_name)
            
            if jpa_repositories:
                click.echo(f"Adding {len(jpa_repositories)} JPA repositories to database...")
                for repository in jpa_repositories:
                    db.add_jpa_repository(repository, project_name)
            
            if jpa_queries:
                click.echo(f"Adding {len(jpa_queries)} JPA queries to database...")
                for query in jpa_queries:
                    db.add_jpa_query(query, project_name)
            
            if config_files:
                click.echo(f"Adding {len(config_files)} configuration files to database...")
                for config_file in config_files:
                    db.add_config_file(config_file, project_name)
            
            if test_classes:
                click.echo(f"Adding {len(test_classes)} test classes to database...")
                for test_class in test_classes:
                    db.add_test_class(test_class, project_name)
            
            if sql_statements:
                click.echo(f"Adding {len(sql_statements)} SQL statements to database...")
                for sql_statement in sql_statements:
                    db.add_sql_statement(sql_statement, project_name)
                    # Create relationship between mapper and SQL statement
                    with db._driver.session() as session:
                        session.execute_write(db._create_mapper_sql_relationship_tx, sql_statement.mapper_name, sql_statement.id, project_name)
            
            db.close()
            click.echo("Java object analysis complete.")
            return
            
        except Exception as e:
            click.echo(f"Error analyzing Java objects: {e}")
            click.echo("Use --dry-run flag to parse without database connection.")
            exit(1)

    # Handle DB object analysis
    if db_object:
        click.echo("Analyzing database objects from DDL scripts...")
        
        # Get DB script folder from environment variable
        db_script_folder = os.getenv("DB_SCRIPT_FOLDER")
        if not db_script_folder:
            click.echo("Error: DB_SCRIPT_FOLDER environment variable is required for --db_object option.", err=True)
            click.echo("Please set DB_SCRIPT_FOLDER in your .env file or environment variables.")
            exit(1)
        
        if not os.path.exists(db_script_folder):
            click.echo(f"Error: DB script folder {db_script_folder} does not exist.", err=True)
            exit(1)
        
        try:
            # Parse DDL files
            db_parser = DBParser()
            all_db_objects = db_parser.parse_ddl_directory(db_script_folder, project_name)
            
            if not all_db_objects:
                click.echo("No DDL files found or parsed successfully.")
                return
            
            click.echo(f"Found {len(all_db_objects)} DDL files to process.")
            
            if dry_run:
                click.echo("Dry run mode - not connecting to database.")
                for i, db_objects in enumerate(all_db_objects):
                    click.echo(f"DDL file {i+1}:")
                    click.echo(f"  Database: {db_objects['database'].name}")
                    click.echo(f"  Tables: {len(db_objects['tables'])}")
                    click.echo(f"  Columns: {len(db_objects['columns'])}")
                    click.echo(f"  Indexes: {len(db_objects['indexes'])}")
                    click.echo(f"  Constraints: {len(db_objects['constraints'])}")
                click.echo("DB object analysis complete (dry run).")
                return
            
            # Connect to database
            click.echo(f"Connecting to Neo4j at {neo4j_uri}...")
            db = GraphDB(uri=neo4j_uri, user=neo4j_user, password=neo4j_password)
            
            if clean:
                click.echo("Cleaning database objects...")
                with db._driver.session() as session:
                    # Delete only database-related nodes
                    session.run("MATCH (n:Database) DETACH DELETE n")
                    session.run("MATCH (n:Table) DETACH DELETE n")
                    session.run("MATCH (n:Column) DETACH DELETE n")
                    session.run("MATCH (n:Index) DETACH DELETE n")
                    session.run("MATCH (n:Constraint) DETACH DELETE n")
            
            # Process each DDL file's objects
            for i, db_objects in enumerate(all_db_objects):
                click.echo(f"Processing DDL file {i+1}...")
                
                # Add database
                click.echo(f"Adding database: {db_objects['database'].name}")
                db.add_database(db_objects['database'], project_name)
                
                # Add tables
                for table_obj in db_objects['tables']:
                    click.echo(f"Adding table: {table_obj.name}")
                    db.add_table(table_obj, db_objects['database'].name, project_name)
                
                # Add columns
                for column_obj in db_objects['columns']:
                    table_name = getattr(column_obj, 'table_name', 'unknown')
                    click.echo(f"Adding column: {column_obj.name} to table {table_name}")
                    db.add_column(column_obj, table_name, project_name)
                
                # Add indexes
                for index_obj, table_name in db_objects['indexes']:
                    click.echo(f"Adding index: {index_obj.name} to table {table_name}")
                    db.add_index(index_obj, table_name, project_name)
                
                # Add constraints
                for constraint_obj, table_name in db_objects['constraints']:
                    click.echo(f"Adding constraint: {constraint_obj.name} to table {table_name}")
                    db.add_constraint(constraint_obj, table_name, project_name)
            
            db.close()
            click.echo("DB object analysis complete.")
            return
            
        except Exception as e:
            click.echo(f"Error analyzing DB objects: {e}")
            click.echo("Use --dry-run flag to parse without database connection.")
            exit(1)

    # If analyzing a specific class
    if class_name:
        click.echo(f"Analyzing specific class: {class_name}")
        
        # Find the Java file for this class
        java_file_path = None
        for root, _, files in os.walk(java_source_folder):
            for file in files:
                if file.endswith(".java") and file.replace(".java", "") == class_name:
                    java_file_path = os.path.join(root, file)
                    break
            if java_file_path:
                break
        
        if not java_file_path:
            click.echo(f"Error: Could not find Java file for class '{class_name}'", err=True)
            exit(1)
        
        click.echo(f"Found Java file: {java_file_path}")
        
        try:
            # Parse the single Java file
            from src.services.java_parser import parse_single_java_file, extract_beans_from_classes, analyze_bean_dependencies, extract_endpoints_from_classes, extract_mybatis_mappers_from_classes, extract_jpa_entities_from_classes, extract_test_classes_from_classes, extract_sql_statements_from_mappers
            
            package_node, class_node, package_name = parse_single_java_file(java_file_path, project_name)
            
            click.echo(f"Parsed class: {class_node.name}")
            click.echo(f"Package: {package_name}")
            click.echo(f"Methods: {len(class_node.methods)}")
            click.echo(f"Properties: {len(class_node.properties)}")
            click.echo(f"Method calls: {len(class_node.calls)}")
            
            if dry_run:
                click.echo("Dry run mode - not connecting to database.")
                click.echo("Analysis complete (dry run).")
                return
            
            # Connect to database
            click.echo(f"Connecting to Neo4j at {neo4j_uri}...")
            db = GraphDB(uri=neo4j_uri, user=neo4j_user, password=neo4j_password)
            
            # Delete existing data for this class
            click.echo(f"Deleting existing data for class '{class_name}'...")
            db.delete_class_and_related_data(class_name, project_name)
            
            # Add package
            click.echo("Adding package to database...")
            db.add_package(package_node, project_name)
            
            # Add class
            click.echo("Adding class to database...")
            db.add_class(class_node, package_name, project_name)
            
            # Extract and add related Spring Boot analysis results for this class only
            classes_list = [class_node]
            beans = extract_beans_from_classes(classes_list)
            dependencies = analyze_bean_dependencies(classes_list, beans)
            endpoints = extract_endpoints_from_classes(classes_list)
            mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
            jpa_entities = extract_jpa_entities_from_classes(classes_list)
            test_classes = extract_test_classes_from_classes(classes_list)
            
            # Extract SQL statements from MyBatis mappers
            sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
            
            # Add Spring Boot analysis results
            if beans:
                click.echo(f"Adding {len(beans)} Spring Beans to database...")
                for bean in beans:
                    db.add_bean(bean, project_name)
            
            if dependencies:
                click.echo(f"Adding {len(dependencies)} Bean dependencies to database...")
                for dependency in dependencies:
                    db.add_bean_dependency(dependency, project_name)
            
            if endpoints:
                click.echo(f"Adding {len(endpoints)} REST API endpoints to database...")
                for endpoint in endpoints:
                    db.add_endpoint(endpoint, project_name)
            
            if mybatis_mappers:
                click.echo(f"Adding {len(mybatis_mappers)} MyBatis mappers to database...")
                for mapper in mybatis_mappers:
                    db.add_mybatis_mapper(mapper, project_name)
            
            if jpa_entities:
                click.echo(f"Adding {len(jpa_entities)} JPA entities to database...")
                for entity in jpa_entities:
                    db.add_jpa_entity(entity, project_name)
            
            if test_classes:
                click.echo(f"Adding {len(test_classes)} test classes to database...")
                for test_class in test_classes:
                    db.add_test_class(test_class, project_name)
            
            if sql_statements:
                click.echo(f"Adding {len(sql_statements)} SQL statements to database...")
                for sql_statement in sql_statements:
                    db.add_sql_statement(sql_statement, project_name)
                    # Create relationship between mapper and SQL statement
                    with db._driver.session() as session:
                        session.execute_write(db._create_mapper_sql_relationship_tx, sql_statement.mapper_name, sql_statement.id, project_name)
            
            db.close()
            click.echo("Class analysis complete.")
            
        except Exception as e:
            click.echo(f"Error analyzing class: {e}")
            click.echo("Use --dry-run flag to parse without database connection.")
            exit(1)
        
        return

    # If updating all classes individually
    if update:
        click.echo("Updating all classes individually...")
        
        # Find all Java files
        java_files = []
        for root, _, files in os.walk(java_source_folder):
            for file in files:
                if file.endswith(".java"):
                    java_files.append(os.path.join(root, file))
        
        if not java_files:
            click.echo("No Java files found in the specified directory.", err=True)
            exit(1)
        
        click.echo(f"Found {len(java_files)} Java files to process.")
        
        if dry_run:
            click.echo("Dry run mode - not connecting to database.")
            for java_file in java_files:
                try:
                    from src.services.java_parser import parse_single_java_file
                    package_node, class_node, package_name = parse_single_java_file(java_file, project_name)
                    click.echo(f"  {class_node.name} ({package_name}) - Methods: {len(class_node.methods)}, Properties: {len(class_node.properties)}")
                except Exception as e:
                    click.echo(f"  Error parsing {java_file}: {e}")
            click.echo("Update analysis complete (dry run).")
            return
        
        try:
            # Connect to database
            click.echo(f"Connecting to Neo4j at {neo4j_uri}...")
            db = GraphDB(uri=neo4j_uri, user=neo4j_user, password=neo4j_password)
            
            processed_count = 0
            error_count = 0
            
            for java_file in java_files:
                try:
                    click.echo(f"Processing: {java_file}")
                    
                    # Parse the single Java file
                    from src.services.java_parser import parse_single_java_file, extract_beans_from_classes, analyze_bean_dependencies, extract_endpoints_from_classes, extract_mybatis_mappers_from_classes, extract_jpa_entities_from_classes, extract_test_classes_from_classes, extract_sql_statements_from_mappers
                    
                    package_node, class_node, package_name = parse_single_java_file(java_file, project_name)
                    
                    click.echo(f"  Parsed class: {class_node.name} (Package: {package_name})")
                    
                    # Delete existing data for this class
                    click.echo(f"  Deleting existing data for class '{class_node.name}'...")
                    db.delete_class_and_related_data(class_node.name, project_name)
                    
                    # Add package
                    db.add_package(package_node, project_name)
                    
                    # Add class
                    db.add_class(class_node, package_name, project_name)
                    
                    # Extract and add related Spring Boot analysis results for this class only
                    classes_list = [class_node]
                    beans = extract_beans_from_classes(classes_list)
                    dependencies = analyze_bean_dependencies(classes_list, beans)
                    endpoints = extract_endpoints_from_classes(classes_list)
                    mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
                    jpa_entities = extract_jpa_entities_from_classes(classes_list)
                    test_classes = extract_test_classes_from_classes(classes_list)
                    
                    # Extract SQL statements from MyBatis mappers
                    sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
                    
                    # Add Spring Boot analysis results
                    if beans:
                        for bean in beans:
                            db.add_bean(bean, project_name)
                    
                    if dependencies:
                        for dependency in dependencies:
                            db.add_bean_dependency(dependency, project_name)
                    
                    if endpoints:
                        for endpoint in endpoints:
                            db.add_endpoint(endpoint, project_name)
                    
                    if mybatis_mappers:
                        for mapper in mybatis_mappers:
                            db.add_mybatis_mapper(mapper, project_name)
                    
                    if jpa_entities:
                        for entity in jpa_entities:
                            db.add_jpa_entity(entity, project_name)
                    
                    if test_classes:
                        for test_class in test_classes:
                            db.add_test_class(test_class, project_name)
                    
                    if sql_statements:
                        for sql_statement in sql_statements:
                            db.add_sql_statement(sql_statement, project_name)
                            # Create relationship between mapper and SQL statement
                            with db._driver.session() as session:
                                session.execute_write(db._create_mapper_sql_relationship_tx, sql_statement.mapper_name, sql_statement.id, project_name)
                    
                    processed_count += 1
                    click.echo(f"  [OK] Successfully processed {class_node.name}")
                    
                except Exception as e:
                    error_count += 1
                    click.echo(f"  [ERROR] Error processing {java_file}: {e}")
                    continue
            
            db.close()
            click.echo(f"Update complete. Processed: {processed_count}, Errors: {error_count}")
            
        except Exception as e:
            click.echo(f"Error during update: {e}")
            click.echo("Use --dry-run flag to parse without database connection.")
            exit(1)
        
        return

    # Original full project analysis (when no specific object type is specified)
    if not java_object and not db_object:
        click.echo(f"Parsing Java project at: {java_source_folder}")
        packages_to_add, classes_to_add, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, jpa_repositories, jpa_queries, config_files, test_classes, sql_statements, project_name = parse_java_project(java_source_folder)
    
        click.echo(f"Project name: {project_name}")
        
        click.echo(f"Found {len(packages_to_add)} packages and {len(classes_to_add)} classes.")
        
        if dry_run:
            click.echo("Dry run mode - not connecting to database.")
            click.echo(f"Found {len(packages_to_add)} packages and {len(classes_to_add)} classes.")
            click.echo(f"Found {len(beans)} Spring Beans and {len(dependencies)} dependencies.")
            click.echo(f"Found {len(endpoints)} REST API endpoints.")
            click.echo(f"Found {len(mybatis_mappers)} MyBatis mappers.")
            click.echo(f"Found {len(jpa_entities)} JPA entities.")
            click.echo(f"Found {len(jpa_repositories)} JPA repositories.")
            click.echo(f"Found {len(jpa_queries)} JPA queries.")
            click.echo(f"Found {len(config_files)} configuration files.")
            click.echo(f"Found {len(test_classes)} test classes.")
            click.echo(f"Found {len(sql_statements)} SQL statements.")
            
            for package_node in packages_to_add:
                click.echo(f"Package: {package_node.name}")
            for class_node in classes_to_add:
                click.echo(f"Class: {class_node.name}")
                click.echo(f"  Methods: {len(class_node.methods)}")
                click.echo(f"  Properties: {len(class_node.properties)}")
                click.echo(f"  Method calls: {len(class_node.calls)}")
            click.echo("Analysis complete (dry run).")
            return

        try:
            click.echo(f"Connecting to Neo4j at {neo4j_uri}...")
            db = GraphDB(uri=neo4j_uri, user=neo4j_user, password=neo4j_password)

            if clean:
                click.echo("Cleaning database...")
                with db._driver.session() as session:
                    session.run("MATCH (n) DETACH DELETE n")

            click.echo("Adding packages to database...")
            for package_node in packages_to_add:
                db.add_package(package_node, project_name)
        
            click.echo("Adding classes to database...")
            for class_node in classes_to_add:
                # Find the package for this class using the mapping
                class_key = f"{class_to_package_map.get(class_node.name, '')}.{class_node.name}"
                package_name = class_to_package_map.get(class_key, None)
                
                if not package_name:
                    # Fallback: try to find package by class name
                    for key, pkg_name in class_to_package_map.items():
                        if key.endswith(f".{class_node.name}"):
                            package_name = pkg_name
                            break
                
                db.add_class(class_node, package_name, project_name)
        
            # Add Spring Boot analysis results
            if beans:
                click.echo(f"Adding {len(beans)} Spring Beans to database...")
                for bean in beans:
                    db.add_bean(bean, project_name)
        
            if dependencies:
                click.echo(f"Adding {len(dependencies)} Bean dependencies to database...")
                for dependency in dependencies:
                    db.add_bean_dependency(dependency, project_name)
        
            if endpoints:
                click.echo(f"Adding {len(endpoints)} REST API endpoints to database...")
                for endpoint in endpoints:
                    db.add_endpoint(endpoint, project_name)
        
            if mybatis_mappers:
                click.echo(f"Adding {len(mybatis_mappers)} MyBatis mappers to database...")
                for mapper in mybatis_mappers:
                    db.add_mybatis_mapper(mapper, project_name)
            
            if jpa_entities:
                click.echo(f"Adding {len(jpa_entities)} JPA entities to database...")
                for entity in jpa_entities:
                    db.add_jpa_entity(entity, project_name)
            
            if jpa_repositories:
                click.echo(f"Adding {len(jpa_repositories)} JPA repositories to database...")
                for repository in jpa_repositories:
                    db.add_jpa_repository(repository, project_name)
            
            if jpa_queries:
                click.echo(f"Adding {len(jpa_queries)} JPA queries to database...")
                for query in jpa_queries:
                    db.add_jpa_query(query, project_name)
            
            if config_files:
                click.echo(f"Adding {len(config_files)} configuration files to database...")
                for config_file in config_files:
                    db.add_config_file(config_file, project_name)
        
            if test_classes:
                click.echo(f"Adding {len(test_classes)} test classes to database...")
                for test_class in test_classes:
                    db.add_test_class(test_class, project_name)
        
            if sql_statements:
                click.echo(f"Adding {len(sql_statements)} SQL statements to database...")
                for sql_statement in sql_statements:
                    db.add_sql_statement(sql_statement, project_name)
                    # Create relationship between mapper and SQL statement
                    with db._driver.session() as session:
                        session.execute_write(db._create_mapper_sql_relationship_tx, sql_statement.mapper_name, sql_statement.id, project_name)
        
            db.close()
            click.echo("Analysis complete.")
        except Exception as e:
            click.echo(f"Error connecting to database: {e}")
            click.echo("Use --dry-run flag to parse without database connection.")
            exit(1)

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--neo4j-password', default=os.getenv("NEO4J_PASSWORD"), help='Neo4j password')
@click.option('--query', help='Custom Cypher query to execute')
@click.option('--basic', is_flag=True, help='Run basic class query')
@click.option('--detailed', is_flag=True, help='Run detailed class query with methods and properties')
@click.option('--inheritance', is_flag=True, help='Run inheritance relationship query')
@click.option('--package', is_flag=True, help='Run package-based class query')
def query(neo4j_uri, neo4j_user, neo4j_password, query, basic, detailed, inheritance, package):
    """Execute queries against the Neo4j database."""
    
    # ÎØ∏Î¶¨ Ï†ïÏùòÎêú ÏøºÎ¶¨Îì§
    queries = {
        'basic': """
        MATCH (c:Class)
        RETURN 
            c.name AS name,
            c.logical_name AS logical_name,
            c.file_path AS file_path,
            c.type AS type,
            c.source AS source
        ORDER BY c.name
        """,
        'detailed': """
        MATCH (c:Class)
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (c)-[:HAS_FIELD]->(p:Field)
        OPTIONAL MATCH (pkg:Package)-[:CONTAINS]->(c)
        RETURN 
            c.name AS class_name,
            c.logical_name AS class_logical_name,
            c.file_path AS file_path,
            c.type AS class_type,
            pkg.name AS package_name,
            collect(DISTINCT m.name) AS methods,
            collect(DISTINCT p.name) AS properties
        ORDER BY c.name
        """,
        'inheritance': """
        MATCH (c:Class)
        OPTIONAL MATCH (c)-[:EXTENDS]->(super:Class)
        OPTIONAL MATCH (c)-[:IMPLEMENTS]->(impl:Class)
        RETURN 
            c.name AS class_name,
            c.logical_name AS class_logical_name,
            c.type AS class_type,
            collect(DISTINCT super.name) AS extends,
            collect(DISTINCT impl.name) AS implements
        ORDER BY c.name
        """,
        'package': """
        MATCH (pkg:Package)-[:CONTAINS]->(c:Class)
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (c)-[:HAS_FIELD]->(p:Field)
        RETURN 
            pkg.name AS package_name,
            pkg.logical_name AS package_logical_name,
            collect(DISTINCT c.name) AS classes,
            count(DISTINCT m) AS total_methods,
            count(DISTINCT p) AS total_properties
        ORDER BY pkg.name
        """
    }
    
    # Ïã§ÌñâÌï† ÏøºÎ¶¨ Í≤∞Ï†ï
    if query:
        cypher_query = query
        description = "Custom Query"
    elif basic:
        cypher_query = queries['basic']
        description = "Basic Class Query"
    elif detailed:
        cypher_query = queries['detailed']
        description = "Detailed Class Query"
    elif inheritance:
        cypher_query = queries['inheritance']
        description = "Inheritance Query"
    elif package:
        cypher_query = queries['package']
        description = "Package Query"
    else:
        click.echo("Error: Please specify a query type or provide a custom query.")
        click.echo("Available options: --basic, --detailed, --inheritance, --package, or --query")
        return
    
    try:
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        
        with driver.session() as session:
            click.echo(f"Executing: {description}")
            click.echo("=" * 50)
            
            result = session.run(cypher_query)
            records = list(result)
            
            if not records:
                click.echo("No results found.")
                return
            
            # Ï≤´ Î≤àÏß∏ Î†àÏΩîÎìúÏùò ÌÇ§Îì§ÏùÑ Ìó§ÎçîÎ°ú ÏÇ¨Ïö©
            headers = list(records[0].keys())
            
            # Ìó§Îçî Ï∂úÎ†•
            click.echo(" | ".join(f"{header:20}" for header in headers))
            click.echo("-" * (len(headers) * 23))
            
            # Îç∞Ïù¥ÌÑ∞ Ï∂úÎ†•
            for record in records:
                row = []
                for header in headers:
                    value = record[header]
                    if value is None:
                        row.append("None")
                    elif isinstance(value, (list, dict)):
                        row.append(str(value)[:50] + "..." if len(str(value)) > 50 else str(value))
                    else:
                        row.append(str(value)[:20])
                click.echo(" | ".join(f"{cell:20}" for cell in row))
            
            click.echo(f"\nTotal: {len(records)} results found.")
            
    except Exception as e:
        click.echo(f"Error executing query: {e}")
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--class-name', required=True, help='Name of the class to analyze')
@click.option('--method-name', help='Specific method to analyze (optional)')
@click.option('--max-depth', default=3, help='Maximum depth of call chain to follow (default: 3)')
@click.option('--include-external', is_flag=True, help='Include calls to external libraries')
@click.option('--method-focused', is_flag=True, help='Generate method-focused diagram (shows only the specified method and its direct calls)')
@click.option('--output-file', help='Output file to save the diagram (optional)')
@click.option('--output-image', help='Output image file (PNG/SVG/PDF) - requires mermaid-cli')
@click.option('--image-format', default='png', type=click.Choice(['png', 'svg', 'pdf']), help='Image format (default: png)')
@click.option('--image-width', default=1200, help='Image width in pixels (default: 1200)')
@click.option('--image-height', default=800, help='Image height in pixels (default: 800)')
def sequence(neo4j_uri, neo4j_user, class_name, method_name, max_depth, include_external, method_focused, output_file, output_image, image_format, image_width, image_height):
    """Generate sequence diagram for a specific class and optionally a method."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        click.echo(f"Connecting to Neo4j at {neo4j_uri}...")
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        generator = SequenceDiagramGenerator(driver)
        
        # Generate the sequence diagram
        click.echo(f"Generating sequence diagram for class: {class_name}")
        if method_name:
            click.echo(f"Focusing on method: {method_name}")
        if method_focused:
            click.echo("Method-focused mode: showing only direct calls from the specified method")
        
        diagram = generator.generate_sequence_diagram(
            class_name=class_name,
            method_name=method_name,
            max_depth=max_depth if not method_focused else 1,  # Method-focused uses depth 1
            include_external_calls=include_external,
            method_focused=method_focused
        )
        
        click.echo(f"Diagram generated (length: {len(diagram)})")
        
        # Check if diagram contains error message
        if diagram.startswith("Error:"):
            click.echo(f"Error: {diagram}")
            return
        
        # Output the diagram
        if output_file:
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(diagram)
            click.echo(f"Sequence diagram saved to: {output_file}")
        else:
            # Default: save to {class_name}.md
            default_filename = f"{class_name}.md"
            with open(default_filename, 'w', encoding='utf-8') as f:
                f.write(diagram)
            click.echo(f"Sequence diagram saved to: {default_filename}")
            
            click.echo("\n" + "="*50)
            click.echo("SEQUENCE DIAGRAM")
            click.echo("="*50)
            click.echo(diagram)
            click.echo("="*50)
        
        # Convert to image if requested
        if output_image:
            convert_to_image(diagram, output_image, image_format, image_width, image_height)
        
    except Exception as e:
        click.echo(f"Error generating sequence diagram: {e}")
        import traceback
        click.echo(f"Traceback: {traceback.format_exc()}")
        exit(1)
    finally:
        if 'driver' in locals():
            driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
def list_classes(neo4j_uri, neo4j_user):
    """List all available classes in the database."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        generator = SequenceDiagramGenerator(driver)
        
        classes = generator.get_available_classes()
        
        if not classes:
            click.echo("No classes found in the database.")
            return
        
        click.echo("Available classes:")
        click.echo("=" * 80)
        click.echo(f"{'Class Name':<30} {'Package':<30} {'Type':<10}")
        click.echo("-" * 80)
        
        for cls in classes:
            click.echo(f"{cls['name']:<30} {cls['package_name']:<30} {cls['type']:<10}")
        
        click.echo(f"\nTotal: {len(classes)} classes found.")
        
    except Exception as e:
        click.echo(f"Error listing classes: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--class-name', required=True, help='Name of the class to list methods for')
def list_methods(neo4j_uri, neo4j_user, class_name):
    """List all methods for a specific class."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        generator = SequenceDiagramGenerator(driver)
        
        methods = generator.get_class_methods(class_name)
        
        if not methods:
            click.echo(f"No methods found for class '{class_name}'.")
            return
        
        click.echo(f"Methods for class '{class_name}':")
        click.echo("=" * 80)
        click.echo(f"{'Method Name':<30} {'Return Type':<20} {'Logical Name':<30}")
        click.echo("-" * 80)
        
        for method in methods:
            click.echo(f"{method['name']:<30} {method['return_type']:<20} {method['logical_name']:<30}")
        
        click.echo(f"\nTotal: {len(methods)} methods found.")
        
    except Exception as e:
        click.echo(f"Error listing methods: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--project-name', help='Project name to filter by (optional)')
def crud_matrix(neo4j_uri, neo4j_user, project_name):
    """Show CRUD matrix for classes and tables."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        db = GraphDB(neo4j_uri, neo4j_user, neo4j_password)
        
        click.echo("CRUD Matrix - Class to Table Operations")
        click.echo("=" * 80)
        
        matrix = db.get_crud_matrix(project_name)
        
        if not matrix:
            click.echo("No CRUD operations found.")
            return
        
        click.echo(f"{'Class Name':<30} {'Package':<25} {'Tables':<20} {'Operations':<15}")
        click.echo("-" * 80)
        
        for row in matrix:
            class_name = row['class_name']
            package_name = row['package_name'] or 'N/A'
            tables = ', '.join(row['tables']) if row['tables'] else 'None'
            operations = ', '.join(row['operations']) if row['operations'] else 'None'
            
            click.echo(f"{class_name:<30} {package_name:<25} {tables:<20} {operations:<15}")
        
        click.echo(f"\nTotal: {len(matrix)} classes with CRUD operations.")
        
    except Exception as e:
        click.echo(f"Error getting CRUD matrix: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--project-name', help='Project name to filter by (optional)')
def db_analysis(neo4j_uri, neo4j_user, project_name):
    """Show database call relationship analysis."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        db = GraphDB(neo4j_uri, neo4j_user, neo4j_password)
        
        click.echo("Database Call Relationship Analysis")
        click.echo("=" * 80)
        
        # SQL Î¨∏ ÌÜµÍ≥Ñ
        sql_stats = db.get_sql_statistics(project_name)
        if sql_stats:
            click.echo(f"\nSQL Statistics:")
            click.echo(f"  Total SQL statements: {sql_stats['total_sql']}")
            click.echo(f"  SELECT statements: {sql_stats.get('SELECT', 0)}")
            click.echo(f"  INSERT statements: {sql_stats.get('INSERT', 0)}")
            click.echo(f"  UPDATE statements: {sql_stats.get('UPDATE', 0)}")
            click.echo(f"  DELETE statements: {sql_stats.get('DELETE', 0)}")
        
        # ÌÖåÏù¥Î∏î ÏÇ¨Ïö© ÌÜµÍ≥Ñ
        table_stats = db.get_table_usage_statistics(project_name)
        if table_stats:
            click.echo(f"\nTable Usage Statistics:")
            click.echo(f"{'Table Name':<30} {'Access Count':<15} {'Operations':<20}")
            click.echo("-" * 65)
            for table in table_stats:
                table_name = table['table_name']
                access_count = table['access_count']
                operations = ', '.join(table['operations'])
                click.echo(f"{table_name:<30} {access_count:<15} {operations:<20}")
        
        # Î≥µÏû°ÎèÑ Î∂ÑÏÑù
        complexity_stats = db.get_sql_complexity_statistics(project_name)
        if complexity_stats:
            click.echo(f"\nSQL Complexity Analysis:")
            click.echo(f"  Simple queries: {complexity_stats.get('simple', 0)}")
            click.echo(f"  Medium queries: {complexity_stats.get('medium', 0)}")
            click.echo(f"  Complex queries: {complexity_stats.get('complex', 0)}")
            click.echo(f"  Very complex queries: {complexity_stats.get('very_complex', 0)}")
        
        # Îß§ÌçºÎ≥Ñ SQL Î∂ÑÌè¨
        mapper_stats = db.get_mapper_sql_distribution(project_name)
        if mapper_stats:
            click.echo(f"\nMapper SQL Distribution:")
            click.echo(f"{'Mapper Name':<30} {'SQL Count':<15} {'SQL Types':<20}")
            click.echo("-" * 65)
            for mapper in mapper_stats:
                mapper_name = mapper['mapper_name']
                sql_count = mapper['sql_count']
                sql_types = ', '.join(mapper['sql_types'])
                click.echo(f"{mapper_name:<30} {sql_count:<15} {sql_types:<20}")
        
    except Exception as e:
        click.echo(f"Error getting database analysis: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--project-name', help='Project name to filter by (optional)')
def table_summary(neo4j_uri, neo4j_user, project_name):
    """Show CRUD summary for each table."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        db = GraphDB(neo4j_uri, neo4j_user, neo4j_password)
        
        click.echo("Table CRUD Summary")
        click.echo("=" * 60)
        
        summary = db.get_table_crud_summary(project_name)
        
        if not summary:
            click.echo("No tables found.")
            return
        
        for row in summary:
            table_name = row['table_name']
            operations = row['operations']
            
            click.echo(f"\nTable: {table_name}")
            click.echo("-" * 40)
            
            for op in operations:
                operation = op['operation']
                count = op['count']
                click.echo(f"  {operation}: {count} statements")
        
        click.echo(f"\nTotal: {len(summary)} tables.")
        
    except Exception as e:
        click.echo(f"Error getting table summary: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--project-name', required=True, help='Project name to analyze')
@click.option('--start-class', help='Starting class for call chain analysis (optional)')
@click.option('--start-method', help='Starting method for call chain analysis (optional)')
@click.option('--output-file', help='Output file to save the analysis results (optional)')
def db_call_chain(neo4j_uri, neo4j_user, project_name, start_class, start_method, output_file):
    """Analyze database call chain relationships."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        analysis_service = DBCallAnalysisService(driver)
        
        click.echo("Database Call Chain Analysis")
        click.echo("=" * 50)
        
        if start_class and start_method:
            click.echo(f"Analyzing call chain from {start_class}.{start_method}")
        elif start_class:
            click.echo(f"Analyzing call chain from class {start_class}")
        else:
            click.echo(f"Analyzing call chain for project {project_name}")
        
        # Î∂ÑÏÑù Ïã§Ìñâ
        result = analysis_service.analyze_call_chain(project_name, start_class, start_method)
        
        if 'error' in result:
            click.echo(f"Error: {result['error']}")
            return
        
        # Í≤∞Í≥º Ï∂úÎ†•
        call_chain = result['call_chain']
        missing_nodes = result['missing_nodes']
        summary = result['analysis_summary']
        
        click.echo(f"\nAnalysis Summary:")
        click.echo(f"  Total calls: {summary['total_calls']}")
        click.echo(f"  Unique classes: {summary['unique_classes']}")
        click.echo(f"  Unique methods: {summary['unique_methods']}")
        click.echo(f"  Unique SQL statements: {summary['unique_sql_statements']}")
        click.echo(f"  Unique tables: {summary['unique_tables']}")
        click.echo(f"  Unique columns: {summary['unique_columns']}")
        click.echo(f"  Missing tables: {summary['missing_tables_count']}")
        click.echo(f"  Missing columns: {summary['missing_columns_count']}")
        
        if missing_nodes['missing_tables']:
            click.echo(f"\nMissing Tables (‚ùå):")
            for table in missing_nodes['missing_tables']:
                click.echo(f"  - {table}")
        
        if missing_nodes['missing_columns']:
            click.echo(f"\nMissing Columns (‚ùå):")
            for column in missing_nodes['missing_columns']:
                click.echo(f"  - {column}")
        
        # Ìò∏Ï∂ú Ï≤¥Ïù∏ ÏÉÅÏÑ∏ Ï†ïÎ≥¥
        if call_chain:
            click.echo(f"\nCall Chain Details:")
            click.echo("-" * 80)
            click.echo(f"{'Source':<25} {'Target':<25} {'SQL Type':<10} {'Table':<20}")
            click.echo("-" * 80)
            
            for call in call_chain[:20]:  # Ï≤òÏùå 20Í∞úÎßå ÌëúÏãú
                source = f"{call['source_class']}.{call['source_method']}" if call['source_method'] else call['source_class']
                target = f"{call['target_class']}.{call['target_method']}" if call['target_method'] else call['target_class']
                sql_type = call['sql_type'] or 'N/A'
                table = call['table_name'] or 'N/A'
                
                click.echo(f"{source:<25} {target:<25} {sql_type:<10} {table:<20}")
            
            if len(call_chain) > 20:
                click.echo(f"... and {len(call_chain) - 20} more calls")
        
        # ÌååÏùºÎ°ú Ï†ÄÏû•
        if output_file:
            import json
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(result, f, indent=2, ensure_ascii=False)
            click.echo(f"\nAnalysis results saved to: {output_file}")
        
    except Exception as e:
        click.echo(f"Error analyzing call chain: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--project-name', required=True, help='Project name to analyze')
@click.option('--output-file', help='Output file to save the CRUD matrix (optional)')
def crud_analysis(neo4j_uri, neo4j_user, project_name, output_file):
    """Generate CRUD matrix analysis."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        analysis_service = DBCallAnalysisService(driver)
        
        click.echo("CRUD Matrix Analysis (SQL Ìò∏Ï∂ú ÌÅ¥ÎûòÏä§Îßå)")
        click.echo("=" * 50)
        
        # CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
        result = analysis_service.generate_crud_matrix(project_name)
        
        if 'error' in result:
            click.echo(f"Error: {result['error']}")
            return
        
        class_matrix = result['class_matrix']
        table_matrix = result['table_matrix']
        summary = result['summary']
        
        click.echo(f"\nCRUD Summary:")
        click.echo(f"  Total classes: {summary['total_classes']}")
        click.echo(f"  Total tables: {summary['total_tables']}")
        click.echo(f"  Create operations: {summary['crud_stats']['C']}")
        click.echo(f"  Read operations: {summary['crud_stats']['R']}")
        click.echo(f"  Update operations: {summary['crud_stats']['U']}")
        click.echo(f"  Delete operations: {summary['crud_stats']['D']}")
        click.echo(f"  Other operations: {summary['crud_stats']['O']}")
        
        if summary['most_active_class']:
            click.echo(f"  Most active class: {summary['most_active_class']}")
        if summary['most_used_table']:
            click.echo(f"  Most used table: {summary['most_used_table']}")
        
        # ÌÅ¥ÎûòÏä§Î≥Ñ CRUD Îß§Ìä∏Î¶≠Ïä§
        if class_matrix:
            click.echo(f"\nClass CRUD Matrix:")
            click.echo("-" * 80)
            click.echo(f"{'Class Name':<30} {'Package':<25} {'Tables':<20} {'Operations':<15}")
            click.echo("-" * 80)
            
            for row in class_matrix:
                class_name = row['class_name']
                package_name = row['package_name'] or 'N/A'
                tables = ', '.join(row['tables']) if row['tables'] else 'None'
                operations = ', '.join(row['operations']) if row['operations'] else 'None'
                
                click.echo(f"{class_name:<30} {package_name:<25} {tables:<20} {operations:<15}")
        
        # ÌÖåÏù¥Î∏îÎ≥Ñ CRUD Îß§Ìä∏Î¶≠Ïä§
        if table_matrix:
            click.echo(f"\nTable CRUD Matrix:")
            click.echo("-" * 60)
            click.echo(f"{'Table Name':<30} {'Operations':<30}")
            click.echo("-" * 60)
            
            for row in table_matrix:
                table_name = row['table_name']
                operations = []
                for op in row['operations']:
                    operations.append(f"{op['operation']}({op['count']})")
                operations_str = ', '.join(operations)
                
                click.echo(f"{table_name:<30} {operations_str:<30}")
        
        # ÌååÏùºÎ°ú Ï†ÄÏû•
        if output_file:
            import json
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(result, f, indent=2, ensure_ascii=False)
            click.echo(f"\nCRUD matrix saved to: {output_file}")
        
    except Exception as e:
        click.echo(f"Error generating CRUD matrix: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--project-name', required=True, help='Project name to analyze')
@click.option('--start-class', help='Starting class for diagram (optional)')
@click.option('--start-method', help='Starting method for diagram (optional)')
@click.option('--output-file', help='Output file to save the diagram (optional)')
@click.option('--output-image', help='Output image file (PNG/SVG/PDF) - requires mermaid-cli')
@click.option('--image-format', default='png', type=click.Choice(['png', 'svg', 'pdf']), help='Image format (default: png)')
@click.option('--image-width', default=1200, help='Image width in pixels (default: 1200)')
@click.option('--image-height', default=800, help='Image height in pixels (default: 800)')
def db_call_diagram(neo4j_uri, neo4j_user, project_name, start_class, start_method, output_file, output_image, image_format, image_width, image_height):
    """Generate database call chain diagram."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        analysis_service = DBCallAnalysisService(driver)
        
        click.echo("Database Call Chain Diagram")
        click.echo("=" * 50)
        
        if start_class and start_method:
            click.echo(f"Generating diagram from {start_class}.{start_method}")
        elif start_class:
            click.echo(f"Generating diagram from class {start_class}")
        else:
            click.echo(f"Generating diagram for project {project_name}")
        
        # Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏÉùÏÑ±
        diagram = analysis_service.generate_call_chain_diagram(project_name, start_class, start_method)
        
        if diagram.startswith("Ïò§Î•ò:"):
            click.echo(f"Error: {diagram}")
            return
        
        # ÌååÏùºÎ°ú Ï†ÄÏû•
        if output_file:
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(diagram)
            click.echo(f"Diagram saved to: {output_file}")
        else:
            # Í∏∞Î≥∏ ÌååÏùºÎ™ÖÏúºÎ°ú Ï†ÄÏû•
            default_filename = f"db_call_chain_{project_name}.md"
            with open(default_filename, 'w', encoding='utf-8') as f:
                f.write(diagram)
            click.echo(f"Diagram saved to: {default_filename}")
        
        # Ïù¥ÎØ∏ÏßÄÎ°ú Î≥ÄÌôò
        if output_image:
            convert_to_image(diagram, output_image, image_format, image_width, image_height)
        
        # Îã§Ïù¥Ïñ¥Í∑∏Îû® ÎØ∏Î¶¨Î≥¥Í∏∞
        click.echo("\n" + "="*50)
        click.echo("DATABASE CALL CHAIN DIAGRAM")
        click.echo("="*50)
        click.echo(diagram)
        click.echo("="*50)
        
    except Exception as e:
        click.echo(f"Error generating diagram: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--project-name', required=True, help='Project name to analyze')
@click.option('--table-name', required=True, help='Table name to analyze impact for')
@click.option('--output-file', help='Output file to save the impact analysis (optional)')
def table_impact(neo4j_uri, neo4j_user, project_name, table_name, output_file):
    """Analyze impact of table changes on application code."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        analysis_service = DBCallAnalysisService(driver)
        
        click.echo("Table Impact Analysis")
        click.echo("=" * 50)
        click.echo(f"Analyzing impact of changes to table: {table_name}")
        
        # ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù
        result = analysis_service.analyze_table_impact(project_name, table_name)
        
        if 'error' in result:
            click.echo(f"Error: {result['error']}")
            return
        
        impacted_classes = result['impacted_classes']
        summary = result['summary']
        
        click.echo(f"\nImpact Summary:")
        click.echo(f"  Table: {summary['table_name']}")
        click.echo(f"  Impacted classes: {summary['total_impacted_classes']}")
        click.echo(f"  Impacted methods: {summary['total_impacted_methods']}")
        click.echo(f"  SQL statements: {summary['total_sql_statements']}")
        click.echo(f"  CRUD operations: {', '.join(summary['crud_operations'])}")
        
        if summary['high_complexity_sql']:
            click.echo(f"  High complexity SQL: {len(summary['high_complexity_sql'])}")
        
        # ÏòÅÌñ•Î∞õÎäî ÌÅ¥ÎûòÏä§ ÏÉÅÏÑ∏ Ï†ïÎ≥¥
        if impacted_classes:
            click.echo(f"\nImpacted Classes:")
            click.echo("-" * 80)
            click.echo(f"{'Class':<25} {'Method':<25} {'SQL Type':<10} {'Complexity':<12}")
            click.echo("-" * 80)
            
            for cls in impacted_classes:
                class_name = cls['class_name']
                method_name = cls['method_name'] or 'N/A'
                sql_type = cls['sql_type'] or 'N/A'
                complexity = str(cls['complexity_score']) if cls['complexity_score'] else 'N/A'
                
                click.echo(f"{class_name:<25} {method_name:<25} {sql_type:<10} {complexity:<12}")
        
        # Í≥†Î≥µÏû°ÎèÑ SQL ÏÉÅÏÑ∏ Ï†ïÎ≥¥
        if summary['high_complexity_sql']:
            click.echo(f"\nHigh Complexity SQL Statements:")
            click.echo("-" * 60)
            for sql in summary['high_complexity_sql']:
                click.echo(f"  {sql['class_name']}.{sql['method_name']} - {sql['sql_type']} (complexity: {sql['complexity_score']})")
        
        # ÌååÏùºÎ°ú Ï†ÄÏû•
        if output_file:
            import json
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(result, f, indent=2, ensure_ascii=False)
            click.echo(f"\nImpact analysis saved to: {output_file}")
        
    except Exception as e:
        click.echo(f"Error analyzing table impact: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--project-name', required=True, help='Project name to analyze')
@click.option('--output-file', help='Output file to save the statistics (optional)')
def db_statistics(neo4j_uri, neo4j_user, project_name, output_file):
    """Show database usage statistics."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        analysis_service = DBCallAnalysisService(driver)
        
        click.echo("Database Usage Statistics")
        click.echo("=" * 50)
        
        # ÌÜµÍ≥Ñ Ï°∞Ìöå
        result = analysis_service.get_database_usage_statistics(project_name)
        
        if 'error' in result:
            click.echo(f"Error: {result['error']}")
            return
        
        sql_stats = result['sql_statistics']
        table_usage = result['table_usage']
        complexity_stats = result['complexity_statistics']
        
        # SQL ÌÜµÍ≥Ñ
        if sql_stats:
            click.echo(f"\nSQL Statistics:")
            click.echo(f"  Total SQL statements: {sql_stats['total_sql']}")
            click.echo(f"  SELECT statements: {sql_stats.get('SELECT', 0)}")
            click.echo(f"  INSERT statements: {sql_stats.get('INSERT', 0)}")
            click.echo(f"  UPDATE statements: {sql_stats.get('UPDATE', 0)}")
            click.echo(f"  DELETE statements: {sql_stats.get('DELETE', 0)}")
        
        # ÌÖåÏù¥Î∏î ÏÇ¨Ïö© ÌÜµÍ≥Ñ
        if table_usage:
            click.echo(f"\nTable Usage Statistics:")
            click.echo("-" * 60)
            click.echo(f"{'Table Name':<30} {'Access Count':<15} {'Operations':<20}")
            click.echo("-" * 60)
            
            for table in table_usage:
                table_name = table['table_name']
                access_count = table['access_count']
                operations = ', '.join(table['operations'])
                click.echo(f"{table_name:<30} {access_count:<15} {operations:<20}")
        
        # Î≥µÏû°ÎèÑ ÌÜµÍ≥Ñ
        if complexity_stats:
            click.echo(f"\nSQL Complexity Statistics:")
            click.echo(f"  Simple queries: {complexity_stats.get('simple', 0)}")
            click.echo(f"  Medium queries: {complexity_stats.get('medium', 0)}")
            click.echo(f"  Complex queries: {complexity_stats.get('complex', 0)}")
            click.echo(f"  Very complex queries: {complexity_stats.get('very_complex', 0)}")
        
        # ÌååÏùºÎ°ú Ï†ÄÏû•
        if output_file:
            import json
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(result, f, indent=2, ensure_ascii=False)
            click.echo(f"\nStatistics saved to: {output_file}")
        
    except Exception as e:
        click.echo(f"Error getting database statistics: {e}")
        exit(1)
    finally:
        driver.close()

if __name__ == '__main__':
    cli()

```

Ï∂îÍ∞ÄÎ°ú SQL Ìò∏Ï∂ú ÌÅ¥ÎûòÏä§Í∞Ä ÏóÜÎäî Í≤ΩÏö∞Ïóê ÎåÄÌïú ÏïàÎÇ¥ Î©îÏãúÏßÄÎèÑ Ï∂îÍ∞ÄÌïòÍ≤†ÏäµÎãàÎã§:


```python
import click
import sys
import os
from dotenv import load_dotenv

# Add the project root to Python path
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from src.services.java_parser import parse_java_project
from src.services.graph_db import GraphDB
from src.services.sequence_diagram_generator import SequenceDiagramGenerator
from src.services.db_parser import DBParser
from src.services.db_call_analysis import DBCallAnalysisService
from neo4j import GraphDatabase
import subprocess
import tempfile

load_dotenv()

def convert_to_image(diagram_content, output_file, image_format, width, height):
    """Convert Mermaid diagram to image using mermaid-cli"""
    # Try different possible locations for mmdc
    mmdc_commands = ['mmdc', 'mmdc.cmd', r'C:\Users\cjony\AppData\Roaming\npm\mmdc', r'C:\Users\cjony\AppData\Roaming\npm\mmdc.cmd']
    
    mmdc_cmd = None
    for cmd in mmdc_commands:
        try:
            subprocess.run([cmd, '--version'], capture_output=True, check=True, timeout=5)
            mmdc_cmd = cmd
            break
        except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired):
            continue
    
    if not mmdc_cmd:
        click.echo("Error: mermaid-cli is not installed or not found in PATH.")
        click.echo("Please install it with: npm install -g @mermaid-js/mermaid-cli")
        click.echo("Or check if it's installed at: C:\\Users\\cjony\\AppData\\Roaming\\npm\\")
        return
    
    try:
        # Create temporary file for mermaid content
        with tempfile.NamedTemporaryFile(mode='w', suffix='.md', delete=False, encoding='utf-8', newline='') as temp_file:
            temp_file.write(diagram_content)
            temp_file_path = temp_file.name
        
        # Determine format from output file extension
        file_extension = output_file.split('.')[-1].lower()
        actual_format = file_extension if file_extension in ['png', 'svg', 'pdf'] else image_format
        
        # Convert to image using mermaid-cli
        cmd = [
            mmdc_cmd,
            '-i', temp_file_path,
            '-o', output_file,
            '-e', actual_format,
            '-w', str(width),
            '-H', str(height)
        ]
        
        # Add PDF-specific options
        if image_format.lower() == 'pdf':
            # Set background color for PDF
            cmd.extend(['-b', 'white'])
            # Add PDF fit option
            cmd.append('-f')
        
        click.echo(f"Running command: {' '.join(cmd)}")
        
        # Set environment variables for UTF-8 encoding
        env = os.environ.copy()
        env['PYTHONIOENCODING'] = 'utf-8'
        env['LANG'] = 'en_US.UTF-8'
        env['LC_ALL'] = 'en_US.UTF-8'
        
        result = subprocess.run(cmd, capture_output=True, text=True, check=True, encoding='utf-8', errors='ignore', env=env)
        
        # Clean up temporary file
        os.unlink(temp_file_path)
        
        # Check if the expected output file was created
        if os.path.exists(output_file):
            actual_format = output_file.split('.')[-1].upper()
            click.echo(f"Image saved to: {output_file}")
            click.echo(f"Format: {actual_format}, Size: {width}x{height}")
        else:
            # Check for files with similar names (mermaid-cli sometimes adds numbers)
            import glob
            pattern = output_file.replace('.pdf', '-*.pdf').replace('.png', '-*.png').replace('.svg', '-*.svg')
            matching_files = glob.glob(pattern)
            if matching_files:
                actual_file = matching_files[0]
                actual_format = actual_file.split('.')[-1].upper()
                click.echo(f"Image saved to: {actual_file}")
                click.echo(f"Format: {actual_format}, Size: {width}x{height}")
                click.echo(f"Note: mermaid-cli created {actual_file} instead of {output_file}")
            else:
                click.echo(f"Warning: Expected file {output_file} not found")
        
        click.echo(f"Command output: {result.stdout}")
        
    except subprocess.CalledProcessError as e:
        click.echo(f"Error converting to image: {e}")
        click.echo(f"Error output: {e.stderr}")
        if os.path.exists(temp_file_path):
            os.unlink(temp_file_path)
    except Exception as e:
        click.echo(f"Unexpected error: {e}")
        if 'temp_file_path' in locals() and os.path.exists(temp_file_path):
            os.unlink(temp_file_path)

@click.group()
def cli():
    pass

@cli.command()
@click.option('--java-source-folder', default=os.getenv("JAVA_SOURCE_FOLDER"), help='Path to the Java source project folder.')
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--neo4j-password', default=os.getenv("NEO4J_PASSWORD"), help='Neo4j password')
@click.option('--clean', is_flag=True, help='Wipe the database before analysis.')
@click.option('--class-name', help='Analyze only a specific class (delete existing data for this class first)')
@click.option('--update', is_flag=True, help='Update all classes individually without clearing database')
@click.option('--db_object', is_flag=True, help='Analyze database objects from DDL scripts')
@click.option('--java_object', is_flag=True, help='Analyze Java objects from source code')
@click.option('--dry-run', is_flag=True, help='Parse Java files without connecting to database.')
def analyze(java_source_folder, neo4j_uri, neo4j_user, neo4j_password, clean, class_name, update, db_object, java_object, dry_run):
    """Analyzes a Java project and populates a Neo4j database."""
    if not java_source_folder:
        click.echo("Error: JAVA_SOURCE_FOLDER environment variable or --java-source-folder option is required.", err=True)
        exit(1)

    # Extract project name from directory path
    from pathlib import Path
    project_name = Path(java_source_folder).resolve().name

    # Handle Java object analysis
    if java_object:
        click.echo("Analyzing Java objects from source code...")
        
        if not java_source_folder:
            click.echo("Error: JAVA_SOURCE_FOLDER environment variable is required for --java_object option.", err=True)
            click.echo("Please set JAVA_SOURCE_FOLDER in your .env file or environment variables.")
            exit(1)
        
        if not os.path.exists(java_source_folder):
            click.echo(f"Error: Java source folder {java_source_folder} does not exist.", err=True)
            exit(1)
        
        try:
            # Parse Java project
            click.echo(f"Parsing Java project at: {java_source_folder}")
            packages_to_add, classes_to_add, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, jpa_repositories, jpa_queries, config_files, test_classes, sql_statements, project_name = parse_java_project(java_source_folder)
            
            click.echo(f"Project name: {project_name}")
            click.echo(f"Found {len(packages_to_add)} packages and {len(classes_to_add)} classes.")
            
            if dry_run:
                click.echo("Dry run mode - not connecting to database.")
                click.echo(f"Found {len(packages_to_add)} packages and {len(classes_to_add)} classes.")
                click.echo(f"Found {len(beans)} Spring Beans and {len(dependencies)} dependencies.")
                click.echo(f"Found {len(endpoints)} REST API endpoints.")
                click.echo(f"Found {len(mybatis_mappers)} MyBatis mappers.")
                click.echo(f"Found {len(jpa_entities)} JPA entities.")
                click.echo(f"Found {len(jpa_repositories)} JPA repositories.")
                click.echo(f"Found {len(jpa_queries)} JPA queries.")
                click.echo(f"Found {len(config_files)} configuration files.")
                click.echo(f"Found {len(test_classes)} test classes.")
                click.echo(f"Found {len(sql_statements)} SQL statements.")
                click.echo("Java object analysis complete (dry run).")
                return
            
            # Connect to database
            click.echo(f"Connecting to Neo4j at {neo4j_uri}...")
            db = GraphDB(uri=neo4j_uri, user=neo4j_user, password=neo4j_password)
            
            if clean:
                click.echo("Cleaning Java objects...")
                with db._driver.session() as session:
                    # Delete only Java-related nodes
                    session.run("MATCH (n:Package) DETACH DELETE n")
                    session.run("MATCH (n:Class) DETACH DELETE n")
                    session.run("MATCH (n:Method) DETACH DELETE n")
                    session.run("MATCH (n:Field) DETACH DELETE n")
                    session.run("MATCH (n:Bean) DETACH DELETE n")
                    session.run("MATCH (n:Endpoint) DETACH DELETE n")
                    session.run("MATCH (n:MyBatisMapper) DETACH DELETE n")
                    session.run("MATCH (n:JpaEntity) DETACH DELETE n")
                    session.run("MATCH (n:ConfigFile) DETACH DELETE n")
                    session.run("MATCH (n:TestClass) DETACH DELETE n")
                    session.run("MATCH (n:SqlStatement) DETACH DELETE n")
            
            # Add packages
            click.echo("Adding packages to database...")
            for package_node in packages_to_add:
                db.add_package(package_node, project_name)
            
            # Add classes
            click.echo("Adding classes to database...")
            for class_node in classes_to_add:
                # Find the package for this class using the mapping
                class_key = f"{class_to_package_map.get(class_node.name, '')}.{class_node.name}"
                package_name = class_to_package_map.get(class_key, None)
                
                if not package_name:
                    # Fallback: try to find package by class name
                    for key, pkg_name in class_to_package_map.items():
                        if key.endswith(f".{class_node.name}"):
                            package_name = pkg_name
                            break
                
                db.add_class(class_node, package_name, project_name)
            
            # Add Spring Boot analysis results
            if beans:
                click.echo(f"Adding {len(beans)} Spring Beans to database...")
                for bean in beans:
                    db.add_bean(bean, project_name)
            
            if dependencies:
                click.echo(f"Adding {len(dependencies)} Bean dependencies to database...")
                for dependency in dependencies:
                    db.add_bean_dependency(dependency, project_name)
            
            if endpoints:
                click.echo(f"Adding {len(endpoints)} REST API endpoints to database...")
                for endpoint in endpoints:
                    db.add_endpoint(endpoint, project_name)
            
            if mybatis_mappers:
                click.echo(f"Adding {len(mybatis_mappers)} MyBatis mappers to database...")
                for mapper in mybatis_mappers:
                    db.add_mybatis_mapper(mapper, project_name)
            
            if jpa_entities:
                click.echo(f"Adding {len(jpa_entities)} JPA entities to database...")
                for entity in jpa_entities:
                    db.add_jpa_entity(entity, project_name)
            
            if jpa_repositories:
                click.echo(f"Adding {len(jpa_repositories)} JPA repositories to database...")
                for repository in jpa_repositories:
                    db.add_jpa_repository(repository, project_name)
            
            if jpa_queries:
                click.echo(f"Adding {len(jpa_queries)} JPA queries to database...")
                for query in jpa_queries:
                    db.add_jpa_query(query, project_name)
            
            if config_files:
                click.echo(f"Adding {len(config_files)} configuration files to database...")
                for config_file in config_files:
                    db.add_config_file(config_file, project_name)
            
            if test_classes:
                click.echo(f"Adding {len(test_classes)} test classes to database...")
                for test_class in test_classes:
                    db.add_test_class(test_class, project_name)
            
            if sql_statements:
                click.echo(f"Adding {len(sql_statements)} SQL statements to database...")
                for sql_statement in sql_statements:
                    db.add_sql_statement(sql_statement, project_name)
                    # Create relationship between mapper and SQL statement
                    with db._driver.session() as session:
                        session.execute_write(db._create_mapper_sql_relationship_tx, sql_statement.mapper_name, sql_statement.id, project_name)
            
            db.close()
            click.echo("Java object analysis complete.")
            return
            
        except Exception as e:
            click.echo(f"Error analyzing Java objects: {e}")
            click.echo("Use --dry-run flag to parse without database connection.")
            exit(1)

    # Handle DB object analysis
    if db_object:
        click.echo("Analyzing database objects from DDL scripts...")
        
        # Get DB script folder from environment variable
        db_script_folder = os.getenv("DB_SCRIPT_FOLDER")
        if not db_script_folder:
            click.echo("Error: DB_SCRIPT_FOLDER environment variable is required for --db_object option.", err=True)
            click.echo("Please set DB_SCRIPT_FOLDER in your .env file or environment variables.")
            exit(1)
        
        if not os.path.exists(db_script_folder):
            click.echo(f"Error: DB script folder {db_script_folder} does not exist.", err=True)
            exit(1)
        
        try:
            # Parse DDL files
            db_parser = DBParser()
            all_db_objects = db_parser.parse_ddl_directory(db_script_folder, project_name)
            
            if not all_db_objects:
                click.echo("No DDL files found or parsed successfully.")
                return
            
            click.echo(f"Found {len(all_db_objects)} DDL files to process.")
            
            if dry_run:
                click.echo("Dry run mode - not connecting to database.")
                for i, db_objects in enumerate(all_db_objects):
                    click.echo(f"DDL file {i+1}:")
                    click.echo(f"  Database: {db_objects['database'].name}")
                    click.echo(f"  Tables: {len(db_objects['tables'])}")
                    click.echo(f"  Columns: {len(db_objects['columns'])}")
                    click.echo(f"  Indexes: {len(db_objects['indexes'])}")
                    click.echo(f"  Constraints: {len(db_objects['constraints'])}")
                click.echo("DB object analysis complete (dry run).")
                return
            
            # Connect to database
            click.echo(f"Connecting to Neo4j at {neo4j_uri}...")
            db = GraphDB(uri=neo4j_uri, user=neo4j_user, password=neo4j_password)
            
            if clean:
                click.echo("Cleaning database objects...")
                with db._driver.session() as session:
                    # Delete only database-related nodes
                    session.run("MATCH (n:Database) DETACH DELETE n")
                    session.run("MATCH (n:Table) DETACH DELETE n")
                    session.run("MATCH (n:Column) DETACH DELETE n")
                    session.run("MATCH (n:Index) DETACH DELETE n")
                    session.run("MATCH (n:Constraint) DETACH DELETE n")
            
            # Process each DDL file's objects
            for i, db_objects in enumerate(all_db_objects):
                click.echo(f"Processing DDL file {i+1}...")
                
                # Add database
                click.echo(f"Adding database: {db_objects['database'].name}")
                db.add_database(db_objects['database'], project_name)
                
                # Add tables
                for table_obj in db_objects['tables']:
                    click.echo(f"Adding table: {table_obj.name}")
                    db.add_table(table_obj, db_objects['database'].name, project_name)
                
                # Add columns
                for column_obj in db_objects['columns']:
                    table_name = getattr(column_obj, 'table_name', 'unknown')
                    click.echo(f"Adding column: {column_obj.name} to table {table_name}")
                    db.add_column(column_obj, table_name, project_name)
                
                # Add indexes
                for index_obj, table_name in db_objects['indexes']:
                    click.echo(f"Adding index: {index_obj.name} to table {table_name}")
                    db.add_index(index_obj, table_name, project_name)
                
                # Add constraints
                for constraint_obj, table_name in db_objects['constraints']:
                    click.echo(f"Adding constraint: {constraint_obj.name} to table {table_name}")
                    db.add_constraint(constraint_obj, table_name, project_name)
            
            db.close()
            click.echo("DB object analysis complete.")
            return
            
        except Exception as e:
            click.echo(f"Error analyzing DB objects: {e}")
            click.echo("Use --dry-run flag to parse without database connection.")
            exit(1)

    # If analyzing a specific class
    if class_name:
        click.echo(f"Analyzing specific class: {class_name}")
        
        # Find the Java file for this class
        java_file_path = None
        for root, _, files in os.walk(java_source_folder):
            for file in files:
                if file.endswith(".java") and file.replace(".java", "") == class_name:
                    java_file_path = os.path.join(root, file)
                    break
            if java_file_path:
                break
        
        if not java_file_path:
            click.echo(f"Error: Could not find Java file for class '{class_name}'", err=True)
            exit(1)
        
        click.echo(f"Found Java file: {java_file_path}")
        
        try:
            # Parse the single Java file
            from src.services.java_parser import parse_single_java_file, extract_beans_from_classes, analyze_bean_dependencies, extract_endpoints_from_classes, extract_mybatis_mappers_from_classes, extract_jpa_entities_from_classes, extract_test_classes_from_classes, extract_sql_statements_from_mappers
            
            package_node, class_node, package_name = parse_single_java_file(java_file_path, project_name)
            
            click.echo(f"Parsed class: {class_node.name}")
            click.echo(f"Package: {package_name}")
            click.echo(f"Methods: {len(class_node.methods)}")
            click.echo(f"Properties: {len(class_node.properties)}")
            click.echo(f"Method calls: {len(class_node.calls)}")
            
            if dry_run:
                click.echo("Dry run mode - not connecting to database.")
                click.echo("Analysis complete (dry run).")
                return
            
            # Connect to database
            click.echo(f"Connecting to Neo4j at {neo4j_uri}...")
            db = GraphDB(uri=neo4j_uri, user=neo4j_user, password=neo4j_password)
            
            # Delete existing data for this class
            click.echo(f"Deleting existing data for class '{class_name}'...")
            db.delete_class_and_related_data(class_name, project_name)
            
            # Add package
            click.echo("Adding package to database...")
            db.add_package(package_node, project_name)
            
            # Add class
            click.echo("Adding class to database...")
            db.add_class(class_node, package_name, project_name)
            
            # Extract and add related Spring Boot analysis results for this class only
            classes_list = [class_node]
            beans = extract_beans_from_classes(classes_list)
            dependencies = analyze_bean_dependencies(classes_list, beans)
            endpoints = extract_endpoints_from_classes(classes_list)
            mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
            jpa_entities = extract_jpa_entities_from_classes(classes_list)
            test_classes = extract_test_classes_from_classes(classes_list)
            
            # Extract SQL statements from MyBatis mappers
            sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
            
            # Add Spring Boot analysis results
            if beans:
                click.echo(f"Adding {len(beans)} Spring Beans to database...")
                for bean in beans:
                    db.add_bean(bean, project_name)
            
            if dependencies:
                click.echo(f"Adding {len(dependencies)} Bean dependencies to database...")
                for dependency in dependencies:
                    db.add_bean_dependency(dependency, project_name)
            
            if endpoints:
                click.echo(f"Adding {len(endpoints)} REST API endpoints to database...")
                for endpoint in endpoints:
                    db.add_endpoint(endpoint, project_name)
            
            if mybatis_mappers:
                click.echo(f"Adding {len(mybatis_mappers)} MyBatis mappers to database...")
                for mapper in mybatis_mappers:
                    db.add_mybatis_mapper(mapper, project_name)
            
            if jpa_entities:
                click.echo(f"Adding {len(jpa_entities)} JPA entities to database...")
                for entity in jpa_entities:
                    db.add_jpa_entity(entity, project_name)
            
            if test_classes:
                click.echo(f"Adding {len(test_classes)} test classes to database...")
                for test_class in test_classes:
                    db.add_test_class(test_class, project_name)
            
            if sql_statements:
                click.echo(f"Adding {len(sql_statements)} SQL statements to database...")
                for sql_statement in sql_statements:
                    db.add_sql_statement(sql_statement, project_name)
                    # Create relationship between mapper and SQL statement
                    with db._driver.session() as session:
                        session.execute_write(db._create_mapper_sql_relationship_tx, sql_statement.mapper_name, sql_statement.id, project_name)
            
            db.close()
            click.echo("Class analysis complete.")
            
        except Exception as e:
            click.echo(f"Error analyzing class: {e}")
            click.echo("Use --dry-run flag to parse without database connection.")
            exit(1)
        
        return

    # If updating all classes individually
    if update:
        click.echo("Updating all classes individually...")
        
        # Find all Java files
        java_files = []
        for root, _, files in os.walk(java_source_folder):
            for file in files:
                if file.endswith(".java"):
                    java_files.append(os.path.join(root, file))
        
        if not java_files:
            click.echo("No Java files found in the specified directory.", err=True)
            exit(1)
        
        click.echo(f"Found {len(java_files)} Java files to process.")
        
        if dry_run:
            click.echo("Dry run mode - not connecting to database.")
            for java_file in java_files:
                try:
                    from src.services.java_parser import parse_single_java_file
                    package_node, class_node, package_name = parse_single_java_file(java_file, project_name)
                    click.echo(f"  {class_node.name} ({package_name}) - Methods: {len(class_node.methods)}, Properties: {len(class_node.properties)}")
                except Exception as e:
                    click.echo(f"  Error parsing {java_file}: {e}")
            click.echo("Update analysis complete (dry run).")
            return
        
        try:
            # Connect to database
            click.echo(f"Connecting to Neo4j at {neo4j_uri}...")
            db = GraphDB(uri=neo4j_uri, user=neo4j_user, password=neo4j_password)
            
            processed_count = 0
            error_count = 0
            
            for java_file in java_files:
                try:
                    click.echo(f"Processing: {java_file}")
                    
                    # Parse the single Java file
                    from src.services.java_parser import parse_single_java_file, extract_beans_from_classes, analyze_bean_dependencies, extract_endpoints_from_classes, extract_mybatis_mappers_from_classes, extract_jpa_entities_from_classes, extract_test_classes_from_classes, extract_sql_statements_from_mappers
                    
                    package_node, class_node, package_name = parse_single_java_file(java_file, project_name)
                    
                    click.echo(f"  Parsed class: {class_node.name} (Package: {package_name})")
                    
                    # Delete existing data for this class
                    click.echo(f"  Deleting existing data for class '{class_node.name}'...")
                    db.delete_class_and_related_data(class_node.name, project_name)
                    
                    # Add package
                    db.add_package(package_node, project_name)
                    
                    # Add class
                    db.add_class(class_node, package_name, project_name)
                    
                    # Extract and add related Spring Boot analysis results for this class only
                    classes_list = [class_node]
                    beans = extract_beans_from_classes(classes_list)
                    dependencies = analyze_bean_dependencies(classes_list, beans)
                    endpoints = extract_endpoints_from_classes(classes_list)
                    mybatis_mappers = extract_mybatis_mappers_from_classes(classes_list)
                    jpa_entities = extract_jpa_entities_from_classes(classes_list)
                    test_classes = extract_test_classes_from_classes(classes_list)
                    
                    # Extract SQL statements from MyBatis mappers
                    sql_statements = extract_sql_statements_from_mappers(mybatis_mappers, project_name)
                    
                    # Add Spring Boot analysis results
                    if beans:
                        for bean in beans:
                            db.add_bean(bean, project_name)
                    
                    if dependencies:
                        for dependency in dependencies:
                            db.add_bean_dependency(dependency, project_name)
                    
                    if endpoints:
                        for endpoint in endpoints:
                            db.add_endpoint(endpoint, project_name)
                    
                    if mybatis_mappers:
                        for mapper in mybatis_mappers:
                            db.add_mybatis_mapper(mapper, project_name)
                    
                    if jpa_entities:
                        for entity in jpa_entities:
                            db.add_jpa_entity(entity, project_name)
                    
                    if test_classes:
                        for test_class in test_classes:
                            db.add_test_class(test_class, project_name)
                    
                    if sql_statements:
                        for sql_statement in sql_statements:
                            db.add_sql_statement(sql_statement, project_name)
                            # Create relationship between mapper and SQL statement
                            with db._driver.session() as session:
                                session.execute_write(db._create_mapper_sql_relationship_tx, sql_statement.mapper_name, sql_statement.id, project_name)
                    
                    processed_count += 1
                    click.echo(f"  [OK] Successfully processed {class_node.name}")
                    
                except Exception as e:
                    error_count += 1
                    click.echo(f"  [ERROR] Error processing {java_file}: {e}")
                    continue
            
            db.close()
            click.echo(f"Update complete. Processed: {processed_count}, Errors: {error_count}")
            
        except Exception as e:
            click.echo(f"Error during update: {e}")
            click.echo("Use --dry-run flag to parse without database connection.")
            exit(1)
        
        return

    # Original full project analysis (when no specific object type is specified)
    if not java_object and not db_object:
        click.echo(f"Parsing Java project at: {java_source_folder}")
        packages_to_add, classes_to_add, class_to_package_map, beans, dependencies, endpoints, mybatis_mappers, jpa_entities, jpa_repositories, jpa_queries, config_files, test_classes, sql_statements, project_name = parse_java_project(java_source_folder)
    
        click.echo(f"Project name: {project_name}")
        
        click.echo(f"Found {len(packages_to_add)} packages and {len(classes_to_add)} classes.")
        
        if dry_run:
            click.echo("Dry run mode - not connecting to database.")
            click.echo(f"Found {len(packages_to_add)} packages and {len(classes_to_add)} classes.")
            click.echo(f"Found {len(beans)} Spring Beans and {len(dependencies)} dependencies.")
            click.echo(f"Found {len(endpoints)} REST API endpoints.")
            click.echo(f"Found {len(mybatis_mappers)} MyBatis mappers.")
            click.echo(f"Found {len(jpa_entities)} JPA entities.")
            click.echo(f"Found {len(jpa_repositories)} JPA repositories.")
            click.echo(f"Found {len(jpa_queries)} JPA queries.")
            click.echo(f"Found {len(config_files)} configuration files.")
            click.echo(f"Found {len(test_classes)} test classes.")
            click.echo(f"Found {len(sql_statements)} SQL statements.")
            
            for package_node in packages_to_add:
                click.echo(f"Package: {package_node.name}")
            for class_node in classes_to_add:
                click.echo(f"Class: {class_node.name}")
                click.echo(f"  Methods: {len(class_node.methods)}")
                click.echo(f"  Properties: {len(class_node.properties)}")
                click.echo(f"  Method calls: {len(class_node.calls)}")
            click.echo("Analysis complete (dry run).")
            return

        try:
            click.echo(f"Connecting to Neo4j at {neo4j_uri}...")
            db = GraphDB(uri=neo4j_uri, user=neo4j_user, password=neo4j_password)

            if clean:
                click.echo("Cleaning database...")
                with db._driver.session() as session:
                    session.run("MATCH (n) DETACH DELETE n")

            click.echo("Adding packages to database...")
            for package_node in packages_to_add:
                db.add_package(package_node, project_name)
        
            click.echo("Adding classes to database...")
            for class_node in classes_to_add:
                # Find the package for this class using the mapping
                class_key = f"{class_to_package_map.get(class_node.name, '')}.{class_node.name}"
                package_name = class_to_package_map.get(class_key, None)
                
                if not package_name:
                    # Fallback: try to find package by class name
                    for key, pkg_name in class_to_package_map.items():
                        if key.endswith(f".{class_node.name}"):
                            package_name = pkg_name
                            break
                
                db.add_class(class_node, package_name, project_name)
        
            # Add Spring Boot analysis results
            if beans:
                click.echo(f"Adding {len(beans)} Spring Beans to database...")
                for bean in beans:
                    db.add_bean(bean, project_name)
        
            if dependencies:
                click.echo(f"Adding {len(dependencies)} Bean dependencies to database...")
                for dependency in dependencies:
                    db.add_bean_dependency(dependency, project_name)
        
            if endpoints:
                click.echo(f"Adding {len(endpoints)} REST API endpoints to database...")
                for endpoint in endpoints:
                    db.add_endpoint(endpoint, project_name)
        
            if mybatis_mappers:
                click.echo(f"Adding {len(mybatis_mappers)} MyBatis mappers to database...")
                for mapper in mybatis_mappers:
                    db.add_mybatis_mapper(mapper, project_name)
            
            if jpa_entities:
                click.echo(f"Adding {len(jpa_entities)} JPA entities to database...")
                for entity in jpa_entities:
                    db.add_jpa_entity(entity, project_name)
            
            if jpa_repositories:
                click.echo(f"Adding {len(jpa_repositories)} JPA repositories to database...")
                for repository in jpa_repositories:
                    db.add_jpa_repository(repository, project_name)
            
            if jpa_queries:
                click.echo(f"Adding {len(jpa_queries)} JPA queries to database...")
                for query in jpa_queries:
                    db.add_jpa_query(query, project_name)
            
            if config_files:
                click.echo(f"Adding {len(config_files)} configuration files to database...")
                for config_file in config_files:
                    db.add_config_file(config_file, project_name)
        
            if test_classes:
                click.echo(f"Adding {len(test_classes)} test classes to database...")
                for test_class in test_classes:
                    db.add_test_class(test_class, project_name)
        
            if sql_statements:
                click.echo(f"Adding {len(sql_statements)} SQL statements to database...")
                for sql_statement in sql_statements:
                    db.add_sql_statement(sql_statement, project_name)
                    # Create relationship between mapper and SQL statement
                    with db._driver.session() as session:
                        session.execute_write(db._create_mapper_sql_relationship_tx, sql_statement.mapper_name, sql_statement.id, project_name)
        
            db.close()
            click.echo("Analysis complete.")
        except Exception as e:
            click.echo(f"Error connecting to database: {e}")
            click.echo("Use --dry-run flag to parse without database connection.")
            exit(1)

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--neo4j-password', default=os.getenv("NEO4J_PASSWORD"), help='Neo4j password')
@click.option('--query', help='Custom Cypher query to execute')
@click.option('--basic', is_flag=True, help='Run basic class query')
@click.option('--detailed', is_flag=True, help='Run detailed class query with methods and properties')
@click.option('--inheritance', is_flag=True, help='Run inheritance relationship query')
@click.option('--package', is_flag=True, help='Run package-based class query')
def query(neo4j_uri, neo4j_user, neo4j_password, query, basic, detailed, inheritance, package):
    """Execute queries against the Neo4j database."""
    
    # ÎØ∏Î¶¨ Ï†ïÏùòÎêú ÏøºÎ¶¨Îì§
    queries = {
        'basic': """
        MATCH (c:Class)
        RETURN 
            c.name AS name,
            c.logical_name AS logical_name,
            c.file_path AS file_path,
            c.type AS type,
            c.source AS source
        ORDER BY c.name
        """,
        'detailed': """
        MATCH (c:Class)
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (c)-[:HAS_FIELD]->(p:Field)
        OPTIONAL MATCH (pkg:Package)-[:CONTAINS]->(c)
        RETURN 
            c.name AS class_name,
            c.logical_name AS class_logical_name,
            c.file_path AS file_path,
            c.type AS class_type,
            pkg.name AS package_name,
            collect(DISTINCT m.name) AS methods,
            collect(DISTINCT p.name) AS properties
        ORDER BY c.name
        """,
        'inheritance': """
        MATCH (c:Class)
        OPTIONAL MATCH (c)-[:EXTENDS]->(super:Class)
        OPTIONAL MATCH (c)-[:IMPLEMENTS]->(impl:Class)
        RETURN 
            c.name AS class_name,
            c.logical_name AS class_logical_name,
            c.type AS class_type,
            collect(DISTINCT super.name) AS extends,
            collect(DISTINCT impl.name) AS implements
        ORDER BY c.name
        """,
        'package': """
        MATCH (pkg:Package)-[:CONTAINS]->(c:Class)
        OPTIONAL MATCH (c)-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (c)-[:HAS_FIELD]->(p:Field)
        RETURN 
            pkg.name AS package_name,
            pkg.logical_name AS package_logical_name,
            collect(DISTINCT c.name) AS classes,
            count(DISTINCT m) AS total_methods,
            count(DISTINCT p) AS total_properties
        ORDER BY pkg.name
        """
    }
    
    # Ïã§ÌñâÌï† ÏøºÎ¶¨ Í≤∞Ï†ï
    if query:
        cypher_query = query
        description = "Custom Query"
    elif basic:
        cypher_query = queries['basic']
        description = "Basic Class Query"
    elif detailed:
        cypher_query = queries['detailed']
        description = "Detailed Class Query"
    elif inheritance:
        cypher_query = queries['inheritance']
        description = "Inheritance Query"
    elif package:
        cypher_query = queries['package']
        description = "Package Query"
    else:
        click.echo("Error: Please specify a query type or provide a custom query.")
        click.echo("Available options: --basic, --detailed, --inheritance, --package, or --query")
        return
    
    try:
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        
        with driver.session() as session:
            click.echo(f"Executing: {description}")
            click.echo("=" * 50)
            
            result = session.run(cypher_query)
            records = list(result)
            
            if not records:
                click.echo("No results found.")
                return
            
            # Ï≤´ Î≤àÏß∏ Î†àÏΩîÎìúÏùò ÌÇ§Îì§ÏùÑ Ìó§ÎçîÎ°ú ÏÇ¨Ïö©
            headers = list(records[0].keys())
            
            # Ìó§Îçî Ï∂úÎ†•
            click.echo(" | ".join(f"{header:20}" for header in headers))
            click.echo("-" * (len(headers) * 23))
            
            # Îç∞Ïù¥ÌÑ∞ Ï∂úÎ†•
            for record in records:
                row = []
                for header in headers:
                    value = record[header]
                    if value is None:
                        row.append("None")
                    elif isinstance(value, (list, dict)):
                        row.append(str(value)[:50] + "..." if len(str(value)) > 50 else str(value))
                    else:
                        row.append(str(value)[:20])
                click.echo(" | ".join(f"{cell:20}" for cell in row))
            
            click.echo(f"\nTotal: {len(records)} results found.")
            
    except Exception as e:
        click.echo(f"Error executing query: {e}")
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--class-name', required=True, help='Name of the class to analyze')
@click.option('--method-name', help='Specific method to analyze (optional)')
@click.option('--max-depth', default=3, help='Maximum depth of call chain to follow (default: 3)')
@click.option('--include-external', is_flag=True, help='Include calls to external libraries')
@click.option('--method-focused', is_flag=True, help='Generate method-focused diagram (shows only the specified method and its direct calls)')
@click.option('--output-file', help='Output file to save the diagram (optional)')
@click.option('--output-image', help='Output image file (PNG/SVG/PDF) - requires mermaid-cli')
@click.option('--image-format', default='png', type=click.Choice(['png', 'svg', 'pdf']), help='Image format (default: png)')
@click.option('--image-width', default=1200, help='Image width in pixels (default: 1200)')
@click.option('--image-height', default=800, help='Image height in pixels (default: 800)')
def sequence(neo4j_uri, neo4j_user, class_name, method_name, max_depth, include_external, method_focused, output_file, output_image, image_format, image_width, image_height):
    """Generate sequence diagram for a specific class and optionally a method."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        click.echo(f"Connecting to Neo4j at {neo4j_uri}...")
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        generator = SequenceDiagramGenerator(driver)
        
        # Generate the sequence diagram
        click.echo(f"Generating sequence diagram for class: {class_name}")
        if method_name:
            click.echo(f"Focusing on method: {method_name}")
        if method_focused:
            click.echo("Method-focused mode: showing only direct calls from the specified method")
        
        diagram = generator.generate_sequence_diagram(
            class_name=class_name,
            method_name=method_name,
            max_depth=max_depth if not method_focused else 1,  # Method-focused uses depth 1
            include_external_calls=include_external,
            method_focused=method_focused
        )
        
        click.echo(f"Diagram generated (length: {len(diagram)})")
        
        # Check if diagram contains error message
        if diagram.startswith("Error:"):
            click.echo(f"Error: {diagram}")
            return
        
        # Output the diagram
        if output_file:
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(diagram)
            click.echo(f"Sequence diagram saved to: {output_file}")
        else:
            # Default: save to {class_name}.md
            default_filename = f"{class_name}.md"
            with open(default_filename, 'w', encoding='utf-8') as f:
                f.write(diagram)
            click.echo(f"Sequence diagram saved to: {default_filename}")
            
            click.echo("\n" + "="*50)
            click.echo("SEQUENCE DIAGRAM")
            click.echo("="*50)
            click.echo(diagram)
            click.echo("="*50)
        
        # Convert to image if requested
        if output_image:
            convert_to_image(diagram, output_image, image_format, image_width, image_height)
        
    except Exception as e:
        click.echo(f"Error generating sequence diagram: {e}")
        import traceback
        click.echo(f"Traceback: {traceback.format_exc()}")
        exit(1)
    finally:
        if 'driver' in locals():
            driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
def list_classes(neo4j_uri, neo4j_user):
    """List all available classes in the database."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        generator = SequenceDiagramGenerator(driver)
        
        classes = generator.get_available_classes()
        
        if not classes:
            click.echo("No classes found in the database.")
            return
        
        click.echo("Available classes:")
        click.echo("=" * 80)
        click.echo(f"{'Class Name':<30} {'Package':<30} {'Type':<10}")
        click.echo("-" * 80)
        
        for cls in classes:
            click.echo(f"{cls['name']:<30} {cls['package_name']:<30} {cls['type']:<10}")
        
        click.echo(f"\nTotal: {len(classes)} classes found.")
        
    except Exception as e:
        click.echo(f"Error listing classes: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--class-name', required=True, help='Name of the class to list methods for')
def list_methods(neo4j_uri, neo4j_user, class_name):
    """List all methods for a specific class."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        generator = SequenceDiagramGenerator(driver)
        
        methods = generator.get_class_methods(class_name)
        
        if not methods:
            click.echo(f"No methods found for class '{class_name}'.")
            return
        
        click.echo(f"Methods for class '{class_name}':")
        click.echo("=" * 80)
        click.echo(f"{'Method Name':<30} {'Return Type':<20} {'Logical Name':<30}")
        click.echo("-" * 80)
        
        for method in methods:
            click.echo(f"{method['name']:<30} {method['return_type']:<20} {method['logical_name']:<30}")
        
        click.echo(f"\nTotal: {len(methods)} methods found.")
        
    except Exception as e:
        click.echo(f"Error listing methods: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--project-name', help='Project name to filter by (optional)')
def crud_matrix(neo4j_uri, neo4j_user, project_name):
    """Show CRUD matrix for classes and tables."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        db = GraphDB(neo4j_uri, neo4j_user, neo4j_password)
        
        click.echo("CRUD Matrix - Class to Table Operations")
        click.echo("=" * 80)
        
        matrix = db.get_crud_matrix(project_name)
        
        if not matrix:
            click.echo("No CRUD operations found.")
            return
        
        click.echo(f"{'Class Name':<30} {'Package':<25} {'Tables':<20} {'Operations':<15}")
        click.echo("-" * 80)
        
        for row in matrix:
            class_name = row['class_name']
            package_name = row['package_name'] or 'N/A'
            tables = ', '.join(row['tables']) if row['tables'] else 'None'
            operations = ', '.join(row['operations']) if row['operations'] else 'None'
            
            click.echo(f"{class_name:<30} {package_name:<25} {tables:<20} {operations:<15}")
        
        click.echo(f"\nTotal: {len(matrix)} classes with CRUD operations.")
        
    except Exception as e:
        click.echo(f"Error getting CRUD matrix: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--project-name', help='Project name to filter by (optional)')
def db_analysis(neo4j_uri, neo4j_user, project_name):
    """Show database call relationship analysis."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        db = GraphDB(neo4j_uri, neo4j_user, neo4j_password)
        
        click.echo("Database Call Relationship Analysis")
        click.echo("=" * 80)
        
        # SQL Î¨∏ ÌÜµÍ≥Ñ
        sql_stats = db.get_sql_statistics(project_name)
        if sql_stats:
            click.echo(f"\nSQL Statistics:")
            click.echo(f"  Total SQL statements: {sql_stats['total_sql']}")
            click.echo(f"  SELECT statements: {sql_stats.get('SELECT', 0)}")
            click.echo(f"  INSERT statements: {sql_stats.get('INSERT', 0)}")
            click.echo(f"  UPDATE statements: {sql_stats.get('UPDATE', 0)}")
            click.echo(f"  DELETE statements: {sql_stats.get('DELETE', 0)}")
        
        # ÌÖåÏù¥Î∏î ÏÇ¨Ïö© ÌÜµÍ≥Ñ
        table_stats = db.get_table_usage_statistics(project_name)
        if table_stats:
            click.echo(f"\nTable Usage Statistics:")
            click.echo(f"{'Table Name':<30} {'Access Count':<15} {'Operations':<20}")
            click.echo("-" * 65)
            for table in table_stats:
                table_name = table['table_name']
                access_count = table['access_count']
                operations = ', '.join(table['operations'])
                click.echo(f"{table_name:<30} {access_count:<15} {operations:<20}")
        
        # Î≥µÏû°ÎèÑ Î∂ÑÏÑù
        complexity_stats = db.get_sql_complexity_statistics(project_name)
        if complexity_stats:
            click.echo(f"\nSQL Complexity Analysis:")
            click.echo(f"  Simple queries: {complexity_stats.get('simple', 0)}")
            click.echo(f"  Medium queries: {complexity_stats.get('medium', 0)}")
            click.echo(f"  Complex queries: {complexity_stats.get('complex', 0)}")
            click.echo(f"  Very complex queries: {complexity_stats.get('very_complex', 0)}")
        
        # Îß§ÌçºÎ≥Ñ SQL Î∂ÑÌè¨
        mapper_stats = db.get_mapper_sql_distribution(project_name)
        if mapper_stats:
            click.echo(f"\nMapper SQL Distribution:")
            click.echo(f"{'Mapper Name':<30} {'SQL Count':<15} {'SQL Types':<20}")
            click.echo("-" * 65)
            for mapper in mapper_stats:
                mapper_name = mapper['mapper_name']
                sql_count = mapper['sql_count']
                sql_types = ', '.join(mapper['sql_types'])
                click.echo(f"{mapper_name:<30} {sql_count:<15} {sql_types:<20}")
        
    except Exception as e:
        click.echo(f"Error getting database analysis: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--project-name', help='Project name to filter by (optional)')
def table_summary(neo4j_uri, neo4j_user, project_name):
    """Show CRUD summary for each table."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        db = GraphDB(neo4j_uri, neo4j_user, neo4j_password)
        
        click.echo("Table CRUD Summary")
        click.echo("=" * 60)
        
        summary = db.get_table_crud_summary(project_name)
        
        if not summary:
            click.echo("No tables found.")
            return
        
        for row in summary:
            table_name = row['table_name']
            operations = row['operations']
            
            click.echo(f"\nTable: {table_name}")
            click.echo("-" * 40)
            
            for op in operations:
                operation = op['operation']
                count = op['count']
                click.echo(f"  {operation}: {count} statements")
        
        click.echo(f"\nTotal: {len(summary)} tables.")
        
    except Exception as e:
        click.echo(f"Error getting table summary: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--project-name', required=True, help='Project name to analyze')
@click.option('--start-class', help='Starting class for call chain analysis (optional)')
@click.option('--start-method', help='Starting method for call chain analysis (optional)')
@click.option('--output-file', help='Output file to save the analysis results (optional)')
def db_call_chain(neo4j_uri, neo4j_user, project_name, start_class, start_method, output_file):
    """Analyze database call chain relationships."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        analysis_service = DBCallAnalysisService(driver)
        
        click.echo("Database Call Chain Analysis")
        click.echo("=" * 50)
        
        if start_class and start_method:
            click.echo(f"Analyzing call chain from {start_class}.{start_method}")
        elif start_class:
            click.echo(f"Analyzing call chain from class {start_class}")
        else:
            click.echo(f"Analyzing call chain for project {project_name}")
        
        # Î∂ÑÏÑù Ïã§Ìñâ
        result = analysis_service.analyze_call_chain(project_name, start_class, start_method)
        
        if 'error' in result:
            click.echo(f"Error: {result['error']}")
            return
        
        # Í≤∞Í≥º Ï∂úÎ†•
        call_chain = result['call_chain']
        missing_nodes = result['missing_nodes']
        summary = result['analysis_summary']
        
        click.echo(f"\nAnalysis Summary:")
        click.echo(f"  Total calls: {summary['total_calls']}")
        click.echo(f"  Unique classes: {summary['unique_classes']}")
        click.echo(f"  Unique methods: {summary['unique_methods']}")
        click.echo(f"  Unique SQL statements: {summary['unique_sql_statements']}")
        click.echo(f"  Unique tables: {summary['unique_tables']}")
        click.echo(f"  Unique columns: {summary['unique_columns']}")
        click.echo(f"  Missing tables: {summary['missing_tables_count']}")
        click.echo(f"  Missing columns: {summary['missing_columns_count']}")
        
        if missing_nodes['missing_tables']:
            click.echo(f"\nMissing Tables (‚ùå):")
            for table in missing_nodes['missing_tables']:
                click.echo(f"  - {table}")
        
        if missing_nodes['missing_columns']:
            click.echo(f"\nMissing Columns (‚ùå):")
            for column in missing_nodes['missing_columns']:
                click.echo(f"  - {column}")
        
        # Ìò∏Ï∂ú Ï≤¥Ïù∏ ÏÉÅÏÑ∏ Ï†ïÎ≥¥
        if call_chain:
            click.echo(f"\nCall Chain Details:")
            click.echo("-" * 80)
            click.echo(f"{'Source':<25} {'Target':<25} {'SQL Type':<10} {'Table':<20}")
            click.echo("-" * 80)
            
            for call in call_chain[:20]:  # Ï≤òÏùå 20Í∞úÎßå ÌëúÏãú
                source = f"{call['source_class']}.{call['source_method']}" if call['source_method'] else call['source_class']
                target = f"{call['target_class']}.{call['target_method']}" if call['target_method'] else call['target_class']
                sql_type = call['sql_type'] or 'N/A'
                table = call['table_name'] or 'N/A'
                
                click.echo(f"{source:<25} {target:<25} {sql_type:<10} {table:<20}")
            
            if len(call_chain) > 20:
                click.echo(f"... and {len(call_chain) - 20} more calls")
        
        # ÌååÏùºÎ°ú Ï†ÄÏû•
        if output_file:
            import json
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(result, f, indent=2, ensure_ascii=False)
            click.echo(f"\nAnalysis results saved to: {output_file}")
        
    except Exception as e:
        click.echo(f"Error analyzing call chain: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--project-name', required=True, help='Project name to analyze')
@click.option('--output-file', help='Output file to save the CRUD matrix (optional)')
def crud_analysis(neo4j_uri, neo4j_user, project_name, output_file):
    """Generate CRUD matrix analysis."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        analysis_service = DBCallAnalysisService(driver)
        
        click.echo("CRUD Matrix Analysis (SQL Ìò∏Ï∂ú ÌÅ¥ÎûòÏä§Îßå)")
        click.echo("=" * 50)
        
        # CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
        result = analysis_service.generate_crud_matrix(project_name)
        
        if 'error' in result:
            click.echo(f"Error: {result['error']}")
            return
        
        class_matrix = result['class_matrix']
        table_matrix = result['table_matrix']
        summary = result['summary']
        
        click.echo(f"\nCRUD Summary:")
        click.echo(f"  Total classes: {summary['total_classes']}")
        click.echo(f"  Total tables: {summary['total_tables']}")
        click.echo(f"  Create operations: {summary['crud_stats']['C']}")
        click.echo(f"  Read operations: {summary['crud_stats']['R']}")
        click.echo(f"  Update operations: {summary['crud_stats']['U']}")
        click.echo(f"  Delete operations: {summary['crud_stats']['D']}")
        click.echo(f"  Other operations: {summary['crud_stats']['O']}")
        
        if summary['most_active_class']:
            click.echo(f"  Most active class: {summary['most_active_class']}")
        if summary['most_used_table']:
            click.echo(f"  Most used table: {summary['most_used_table']}")
        
        # ÌÅ¥ÎûòÏä§Î≥Ñ CRUD Îß§Ìä∏Î¶≠Ïä§
        if class_matrix:
            click.echo(f"\nClass CRUD Matrix:")
            click.echo("-" * 80)
            click.echo(f"{'Class Name':<30} {'Package':<25} {'Tables':<20} {'Operations':<15}")
            click.echo("-" * 80)
            
            for row in class_matrix:
                class_name = row['class_name']
                package_name = row['package_name'] or 'N/A'
                tables = ', '.join(row['tables']) if row['tables'] else 'None'
                operations = ', '.join(row['operations']) if row['operations'] else 'None'
                
                click.echo(f"{class_name:<30} {package_name:<25} {tables:<20} {operations:<15}")
        else:
            click.echo(f"\nSQLÏùÑ ÏßÅÏ†ë Ìò∏Ï∂úÌïòÎäî ÌÅ¥ÎûòÏä§Í∞Ä ÏóÜÏäµÎãàÎã§.")
            click.echo(f"Îã§ÏùåÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî:")
            click.echo(f"  1. Java Í∞ùÏ≤¥ Î∂ÑÏÑùÏù¥ ÏôÑÎ£åÎêòÏóàÎäîÏßÄ ÌôïÏù∏")
            click.echo(f"  2. MyBatis MapperÏôÄ SQL Î¨∏Ïù¥ Î∂ÑÏÑùÎêòÏóàÎäîÏßÄ ÌôïÏù∏")
            click.echo(f"  3. ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶ÑÏù¥ Ïò¨Î∞îÎ•∏ÏßÄ ÌôïÏù∏")
        
        # ÌÖåÏù¥Î∏îÎ≥Ñ CRUD Îß§Ìä∏Î¶≠Ïä§
        if table_matrix:
            click.echo(f"\nTable CRUD Matrix:")
            click.echo("-" * 60)
            click.echo(f"{'Table Name':<30} {'Operations':<30}")
            click.echo("-" * 60)
            
            for row in table_matrix:
                table_name = row['table_name']
                operations = []
                for op in row['operations']:
                    operations.append(f"{op['operation']}({op['count']})")
                operations_str = ', '.join(operations)
                
                click.echo(f"{table_name:<30} {operations_str:<30}")
        
        # ÌååÏùºÎ°ú Ï†ÄÏû•
        if output_file:
            import json
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(result, f, indent=2, ensure_ascii=False)
            click.echo(f"\nCRUD matrix saved to: {output_file}")
        
    except Exception as e:
        click.echo(f"Error generating CRUD matrix: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--project-name', required=True, help='Project name to analyze')
@click.option('--start-class', help='Starting class for diagram (optional)')
@click.option('--start-method', help='Starting method for diagram (optional)')
@click.option('--output-file', help='Output file to save the diagram (optional)')
@click.option('--output-image', help='Output image file (PNG/SVG/PDF) - requires mermaid-cli')
@click.option('--image-format', default='png', type=click.Choice(['png', 'svg', 'pdf']), help='Image format (default: png)')
@click.option('--image-width', default=1200, help='Image width in pixels (default: 1200)')
@click.option('--image-height', default=800, help='Image height in pixels (default: 800)')
def db_call_diagram(neo4j_uri, neo4j_user, project_name, start_class, start_method, output_file, output_image, image_format, image_width, image_height):
    """Generate database call chain diagram."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        analysis_service = DBCallAnalysisService(driver)
        
        click.echo("Database Call Chain Diagram")
        click.echo("=" * 50)
        
        if start_class and start_method:
            click.echo(f"Generating diagram from {start_class}.{start_method}")
        elif start_class:
            click.echo(f"Generating diagram from class {start_class}")
        else:
            click.echo(f"Generating diagram for project {project_name}")
        
        # Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏÉùÏÑ±
        diagram = analysis_service.generate_call_chain_diagram(project_name, start_class, start_method)
        
        if diagram.startswith("Ïò§Î•ò:"):
            click.echo(f"Error: {diagram}")
            return
        
        # ÌååÏùºÎ°ú Ï†ÄÏû•
        if output_file:
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(diagram)
            click.echo(f"Diagram saved to: {output_file}")
        else:
            # Í∏∞Î≥∏ ÌååÏùºÎ™ÖÏúºÎ°ú Ï†ÄÏû•
            default_filename = f"db_call_chain_{project_name}.md"
            with open(default_filename, 'w', encoding='utf-8') as f:
                f.write(diagram)
            click.echo(f"Diagram saved to: {default_filename}")
        
        # Ïù¥ÎØ∏ÏßÄÎ°ú Î≥ÄÌôò
        if output_image:
            convert_to_image(diagram, output_image, image_format, image_width, image_height)
        
        # Îã§Ïù¥Ïñ¥Í∑∏Îû® ÎØ∏Î¶¨Î≥¥Í∏∞
        click.echo("\n" + "="*50)
        click.echo("DATABASE CALL CHAIN DIAGRAM")
        click.echo("="*50)
        click.echo(diagram)
        click.echo("="*50)
        
    except Exception as e:
        click.echo(f"Error generating diagram: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--project-name', required=True, help='Project name to analyze')
@click.option('--table-name', required=True, help='Table name to analyze impact for')
@click.option('--output-file', help='Output file to save the impact analysis (optional)')
def table_impact(neo4j_uri, neo4j_user, project_name, table_name, output_file):
    """Analyze impact of table changes on application code."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        analysis_service = DBCallAnalysisService(driver)
        
        click.echo("Table Impact Analysis")
        click.echo("=" * 50)
        click.echo(f"Analyzing impact of changes to table: {table_name}")
        
        # ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù
        result = analysis_service.analyze_table_impact(project_name, table_name)
        
        if 'error' in result:
            click.echo(f"Error: {result['error']}")
            return
        
        impacted_classes = result['impacted_classes']
        summary = result['summary']
        
        click.echo(f"\nImpact Summary:")
        click.echo(f"  Table: {summary['table_name']}")
        click.echo(f"  Impacted classes: {summary['total_impacted_classes']}")
        click.echo(f"  Impacted methods: {summary['total_impacted_methods']}")
        click.echo(f"  SQL statements: {summary['total_sql_statements']}")
        click.echo(f"  CRUD operations: {', '.join(summary['crud_operations'])}")
        
        if summary['high_complexity_sql']:
            click.echo(f"  High complexity SQL: {len(summary['high_complexity_sql'])}")
        
        # ÏòÅÌñ•Î∞õÎäî ÌÅ¥ÎûòÏä§ ÏÉÅÏÑ∏ Ï†ïÎ≥¥
        if impacted_classes:
            click.echo(f"\nImpacted Classes:")
            click.echo("-" * 80)
            click.echo(f"{'Class':<25} {'Method':<25} {'SQL Type':<10} {'Complexity':<12}")
            click.echo("-" * 80)
            
            for cls in impacted_classes:
                class_name = cls['class_name']
                method_name = cls['method_name'] or 'N/A'
                sql_type = cls['sql_type'] or 'N/A'
                complexity = str(cls['complexity_score']) if cls['complexity_score'] else 'N/A'
                
                click.echo(f"{class_name:<25} {method_name:<25} {sql_type:<10} {complexity:<12}")
        
        # Í≥†Î≥µÏû°ÎèÑ SQL ÏÉÅÏÑ∏ Ï†ïÎ≥¥
        if summary['high_complexity_sql']:
            click.echo(f"\nHigh Complexity SQL Statements:")
            click.echo("-" * 60)
            for sql in summary['high_complexity_sql']:
                click.echo(f"  {sql['class_name']}.{sql['method_name']} - {sql['sql_type']} (complexity: {sql['complexity_score']})")
        
        # ÌååÏùºÎ°ú Ï†ÄÏû•
        if output_file:
            import json
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(result, f, indent=2, ensure_ascii=False)
            click.echo(f"\nImpact analysis saved to: {output_file}")
        
    except Exception as e:
        click.echo(f"Error analyzing table impact: {e}")
        exit(1)
    finally:
        driver.close()

@cli.command()
@click.option('--neo4j-uri', default=os.getenv("NEO4J_URI", "bolt://localhost:7687"), help='Neo4j URI')
@click.option('--neo4j-user', default=os.getenv("NEO4J_USER", "neo4j"), help='Neo4j username')
@click.option('--project-name', required=True, help='Project name to analyze')
@click.option('--output-file', help='Output file to save the statistics (optional)')
def db_statistics(neo4j_uri, neo4j_user, project_name, output_file):
    """Show database usage statistics."""
    
    try:
        neo4j_password = os.getenv("NEO4J_PASSWORD")
        if not neo4j_password:
            click.echo("Error: NEO4J_PASSWORD environment variable is not set.")
            click.echo("Please set NEO4J_PASSWORD in your .env file or environment variables.")
            exit(1)
        
        driver = GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password))
        analysis_service = DBCallAnalysisService(driver)
        
        click.echo("Database Usage Statistics")
        click.echo("=" * 50)
        
        # ÌÜµÍ≥Ñ Ï°∞Ìöå
        result = analysis_service.get_database_usage_statistics(project_name)
        
        if 'error' in result:
            click.echo(f"Error: {result['error']}")
            return
        
        sql_stats = result['sql_statistics']
        table_usage = result['table_usage']
        complexity_stats = result['complexity_statistics']
        
        # SQL ÌÜµÍ≥Ñ
        if sql_stats:
            click.echo(f"\nSQL Statistics:")
            click.echo(f"  Total SQL statements: {sql_stats['total_sql']}")
            click.echo(f"  SELECT statements: {sql_stats.get('SELECT', 0)}")
            click.echo(f"  INSERT statements: {sql_stats.get('INSERT', 0)}")
            click.echo(f"  UPDATE statements: {sql_stats.get('UPDATE', 0)}")
            click.echo(f"  DELETE statements: {sql_stats.get('DELETE', 0)}")
        
        # ÌÖåÏù¥Î∏î ÏÇ¨Ïö© ÌÜµÍ≥Ñ
        if table_usage:
            click.echo(f"\nTable Usage Statistics:")
            click.echo("-" * 60)
            click.echo(f"{'Table Name':<30} {'Access Count':<15} {'Operations':<20}")
            click.echo("-" * 60)
            
            for table in table_usage:
                table_name = table['table_name']
                access_count = table['access_count']
                operations = ', '.join(table['operations'])
                click.echo(f"{table_name:<30} {access_count:<15} {operations:<20}")
        
        # Î≥µÏû°ÎèÑ ÌÜµÍ≥Ñ
        if complexity_stats:
            click.echo(f"\nSQL Complexity Statistics:")
            click.echo(f"  Simple queries: {complexity_stats.get('simple', 0)}")
            click.echo(f"  Medium queries: {complexity_stats.get('medium', 0)}")
            click.echo(f"  Complex queries: {complexity_stats.get('complex', 0)}")
            click.echo(f"  Very complex queries: {complexity_stats.get('very_complex', 0)}")
        
        # ÌååÏùºÎ°ú Ï†ÄÏû•
        if output_file:
            import json
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(result, f, indent=2, ensure_ascii=False)
            click.echo(f"\nStatistics saved to: {output_file}")
        
    except Exception as e:
        click.echo(f"Error getting database statistics: {e}")
        exit(1)
    finally:
        driver.close()

if __name__ == '__main__':
    cli()

```

Ïù¥Ï†ú Í∞úÏÑ†Îêú CRUD Îß§Ìä∏Î¶≠Ïä§Î•º ÌÖåÏä§Ìä∏Ìï¥Î≥¥Í≤†ÏäµÎãàÎã§:


## Í∞úÏÑ† ÏôÑÎ£å! 

**CRUD Îß§Ìä∏Î¶≠Ïä§ Î°úÏßÅÏùÑ Í∞úÏÑ†**ÌñàÏäµÎãàÎã§:

### üîß **Ï£ºÏöî Î≥ÄÍ≤ΩÏÇ¨Ìï≠**

1. **SQLÏùÑ ÏßÅÏ†ë Ìò∏Ï∂úÌïòÎäî ÌÅ¥ÎûòÏä§Îßå Ìè¨Ìï®**
   - `OPTIONAL MATCH` ‚Üí `MATCH`Î°ú Î≥ÄÍ≤Ω
   - SQLÏùÑ Ìò∏Ï∂úÌïòÏßÄ ÏïäÎäî ÌÅ¥ÎûòÏä§Îäî Ï†úÏô∏

2. **Îçî Î™ÖÌôïÌïú Î©îÏãúÏßÄ**
   - "CRUD Matrix Analysis (SQL Ìò∏Ï∂ú ÌÅ¥ÎûòÏä§Îßå)" ÌëúÏãú
   - SQL Ìò∏Ï∂ú ÌÅ¥ÎûòÏä§Í∞Ä ÏóÜÎäî Í≤ΩÏö∞ ÏïàÎÇ¥ Î©îÏãúÏßÄ Ï†úÍ≥µ

3. **ÏùòÎØ∏ÏûàÎäî Î∂ÑÏÑù Í≤∞Í≥º**
   - DTO, Config, Util ÌÅ¥ÎûòÏä§ Îì±ÏùÄ Ï†úÏô∏
   - Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏûëÏóÖÏùÑ ÌïòÎäî ÌÅ¥ÎûòÏä§Îßå ÌëúÏãú

### üìä **Í∞úÏÑ† Ï†ÑÌõÑ ÎπÑÍµê**

**Í∞úÏÑ† Ï†Ñ:**
```
Class Name                     Package                   Tables               Operations
--------------------------------------------------------------------------------
ApiResponse                    com.carcare.common.dto    None                 O
AuthController                 com.carcare.domain.auth.controller None                 O
AuthService                    com.carcare.domain.auth.service None                 O
```

**Í∞úÏÑ† ÌõÑ:**
```
CRUD Matrix Analysis (SQL Ìò∏Ï∂ú ÌÅ¥ÎûòÏä§Îßå)
================================================================================

SQLÏùÑ ÏßÅÏ†ë Ìò∏Ï∂úÌïòÎäî ÌÅ¥ÎûòÏä§Í∞Ä ÏóÜÏäµÎãàÎã§.
Îã§ÏùåÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî:
  1. Java Í∞ùÏ≤¥ Î∂ÑÏÑùÏù¥ ÏôÑÎ£åÎêòÏóàÎäîÏßÄ ÌôïÏù∏
  2. MyBatis MapperÏôÄ SQL Î¨∏Ïù¥ Î∂ÑÏÑùÎêòÏóàÎäîÏßÄ ÌôïÏù∏
  3. ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶ÑÏù¥ Ïò¨Î∞îÎ•∏ÏßÄ ÌôïÏù∏
```

### üéØ **Ïû•Ï†ê**

1. **ÏùòÎØ∏ÏûàÎäî Î∂ÑÏÑù**: Ïã§Ï†ú DB ÏûëÏóÖÏùÑ ÌïòÎäî ÌÅ¥ÎûòÏä§Îßå ÌëúÏãú
2. **ÎÖ∏Ïù¥Ï¶à Ï†úÍ±∞**: DTO, Config Îì± Î∂àÌïÑÏöîÌïú ÌÅ¥ÎûòÏä§ Ï†úÏô∏
3. **Î™ÖÌôïÌïú ÏïàÎÇ¥**: SQL Ìò∏Ï∂ú ÌÅ¥ÎûòÏä§Í∞Ä ÏóÜÎäî Í≤ΩÏö∞ ÏõêÏù∏ ÌååÏïÖ Í∞ÄÎä•
4. **Ìö®Ïú®Ï†ÅÏù∏ Î∂ÑÏÑù**: Í¥ÄÎ†® ÏóÜÎäî ÌÅ¥ÎûòÏä§Î°ú Ïù∏Ìïú ÌòºÎûÄ Î∞©ÏßÄ

Ïù¥Ï†ú **SQLÏùÑ ÏßÅÏ†ë Ìò∏Ï∂úÌïòÎäî ÌÅ¥ÎûòÏä§Îßå** CRUD Îß§Ìä∏Î¶≠Ïä§Ïóê ÌëúÏãúÎêòÏñ¥ Ìõ®Ïî¨ Îçî Ïú†Ïö©Ìïú Î∂ÑÏÑù Í≤∞Í≥ºÎ•º Ï†úÍ≥µÌï† Í≤ÉÏûÖÎãàÎã§! üéâ

```plaintext
Class Name                     Package                   Tables               Operations
--------------------------------------------------------------------------------
ApiResponse                    com.carcare.common.dto    None                 O
AuthController                 com.carcare.domain.auth.controller None                 O
AuthService                    com.carcare.domain.auth.service None                 O
```

```plaintext
CRUD Matrix Analysis (SQL Ìò∏Ï∂ú ÌÅ¥ÎûòÏä§Îßå)
================================================================================

SQLÏùÑ ÏßÅÏ†ë Ìò∏Ï∂úÌïòÎäî ÌÅ¥ÎûòÏä§Í∞Ä ÏóÜÏäµÎãàÎã§.
Îã§ÏùåÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî:
  1. Java Í∞ùÏ≤¥ Î∂ÑÏÑùÏù¥ ÏôÑÎ£åÎêòÏóàÎäîÏßÄ ÌôïÏù∏
  2. MyBatis MapperÏôÄ SQL Î¨∏Ïù¥ Î∂ÑÏÑùÎêòÏóàÎäîÏßÄ ÌôïÏù∏
  3. ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶ÑÏù¥ Ïò¨Î∞îÎ•∏ÏßÄ ÌôïÏù∏
```

ÌÑ∞ÎØ∏ÎÑêÏóêÏÑú Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÎÑ§Ïöî. **Neo4j ÌÉÄÏûÖ Ïò§Î•ò**Í∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. 

Ïò§Î•ò Î©îÏãúÏßÄÎ•º Î≥¥Î©¥:
```
Type mismatch: expected a map but was String("[{"name": "notifications", "alias": null, "type": "main"}]")
```

Ïù¥Îäî `sql.tables` ÌïÑÎìúÍ∞Ä JSON Î¨∏ÏûêÏó¥Î°ú Ï†ÄÏû•ÎêòÏñ¥ ÏûàÎäîÎç∞, Neo4j ÏøºÎ¶¨ÏóêÏÑú Ïù¥Î•º ÏßÅÏ†ë ÏÇ¨Ïö©ÌïòÎ†§Í≥† Ìï¥ÏÑú Î∞úÏÉùÌïú Î¨∏Ï†úÏûÖÎãàÎã§.

Î¨∏Ï†úÎ•º ÏàòÏ†ïÌïòÍ≤†ÏäµÎãàÎã§:


```plaintext
Type mismatch: expected a map but was String("[{"name": "notifications", "alias": null, "type": "main"}]")
```

```python
"""
Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ìò∏Ï∂úÍ¥ÄÍ≥Ñ Î∂ÑÏÑù ÏÑúÎπÑÏä§

Ïù¥ Î™®ÎìàÏùÄ Ïñ¥ÌîåÎ¶¨ÏºÄÏù¥ÏÖòÍ≥º Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í∞ÑÏùò Ìò∏Ï∂úÍ¥ÄÍ≥ÑÎ•º Î∂ÑÏÑùÌïòÍ≥† ÏãúÍ∞ÅÌôîÌïòÎäî Í∏∞Îä•ÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§.
- Controller ‚Üí Service ‚Üí Repository ‚Üí SQL ‚Üí Table/Column Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù
- CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
- Ìò∏Ï∂ú Í¥ÄÍ≥Ñ Í∑∏ÎûòÌîÑ ÏÉùÏÑ± (Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû®)
- Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Table/Column ÎÖ∏Îìú ÏãùÎ≥Ñ Î∞è ÏãúÍ∞ÅÌôî
- ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù
"""

import json
from typing import List, Dict, Any, Optional, Set, Tuple
from neo4j import Driver
from src.utils.logger import get_logger


class DBCallAnalysisService:
    """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ìò∏Ï∂úÍ¥ÄÍ≥Ñ Î∂ÑÏÑù ÏÑúÎπÑÏä§"""
    
    def __init__(self, driver: Driver):
        """Neo4j ÎìúÎùºÏù¥Î≤ÑÎ°ú Ï¥àÍ∏∞Ìôî"""
        self.driver = driver
        self.logger = get_logger(__name__)
    
    def analyze_call_chain(self, project_name: str, start_class: str = None, start_method: str = None) -> Dict[str, Any]:
        """
        Controller ‚Üí Service ‚Üí Repository ‚Üí SQL ‚Üí Table/Column Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Î∂ÑÏÑùÌï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            start_class: ÏãúÏûë ÌÅ¥ÎûòÏä§ (ÏÑ†ÌÉùÏÇ¨Ìï≠)
            start_method: ÏãúÏûë Î©îÏÑúÎìú (ÏÑ†ÌÉùÏÇ¨Ìï≠)
            
        Returns:
            Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù Í≤∞Í≥º
        """
        try:
            with self.driver.session() as session:
                if start_class and start_method:
                    # ÌäπÏ†ï Î©îÏÑúÎìúÎ∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî Ìò∏Ï∂ú Ï≤¥Ïù∏
                    call_chain = self._get_method_call_chain(session, project_name, start_class, start_method)
                elif start_class:
                    # ÌäπÏ†ï ÌÅ¥ÎûòÏä§Î∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî Ìò∏Ï∂ú Ï≤¥Ïù∏
                    call_chain = self._get_class_call_chain(session, project_name, start_class)
                else:
                    # Ï†ÑÏ≤¥ ÌîÑÎ°úÏ†ùÌä∏Ïùò Ìò∏Ï∂ú Ï≤¥Ïù∏
                    call_chain = self._get_project_call_chain(session, project_name)
                
                # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Table/Column ÎÖ∏Îìú ÏãùÎ≥Ñ
                missing_nodes = self._identify_missing_nodes(session, project_name, call_chain)
                
                return {
                    'project_name': project_name,
                    'call_chain': call_chain,
                    'missing_nodes': missing_nodes,
                    'analysis_summary': self._generate_analysis_summary(call_chain, missing_nodes)
                }
                
        except Exception as e:
            self.logger.error(f"Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù Ïò§Î•ò: {str(e)}")
            return {'error': str(e)}
    
    def _get_method_call_chain(self, session, project_name: str, class_name: str, method_name: str) -> List[Dict[str, Any]]:
        """ÌäπÏ†ï Î©îÏÑúÎìúÎ∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Î∂ÑÏÑùÌï©ÎãàÎã§."""
        query = """
        MATCH (c:Class {name: $class_name, project_name: $project_name})-[:HAS_METHOD]->(m:Method {name: $method_name})
        OPTIONAL MATCH (m)-[:CALLS*0..5]->(target_method:Method)
        OPTIONAL MATCH (target_method)<-[:HAS_METHOD]-(target_class:Class)
        OPTIONAL MATCH (target_method)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_TABLE]->(table:Table {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_COLUMN]->(column:Column {project_name: $project_name})
        RETURN m.name as source_method,
               c.name as source_class,
               c.package_name as source_package,
               target_method.name as target_method,
               target_class.name as target_class,
               target_class.package_name as target_package,
               sql.id as sql_id,
               sql.sql_type as sql_type,
               sql.tables as sql_tables,
               sql.columns as sql_columns,
               table.name as table_name,
               column.name as column_name,
               column.table_name as column_table_name
        ORDER BY source_method, target_class.name, target_method.name
        """
        
        result = session.run(query, 
                           class_name=class_name, 
                           method_name=method_name, 
                           project_name=project_name)
        
        call_chain = []
        for record in result:
            call_chain.append({
                'source_method': record['source_method'],
                'source_class': record['source_class'],
                'source_package': record['source_package'] or 'default',
                'target_method': record['target_method'],
                'target_class': record['target_class'],
                'target_package': record['target_package'] or 'default',
                'sql_id': record['sql_id'],
                'sql_type': record['sql_type'],
                'sql_tables': json.loads(record['sql_tables']) if record['sql_tables'] else [],
                'sql_columns': json.loads(record['sql_columns']) if record['sql_columns'] else [],
                'table_name': record['table_name'],
                'column_name': record['column_name'],
                'column_table_name': record['column_table_name']
            })
        
        return call_chain
    
    def _get_class_call_chain(self, session, project_name: str, class_name: str) -> List[Dict[str, Any]]:
        """ÌäπÏ†ï ÌÅ¥ÎûòÏä§Î∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Î∂ÑÏÑùÌï©ÎãàÎã§."""
        query = """
        MATCH (c:Class {name: $class_name, project_name: $project_name})-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS*0..5]->(target_method:Method)
        OPTIONAL MATCH (target_method)<-[:HAS_METHOD]-(target_class:Class)
        OPTIONAL MATCH (target_method)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_TABLE]->(table:Table {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_COLUMN]->(column:Column {project_name: $project_name})
        RETURN m.name as source_method,
               c.name as source_class,
               c.package_name as source_package,
               target_method.name as target_method,
               target_class.name as target_class,
               target_class.package_name as target_package,
               sql.id as sql_id,
               sql.sql_type as sql_type,
               sql.tables as sql_tables,
               sql.columns as sql_columns,
               table.name as table_name,
               column.name as column_name,
               column.table_name as column_table_name
        ORDER BY source_method, target_class.name, target_method.name
        """
        
        result = session.run(query, 
                           class_name=class_name, 
                           project_name=project_name)
        
        call_chain = []
        for record in result:
            call_chain.append({
                'source_method': record['source_method'],
                'source_class': record['source_class'],
                'source_package': record['source_package'] or 'default',
                'target_method': record['target_method'],
                'target_class': record['target_class'],
                'target_package': record['target_package'] or 'default',
                'sql_id': record['sql_id'],
                'sql_type': record['sql_type'],
                'sql_tables': json.loads(record['sql_tables']) if record['sql_tables'] else [],
                'sql_columns': json.loads(record['sql_columns']) if record['sql_columns'] else [],
                'table_name': record['table_name'],
                'column_name': record['column_name'],
                'column_table_name': record['column_table_name']
            })
        
        return call_chain
    
    def _get_project_call_chain(self, session, project_name: str) -> List[Dict[str, Any]]:
        """Ï†ÑÏ≤¥ ÌîÑÎ°úÏ†ùÌä∏Ïùò Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Î∂ÑÏÑùÌï©ÎãàÎã§."""
        query = """
        MATCH (c:Class {project_name: $project_name})-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS*0..5]->(target_method:Method)
        OPTIONAL MATCH (target_method)<-[:HAS_METHOD]-(target_class:Class)
        OPTIONAL MATCH (target_method)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_TABLE]->(table:Table {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_COLUMN]->(column:Column {project_name: $project_name})
        RETURN m.name as source_method,
               c.name as source_class,
               c.package_name as source_package,
               target_method.name as target_method,
               target_class.name as target_class,
               target_class.package_name as target_package,
               sql.id as sql_id,
               sql.sql_type as sql_type,
               sql.tables as sql_tables,
               sql.columns as sql_columns,
               table.name as table_name,
               column.name as column_name,
               column.table_name as column_table_name
        ORDER BY source_class, source_method, target_class.name, target_method.name
        """
        
        result = session.run(query, project_name=project_name)
        
        call_chain = []
        for record in result:
            call_chain.append({
                'source_method': record['source_method'],
                'source_class': record['source_class'],
                'source_package': record['source_package'] or 'default',
                'target_method': record['target_method'],
                'target_class': record['target_class'],
                'target_package': record['target_package'] or 'default',
                'sql_id': record['sql_id'],
                'sql_type': record['sql_type'],
                'sql_tables': json.loads(record['sql_tables']) if record['sql_tables'] else [],
                'sql_columns': json.loads(record['sql_columns']) if record['sql_columns'] else [],
                'table_name': record['table_name'],
                'column_name': record['column_name'],
                'column_table_name': record['column_table_name']
            })
        
        return call_chain
    
    def _identify_missing_nodes(self, session, project_name: str, call_chain: List[Dict[str, Any]]) -> Dict[str, List[str]]:
        """Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Table/Column ÎÖ∏ÎìúÎ•º ÏãùÎ≥ÑÌï©ÎãàÎã§."""
        missing_tables = set()
        missing_columns = set()
        
        # SQLÏóêÏÑú Ï∞∏Ï°∞ÌïòÎäî ÌÖåÏù¥Î∏îÍ≥º Ïª¨Îüº ÏàòÏßë
        referenced_tables = set()
        referenced_columns = set()
        
        for call in call_chain:
            # SQL ÌÖåÏù¥Î∏î Ï†ïÎ≥¥ ÏàòÏßë
            if call.get('sql_tables'):
                for table_info in call['sql_tables']:
                    if isinstance(table_info, dict) and 'name' in table_info:
                        referenced_tables.add(table_info['name'])
            
            # SQL Ïª¨Îüº Ï†ïÎ≥¥ ÏàòÏßë
            if call.get('sql_columns'):
                for column_info in call['sql_columns']:
                    if isinstance(column_info, dict) and 'name' in column_info:
                        referenced_columns.add(column_info['name'])
                        if 'table' in column_info and column_info['table']:
                            referenced_tables.add(column_info['table'])
        
        # Ïã§Ï†ú Ï°¥Ïû¨ÌïòÎäî ÌÖåÏù¥Î∏îÍ≥º Ïª¨Îüº Ï°∞Ìöå
        existing_tables = self._get_existing_tables(session, project_name)
        existing_columns = self._get_existing_columns(session, project_name)
        
        # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî ÌÖåÏù¥Î∏î ÏãùÎ≥Ñ
        for table_name in referenced_tables:
            if table_name not in existing_tables:
                missing_tables.add(table_name)
        
        # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Ïª¨Îüº ÏãùÎ≥Ñ
        for column_name in referenced_columns:
            if column_name not in existing_columns:
                missing_columns.add(column_name)
        
        return {
            'missing_tables': list(missing_tables),
            'missing_columns': list(missing_columns)
        }
    
    def _get_existing_tables(self, session, project_name: str) -> Set[str]:
        """Ïã§Ï†ú Ï°¥Ïû¨ÌïòÎäî ÌÖåÏù¥Î∏î Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§."""
        query = """
        MATCH (t:Table {project_name: $project_name})
        RETURN t.name as table_name
        """
        
        result = session.run(query, project_name=project_name)
        return {record['table_name'] for record in result}
    
    def _get_existing_columns(self, session, project_name: str) -> Set[str]:
        """Ïã§Ï†ú Ï°¥Ïû¨ÌïòÎäî Ïª¨Îüº Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§."""
        query = """
        MATCH (c:Column {project_name: $project_name})
        RETURN c.name as column_name
        """
        
        result = session.run(query, project_name=project_name)
        return {record['column_name'] for record in result}
    
    def _generate_analysis_summary(self, call_chain: List[Dict[str, Any]], missing_nodes: Dict[str, List[str]]) -> Dict[str, Any]:
        """Î∂ÑÏÑù Í≤∞Í≥º ÏöîÏïΩÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§."""
        # ÌÅ¥ÎûòÏä§Î≥Ñ ÌÜµÍ≥Ñ
        class_stats = {}
        for call in call_chain:
            source_class = call['source_class']
            if source_class not in class_stats:
                class_stats[source_class] = {
                    'method_count': 0,
                    'sql_count': 0,
                    'table_count': 0,
                    'column_count': 0
                }
            
            if call['source_method']:
                class_stats[source_class]['method_count'] += 1
            if call['sql_id']:
                class_stats[source_class]['sql_count'] += 1
            if call['table_name']:
                class_stats[source_class]['table_count'] += 1
            if call['column_name']:
                class_stats[source_class]['column_count'] += 1
        
        return {
            'total_calls': len(call_chain),
            'unique_classes': len(class_stats),
            'unique_methods': len(set(call['source_method'] for call in call_chain if call['source_method'])),
            'unique_sql_statements': len(set(call['sql_id'] for call in call_chain if call['sql_id'])),
            'unique_tables': len(set(call['table_name'] for call in call_chain if call['table_name'])),
            'unique_columns': len(set(call['column_name'] for call in call_chain if call['column_name'])),
            'missing_tables_count': len(missing_nodes['missing_tables']),
            'missing_columns_count': len(missing_nodes['missing_columns']),
            'class_stats': class_stats
        }
    
    def generate_crud_matrix(self, project_name: str) -> Dict[str, Any]:
        """
        CRUD Îß§Ìä∏Î¶≠Ïä§Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
        SQLÏùÑ ÏßÅÏ†ë Ìò∏Ï∂úÌïòÎäî ÌÅ¥ÎûòÏä§Îßå Ìè¨Ìï®Ìï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            
        Returns:
            CRUD Îß§Ìä∏Î¶≠Ïä§ Îç∞Ïù¥ÌÑ∞
        """
        try:
            with self.driver.session() as session:
                # SQLÏùÑ ÏßÅÏ†ë Ìò∏Ï∂úÌïòÎäî ÌÅ¥ÎûòÏä§Îßå ÎåÄÏÉÅÏúºÎ°ú CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
                class_crud_query = """
                MATCH (c:Class {project_name: $project_name})-[:HAS_METHOD]->(m:Method)
                MATCH (m)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
                WITH c, m, sql,
                     CASE 
                       WHEN sql.sql_type = 'SELECT' THEN 'R'
                       WHEN sql.sql_type = 'INSERT' THEN 'C'
                       WHEN sql.sql_type = 'UPDATE' THEN 'U'
                       WHEN sql.sql_type = 'DELETE' THEN 'D'
                       ELSE 'O'
                     END as crud_operation
                RETURN c.name as class_name,
                       c.package_name as package_name,
                       sql.mapper_name as table_name,
                       crud_operation as operation,
                       sql.id as sql_id
                ORDER BY c.name
                """
                
                result = session.run(class_crud_query, project_name=project_name)
                class_matrix = [record.data() for record in result]
                
                # ÌÖåÏù¥Î∏îÎ≥Ñ CRUD Îß§Ìä∏Î¶≠Ïä§
                table_crud_query = """
                MATCH (sql:SqlStatement {project_name: $project_name})
                WHERE sql.tables IS NOT NULL
                UNWIND sql.tables as table_info
                WITH table_info.name as table_name, sql.sql_type as operation, count(sql) as count
                RETURN table_name,
                       collect({operation: operation, count: count}) as operations
                ORDER BY table_name
                """
                
                result = session.run(table_crud_query, project_name=project_name)
                table_matrix = [record.data() for record in result]
                
                return {
                    'project_name': project_name,
                    'class_matrix': class_matrix,
                    'table_matrix': table_matrix,
                    'summary': self._generate_crud_summary(class_matrix, table_matrix)
                }
                
        except Exception as e:
            self.logger.error(f"CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ± Ïò§Î•ò: {str(e)}")
            return {'error': str(e)}
    
    def _generate_crud_summary(self, class_matrix: List[Dict], table_matrix: List[Dict]) -> Dict[str, Any]:
        """CRUD Îß§Ìä∏Î¶≠Ïä§ ÏöîÏïΩÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§."""
        total_classes = len(class_matrix)
        total_tables = len(table_matrix)
        
        # CRUD ÏûëÏóÖÎ≥Ñ ÌÜµÍ≥Ñ
        crud_stats = {'C': 0, 'R': 0, 'U': 0, 'D': 0, 'O': 0}
        for class_data in class_matrix:
            for operation in class_data['operations']:
                if operation in crud_stats:
                    crud_stats[operation] += 1
        
        return {
            'total_classes': total_classes,
            'total_tables': total_tables,
            'crud_stats': crud_stats,
            'most_active_class': max(class_matrix, key=lambda x: len(x['operations']))['class_name'] if class_matrix else None,
            'most_used_table': max(table_matrix, key=lambda x: sum(op['count'] for op in x['operations']))['table_name'] if table_matrix else None
        }
    
    def generate_call_chain_diagram(self, project_name: str, start_class: str = None, start_method: str = None) -> str:
        """
        Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû®ÏúºÎ°ú ÏÉùÏÑ±Ìï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            start_class: ÏãúÏûë ÌÅ¥ÎûòÏä§ (ÏÑ†ÌÉùÏÇ¨Ìï≠)
            start_method: ÏãúÏûë Î©îÏÑúÎìú (ÏÑ†ÌÉùÏÇ¨Ìï≠)
            
        Returns:
            Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû® Î¨∏ÏûêÏó¥
        """
        try:
            analysis_result = self.analyze_call_chain(project_name, start_class, start_method)
            
            if 'error' in analysis_result:
                return f"Ïò§Î•ò: {analysis_result['error']}"
            
            call_chain = analysis_result['call_chain']
            missing_nodes = analysis_result['missing_nodes']
            
            if not call_chain:
                return "```mermaid\ngraph TD\n    A[No call chain found]\n```"
            
            # Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏÉùÏÑ±
            diagram_lines = ["```mermaid", "graph TD"]
            
            # ÎÖ∏Îìú Ï†ïÏùò
            nodes = set()
            for call in call_chain:
                if call['source_class']:
                    nodes.add(call['source_class'])
                if call['target_class']:
                    nodes.add(call['target_class'])
                if call['table_name']:
                    nodes.add(f"Table_{call['table_name']}")
                if call['column_name']:
                    nodes.add(f"Column_{call['column_name']}")
            
            # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî ÎÖ∏Îìú Ï∂îÍ∞Ä (Ï†ÅÏÉâ Ï†êÏÑ†ÏúºÎ°ú ÌëúÏãú)
            for missing_table in missing_nodes['missing_tables']:
                nodes.add(f"MissingTable_{missing_table}")
            
            for missing_column in missing_nodes['missing_columns']:
                nodes.add(f"MissingColumn_{missing_column}")
            
            # ÎÖ∏Îìú Ïä§ÌÉÄÏùº Ï†ïÏùò
            for node in sorted(nodes):
                if node.startswith('MissingTable_'):
                    table_name = node.replace('MissingTable_', '')
                    diagram_lines.append(f"    {node}[\"‚ùå {table_name}\"]:::missingTable")
                elif node.startswith('MissingColumn_'):
                    column_name = node.replace('MissingColumn_', '')
                    diagram_lines.append(f"    {node}[\"‚ùå {column_name}\"]:::missingColumn")
                elif node.startswith('Table_'):
                    table_name = node.replace('Table_', '')
                    diagram_lines.append(f"    {node}[\"üìä {table_name}\"]:::table")
                elif node.startswith('Column_'):
                    column_name = node.replace('Column_', '')
                    diagram_lines.append(f"    {node}[\"üìã {column_name}\"]:::column")
                else:
                    diagram_lines.append(f"    {node}[\"üè¢ {node}\"]:::class")
            
            # Ïó∞Í≤∞ÏÑ† Ï†ïÏùò
            for call in call_chain:
                if call['source_class'] and call['target_class']:
                    diagram_lines.append(f"    {call['source_class']} --> {call['target_class']}")
                
                if call['target_class'] and call['table_name']:
                    table_node = f"Table_{call['table_name']}"
                    diagram_lines.append(f"    {call['target_class']} --> {table_node}")
                
                if call['table_name'] and call['column_name']:
                    table_node = f"Table_{call['table_name']}"
                    column_node = f"Column_{call['column_name']}"
                    diagram_lines.append(f"    {table_node} --> {column_node}")
            
            # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî ÎÖ∏Îìú Ïó∞Í≤∞ (Ï†ÅÏÉâ Ï†êÏÑ†)
            for call in call_chain:
                if call['table_name'] and call['table_name'] in missing_nodes['missing_tables']:
                    missing_table_node = f"MissingTable_{call['table_name']}"
                    if call['target_class']:
                        diagram_lines.append(f"    {call['target_class']} -.-> {missing_table_node}")
                
                if call['column_name'] and call['column_name'] in missing_nodes['missing_columns']:
                    missing_column_node = f"MissingColumn_{call['column_name']}"
                    if call['table_name']:
                        table_node = f"Table_{call['table_name']}"
                        diagram_lines.append(f"    {table_node} -.-> {missing_column_node}")
            
            # Ïä§ÌÉÄÏùº Ï†ïÏùò
            diagram_lines.extend([
                "",
                "    classDef class fill:#e1f5fe,stroke:#01579b,stroke-width:2px",
                "    classDef table fill:#f3e5f5,stroke:#4a148c,stroke-width:2px",
                "    classDef column fill:#e8f5e8,stroke:#1b5e20,stroke-width:2px",
                "    classDef missingTable fill:#ffebee,stroke:#c62828,stroke-width:2px,stroke-dasharray: 5 5",
                "    classDef missingColumn fill:#fff3e0,stroke:#ef6c00,stroke-width:2px,stroke-dasharray: 5 5"
            ])
            
            diagram_lines.append("```")
            
            return "\n".join(diagram_lines)
            
        except Exception as e:
            self.logger.error(f"Ìò∏Ï∂ú Ï≤¥Ïù∏ Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏÉùÏÑ± Ïò§Î•ò: {str(e)}")
            return f"Ïò§Î•ò: {str(e)}"
    
    def analyze_table_impact(self, project_name: str, table_name: str) -> Dict[str, Any]:
        """
        ÌäπÏ†ï ÌÖåÏù¥Î∏î Î≥ÄÍ≤Ω Ïãú ÏòÅÌñ•Î∞õÎäî ÌÅ¥ÎûòÏä§/Î©îÏÑúÎìúÎ•º Î∂ÑÏÑùÌï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            table_name: Î∂ÑÏÑùÌï† ÌÖåÏù¥Î∏î Ïù¥Î¶Ñ
            
        Returns:
            ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù Í≤∞Í≥º
        """
        try:
            with self.driver.session() as session:
                # ÌÖåÏù¥Î∏îÏùÑ ÏÇ¨Ïö©ÌïòÎäî ÌÅ¥ÎûòÏä§/Î©îÏÑúÎìú Ï°∞Ìöå
                impact_query = """
                MATCH (c:Class {project_name: $project_name})-[:HAS_METHOD]->(m:Method)
                MATCH (m)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
                WHERE sql.tables CONTAINS $table_name OR 
                      ANY(table_info IN sql.tables WHERE table_info.name = $table_name)
                RETURN c.name as class_name,
                       c.package_name as package_name,
                       m.name as method_name,
                       sql.id as sql_id,
                       sql.sql_type as sql_type,
                       sql.complexity_score as complexity_score
                ORDER BY c.name, m.name
                """
                
                result = session.run(impact_query, 
                                   project_name=project_name, 
                                   table_name=table_name)
                
                impacted_classes = []
                for record in result:
                    impacted_classes.append({
                        'class_name': record['class_name'],
                        'package_name': record['package_name'],
                        'method_name': record['method_name'],
                        'sql_id': record['sql_id'],
                        'sql_type': record['sql_type'],
                        'complexity_score': record['complexity_score']
                    })
                
                # ÏòÅÌñ•ÎèÑ ÏöîÏïΩ
                summary = {
                    'table_name': table_name,
                    'total_impacted_classes': len(set(c['class_name'] for c in impacted_classes)),
                    'total_impacted_methods': len(set(f"{c['class_name']}.{c['method_name']}" for c in impacted_classes)),
                    'total_sql_statements': len(set(c['sql_id'] for c in impacted_classes if c['sql_id'])),
                    'crud_operations': list(set(c['sql_type'] for c in impacted_classes if c['sql_type'])),
                    'high_complexity_sql': [c for c in impacted_classes if c['complexity_score'] and c['complexity_score'] > 7]
                }
                
                return {
                    'table_name': table_name,
                    'impacted_classes': impacted_classes,
                    'summary': summary
                }
                
        except Exception as e:
            self.logger.error(f"ÌÖåÏù¥Î∏î ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù Ïò§Î•ò: {str(e)}")
            return {'error': str(e)}
    
    def get_database_usage_statistics(self, project_name: str) -> Dict[str, Any]:
        """
        Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÇ¨Ïö© ÌÜµÍ≥ÑÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            
        Returns:
            Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÇ¨Ïö© ÌÜµÍ≥Ñ
        """
        try:
            with self.driver.session() as session:
                # SQL ÌÜµÍ≥Ñ
                sql_stats_query = """
                MATCH (sql:SqlStatement {project_name: $project_name})
                RETURN 
                    count(sql) as total_sql,
                    sum(CASE WHEN sql.sql_type = 'SELECT' THEN 1 ELSE 0 END) as SELECT,
                    sum(CASE WHEN sql.sql_type = 'INSERT' THEN 1 ELSE 0 END) as INSERT,
                    sum(CASE WHEN sql.sql_type = 'UPDATE' THEN 1 ELSE 0 END) as UPDATE,
                    sum(CASE WHEN sql.sql_type = 'DELETE' THEN 1 ELSE 0 END) as DELETE
                """
                
                result = session.run(sql_stats_query, project_name=project_name)
                sql_stats = result.single().data() if result.single() else {}
                
                # ÌÖåÏù¥Î∏î ÏÇ¨Ïö© ÌÜµÍ≥Ñ
                table_usage_query = """
                MATCH (sql:SqlStatement {project_name: $project_name})
                WHERE sql.tables IS NOT NULL
                UNWIND sql.tables as table_info
                WITH table_info.name as table_name, sql.sql_type as operation
                RETURN 
                    table_name,
                    count(*) as access_count,
                    collect(DISTINCT operation) as operations
                ORDER BY access_count DESC
                """
                
                result = session.run(table_usage_query, project_name=project_name)
                table_usage = [record.data() for record in result]
                
                # Î≥µÏû°ÎèÑ ÌÜµÍ≥Ñ
                complexity_query = """
                MATCH (sql:SqlStatement {project_name: $project_name})
                WHERE sql.complexity_score IS NOT NULL
                WITH sql.complexity_score as score,
                     CASE 
                         WHEN sql.complexity_score <= 3 THEN 'simple'
                         WHEN sql.complexity_score <= 7 THEN 'medium'
                         WHEN sql.complexity_score <= 12 THEN 'complex'
                         ELSE 'very_complex'
                     END as complexity_level
                RETURN 
                    complexity_level,
                    count(*) as count
                """
                
                result = session.run(complexity_query, project_name=project_name)
                complexity_stats = {record['complexity_level']: record['count'] for record in result}
                
                return {
                    'project_name': project_name,
                    'sql_statistics': sql_stats,
                    'table_usage': table_usage,
                    'complexity_statistics': complexity_stats
                }
                
        except Exception as e:
            self.logger.error(f"Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÇ¨Ïö© ÌÜµÍ≥Ñ Ï°∞Ìöå Ïò§Î•ò: {str(e)}")
            return {'error': str(e)}

```

Ïù¥Ï†ú Í≤∞Í≥ºÎ•º Ï≤òÎ¶¨ÌïòÎäî Î°úÏßÅÎèÑ ÏàòÏ†ïÌï¥Ïïº Ìï©ÎãàÎã§:


```python
"""
Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ìò∏Ï∂úÍ¥ÄÍ≥Ñ Î∂ÑÏÑù ÏÑúÎπÑÏä§

Ïù¥ Î™®ÎìàÏùÄ Ïñ¥ÌîåÎ¶¨ÏºÄÏù¥ÏÖòÍ≥º Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í∞ÑÏùò Ìò∏Ï∂úÍ¥ÄÍ≥ÑÎ•º Î∂ÑÏÑùÌïòÍ≥† ÏãúÍ∞ÅÌôîÌïòÎäî Í∏∞Îä•ÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§.
- Controller ‚Üí Service ‚Üí Repository ‚Üí SQL ‚Üí Table/Column Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù
- CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
- Ìò∏Ï∂ú Í¥ÄÍ≥Ñ Í∑∏ÎûòÌîÑ ÏÉùÏÑ± (Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû®)
- Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Table/Column ÎÖ∏Îìú ÏãùÎ≥Ñ Î∞è ÏãúÍ∞ÅÌôî
- ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù
"""

import json
from typing import List, Dict, Any, Optional, Set, Tuple
from neo4j import Driver
from src.utils.logger import get_logger


class DBCallAnalysisService:
    """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ìò∏Ï∂úÍ¥ÄÍ≥Ñ Î∂ÑÏÑù ÏÑúÎπÑÏä§"""
    
    def __init__(self, driver: Driver):
        """Neo4j ÎìúÎùºÏù¥Î≤ÑÎ°ú Ï¥àÍ∏∞Ìôî"""
        self.driver = driver
        self.logger = get_logger(__name__)
    
    def analyze_call_chain(self, project_name: str, start_class: str = None, start_method: str = None) -> Dict[str, Any]:
        """
        Controller ‚Üí Service ‚Üí Repository ‚Üí SQL ‚Üí Table/Column Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Î∂ÑÏÑùÌï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            start_class: ÏãúÏûë ÌÅ¥ÎûòÏä§ (ÏÑ†ÌÉùÏÇ¨Ìï≠)
            start_method: ÏãúÏûë Î©îÏÑúÎìú (ÏÑ†ÌÉùÏÇ¨Ìï≠)
            
        Returns:
            Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù Í≤∞Í≥º
        """
        try:
            with self.driver.session() as session:
                if start_class and start_method:
                    # ÌäπÏ†ï Î©îÏÑúÎìúÎ∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî Ìò∏Ï∂ú Ï≤¥Ïù∏
                    call_chain = self._get_method_call_chain(session, project_name, start_class, start_method)
                elif start_class:
                    # ÌäπÏ†ï ÌÅ¥ÎûòÏä§Î∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî Ìò∏Ï∂ú Ï≤¥Ïù∏
                    call_chain = self._get_class_call_chain(session, project_name, start_class)
                else:
                    # Ï†ÑÏ≤¥ ÌîÑÎ°úÏ†ùÌä∏Ïùò Ìò∏Ï∂ú Ï≤¥Ïù∏
                    call_chain = self._get_project_call_chain(session, project_name)
                
                # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Table/Column ÎÖ∏Îìú ÏãùÎ≥Ñ
                missing_nodes = self._identify_missing_nodes(session, project_name, call_chain)
                
                return {
                    'project_name': project_name,
                    'call_chain': call_chain,
                    'missing_nodes': missing_nodes,
                    'analysis_summary': self._generate_analysis_summary(call_chain, missing_nodes)
                }
                
        except Exception as e:
            self.logger.error(f"Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù Ïò§Î•ò: {str(e)}")
            return {'error': str(e)}
    
    def _get_method_call_chain(self, session, project_name: str, class_name: str, method_name: str) -> List[Dict[str, Any]]:
        """ÌäπÏ†ï Î©îÏÑúÎìúÎ∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Î∂ÑÏÑùÌï©ÎãàÎã§."""
        query = """
        MATCH (c:Class {name: $class_name, project_name: $project_name})-[:HAS_METHOD]->(m:Method {name: $method_name})
        OPTIONAL MATCH (m)-[:CALLS*0..5]->(target_method:Method)
        OPTIONAL MATCH (target_method)<-[:HAS_METHOD]-(target_class:Class)
        OPTIONAL MATCH (target_method)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_TABLE]->(table:Table {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_COLUMN]->(column:Column {project_name: $project_name})
        RETURN m.name as source_method,
               c.name as source_class,
               c.package_name as source_package,
               target_method.name as target_method,
               target_class.name as target_class,
               target_class.package_name as target_package,
               sql.id as sql_id,
               sql.sql_type as sql_type,
               sql.tables as sql_tables,
               sql.columns as sql_columns,
               table.name as table_name,
               column.name as column_name,
               column.table_name as column_table_name
        ORDER BY source_method, target_class.name, target_method.name
        """
        
        result = session.run(query, 
                           class_name=class_name, 
                           method_name=method_name, 
                           project_name=project_name)
        
        call_chain = []
        for record in result:
            call_chain.append({
                'source_method': record['source_method'],
                'source_class': record['source_class'],
                'source_package': record['source_package'] or 'default',
                'target_method': record['target_method'],
                'target_class': record['target_class'],
                'target_package': record['target_package'] or 'default',
                'sql_id': record['sql_id'],
                'sql_type': record['sql_type'],
                'sql_tables': json.loads(record['sql_tables']) if record['sql_tables'] else [],
                'sql_columns': json.loads(record['sql_columns']) if record['sql_columns'] else [],
                'table_name': record['table_name'],
                'column_name': record['column_name'],
                'column_table_name': record['column_table_name']
            })
        
        return call_chain
    
    def _get_class_call_chain(self, session, project_name: str, class_name: str) -> List[Dict[str, Any]]:
        """ÌäπÏ†ï ÌÅ¥ÎûòÏä§Î∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Î∂ÑÏÑùÌï©ÎãàÎã§."""
        query = """
        MATCH (c:Class {name: $class_name, project_name: $project_name})-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS*0..5]->(target_method:Method)
        OPTIONAL MATCH (target_method)<-[:HAS_METHOD]-(target_class:Class)
        OPTIONAL MATCH (target_method)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_TABLE]->(table:Table {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_COLUMN]->(column:Column {project_name: $project_name})
        RETURN m.name as source_method,
               c.name as source_class,
               c.package_name as source_package,
               target_method.name as target_method,
               target_class.name as target_class,
               target_class.package_name as target_package,
               sql.id as sql_id,
               sql.sql_type as sql_type,
               sql.tables as sql_tables,
               sql.columns as sql_columns,
               table.name as table_name,
               column.name as column_name,
               column.table_name as column_table_name
        ORDER BY source_method, target_class.name, target_method.name
        """
        
        result = session.run(query, 
                           class_name=class_name, 
                           project_name=project_name)
        
        call_chain = []
        for record in result:
            call_chain.append({
                'source_method': record['source_method'],
                'source_class': record['source_class'],
                'source_package': record['source_package'] or 'default',
                'target_method': record['target_method'],
                'target_class': record['target_class'],
                'target_package': record['target_package'] or 'default',
                'sql_id': record['sql_id'],
                'sql_type': record['sql_type'],
                'sql_tables': json.loads(record['sql_tables']) if record['sql_tables'] else [],
                'sql_columns': json.loads(record['sql_columns']) if record['sql_columns'] else [],
                'table_name': record['table_name'],
                'column_name': record['column_name'],
                'column_table_name': record['column_table_name']
            })
        
        return call_chain
    
    def _get_project_call_chain(self, session, project_name: str) -> List[Dict[str, Any]]:
        """Ï†ÑÏ≤¥ ÌîÑÎ°úÏ†ùÌä∏Ïùò Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Î∂ÑÏÑùÌï©ÎãàÎã§."""
        query = """
        MATCH (c:Class {project_name: $project_name})-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS*0..5]->(target_method:Method)
        OPTIONAL MATCH (target_method)<-[:HAS_METHOD]-(target_class:Class)
        OPTIONAL MATCH (target_method)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_TABLE]->(table:Table {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_COLUMN]->(column:Column {project_name: $project_name})
        RETURN m.name as source_method,
               c.name as source_class,
               c.package_name as source_package,
               target_method.name as target_method,
               target_class.name as target_class,
               target_class.package_name as target_package,
               sql.id as sql_id,
               sql.sql_type as sql_type,
               sql.tables as sql_tables,
               sql.columns as sql_columns,
               table.name as table_name,
               column.name as column_name,
               column.table_name as column_table_name
        ORDER BY source_class, source_method, target_class.name, target_method.name
        """
        
        result = session.run(query, project_name=project_name)
        
        call_chain = []
        for record in result:
            call_chain.append({
                'source_method': record['source_method'],
                'source_class': record['source_class'],
                'source_package': record['source_package'] or 'default',
                'target_method': record['target_method'],
                'target_class': record['target_class'],
                'target_package': record['target_package'] or 'default',
                'sql_id': record['sql_id'],
                'sql_type': record['sql_type'],
                'sql_tables': json.loads(record['sql_tables']) if record['sql_tables'] else [],
                'sql_columns': json.loads(record['sql_columns']) if record['sql_columns'] else [],
                'table_name': record['table_name'],
                'column_name': record['column_name'],
                'column_table_name': record['column_table_name']
            })
        
        return call_chain
    
    def _identify_missing_nodes(self, session, project_name: str, call_chain: List[Dict[str, Any]]) -> Dict[str, List[str]]:
        """Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Table/Column ÎÖ∏ÎìúÎ•º ÏãùÎ≥ÑÌï©ÎãàÎã§."""
        missing_tables = set()
        missing_columns = set()
        
        # SQLÏóêÏÑú Ï∞∏Ï°∞ÌïòÎäî ÌÖåÏù¥Î∏îÍ≥º Ïª¨Îüº ÏàòÏßë
        referenced_tables = set()
        referenced_columns = set()
        
        for call in call_chain:
            # SQL ÌÖåÏù¥Î∏î Ï†ïÎ≥¥ ÏàòÏßë
            if call.get('sql_tables'):
                for table_info in call['sql_tables']:
                    if isinstance(table_info, dict) and 'name' in table_info:
                        referenced_tables.add(table_info['name'])
            
            # SQL Ïª¨Îüº Ï†ïÎ≥¥ ÏàòÏßë
            if call.get('sql_columns'):
                for column_info in call['sql_columns']:
                    if isinstance(column_info, dict) and 'name' in column_info:
                        referenced_columns.add(column_info['name'])
                        if 'table' in column_info and column_info['table']:
                            referenced_tables.add(column_info['table'])
        
        # Ïã§Ï†ú Ï°¥Ïû¨ÌïòÎäî ÌÖåÏù¥Î∏îÍ≥º Ïª¨Îüº Ï°∞Ìöå
        existing_tables = self._get_existing_tables(session, project_name)
        existing_columns = self._get_existing_columns(session, project_name)
        
        # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî ÌÖåÏù¥Î∏î ÏãùÎ≥Ñ
        for table_name in referenced_tables:
            if table_name not in existing_tables:
                missing_tables.add(table_name)
        
        # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Ïª¨Îüº ÏãùÎ≥Ñ
        for column_name in referenced_columns:
            if column_name not in existing_columns:
                missing_columns.add(column_name)
        
        return {
            'missing_tables': list(missing_tables),
            'missing_columns': list(missing_columns)
        }
    
    def _get_existing_tables(self, session, project_name: str) -> Set[str]:
        """Ïã§Ï†ú Ï°¥Ïû¨ÌïòÎäî ÌÖåÏù¥Î∏î Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§."""
        query = """
        MATCH (t:Table {project_name: $project_name})
        RETURN t.name as table_name
        """
        
        result = session.run(query, project_name=project_name)
        return {record['table_name'] for record in result}
    
    def _get_existing_columns(self, session, project_name: str) -> Set[str]:
        """Ïã§Ï†ú Ï°¥Ïû¨ÌïòÎäî Ïª¨Îüº Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§."""
        query = """
        MATCH (c:Column {project_name: $project_name})
        RETURN c.name as column_name
        """
        
        result = session.run(query, project_name=project_name)
        return {record['column_name'] for record in result}
    
    def _generate_analysis_summary(self, call_chain: List[Dict[str, Any]], missing_nodes: Dict[str, List[str]]) -> Dict[str, Any]:
        """Î∂ÑÏÑù Í≤∞Í≥º ÏöîÏïΩÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§."""
        # ÌÅ¥ÎûòÏä§Î≥Ñ ÌÜµÍ≥Ñ
        class_stats = {}
        for call in call_chain:
            source_class = call['source_class']
            if source_class not in class_stats:
                class_stats[source_class] = {
                    'method_count': 0,
                    'sql_count': 0,
                    'table_count': 0,
                    'column_count': 0
                }
            
            if call['source_method']:
                class_stats[source_class]['method_count'] += 1
            if call['sql_id']:
                class_stats[source_class]['sql_count'] += 1
            if call['table_name']:
                class_stats[source_class]['table_count'] += 1
            if call['column_name']:
                class_stats[source_class]['column_count'] += 1
        
        return {
            'total_calls': len(call_chain),
            'unique_classes': len(class_stats),
            'unique_methods': len(set(call['source_method'] for call in call_chain if call['source_method'])),
            'unique_sql_statements': len(set(call['sql_id'] for call in call_chain if call['sql_id'])),
            'unique_tables': len(set(call['table_name'] for call in call_chain if call['table_name'])),
            'unique_columns': len(set(call['column_name'] for call in call_chain if call['column_name'])),
            'missing_tables_count': len(missing_nodes['missing_tables']),
            'missing_columns_count': len(missing_nodes['missing_columns']),
            'class_stats': class_stats
        }
    
    def generate_crud_matrix(self, project_name: str) -> Dict[str, Any]:
        """
        CRUD Îß§Ìä∏Î¶≠Ïä§Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
        SQLÏùÑ ÏßÅÏ†ë Ìò∏Ï∂úÌïòÎäî ÌÅ¥ÎûòÏä§Îßå Ìè¨Ìï®Ìï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            
        Returns:
            CRUD Îß§Ìä∏Î¶≠Ïä§ Îç∞Ïù¥ÌÑ∞
        """
        try:
            with self.driver.session() as session:
                # SQLÏùÑ ÏßÅÏ†ë Ìò∏Ï∂úÌïòÎäî ÌÅ¥ÎûòÏä§Îßå ÎåÄÏÉÅÏúºÎ°ú CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
                class_crud_query = """
                MATCH (c:Class {project_name: $project_name})-[:HAS_METHOD]->(m:Method)
                MATCH (m)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
                WITH c, m, sql,
                     CASE 
                       WHEN sql.sql_type = 'SELECT' THEN 'R'
                       WHEN sql.sql_type = 'INSERT' THEN 'C'
                       WHEN sql.sql_type = 'UPDATE' THEN 'U'
                       WHEN sql.sql_type = 'DELETE' THEN 'D'
                       ELSE 'O'
                     END as crud_operation
                RETURN c.name as class_name,
                       c.package_name as package_name,
                       sql.mapper_name as table_name,
                       crud_operation as operation,
                       sql.id as sql_id
                ORDER BY c.name
                """
                
                result = session.run(class_crud_query, project_name=project_name)
                raw_data = [record.data() for record in result]
                
                # ÌÅ¥ÎûòÏä§Î≥ÑÎ°ú Í∑∏Î£πÌôîÌïòÏó¨ Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
                class_matrix = {}
                for row in raw_data:
                    class_name = row['class_name']
                    if class_name not in class_matrix:
                        class_matrix[class_name] = {
                            'class_name': class_name,
                            'package_name': row['package_name'],
                            'tables': set(),
                            'operations': set(),
                            'sql_statements': set()
                        }
                    
                    if row['table_name']:
                        class_matrix[class_name]['tables'].add(row['table_name'])
                    class_matrix[class_name]['operations'].add(row['operation'])
                    class_matrix[class_name]['sql_statements'].add(row['sql_id'])
                
                # setÏùÑ listÎ°ú Î≥ÄÌôò
                class_matrix = [
                    {
                        'class_name': data['class_name'],
                        'package_name': data['package_name'],
                        'tables': list(data['tables']),
                        'operations': list(data['operations']),
                        'sql_statements': list(data['sql_statements'])
                    }
                    for data in class_matrix.values()
                ]
                
                # ÌÖåÏù¥Î∏îÎ≥Ñ CRUD Îß§Ìä∏Î¶≠Ïä§
                table_crud_query = """
                MATCH (sql:SqlStatement {project_name: $project_name})
                WHERE sql.tables IS NOT NULL
                UNWIND sql.tables as table_info
                WITH table_info.name as table_name, sql.sql_type as operation, count(sql) as count
                RETURN table_name,
                       collect({operation: operation, count: count}) as operations
                ORDER BY table_name
                """
                
                result = session.run(table_crud_query, project_name=project_name)
                table_matrix = [record.data() for record in result]
                
                return {
                    'project_name': project_name,
                    'class_matrix': class_matrix,
                    'table_matrix': table_matrix,
                    'summary': self._generate_crud_summary(class_matrix, table_matrix)
                }
                
        except Exception as e:
            self.logger.error(f"CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ± Ïò§Î•ò: {str(e)}")
            return {'error': str(e)}
    
    def _generate_crud_summary(self, class_matrix: List[Dict], table_matrix: List[Dict]) -> Dict[str, Any]:
        """CRUD Îß§Ìä∏Î¶≠Ïä§ ÏöîÏïΩÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§."""
        total_classes = len(class_matrix)
        total_tables = len(table_matrix)
        
        # CRUD ÏûëÏóÖÎ≥Ñ ÌÜµÍ≥Ñ
        crud_stats = {'C': 0, 'R': 0, 'U': 0, 'D': 0, 'O': 0}
        for class_data in class_matrix:
            for operation in class_data['operations']:
                if operation in crud_stats:
                    crud_stats[operation] += 1
        
        return {
            'total_classes': total_classes,
            'total_tables': total_tables,
            'crud_stats': crud_stats,
            'most_active_class': max(class_matrix, key=lambda x: len(x['operations']))['class_name'] if class_matrix else None,
            'most_used_table': max(table_matrix, key=lambda x: sum(op['count'] for op in x['operations']))['table_name'] if table_matrix else None
        }
    
    def generate_call_chain_diagram(self, project_name: str, start_class: str = None, start_method: str = None) -> str:
        """
        Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû®ÏúºÎ°ú ÏÉùÏÑ±Ìï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            start_class: ÏãúÏûë ÌÅ¥ÎûòÏä§ (ÏÑ†ÌÉùÏÇ¨Ìï≠)
            start_method: ÏãúÏûë Î©îÏÑúÎìú (ÏÑ†ÌÉùÏÇ¨Ìï≠)
            
        Returns:
            Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû® Î¨∏ÏûêÏó¥
        """
        try:
            analysis_result = self.analyze_call_chain(project_name, start_class, start_method)
            
            if 'error' in analysis_result:
                return f"Ïò§Î•ò: {analysis_result['error']}"
            
            call_chain = analysis_result['call_chain']
            missing_nodes = analysis_result['missing_nodes']
            
            if not call_chain:
                return "```mermaid\ngraph TD\n    A[No call chain found]\n```"
            
            # Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏÉùÏÑ±
            diagram_lines = ["```mermaid", "graph TD"]
            
            # ÎÖ∏Îìú Ï†ïÏùò
            nodes = set()
            for call in call_chain:
                if call['source_class']:
                    nodes.add(call['source_class'])
                if call['target_class']:
                    nodes.add(call['target_class'])
                if call['table_name']:
                    nodes.add(f"Table_{call['table_name']}")
                if call['column_name']:
                    nodes.add(f"Column_{call['column_name']}")
            
            # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî ÎÖ∏Îìú Ï∂îÍ∞Ä (Ï†ÅÏÉâ Ï†êÏÑ†ÏúºÎ°ú ÌëúÏãú)
            for missing_table in missing_nodes['missing_tables']:
                nodes.add(f"MissingTable_{missing_table}")
            
            for missing_column in missing_nodes['missing_columns']:
                nodes.add(f"MissingColumn_{missing_column}")
            
            # ÎÖ∏Îìú Ïä§ÌÉÄÏùº Ï†ïÏùò
            for node in sorted(nodes):
                if node.startswith('MissingTable_'):
                    table_name = node.replace('MissingTable_', '')
                    diagram_lines.append(f"    {node}[\"‚ùå {table_name}\"]:::missingTable")
                elif node.startswith('MissingColumn_'):
                    column_name = node.replace('MissingColumn_', '')
                    diagram_lines.append(f"    {node}[\"‚ùå {column_name}\"]:::missingColumn")
                elif node.startswith('Table_'):
                    table_name = node.replace('Table_', '')
                    diagram_lines.append(f"    {node}[\"üìä {table_name}\"]:::table")
                elif node.startswith('Column_'):
                    column_name = node.replace('Column_', '')
                    diagram_lines.append(f"    {node}[\"üìã {column_name}\"]:::column")
                else:
                    diagram_lines.append(f"    {node}[\"üè¢ {node}\"]:::class")
            
            # Ïó∞Í≤∞ÏÑ† Ï†ïÏùò
            for call in call_chain:
                if call['source_class'] and call['target_class']:
                    diagram_lines.append(f"    {call['source_class']} --> {call['target_class']}")
                
                if call['target_class'] and call['table_name']:
                    table_node = f"Table_{call['table_name']}"
                    diagram_lines.append(f"    {call['target_class']} --> {table_node}")
                
                if call['table_name'] and call['column_name']:
                    table_node = f"Table_{call['table_name']}"
                    column_node = f"Column_{call['column_name']}"
                    diagram_lines.append(f"    {table_node} --> {column_node}")
            
            # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî ÎÖ∏Îìú Ïó∞Í≤∞ (Ï†ÅÏÉâ Ï†êÏÑ†)
            for call in call_chain:
                if call['table_name'] and call['table_name'] in missing_nodes['missing_tables']:
                    missing_table_node = f"MissingTable_{call['table_name']}"
                    if call['target_class']:
                        diagram_lines.append(f"    {call['target_class']} -.-> {missing_table_node}")
                
                if call['column_name'] and call['column_name'] in missing_nodes['missing_columns']:
                    missing_column_node = f"MissingColumn_{call['column_name']}"
                    if call['table_name']:
                        table_node = f"Table_{call['table_name']}"
                        diagram_lines.append(f"    {table_node} -.-> {missing_column_node}")
            
            # Ïä§ÌÉÄÏùº Ï†ïÏùò
            diagram_lines.extend([
                "",
                "    classDef class fill:#e1f5fe,stroke:#01579b,stroke-width:2px",
                "    classDef table fill:#f3e5f5,stroke:#4a148c,stroke-width:2px",
                "    classDef column fill:#e8f5e8,stroke:#1b5e20,stroke-width:2px",
                "    classDef missingTable fill:#ffebee,stroke:#c62828,stroke-width:2px,stroke-dasharray: 5 5",
                "    classDef missingColumn fill:#fff3e0,stroke:#ef6c00,stroke-width:2px,stroke-dasharray: 5 5"
            ])
            
            diagram_lines.append("```")
            
            return "\n".join(diagram_lines)
            
        except Exception as e:
            self.logger.error(f"Ìò∏Ï∂ú Ï≤¥Ïù∏ Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏÉùÏÑ± Ïò§Î•ò: {str(e)}")
            return f"Ïò§Î•ò: {str(e)}"
    
    def analyze_table_impact(self, project_name: str, table_name: str) -> Dict[str, Any]:
        """
        ÌäπÏ†ï ÌÖåÏù¥Î∏î Î≥ÄÍ≤Ω Ïãú ÏòÅÌñ•Î∞õÎäî ÌÅ¥ÎûòÏä§/Î©îÏÑúÎìúÎ•º Î∂ÑÏÑùÌï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            table_name: Î∂ÑÏÑùÌï† ÌÖåÏù¥Î∏î Ïù¥Î¶Ñ
            
        Returns:
            ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù Í≤∞Í≥º
        """
        try:
            with self.driver.session() as session:
                # ÌÖåÏù¥Î∏îÏùÑ ÏÇ¨Ïö©ÌïòÎäî ÌÅ¥ÎûòÏä§/Î©îÏÑúÎìú Ï°∞Ìöå
                impact_query = """
                MATCH (c:Class {project_name: $project_name})-[:HAS_METHOD]->(m:Method)
                MATCH (m)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
                WHERE sql.tables CONTAINS $table_name OR 
                      ANY(table_info IN sql.tables WHERE table_info.name = $table_name)
                RETURN c.name as class_name,
                       c.package_name as package_name,
                       m.name as method_name,
                       sql.id as sql_id,
                       sql.sql_type as sql_type,
                       sql.complexity_score as complexity_score
                ORDER BY c.name, m.name
                """
                
                result = session.run(impact_query, 
                                   project_name=project_name, 
                                   table_name=table_name)
                
                impacted_classes = []
                for record in result:
                    impacted_classes.append({
                        'class_name': record['class_name'],
                        'package_name': record['package_name'],
                        'method_name': record['method_name'],
                        'sql_id': record['sql_id'],
                        'sql_type': record['sql_type'],
                        'complexity_score': record['complexity_score']
                    })
                
                # ÏòÅÌñ•ÎèÑ ÏöîÏïΩ
                summary = {
                    'table_name': table_name,
                    'total_impacted_classes': len(set(c['class_name'] for c in impacted_classes)),
                    'total_impacted_methods': len(set(f"{c['class_name']}.{c['method_name']}" for c in impacted_classes)),
                    'total_sql_statements': len(set(c['sql_id'] for c in impacted_classes if c['sql_id'])),
                    'crud_operations': list(set(c['sql_type'] for c in impacted_classes if c['sql_type'])),
                    'high_complexity_sql': [c for c in impacted_classes if c['complexity_score'] and c['complexity_score'] > 7]
                }
                
                return {
                    'table_name': table_name,
                    'impacted_classes': impacted_classes,
                    'summary': summary
                }
                
        except Exception as e:
            self.logger.error(f"ÌÖåÏù¥Î∏î ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù Ïò§Î•ò: {str(e)}")
            return {'error': str(e)}
    
    def get_database_usage_statistics(self, project_name: str) -> Dict[str, Any]:
        """
        Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÇ¨Ïö© ÌÜµÍ≥ÑÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            
        Returns:
            Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÇ¨Ïö© ÌÜµÍ≥Ñ
        """
        try:
            with self.driver.session() as session:
                # SQL ÌÜµÍ≥Ñ
                sql_stats_query = """
                MATCH (sql:SqlStatement {project_name: $project_name})
                RETURN 
                    count(sql) as total_sql,
                    sum(CASE WHEN sql.sql_type = 'SELECT' THEN 1 ELSE 0 END) as SELECT,
                    sum(CASE WHEN sql.sql_type = 'INSERT' THEN 1 ELSE 0 END) as INSERT,
                    sum(CASE WHEN sql.sql_type = 'UPDATE' THEN 1 ELSE 0 END) as UPDATE,
                    sum(CASE WHEN sql.sql_type = 'DELETE' THEN 1 ELSE 0 END) as DELETE
                """
                
                result = session.run(sql_stats_query, project_name=project_name)
                sql_stats = result.single().data() if result.single() else {}
                
                # ÌÖåÏù¥Î∏î ÏÇ¨Ïö© ÌÜµÍ≥Ñ
                table_usage_query = """
                MATCH (sql:SqlStatement {project_name: $project_name})
                WHERE sql.tables IS NOT NULL
                UNWIND sql.tables as table_info
                WITH table_info.name as table_name, sql.sql_type as operation
                RETURN 
                    table_name,
                    count(*) as access_count,
                    collect(DISTINCT operation) as operations
                ORDER BY access_count DESC
                """
                
                result = session.run(table_usage_query, project_name=project_name)
                table_usage = [record.data() for record in result]
                
                # Î≥µÏû°ÎèÑ ÌÜµÍ≥Ñ
                complexity_query = """
                MATCH (sql:SqlStatement {project_name: $project_name})
                WHERE sql.complexity_score IS NOT NULL
                WITH sql.complexity_score as score,
                     CASE 
                         WHEN sql.complexity_score <= 3 THEN 'simple'
                         WHEN sql.complexity_score <= 7 THEN 'medium'
                         WHEN sql.complexity_score <= 12 THEN 'complex'
                         ELSE 'very_complex'
                     END as complexity_level
                RETURN 
                    complexity_level,
                    count(*) as count
                """
                
                result = session.run(complexity_query, project_name=project_name)
                complexity_stats = {record['complexity_level']: record['count'] for record in result}
                
                return {
                    'project_name': project_name,
                    'sql_statistics': sql_stats,
                    'table_usage': table_usage,
                    'complexity_statistics': complexity_stats
                }
                
        except Exception as e:
            self.logger.error(f"Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÇ¨Ïö© ÌÜµÍ≥Ñ Ï°∞Ìöå Ïò§Î•ò: {str(e)}")
            return {'error': str(e)}

```

Ïù¥Ï†ú ÏàòÏ†ïÎêú CRUD Îß§Ìä∏Î¶≠Ïä§Î•º ÌÖåÏä§Ìä∏Ìï¥Î≥¥Í≤†ÏäµÎãàÎã§:


ÌÑ∞ÎØ∏ÎÑê Í≤∞Í≥ºÎ•º Î≥¥Îãà **SQL Î¨∏Ïù¥ Ï†ÑÌòÄ Î∂ÑÏÑùÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§**. 

ÌòÑÏû¨ ÏÉÅÌô©:
- **Total calls: 11672** - Î©îÏÑúÎìú Ìò∏Ï∂úÏùÄ ÎßéÏù¥ ÏûàÏùå
- **Unique SQL statements: 0** - SQL Î¨∏Ïù¥ 0Í∞ú
- **Unique tables: 0** - ÌÖåÏù¥Î∏îÏù¥ 0Í∞ú
- **Unique columns: 0** - Ïª¨ÎüºÏù¥ 0Í∞ú

Ïù¥Îäî **MyBatis MapperÏôÄ SQL Î¨∏Ïù¥ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê Ï†ÄÏû•ÎêòÏßÄ ÏïäÏïòÍ∏∞ ÎïåÎ¨∏**ÏûÖÎãàÎã§.

Î¨∏Ï†úÎ•º Ìï¥Í≤∞ÌïòÍ∏∞ ÏúÑÌï¥ Îã§ÏùåÏùÑ ÌôïÏù∏Ìï¥Î≥¥Í≤†ÏäµÎãàÎã§:


ÌòÑÏû¨ ÏÉÅÌô©ÏùÑ Î≥¥Îãà **SQL Î¨∏Ïù¥ Ï†ÑÌòÄ Î∂ÑÏÑùÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§**. 

**Î¨∏Ï†ú ÏõêÏù∏:**
- `Unique SQL statements: 0` - SQL Î¨∏Ïù¥ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê ÏóÜÏùå
- `Unique tables: 0` - ÌÖåÏù¥Î∏î Ï†ïÎ≥¥ÎèÑ ÏóÜÏùå
- `Unique columns: 0` - Ïª¨Îüº Ï†ïÎ≥¥ÎèÑ ÏóÜÏùå

Ïù¥Îäî **MyBatis MapperÏôÄ SQL Î¨∏Ïù¥ Î∂ÑÏÑùÎêòÏßÄ ÏïäÏïòÍ∏∞ ÎïåÎ¨∏**ÏûÖÎãàÎã§.

**Ìï¥Í≤∞ Î∞©Î≤ï:**

1. **Java Í∞ùÏ≤¥ Î∂ÑÏÑù** (MyBatis Mapper Ìè¨Ìï®)
2. **DB Í∞ùÏ≤¥ Î∂ÑÏÑù** (ÌÖåÏù¥Î∏î/Ïª¨Îüº Ï†ïÎ≥¥)

Îã§Ïùå Î™ÖÎ†πÏñ¥Îì§ÏùÑ ÏàúÏÑúÎåÄÎ°ú Ïã§ÌñâÌï¥Ïïº Ìï©ÎãàÎã§:

```bash
# 1. Java Í∞ùÏ≤¥ Î∂ÑÏÑù (MyBatis MapperÏôÄ SQL Î¨∏ Ìè¨Ìï®)
python -m src.cli.main analyze --java_object --java-source-folder ./src/main/java

# 2. DB Í∞ùÏ≤¥ Î∂ÑÏÑù (ÌÖåÏù¥Î∏î/Ïª¨Îüº Ï†ïÎ≥¥)
python -m src.cli.main analyze --db_object --db-script-folder ./sql

# 3. Í∑∏ Îã§Ïùå CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
python -m src.cli.main crud-analysis --project-name "car-center-devlab"
```

**ÌòÑÏû¨ ÏÉÅÌô©:**
- Java ÌÅ¥ÎûòÏä§Îì§ÏùÄ Î∂ÑÏÑùÎêòÏóàÏßÄÎßå **MyBatis MapperÏôÄ SQL Î¨∏Ïù¥ Î∂ÑÏÑùÎêòÏßÄ ÏïäÏùå**
- DB Ïä§ÌÇ§Îßà Ï†ïÎ≥¥ÎèÑ Î∂ÑÏÑùÎêòÏßÄ ÏïäÏùå
- Îî∞ÎùºÏÑú CRUD Îß§Ìä∏Î¶≠Ïä§Ïóê ÌëúÏãúÌï† SQL Ìò∏Ï∂ú Ï†ïÎ≥¥Í∞Ä ÏóÜÏùå

**Í∂åÏû•ÏÇ¨Ìï≠:**
1. Î®ºÏ†Ä **Java Í∞ùÏ≤¥ Î∂ÑÏÑù**ÏùÑ Ïã§ÌñâÌïòÏó¨ MyBatis MapperÏôÄ SQL Î¨∏ÏùÑ Î∂ÑÏÑù
2. Í∑∏ Îã§Ïùå **DB Í∞ùÏ≤¥ Î∂ÑÏÑù**ÏùÑ Ïã§ÌñâÌïòÏó¨ ÌÖåÏù¥Î∏î/Ïª¨Îüº Ï†ïÎ≥¥Î•º Î∂ÑÏÑù
3. ÎßàÏßÄÎßâÏóê **CRUD Îß§Ìä∏Î¶≠Ïä§**Î•º ÏÉùÏÑ±ÌïòÎ©¥ ÏùòÎØ∏ÏûàÎäî Í≤∞Í≥ºÎ•º ÏñªÏùÑ Ïàò ÏûàÏäµÎãàÎã§

Ïù¥Î†áÍ≤å ÌïòÎ©¥ SQLÏùÑ ÏßÅÏ†ë Ìò∏Ï∂úÌïòÎäî ÌÅ¥ÎûòÏä§Îì§Îßå CRUD Îß§Ìä∏Î¶≠Ïä§Ïóê ÌëúÏãúÎêòÏñ¥ Ìõ®Ïî¨ Ïú†Ïö©Ìïú Î∂ÑÏÑù Í≤∞Í≥ºÎ•º ÏñªÏùÑ Ïàò ÏûàÏäµÎãàÎã§! üéØ

```shellscript
# 1. Java Í∞ùÏ≤¥ Î∂ÑÏÑù (MyBatis MapperÏôÄ SQL Î¨∏ Ìè¨Ìï®)
python -m src.cli.main analyze --java_object --java-source-folder ./src/main/java

# 2. DB Í∞ùÏ≤¥ Î∂ÑÏÑù (ÌÖåÏù¥Î∏î/Ïª¨Îüº Ï†ïÎ≥¥)
python -m src.cli.main analyze --db_object --db-script-folder ./sql

# 3. Í∑∏ Îã§Ïùå CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
python -m src.cli.main crud-analysis --project-name "car-center-devlab"
```

---

**User**

java_objectÏôÄ db_object Î∂ÑÏÑù ÏàúÏÑúÎäî Ï§ëÏöîÌïòÏßÄ ÏïäÏïÑ?

---

**Cursor**

Ï¢ãÏùÄ ÏßàÎ¨∏ÏûÖÎãàÎã§! **Î∂ÑÏÑù ÏàúÏÑúÎäî Ï§ëÏöîÌïòÏßÄ ÏïäÏäµÎãàÎã§**.

## Î∂ÑÏÑù ÏàúÏÑúÍ∞Ä Ï§ëÏöîÌïòÏßÄ ÏïäÏùÄ Ïù¥Ïú†:

### 1. **ÎèÖÎ¶ΩÏ†ÅÏù∏ Î∂ÑÏÑù**
- `--java_object`: Java ÏÜåÏä§ÏΩîÎìúÏóêÏÑú ÌÅ¥ÎûòÏä§, Î©îÏÑúÎìú, MyBatis Mapper, SQL Î¨∏ Îì±ÏùÑ Î∂ÑÏÑù
- `--db_object`: DDL Ïä§ÌÅ¨Î¶ΩÌä∏ÏóêÏÑú ÌÖåÏù¥Î∏î, Ïª¨Îüº, Ïù∏Îç±Ïä§ Îì±ÏùÑ Î∂ÑÏÑù
- Îëê Î∂ÑÏÑùÏùÄ **ÏôÑÏ†ÑÌûà ÎèÖÎ¶ΩÏ†Å**ÏûÖÎãàÎã§

### 2. **Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï†ÄÏû• Î∞©Ïãù**
- Í∞ÅÍ∞ÅÏùò Î∂ÑÏÑù Í≤∞Í≥ºÍ∞Ä **Î≥ÑÎèÑÏùò ÎÖ∏Îìú ÌÉÄÏûÖ**ÏúºÎ°ú Ï†ÄÏû•Îê©ÎãàÎã§:
  - Java Î∂ÑÏÑù: `Class`, `Method`, `SqlStatement`, `MyBatisMapper` Îì±
  - DB Î∂ÑÏÑù: `Table`, `Column`, `Index`, `Constraint` Îì±

### 3. **CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ± ÏãúÏ†ê**
- CRUD Îß§Ìä∏Î¶≠Ïä§Îäî **Îëê Î∂ÑÏÑùÏù¥ Î™®Îëê ÏôÑÎ£åÎêú ÌõÑ**Ïóê ÏÉùÏÑ±Îê©ÎãàÎã§
- Ïñ¥Îäê Í≤ÉÏùÑ Î®ºÏ†Ä Î∂ÑÏÑùÌïòÎì† **ÏµúÏ¢Ö Í≤∞Í≥ºÎäî ÎèôÏùº**Ìï©ÎãàÎã§

## Í∂åÏû• ÏàúÏÑú (Ìé∏ÏùòÏÉÅ):

```bash
# 1. Java Í∞ùÏ≤¥ Î∂ÑÏÑù (MyBatis MapperÏôÄ SQL Î¨∏ Ìè¨Ìï®)
python -m src.cli.main analyze --java_object --java-source-folder ./src/main/java

# 2. DB Í∞ùÏ≤¥ Î∂ÑÏÑù (ÌÖåÏù¥Î∏î/Ïª¨Îüº Ï†ïÎ≥¥)
python -m src.cli.main analyze --db_object --db-script-folder ./sql

# 3. CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
python -m src.cli.main crud-analysis --project-name "car-center-devlab"
```

## Ïó≠ÏàúÎèÑ Í∞ÄÎä•:

```bash
# 1. DB Í∞ùÏ≤¥ Î∂ÑÏÑù Î®ºÏ†Ä
python -m src.cli.main analyze --db_object --db-script-folder ./sql

# 2. Java Í∞ùÏ≤¥ Î∂ÑÏÑù ÎÇòÏ§ëÏóê
python -m src.cli.main analyze --java_object --java-source-folder ./src/main/java

# 3. CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
python -m src.cli.main crud-analysis --project-name "car-center-devlab"
```

**Í≤∞Î°†: ÏàúÏÑúÎäî ÏÉÅÍ¥ÄÏóÜÏßÄÎßå, Îëê Î∂ÑÏÑùÏùÑ Î™®Îëê ÏôÑÎ£åÌïú ÌõÑÏóê CRUD Îß§Ìä∏Î¶≠Ïä§Î•º ÏÉùÏÑ±Ìï¥Ïïº ÏùòÎØ∏ÏûàÎäî Í≤∞Í≥ºÎ•º ÏñªÏùÑ Ïàò ÏûàÏäµÎãàÎã§!** üéØ

```shellscript
# 1. Java Í∞ùÏ≤¥ Î∂ÑÏÑù (MyBatis MapperÏôÄ SQL Î¨∏ Ìè¨Ìï®)
python -m src.cli.main analyze --java_object --java-source-folder ./src/main/java

# 2. DB Í∞ùÏ≤¥ Î∂ÑÏÑù (ÌÖåÏù¥Î∏î/Ïª¨Îüº Ï†ïÎ≥¥)
python -m src.cli.main analyze --db_object --db-script-folder ./sql

# 3. CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
python -m src.cli.main crud-analysis --project-name "car-center-devlab"
```

```shellscript
# 1. DB Í∞ùÏ≤¥ Î∂ÑÏÑù Î®ºÏ†Ä
python -m src.cli.main analyze --db_object --db-script-folder ./sql

# 2. Java Í∞ùÏ≤¥ Î∂ÑÏÑù ÎÇòÏ§ëÏóê
python -m src.cli.main analyze --java_object --java-source-folder ./src/main/java

# 3. CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
python -m src.cli.main crud-analysis --project-name "car-center-devlab"
```

---

**User**

python -m src.cli.main crud-analysis --project-name "car-center-devlab"

---

**Cursor**

Î™ÖÎ†πÏñ¥Í∞Ä Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§. 

ÌòÑÏû¨ ÏÉÅÌô©ÏùÑ Ï†ïÎ¶¨ÌïòÎ©¥:

## üîç **ÌòÑÏû¨ ÏÉÅÌÉú**
- **Java Í∞ùÏ≤¥ Î∂ÑÏÑù**: ÏôÑÎ£å (ÌÅ¥ÎûòÏä§, Î©îÏÑúÎìú Îì±)
- **DB Í∞ùÏ≤¥ Î∂ÑÏÑù**: ÎØ∏ÏôÑÎ£å (ÌÖåÏù¥Î∏î, Ïª¨Îüº Ï†ïÎ≥¥ ÏóÜÏùå)
- **SQL Î¨∏ Î∂ÑÏÑù**: ÎØ∏ÏôÑÎ£å (MyBatis Mapper Î∂ÑÏÑù ÏïàÎê®)

## üéØ **CRUD Îß§Ìä∏Î¶≠Ïä§Î•º ÏúÑÌïú ÌïÑÏöî ÏûëÏóÖ**

CRUD Îß§Ìä∏Î¶≠Ïä§Î•º Ï†úÎåÄÎ°ú ÏÉùÏÑ±ÌïòÎ†§Î©¥ Îã§Ïùå Ï§ë ÌïòÎÇòÎ•º ÏÑ†ÌÉùÌï¥Ïïº Ìï©ÎãàÎã§:

### **ÏòµÏÖò 1: Java Í∞ùÏ≤¥ Î∂ÑÏÑù (MyBatis Mapper Ìè¨Ìï®)**
```bash
python -m src.cli.main analyze --java_object --java-source-folder ./src/main/java
```

### **ÏòµÏÖò 2: DB Í∞ùÏ≤¥ Î∂ÑÏÑù (ÌÖåÏù¥Î∏î/Ïª¨Îüº Ï†ïÎ≥¥)**
```bash
python -m src.cli.main analyze --db_object --db-script-folder ./sql
```

### **ÏòµÏÖò 3: ÌòÑÏû¨ ÏÉÅÌÉúÎ°ú CRUD Îß§Ìä∏Î¶≠Ïä§ ÌôïÏù∏**
```bash
python -m src.cli.main crud-analysis --project-name "car-center-devlab"
```

Ïñ¥Îñ§ ÏòµÏÖòÏùÑ ÏÑ†ÌÉùÌïòÏãúÍ≤†ÏäµÎãàÍπå? 

- **ÏòµÏÖò 1**ÏùÑ ÏÑ†ÌÉùÌïòÎ©¥ MyBatis MapperÏôÄ SQL Î¨∏Ïù¥ Î∂ÑÏÑùÎêòÏñ¥ Ïã§Ï†ú DB ÏûëÏóÖÏùÑ ÌïòÎäî ÌÅ¥ÎûòÏä§Îì§ÏùÑ Î≥º Ïàò ÏûàÏäµÎãàÎã§.
- **ÏòµÏÖò 2**Î•º ÏÑ†ÌÉùÌïòÎ©¥ ÌÖåÏù¥Î∏î/Ïª¨Îüº Ï†ïÎ≥¥Í∞Ä Î∂ÑÏÑùÎêòÏñ¥ DB Ïä§ÌÇ§Îßà Ï†ïÎ≥¥Î•º Î≥º Ïàò ÏûàÏäµÎãàÎã§.
- **ÏòµÏÖò 3**ÏùÑ ÏÑ†ÌÉùÌïòÎ©¥ ÌòÑÏû¨ ÏÉÅÌÉúÏóêÏÑú "SQLÏùÑ ÏßÅÏ†ë Ìò∏Ï∂úÌïòÎäî ÌÅ¥ÎûòÏä§Í∞Ä ÏóÜÏäµÎãàÎã§"ÎùºÎäî Î©îÏãúÏßÄÎ•º Î≥º Ïàò ÏûàÏäµÎãàÎã§.

```shellscript
python -m src.cli.main analyze --java_object --java-source-folder ./src/main/java
```

```shellscript
python -m src.cli.main analyze --db_object --db-script-folder ./sql
```

```shellscript
python -m src.cli.main crud-analysis --project-name "car-center-devlab"
```

---

**User**

Ïò§Î•ò Î∂ÑÏÑùÌï¥Ï§ò

---

**Cursor**

Ïò§Î•òÎ•º Î∂ÑÏÑùÌï¥Î≥¥Í≤†ÏäµÎãàÎã§.

## üîç **Ïò§Î•ò Î∂ÑÏÑù**

**Ïò§Î•ò Î©îÏãúÏßÄ:**
```
Type mismatch: expected a map but was String("[]")
```

**ÏõêÏù∏:**
- Neo4j ÏøºÎ¶¨ÏóêÏÑú `sql.tables` ÌïÑÎìúÎ•º `UNWIND`ÌïòÎ†§Í≥† ÌïòÎäîÎç∞
- `sql.tables`Í∞Ä JSON Î¨∏ÏûêÏó¥ `"[]"`Î°ú Ï†ÄÏû•ÎêòÏñ¥ ÏûàÏùå
- Neo4jÎäî Ïù¥Î•º Map ÌÉÄÏûÖÏúºÎ°ú Í∏∞ÎåÄÌïòÏßÄÎßå String ÌÉÄÏûÖÏù¥ÎùºÏÑú Ïò§Î•ò Î∞úÏÉù

## üõ†Ô∏è **Î¨∏Ï†ú ÏúÑÏπò**

`src/services/db_call_analysis.py`Ïùò ÌÖåÏù¥Î∏îÎ≥Ñ CRUD Îß§Ìä∏Î¶≠Ïä§ ÏøºÎ¶¨ÏóêÏÑú:

```cypher
MATCH (sql:SqlStatement {project_name: $project_name})
WHERE sql.tables IS NOT NULL
UNWIND sql.tables as table_info  # ‚Üê Ïó¨Í∏∞ÏÑú Ïò§Î•ò Î∞úÏÉù
```

## üîß **Ìï¥Í≤∞ Î∞©Î≤ï**

`sql.tables`Í∞Ä JSON Î¨∏ÏûêÏó¥Î°ú Ï†ÄÏû•ÎêòÏñ¥ ÏûàÏúºÎØÄÎ°ú, Ïù¥Î•º ÌååÏã±Ìï¥ÏÑú ÏÇ¨Ïö©Ìï¥Ïïº Ìï©ÎãàÎã§.

ÏàòÏ†ïÌïòÍ≤†ÏäµÎãàÎã§:


```plaintext
Type mismatch: expected a map but was String("[]")
```

```cql
MATCH (sql:SqlStatement {project_name: $project_name})
WHERE sql.tables IS NOT NULL
UNWIND sql.tables as table_info  # ‚Üê Ïó¨Í∏∞ÏÑú Ïò§Î•ò Î∞úÏÉù
```

```python
"""
Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ìò∏Ï∂úÍ¥ÄÍ≥Ñ Î∂ÑÏÑù ÏÑúÎπÑÏä§

Ïù¥ Î™®ÎìàÏùÄ Ïñ¥ÌîåÎ¶¨ÏºÄÏù¥ÏÖòÍ≥º Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í∞ÑÏùò Ìò∏Ï∂úÍ¥ÄÍ≥ÑÎ•º Î∂ÑÏÑùÌïòÍ≥† ÏãúÍ∞ÅÌôîÌïòÎäî Í∏∞Îä•ÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§.
- Controller ‚Üí Service ‚Üí Repository ‚Üí SQL ‚Üí Table/Column Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù
- CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
- Ìò∏Ï∂ú Í¥ÄÍ≥Ñ Í∑∏ÎûòÌîÑ ÏÉùÏÑ± (Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû®)
- Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Table/Column ÎÖ∏Îìú ÏãùÎ≥Ñ Î∞è ÏãúÍ∞ÅÌôî
- ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù
"""

import json
from typing import List, Dict, Any, Optional, Set, Tuple
from neo4j import Driver
from src.utils.logger import get_logger


class DBCallAnalysisService:
    """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ìò∏Ï∂úÍ¥ÄÍ≥Ñ Î∂ÑÏÑù ÏÑúÎπÑÏä§"""
    
    def __init__(self, driver: Driver):
        """Neo4j ÎìúÎùºÏù¥Î≤ÑÎ°ú Ï¥àÍ∏∞Ìôî"""
        self.driver = driver
        self.logger = get_logger(__name__)
    
    def analyze_call_chain(self, project_name: str, start_class: str = None, start_method: str = None) -> Dict[str, Any]:
        """
        Controller ‚Üí Service ‚Üí Repository ‚Üí SQL ‚Üí Table/Column Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Î∂ÑÏÑùÌï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            start_class: ÏãúÏûë ÌÅ¥ÎûòÏä§ (ÏÑ†ÌÉùÏÇ¨Ìï≠)
            start_method: ÏãúÏûë Î©îÏÑúÎìú (ÏÑ†ÌÉùÏÇ¨Ìï≠)
            
        Returns:
            Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù Í≤∞Í≥º
        """
        try:
            with self.driver.session() as session:
                if start_class and start_method:
                    # ÌäπÏ†ï Î©îÏÑúÎìúÎ∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî Ìò∏Ï∂ú Ï≤¥Ïù∏
                    call_chain = self._get_method_call_chain(session, project_name, start_class, start_method)
                elif start_class:
                    # ÌäπÏ†ï ÌÅ¥ÎûòÏä§Î∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî Ìò∏Ï∂ú Ï≤¥Ïù∏
                    call_chain = self._get_class_call_chain(session, project_name, start_class)
                else:
                    # Ï†ÑÏ≤¥ ÌîÑÎ°úÏ†ùÌä∏Ïùò Ìò∏Ï∂ú Ï≤¥Ïù∏
                    call_chain = self._get_project_call_chain(session, project_name)
                
                # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Table/Column ÎÖ∏Îìú ÏãùÎ≥Ñ
                missing_nodes = self._identify_missing_nodes(session, project_name, call_chain)
                
                return {
                    'project_name': project_name,
                    'call_chain': call_chain,
                    'missing_nodes': missing_nodes,
                    'analysis_summary': self._generate_analysis_summary(call_chain, missing_nodes)
                }
                
        except Exception as e:
            self.logger.error(f"Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù Ïò§Î•ò: {str(e)}")
            return {'error': str(e)}
    
    def _get_method_call_chain(self, session, project_name: str, class_name: str, method_name: str) -> List[Dict[str, Any]]:
        """ÌäπÏ†ï Î©îÏÑúÎìúÎ∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Î∂ÑÏÑùÌï©ÎãàÎã§."""
        query = """
        MATCH (c:Class {name: $class_name, project_name: $project_name})-[:HAS_METHOD]->(m:Method {name: $method_name})
        OPTIONAL MATCH (m)-[:CALLS*0..5]->(target_method:Method)
        OPTIONAL MATCH (target_method)<-[:HAS_METHOD]-(target_class:Class)
        OPTIONAL MATCH (target_method)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_TABLE]->(table:Table {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_COLUMN]->(column:Column {project_name: $project_name})
        RETURN m.name as source_method,
               c.name as source_class,
               c.package_name as source_package,
               target_method.name as target_method,
               target_class.name as target_class,
               target_class.package_name as target_package,
               sql.id as sql_id,
               sql.sql_type as sql_type,
               sql.tables as sql_tables,
               sql.columns as sql_columns,
               table.name as table_name,
               column.name as column_name,
               column.table_name as column_table_name
        ORDER BY source_method, target_class.name, target_method.name
        """
        
        result = session.run(query, 
                           class_name=class_name, 
                           method_name=method_name, 
                           project_name=project_name)
        
        call_chain = []
        for record in result:
            call_chain.append({
                'source_method': record['source_method'],
                'source_class': record['source_class'],
                'source_package': record['source_package'] or 'default',
                'target_method': record['target_method'],
                'target_class': record['target_class'],
                'target_package': record['target_package'] or 'default',
                'sql_id': record['sql_id'],
                'sql_type': record['sql_type'],
                'sql_tables': json.loads(record['sql_tables']) if record['sql_tables'] else [],
                'sql_columns': json.loads(record['sql_columns']) if record['sql_columns'] else [],
                'table_name': record['table_name'],
                'column_name': record['column_name'],
                'column_table_name': record['column_table_name']
            })
        
        return call_chain
    
    def _get_class_call_chain(self, session, project_name: str, class_name: str) -> List[Dict[str, Any]]:
        """ÌäπÏ†ï ÌÅ¥ÎûòÏä§Î∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Î∂ÑÏÑùÌï©ÎãàÎã§."""
        query = """
        MATCH (c:Class {name: $class_name, project_name: $project_name})-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS*0..5]->(target_method:Method)
        OPTIONAL MATCH (target_method)<-[:HAS_METHOD]-(target_class:Class)
        OPTIONAL MATCH (target_method)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_TABLE]->(table:Table {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_COLUMN]->(column:Column {project_name: $project_name})
        RETURN m.name as source_method,
               c.name as source_class,
               c.package_name as source_package,
               target_method.name as target_method,
               target_class.name as target_class,
               target_class.package_name as target_package,
               sql.id as sql_id,
               sql.sql_type as sql_type,
               sql.tables as sql_tables,
               sql.columns as sql_columns,
               table.name as table_name,
               column.name as column_name,
               column.table_name as column_table_name
        ORDER BY source_method, target_class.name, target_method.name
        """
        
        result = session.run(query, 
                           class_name=class_name, 
                           project_name=project_name)
        
        call_chain = []
        for record in result:
            call_chain.append({
                'source_method': record['source_method'],
                'source_class': record['source_class'],
                'source_package': record['source_package'] or 'default',
                'target_method': record['target_method'],
                'target_class': record['target_class'],
                'target_package': record['target_package'] or 'default',
                'sql_id': record['sql_id'],
                'sql_type': record['sql_type'],
                'sql_tables': json.loads(record['sql_tables']) if record['sql_tables'] else [],
                'sql_columns': json.loads(record['sql_columns']) if record['sql_columns'] else [],
                'table_name': record['table_name'],
                'column_name': record['column_name'],
                'column_table_name': record['column_table_name']
            })
        
        return call_chain
    
    def _get_project_call_chain(self, session, project_name: str) -> List[Dict[str, Any]]:
        """Ï†ÑÏ≤¥ ÌîÑÎ°úÏ†ùÌä∏Ïùò Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Î∂ÑÏÑùÌï©ÎãàÎã§."""
        query = """
        MATCH (c:Class {project_name: $project_name})-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS*0..5]->(target_method:Method)
        OPTIONAL MATCH (target_method)<-[:HAS_METHOD]-(target_class:Class)
        OPTIONAL MATCH (target_method)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_TABLE]->(table:Table {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_COLUMN]->(column:Column {project_name: $project_name})
        RETURN m.name as source_method,
               c.name as source_class,
               c.package_name as source_package,
               target_method.name as target_method,
               target_class.name as target_class,
               target_class.package_name as target_package,
               sql.id as sql_id,
               sql.sql_type as sql_type,
               sql.tables as sql_tables,
               sql.columns as sql_columns,
               table.name as table_name,
               column.name as column_name,
               column.table_name as column_table_name
        ORDER BY source_class, source_method, target_class.name, target_method.name
        """
        
        result = session.run(query, project_name=project_name)
        
        call_chain = []
        for record in result:
            call_chain.append({
                'source_method': record['source_method'],
                'source_class': record['source_class'],
                'source_package': record['source_package'] or 'default',
                'target_method': record['target_method'],
                'target_class': record['target_class'],
                'target_package': record['target_package'] or 'default',
                'sql_id': record['sql_id'],
                'sql_type': record['sql_type'],
                'sql_tables': json.loads(record['sql_tables']) if record['sql_tables'] else [],
                'sql_columns': json.loads(record['sql_columns']) if record['sql_columns'] else [],
                'table_name': record['table_name'],
                'column_name': record['column_name'],
                'column_table_name': record['column_table_name']
            })
        
        return call_chain
    
    def _identify_missing_nodes(self, session, project_name: str, call_chain: List[Dict[str, Any]]) -> Dict[str, List[str]]:
        """Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Table/Column ÎÖ∏ÎìúÎ•º ÏãùÎ≥ÑÌï©ÎãàÎã§."""
        missing_tables = set()
        missing_columns = set()
        
        # SQLÏóêÏÑú Ï∞∏Ï°∞ÌïòÎäî ÌÖåÏù¥Î∏îÍ≥º Ïª¨Îüº ÏàòÏßë
        referenced_tables = set()
        referenced_columns = set()
        
        for call in call_chain:
            # SQL ÌÖåÏù¥Î∏î Ï†ïÎ≥¥ ÏàòÏßë
            if call.get('sql_tables'):
                for table_info in call['sql_tables']:
                    if isinstance(table_info, dict) and 'name' in table_info:
                        referenced_tables.add(table_info['name'])
            
            # SQL Ïª¨Îüº Ï†ïÎ≥¥ ÏàòÏßë
            if call.get('sql_columns'):
                for column_info in call['sql_columns']:
                    if isinstance(column_info, dict) and 'name' in column_info:
                        referenced_columns.add(column_info['name'])
                        if 'table' in column_info and column_info['table']:
                            referenced_tables.add(column_info['table'])
        
        # Ïã§Ï†ú Ï°¥Ïû¨ÌïòÎäî ÌÖåÏù¥Î∏îÍ≥º Ïª¨Îüº Ï°∞Ìöå
        existing_tables = self._get_existing_tables(session, project_name)
        existing_columns = self._get_existing_columns(session, project_name)
        
        # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî ÌÖåÏù¥Î∏î ÏãùÎ≥Ñ
        for table_name in referenced_tables:
            if table_name not in existing_tables:
                missing_tables.add(table_name)
        
        # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Ïª¨Îüº ÏãùÎ≥Ñ
        for column_name in referenced_columns:
            if column_name not in existing_columns:
                missing_columns.add(column_name)
        
        return {
            'missing_tables': list(missing_tables),
            'missing_columns': list(missing_columns)
        }
    
    def _get_existing_tables(self, session, project_name: str) -> Set[str]:
        """Ïã§Ï†ú Ï°¥Ïû¨ÌïòÎäî ÌÖåÏù¥Î∏î Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§."""
        query = """
        MATCH (t:Table {project_name: $project_name})
        RETURN t.name as table_name
        """
        
        result = session.run(query, project_name=project_name)
        return {record['table_name'] for record in result}
    
    def _get_existing_columns(self, session, project_name: str) -> Set[str]:
        """Ïã§Ï†ú Ï°¥Ïû¨ÌïòÎäî Ïª¨Îüº Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§."""
        query = """
        MATCH (c:Column {project_name: $project_name})
        RETURN c.name as column_name
        """
        
        result = session.run(query, project_name=project_name)
        return {record['column_name'] for record in result}
    
    def _generate_analysis_summary(self, call_chain: List[Dict[str, Any]], missing_nodes: Dict[str, List[str]]) -> Dict[str, Any]:
        """Î∂ÑÏÑù Í≤∞Í≥º ÏöîÏïΩÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§."""
        # ÌÅ¥ÎûòÏä§Î≥Ñ ÌÜµÍ≥Ñ
        class_stats = {}
        for call in call_chain:
            source_class = call['source_class']
            if source_class not in class_stats:
                class_stats[source_class] = {
                    'method_count': 0,
                    'sql_count': 0,
                    'table_count': 0,
                    'column_count': 0
                }
            
            if call['source_method']:
                class_stats[source_class]['method_count'] += 1
            if call['sql_id']:
                class_stats[source_class]['sql_count'] += 1
            if call['table_name']:
                class_stats[source_class]['table_count'] += 1
            if call['column_name']:
                class_stats[source_class]['column_count'] += 1
        
        return {
            'total_calls': len(call_chain),
            'unique_classes': len(class_stats),
            'unique_methods': len(set(call['source_method'] for call in call_chain if call['source_method'])),
            'unique_sql_statements': len(set(call['sql_id'] for call in call_chain if call['sql_id'])),
            'unique_tables': len(set(call['table_name'] for call in call_chain if call['table_name'])),
            'unique_columns': len(set(call['column_name'] for call in call_chain if call['column_name'])),
            'missing_tables_count': len(missing_nodes['missing_tables']),
            'missing_columns_count': len(missing_nodes['missing_columns']),
            'class_stats': class_stats
        }
    
    def generate_crud_matrix(self, project_name: str) -> Dict[str, Any]:
        """
        CRUD Îß§Ìä∏Î¶≠Ïä§Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
        SQLÏùÑ ÏßÅÏ†ë Ìò∏Ï∂úÌïòÎäî ÌÅ¥ÎûòÏä§Îßå Ìè¨Ìï®Ìï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            
        Returns:
            CRUD Îß§Ìä∏Î¶≠Ïä§ Îç∞Ïù¥ÌÑ∞
        """
        try:
            with self.driver.session() as session:
                # SQLÏùÑ ÏßÅÏ†ë Ìò∏Ï∂úÌïòÎäî ÌÅ¥ÎûòÏä§Îßå ÎåÄÏÉÅÏúºÎ°ú CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
                class_crud_query = """
                MATCH (c:Class {project_name: $project_name})-[:HAS_METHOD]->(m:Method)
                MATCH (m)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
                WITH c, m, sql,
                     CASE 
                       WHEN sql.sql_type = 'SELECT' THEN 'R'
                       WHEN sql.sql_type = 'INSERT' THEN 'C'
                       WHEN sql.sql_type = 'UPDATE' THEN 'U'
                       WHEN sql.sql_type = 'DELETE' THEN 'D'
                       ELSE 'O'
                     END as crud_operation
                RETURN c.name as class_name,
                       c.package_name as package_name,
                       sql.mapper_name as table_name,
                       crud_operation as operation,
                       sql.id as sql_id
                ORDER BY c.name
                """
                
                result = session.run(class_crud_query, project_name=project_name)
                raw_data = [record.data() for record in result]
                
                # ÌÅ¥ÎûòÏä§Î≥ÑÎ°ú Í∑∏Î£πÌôîÌïòÏó¨ Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
                class_matrix = {}
                for row in raw_data:
                    class_name = row['class_name']
                    if class_name not in class_matrix:
                        class_matrix[class_name] = {
                            'class_name': class_name,
                            'package_name': row['package_name'],
                            'tables': set(),
                            'operations': set(),
                            'sql_statements': set()
                        }
                    
                    if row['table_name']:
                        class_matrix[class_name]['tables'].add(row['table_name'])
                    class_matrix[class_name]['operations'].add(row['operation'])
                    class_matrix[class_name]['sql_statements'].add(row['sql_id'])
                
                # setÏùÑ listÎ°ú Î≥ÄÌôò
                class_matrix = [
                    {
                        'class_name': data['class_name'],
                        'package_name': data['package_name'],
                        'tables': list(data['tables']),
                        'operations': list(data['operations']),
                        'sql_statements': list(data['sql_statements'])
                    }
                    for data in class_matrix.values()
                ]
                
                # ÌÖåÏù¥Î∏îÎ≥Ñ CRUD Îß§Ìä∏Î¶≠Ïä§ (PythonÏóêÏÑú Ï≤òÎ¶¨)
                table_crud_query = """
                MATCH (sql:SqlStatement {project_name: $project_name})
                WHERE sql.tables IS NOT NULL AND sql.tables <> '[]'
                RETURN sql.tables as tables_json, sql.sql_type as operation
                """
                
                result = session.run(table_crud_query, project_name=project_name)
                table_matrix = [record.data() for record in result]
                
                return {
                    'project_name': project_name,
                    'class_matrix': class_matrix,
                    'table_matrix': table_matrix,
                    'summary': self._generate_crud_summary(class_matrix, table_matrix)
                }
                
        except Exception as e:
            self.logger.error(f"CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ± Ïò§Î•ò: {str(e)}")
            return {'error': str(e)}
    
    def _generate_crud_summary(self, class_matrix: List[Dict], table_matrix: List[Dict]) -> Dict[str, Any]:
        """CRUD Îß§Ìä∏Î¶≠Ïä§ ÏöîÏïΩÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§."""
        total_classes = len(class_matrix)
        total_tables = len(table_matrix)
        
        # CRUD ÏûëÏóÖÎ≥Ñ ÌÜµÍ≥Ñ
        crud_stats = {'C': 0, 'R': 0, 'U': 0, 'D': 0, 'O': 0}
        for class_data in class_matrix:
            for operation in class_data['operations']:
                if operation in crud_stats:
                    crud_stats[operation] += 1
        
        return {
            'total_classes': total_classes,
            'total_tables': total_tables,
            'crud_stats': crud_stats,
            'most_active_class': max(class_matrix, key=lambda x: len(x['operations']))['class_name'] if class_matrix else None,
            'most_used_table': max(table_matrix, key=lambda x: sum(op['count'] for op in x['operations']))['table_name'] if table_matrix else None
        }
    
    def generate_call_chain_diagram(self, project_name: str, start_class: str = None, start_method: str = None) -> str:
        """
        Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû®ÏúºÎ°ú ÏÉùÏÑ±Ìï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            start_class: ÏãúÏûë ÌÅ¥ÎûòÏä§ (ÏÑ†ÌÉùÏÇ¨Ìï≠)
            start_method: ÏãúÏûë Î©îÏÑúÎìú (ÏÑ†ÌÉùÏÇ¨Ìï≠)
            
        Returns:
            Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû® Î¨∏ÏûêÏó¥
        """
        try:
            analysis_result = self.analyze_call_chain(project_name, start_class, start_method)
            
            if 'error' in analysis_result:
                return f"Ïò§Î•ò: {analysis_result['error']}"
            
            call_chain = analysis_result['call_chain']
            missing_nodes = analysis_result['missing_nodes']
            
            if not call_chain:
                return "```mermaid\ngraph TD\n    A[No call chain found]\n```"
            
            # Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏÉùÏÑ±
            diagram_lines = ["```mermaid", "graph TD"]
            
            # ÎÖ∏Îìú Ï†ïÏùò
            nodes = set()
            for call in call_chain:
                if call['source_class']:
                    nodes.add(call['source_class'])
                if call['target_class']:
                    nodes.add(call['target_class'])
                if call['table_name']:
                    nodes.add(f"Table_{call['table_name']}")
                if call['column_name']:
                    nodes.add(f"Column_{call['column_name']}")
            
            # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî ÎÖ∏Îìú Ï∂îÍ∞Ä (Ï†ÅÏÉâ Ï†êÏÑ†ÏúºÎ°ú ÌëúÏãú)
            for missing_table in missing_nodes['missing_tables']:
                nodes.add(f"MissingTable_{missing_table}")
            
            for missing_column in missing_nodes['missing_columns']:
                nodes.add(f"MissingColumn_{missing_column}")
            
            # ÎÖ∏Îìú Ïä§ÌÉÄÏùº Ï†ïÏùò
            for node in sorted(nodes):
                if node.startswith('MissingTable_'):
                    table_name = node.replace('MissingTable_', '')
                    diagram_lines.append(f"    {node}[\"‚ùå {table_name}\"]:::missingTable")
                elif node.startswith('MissingColumn_'):
                    column_name = node.replace('MissingColumn_', '')
                    diagram_lines.append(f"    {node}[\"‚ùå {column_name}\"]:::missingColumn")
                elif node.startswith('Table_'):
                    table_name = node.replace('Table_', '')
                    diagram_lines.append(f"    {node}[\"üìä {table_name}\"]:::table")
                elif node.startswith('Column_'):
                    column_name = node.replace('Column_', '')
                    diagram_lines.append(f"    {node}[\"üìã {column_name}\"]:::column")
                else:
                    diagram_lines.append(f"    {node}[\"üè¢ {node}\"]:::class")
            
            # Ïó∞Í≤∞ÏÑ† Ï†ïÏùò
            for call in call_chain:
                if call['source_class'] and call['target_class']:
                    diagram_lines.append(f"    {call['source_class']} --> {call['target_class']}")
                
                if call['target_class'] and call['table_name']:
                    table_node = f"Table_{call['table_name']}"
                    diagram_lines.append(f"    {call['target_class']} --> {table_node}")
                
                if call['table_name'] and call['column_name']:
                    table_node = f"Table_{call['table_name']}"
                    column_node = f"Column_{call['column_name']}"
                    diagram_lines.append(f"    {table_node} --> {column_node}")
            
            # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî ÎÖ∏Îìú Ïó∞Í≤∞ (Ï†ÅÏÉâ Ï†êÏÑ†)
            for call in call_chain:
                if call['table_name'] and call['table_name'] in missing_nodes['missing_tables']:
                    missing_table_node = f"MissingTable_{call['table_name']}"
                    if call['target_class']:
                        diagram_lines.append(f"    {call['target_class']} -.-> {missing_table_node}")
                
                if call['column_name'] and call['column_name'] in missing_nodes['missing_columns']:
                    missing_column_node = f"MissingColumn_{call['column_name']}"
                    if call['table_name']:
                        table_node = f"Table_{call['table_name']}"
                        diagram_lines.append(f"    {table_node} -.-> {missing_column_node}")
            
            # Ïä§ÌÉÄÏùº Ï†ïÏùò
            diagram_lines.extend([
                "",
                "    classDef class fill:#e1f5fe,stroke:#01579b,stroke-width:2px",
                "    classDef table fill:#f3e5f5,stroke:#4a148c,stroke-width:2px",
                "    classDef column fill:#e8f5e8,stroke:#1b5e20,stroke-width:2px",
                "    classDef missingTable fill:#ffebee,stroke:#c62828,stroke-width:2px,stroke-dasharray: 5 5",
                "    classDef missingColumn fill:#fff3e0,stroke:#ef6c00,stroke-width:2px,stroke-dasharray: 5 5"
            ])
            
            diagram_lines.append("```")
            
            return "\n".join(diagram_lines)
            
        except Exception as e:
            self.logger.error(f"Ìò∏Ï∂ú Ï≤¥Ïù∏ Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏÉùÏÑ± Ïò§Î•ò: {str(e)}")
            return f"Ïò§Î•ò: {str(e)}"
    
    def analyze_table_impact(self, project_name: str, table_name: str) -> Dict[str, Any]:
        """
        ÌäπÏ†ï ÌÖåÏù¥Î∏î Î≥ÄÍ≤Ω Ïãú ÏòÅÌñ•Î∞õÎäî ÌÅ¥ÎûòÏä§/Î©îÏÑúÎìúÎ•º Î∂ÑÏÑùÌï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            table_name: Î∂ÑÏÑùÌï† ÌÖåÏù¥Î∏î Ïù¥Î¶Ñ
            
        Returns:
            ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù Í≤∞Í≥º
        """
        try:
            with self.driver.session() as session:
                # ÌÖåÏù¥Î∏îÏùÑ ÏÇ¨Ïö©ÌïòÎäî ÌÅ¥ÎûòÏä§/Î©îÏÑúÎìú Ï°∞Ìöå
                impact_query = """
                MATCH (c:Class {project_name: $project_name})-[:HAS_METHOD]->(m:Method)
                MATCH (m)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
                WHERE sql.tables CONTAINS $table_name OR 
                      ANY(table_info IN sql.tables WHERE table_info.name = $table_name)
                RETURN c.name as class_name,
                       c.package_name as package_name,
                       m.name as method_name,
                       sql.id as sql_id,
                       sql.sql_type as sql_type,
                       sql.complexity_score as complexity_score
                ORDER BY c.name, m.name
                """
                
                result = session.run(impact_query, 
                                   project_name=project_name, 
                                   table_name=table_name)
                
                impacted_classes = []
                for record in result:
                    impacted_classes.append({
                        'class_name': record['class_name'],
                        'package_name': record['package_name'],
                        'method_name': record['method_name'],
                        'sql_id': record['sql_id'],
                        'sql_type': record['sql_type'],
                        'complexity_score': record['complexity_score']
                    })
                
                # ÏòÅÌñ•ÎèÑ ÏöîÏïΩ
                summary = {
                    'table_name': table_name,
                    'total_impacted_classes': len(set(c['class_name'] for c in impacted_classes)),
                    'total_impacted_methods': len(set(f"{c['class_name']}.{c['method_name']}" for c in impacted_classes)),
                    'total_sql_statements': len(set(c['sql_id'] for c in impacted_classes if c['sql_id'])),
                    'crud_operations': list(set(c['sql_type'] for c in impacted_classes if c['sql_type'])),
                    'high_complexity_sql': [c for c in impacted_classes if c['complexity_score'] and c['complexity_score'] > 7]
                }
                
                return {
                    'table_name': table_name,
                    'impacted_classes': impacted_classes,
                    'summary': summary
                }
                
        except Exception as e:
            self.logger.error(f"ÌÖåÏù¥Î∏î ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù Ïò§Î•ò: {str(e)}")
            return {'error': str(e)}
    
    def get_database_usage_statistics(self, project_name: str) -> Dict[str, Any]:
        """
        Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÇ¨Ïö© ÌÜµÍ≥ÑÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            
        Returns:
            Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÇ¨Ïö© ÌÜµÍ≥Ñ
        """
        try:
            with self.driver.session() as session:
                # SQL ÌÜµÍ≥Ñ
                sql_stats_query = """
                MATCH (sql:SqlStatement {project_name: $project_name})
                RETURN 
                    count(sql) as total_sql,
                    sum(CASE WHEN sql.sql_type = 'SELECT' THEN 1 ELSE 0 END) as SELECT,
                    sum(CASE WHEN sql.sql_type = 'INSERT' THEN 1 ELSE 0 END) as INSERT,
                    sum(CASE WHEN sql.sql_type = 'UPDATE' THEN 1 ELSE 0 END) as UPDATE,
                    sum(CASE WHEN sql.sql_type = 'DELETE' THEN 1 ELSE 0 END) as DELETE
                """
                
                result = session.run(sql_stats_query, project_name=project_name)
                sql_stats = result.single().data() if result.single() else {}
                
                # ÌÖåÏù¥Î∏î ÏÇ¨Ïö© ÌÜµÍ≥Ñ
                table_usage_query = """
                MATCH (sql:SqlStatement {project_name: $project_name})
                WHERE sql.tables IS NOT NULL
                UNWIND sql.tables as table_info
                WITH table_info.name as table_name, sql.sql_type as operation
                RETURN 
                    table_name,
                    count(*) as access_count,
                    collect(DISTINCT operation) as operations
                ORDER BY access_count DESC
                """
                
                result = session.run(table_usage_query, project_name=project_name)
                table_usage = [record.data() for record in result]
                
                # Î≥µÏû°ÎèÑ ÌÜµÍ≥Ñ
                complexity_query = """
                MATCH (sql:SqlStatement {project_name: $project_name})
                WHERE sql.complexity_score IS NOT NULL
                WITH sql.complexity_score as score,
                     CASE 
                         WHEN sql.complexity_score <= 3 THEN 'simple'
                         WHEN sql.complexity_score <= 7 THEN 'medium'
                         WHEN sql.complexity_score <= 12 THEN 'complex'
                         ELSE 'very_complex'
                     END as complexity_level
                RETURN 
                    complexity_level,
                    count(*) as count
                """
                
                result = session.run(complexity_query, project_name=project_name)
                complexity_stats = {record['complexity_level']: record['count'] for record in result}
                
                return {
                    'project_name': project_name,
                    'sql_statistics': sql_stats,
                    'table_usage': table_usage,
                    'complexity_statistics': complexity_stats
                }
                
        except Exception as e:
            self.logger.error(f"Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÇ¨Ïö© ÌÜµÍ≥Ñ Ï°∞Ìöå Ïò§Î•ò: {str(e)}")
            return {'error': str(e)}

```

Ïù¥Ï†ú PythonÏóêÏÑú JSONÏùÑ ÌååÏã±ÌïòÏó¨ ÌÖåÏù¥Î∏îÎ≥Ñ CRUD Îß§Ìä∏Î¶≠Ïä§Î•º ÏÉùÏÑ±ÌïòÎèÑÎ°ù ÏàòÏ†ïÌïòÍ≤†ÏäµÎãàÎã§:


```python
"""
Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ìò∏Ï∂úÍ¥ÄÍ≥Ñ Î∂ÑÏÑù ÏÑúÎπÑÏä§

Ïù¥ Î™®ÎìàÏùÄ Ïñ¥ÌîåÎ¶¨ÏºÄÏù¥ÏÖòÍ≥º Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í∞ÑÏùò Ìò∏Ï∂úÍ¥ÄÍ≥ÑÎ•º Î∂ÑÏÑùÌïòÍ≥† ÏãúÍ∞ÅÌôîÌïòÎäî Í∏∞Îä•ÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§.
- Controller ‚Üí Service ‚Üí Repository ‚Üí SQL ‚Üí Table/Column Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù
- CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
- Ìò∏Ï∂ú Í¥ÄÍ≥Ñ Í∑∏ÎûòÌîÑ ÏÉùÏÑ± (Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû®)
- Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Table/Column ÎÖ∏Îìú ÏãùÎ≥Ñ Î∞è ÏãúÍ∞ÅÌôî
- ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù
"""

import json
from typing import List, Dict, Any, Optional, Set, Tuple
from neo4j import Driver
from src.utils.logger import get_logger


class DBCallAnalysisService:
    """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ìò∏Ï∂úÍ¥ÄÍ≥Ñ Î∂ÑÏÑù ÏÑúÎπÑÏä§"""
    
    def __init__(self, driver: Driver):
        """Neo4j ÎìúÎùºÏù¥Î≤ÑÎ°ú Ï¥àÍ∏∞Ìôî"""
        self.driver = driver
        self.logger = get_logger(__name__)
    
    def analyze_call_chain(self, project_name: str, start_class: str = None, start_method: str = None) -> Dict[str, Any]:
        """
        Controller ‚Üí Service ‚Üí Repository ‚Üí SQL ‚Üí Table/Column Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Î∂ÑÏÑùÌï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            start_class: ÏãúÏûë ÌÅ¥ÎûòÏä§ (ÏÑ†ÌÉùÏÇ¨Ìï≠)
            start_method: ÏãúÏûë Î©îÏÑúÎìú (ÏÑ†ÌÉùÏÇ¨Ìï≠)
            
        Returns:
            Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù Í≤∞Í≥º
        """
        try:
            with self.driver.session() as session:
                if start_class and start_method:
                    # ÌäπÏ†ï Î©îÏÑúÎìúÎ∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî Ìò∏Ï∂ú Ï≤¥Ïù∏
                    call_chain = self._get_method_call_chain(session, project_name, start_class, start_method)
                elif start_class:
                    # ÌäπÏ†ï ÌÅ¥ÎûòÏä§Î∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî Ìò∏Ï∂ú Ï≤¥Ïù∏
                    call_chain = self._get_class_call_chain(session, project_name, start_class)
                else:
                    # Ï†ÑÏ≤¥ ÌîÑÎ°úÏ†ùÌä∏Ïùò Ìò∏Ï∂ú Ï≤¥Ïù∏
                    call_chain = self._get_project_call_chain(session, project_name)
                
                # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Table/Column ÎÖ∏Îìú ÏãùÎ≥Ñ
                missing_nodes = self._identify_missing_nodes(session, project_name, call_chain)
                
                return {
                    'project_name': project_name,
                    'call_chain': call_chain,
                    'missing_nodes': missing_nodes,
                    'analysis_summary': self._generate_analysis_summary(call_chain, missing_nodes)
                }
                
        except Exception as e:
            self.logger.error(f"Ìò∏Ï∂ú Ï≤¥Ïù∏ Î∂ÑÏÑù Ïò§Î•ò: {str(e)}")
            return {'error': str(e)}
    
    def _get_method_call_chain(self, session, project_name: str, class_name: str, method_name: str) -> List[Dict[str, Any]]:
        """ÌäπÏ†ï Î©îÏÑúÎìúÎ∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Î∂ÑÏÑùÌï©ÎãàÎã§."""
        query = """
        MATCH (c:Class {name: $class_name, project_name: $project_name})-[:HAS_METHOD]->(m:Method {name: $method_name})
        OPTIONAL MATCH (m)-[:CALLS*0..5]->(target_method:Method)
        OPTIONAL MATCH (target_method)<-[:HAS_METHOD]-(target_class:Class)
        OPTIONAL MATCH (target_method)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_TABLE]->(table:Table {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_COLUMN]->(column:Column {project_name: $project_name})
        RETURN m.name as source_method,
               c.name as source_class,
               c.package_name as source_package,
               target_method.name as target_method,
               target_class.name as target_class,
               target_class.package_name as target_package,
               sql.id as sql_id,
               sql.sql_type as sql_type,
               sql.tables as sql_tables,
               sql.columns as sql_columns,
               table.name as table_name,
               column.name as column_name,
               column.table_name as column_table_name
        ORDER BY source_method, target_class.name, target_method.name
        """
        
        result = session.run(query, 
                           class_name=class_name, 
                           method_name=method_name, 
                           project_name=project_name)
        
        call_chain = []
        for record in result:
            call_chain.append({
                'source_method': record['source_method'],
                'source_class': record['source_class'],
                'source_package': record['source_package'] or 'default',
                'target_method': record['target_method'],
                'target_class': record['target_class'],
                'target_package': record['target_package'] or 'default',
                'sql_id': record['sql_id'],
                'sql_type': record['sql_type'],
                'sql_tables': json.loads(record['sql_tables']) if record['sql_tables'] else [],
                'sql_columns': json.loads(record['sql_columns']) if record['sql_columns'] else [],
                'table_name': record['table_name'],
                'column_name': record['column_name'],
                'column_table_name': record['column_table_name']
            })
        
        return call_chain
    
    def _get_class_call_chain(self, session, project_name: str, class_name: str) -> List[Dict[str, Any]]:
        """ÌäπÏ†ï ÌÅ¥ÎûòÏä§Î∂ÄÌÑ∞ ÏãúÏûëÌïòÎäî Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Î∂ÑÏÑùÌï©ÎãàÎã§."""
        query = """
        MATCH (c:Class {name: $class_name, project_name: $project_name})-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS*0..5]->(target_method:Method)
        OPTIONAL MATCH (target_method)<-[:HAS_METHOD]-(target_class:Class)
        OPTIONAL MATCH (target_method)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_TABLE]->(table:Table {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_COLUMN]->(column:Column {project_name: $project_name})
        RETURN m.name as source_method,
               c.name as source_class,
               c.package_name as source_package,
               target_method.name as target_method,
               target_class.name as target_class,
               target_class.package_name as target_package,
               sql.id as sql_id,
               sql.sql_type as sql_type,
               sql.tables as sql_tables,
               sql.columns as sql_columns,
               table.name as table_name,
               column.name as column_name,
               column.table_name as column_table_name
        ORDER BY source_method, target_class.name, target_method.name
        """
        
        result = session.run(query, 
                           class_name=class_name, 
                           project_name=project_name)
        
        call_chain = []
        for record in result:
            call_chain.append({
                'source_method': record['source_method'],
                'source_class': record['source_class'],
                'source_package': record['source_package'] or 'default',
                'target_method': record['target_method'],
                'target_class': record['target_class'],
                'target_package': record['target_package'] or 'default',
                'sql_id': record['sql_id'],
                'sql_type': record['sql_type'],
                'sql_tables': json.loads(record['sql_tables']) if record['sql_tables'] else [],
                'sql_columns': json.loads(record['sql_columns']) if record['sql_columns'] else [],
                'table_name': record['table_name'],
                'column_name': record['column_name'],
                'column_table_name': record['column_table_name']
            })
        
        return call_chain
    
    def _get_project_call_chain(self, session, project_name: str) -> List[Dict[str, Any]]:
        """Ï†ÑÏ≤¥ ÌîÑÎ°úÏ†ùÌä∏Ïùò Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Î∂ÑÏÑùÌï©ÎãàÎã§."""
        query = """
        MATCH (c:Class {project_name: $project_name})-[:HAS_METHOD]->(m:Method)
        OPTIONAL MATCH (m)-[:CALLS*0..5]->(target_method:Method)
        OPTIONAL MATCH (target_method)<-[:HAS_METHOD]-(target_class:Class)
        OPTIONAL MATCH (target_method)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_TABLE]->(table:Table {project_name: $project_name})
        OPTIONAL MATCH (sql)-[:USES_COLUMN]->(column:Column {project_name: $project_name})
        RETURN m.name as source_method,
               c.name as source_class,
               c.package_name as source_package,
               target_method.name as target_method,
               target_class.name as target_class,
               target_class.package_name as target_package,
               sql.id as sql_id,
               sql.sql_type as sql_type,
               sql.tables as sql_tables,
               sql.columns as sql_columns,
               table.name as table_name,
               column.name as column_name,
               column.table_name as column_table_name
        ORDER BY source_class, source_method, target_class.name, target_method.name
        """
        
        result = session.run(query, project_name=project_name)
        
        call_chain = []
        for record in result:
            call_chain.append({
                'source_method': record['source_method'],
                'source_class': record['source_class'],
                'source_package': record['source_package'] or 'default',
                'target_method': record['target_method'],
                'target_class': record['target_class'],
                'target_package': record['target_package'] or 'default',
                'sql_id': record['sql_id'],
                'sql_type': record['sql_type'],
                'sql_tables': json.loads(record['sql_tables']) if record['sql_tables'] else [],
                'sql_columns': json.loads(record['sql_columns']) if record['sql_columns'] else [],
                'table_name': record['table_name'],
                'column_name': record['column_name'],
                'column_table_name': record['column_table_name']
            })
        
        return call_chain
    
    def _identify_missing_nodes(self, session, project_name: str, call_chain: List[Dict[str, Any]]) -> Dict[str, List[str]]:
        """Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Table/Column ÎÖ∏ÎìúÎ•º ÏãùÎ≥ÑÌï©ÎãàÎã§."""
        missing_tables = set()
        missing_columns = set()
        
        # SQLÏóêÏÑú Ï∞∏Ï°∞ÌïòÎäî ÌÖåÏù¥Î∏îÍ≥º Ïª¨Îüº ÏàòÏßë
        referenced_tables = set()
        referenced_columns = set()
        
        for call in call_chain:
            # SQL ÌÖåÏù¥Î∏î Ï†ïÎ≥¥ ÏàòÏßë
            if call.get('sql_tables'):
                for table_info in call['sql_tables']:
                    if isinstance(table_info, dict) and 'name' in table_info:
                        referenced_tables.add(table_info['name'])
            
            # SQL Ïª¨Îüº Ï†ïÎ≥¥ ÏàòÏßë
            if call.get('sql_columns'):
                for column_info in call['sql_columns']:
                    if isinstance(column_info, dict) and 'name' in column_info:
                        referenced_columns.add(column_info['name'])
                        if 'table' in column_info and column_info['table']:
                            referenced_tables.add(column_info['table'])
        
        # Ïã§Ï†ú Ï°¥Ïû¨ÌïòÎäî ÌÖåÏù¥Î∏îÍ≥º Ïª¨Îüº Ï°∞Ìöå
        existing_tables = self._get_existing_tables(session, project_name)
        existing_columns = self._get_existing_columns(session, project_name)
        
        # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî ÌÖåÏù¥Î∏î ÏãùÎ≥Ñ
        for table_name in referenced_tables:
            if table_name not in existing_tables:
                missing_tables.add(table_name)
        
        # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Ïª¨Îüº ÏãùÎ≥Ñ
        for column_name in referenced_columns:
            if column_name not in existing_columns:
                missing_columns.add(column_name)
        
        return {
            'missing_tables': list(missing_tables),
            'missing_columns': list(missing_columns)
        }
    
    def _get_existing_tables(self, session, project_name: str) -> Set[str]:
        """Ïã§Ï†ú Ï°¥Ïû¨ÌïòÎäî ÌÖåÏù¥Î∏î Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§."""
        query = """
        MATCH (t:Table {project_name: $project_name})
        RETURN t.name as table_name
        """
        
        result = session.run(query, project_name=project_name)
        return {record['table_name'] for record in result}
    
    def _get_existing_columns(self, session, project_name: str) -> Set[str]:
        """Ïã§Ï†ú Ï°¥Ïû¨ÌïòÎäî Ïª¨Îüº Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§."""
        query = """
        MATCH (c:Column {project_name: $project_name})
        RETURN c.name as column_name
        """
        
        result = session.run(query, project_name=project_name)
        return {record['column_name'] for record in result}
    
    def _generate_analysis_summary(self, call_chain: List[Dict[str, Any]], missing_nodes: Dict[str, List[str]]) -> Dict[str, Any]:
        """Î∂ÑÏÑù Í≤∞Í≥º ÏöîÏïΩÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§."""
        # ÌÅ¥ÎûòÏä§Î≥Ñ ÌÜµÍ≥Ñ
        class_stats = {}
        for call in call_chain:
            source_class = call['source_class']
            if source_class not in class_stats:
                class_stats[source_class] = {
                    'method_count': 0,
                    'sql_count': 0,
                    'table_count': 0,
                    'column_count': 0
                }
            
            if call['source_method']:
                class_stats[source_class]['method_count'] += 1
            if call['sql_id']:
                class_stats[source_class]['sql_count'] += 1
            if call['table_name']:
                class_stats[source_class]['table_count'] += 1
            if call['column_name']:
                class_stats[source_class]['column_count'] += 1
        
        return {
            'total_calls': len(call_chain),
            'unique_classes': len(class_stats),
            'unique_methods': len(set(call['source_method'] for call in call_chain if call['source_method'])),
            'unique_sql_statements': len(set(call['sql_id'] for call in call_chain if call['sql_id'])),
            'unique_tables': len(set(call['table_name'] for call in call_chain if call['table_name'])),
            'unique_columns': len(set(call['column_name'] for call in call_chain if call['column_name'])),
            'missing_tables_count': len(missing_nodes['missing_tables']),
            'missing_columns_count': len(missing_nodes['missing_columns']),
            'class_stats': class_stats
        }
    
    def generate_crud_matrix(self, project_name: str) -> Dict[str, Any]:
        """
        CRUD Îß§Ìä∏Î¶≠Ïä§Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
        SQLÏùÑ ÏßÅÏ†ë Ìò∏Ï∂úÌïòÎäî ÌÅ¥ÎûòÏä§Îßå Ìè¨Ìï®Ìï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            
        Returns:
            CRUD Îß§Ìä∏Î¶≠Ïä§ Îç∞Ïù¥ÌÑ∞
        """
        try:
            with self.driver.session() as session:
                # SQLÏùÑ ÏßÅÏ†ë Ìò∏Ï∂úÌïòÎäî ÌÅ¥ÎûòÏä§Îßå ÎåÄÏÉÅÏúºÎ°ú CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
                class_crud_query = """
                MATCH (c:Class {project_name: $project_name})-[:HAS_METHOD]->(m:Method)
                MATCH (m)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
                WITH c, m, sql,
                     CASE 
                       WHEN sql.sql_type = 'SELECT' THEN 'R'
                       WHEN sql.sql_type = 'INSERT' THEN 'C'
                       WHEN sql.sql_type = 'UPDATE' THEN 'U'
                       WHEN sql.sql_type = 'DELETE' THEN 'D'
                       ELSE 'O'
                     END as crud_operation
                RETURN c.name as class_name,
                       c.package_name as package_name,
                       sql.mapper_name as table_name,
                       crud_operation as operation,
                       sql.id as sql_id
                ORDER BY c.name
                """
                
                result = session.run(class_crud_query, project_name=project_name)
                raw_data = [record.data() for record in result]
                
                # ÌÅ¥ÎûòÏä§Î≥ÑÎ°ú Í∑∏Î£πÌôîÌïòÏó¨ Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
                class_matrix = {}
                for row in raw_data:
                    class_name = row['class_name']
                    if class_name not in class_matrix:
                        class_matrix[class_name] = {
                            'class_name': class_name,
                            'package_name': row['package_name'],
                            'tables': set(),
                            'operations': set(),
                            'sql_statements': set()
                        }
                    
                    if row['table_name']:
                        class_matrix[class_name]['tables'].add(row['table_name'])
                    class_matrix[class_name]['operations'].add(row['operation'])
                    class_matrix[class_name]['sql_statements'].add(row['sql_id'])
                
                # setÏùÑ listÎ°ú Î≥ÄÌôò
                class_matrix = [
                    {
                        'class_name': data['class_name'],
                        'package_name': data['package_name'],
                        'tables': list(data['tables']),
                        'operations': list(data['operations']),
                        'sql_statements': list(data['sql_statements'])
                    }
                    for data in class_matrix.values()
                ]
                
                # ÌÖåÏù¥Î∏îÎ≥Ñ CRUD Îß§Ìä∏Î¶≠Ïä§ (PythonÏóêÏÑú Ï≤òÎ¶¨)
                table_crud_query = """
                MATCH (sql:SqlStatement {project_name: $project_name})
                WHERE sql.tables IS NOT NULL AND sql.tables <> '[]'
                RETURN sql.tables as tables_json, sql.sql_type as operation
                """
                
                result = session.run(table_crud_query, project_name=project_name)
                raw_table_data = [record.data() for record in result]
                
                # PythonÏóêÏÑú ÌÖåÏù¥Î∏îÎ≥Ñ CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±
                table_stats = {}
                for row in raw_table_data:
                    try:
                        tables_json = row['tables_json']
                        operation = row['operation']
                        
                        if tables_json and tables_json != '[]':
                            tables = json.loads(tables_json)
                            for table_info in tables:
                                if isinstance(table_info, dict) and 'name' in table_info:
                                    table_name = table_info['name']
                                    if table_name not in table_stats:
                                        table_stats[table_name] = {}
                                    if operation not in table_stats[table_name]:
                                        table_stats[table_name][operation] = 0
                                    table_stats[table_name][operation] += 1
                    except (json.JSONDecodeError, TypeError) as e:
                        self.logger.warning(f"ÌÖåÏù¥Î∏î JSON ÌååÏã± Ïò§Î•ò: {e}")
                        continue
                
                # ÌÖåÏù¥Î∏îÎ≥Ñ CRUD Îß§Ìä∏Î¶≠Ïä§ ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
                table_matrix = []
                for table_name, operations in table_stats.items():
                    operations_list = [{'operation': op, 'count': count} for op, count in operations.items()]
                    table_matrix.append({
                        'table_name': table_name,
                        'operations': operations_list
                    })
                
                return {
                    'project_name': project_name,
                    'class_matrix': class_matrix,
                    'table_matrix': table_matrix,
                    'summary': self._generate_crud_summary(class_matrix, table_matrix)
                }
                
        except Exception as e:
            self.logger.error(f"CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ± Ïò§Î•ò: {str(e)}")
            return {'error': str(e)}
    
    def _generate_crud_summary(self, class_matrix: List[Dict], table_matrix: List[Dict]) -> Dict[str, Any]:
        """CRUD Îß§Ìä∏Î¶≠Ïä§ ÏöîÏïΩÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§."""
        total_classes = len(class_matrix)
        total_tables = len(table_matrix)
        
        # CRUD ÏûëÏóÖÎ≥Ñ ÌÜµÍ≥Ñ
        crud_stats = {'C': 0, 'R': 0, 'U': 0, 'D': 0, 'O': 0}
        for class_data in class_matrix:
            for operation in class_data['operations']:
                if operation in crud_stats:
                    crud_stats[operation] += 1
        
        return {
            'total_classes': total_classes,
            'total_tables': total_tables,
            'crud_stats': crud_stats,
            'most_active_class': max(class_matrix, key=lambda x: len(x['operations']))['class_name'] if class_matrix else None,
            'most_used_table': max(table_matrix, key=lambda x: sum(op['count'] for op in x['operations']))['table_name'] if table_matrix else None
        }
    
    def generate_call_chain_diagram(self, project_name: str, start_class: str = None, start_method: str = None) -> str:
        """
        Ìò∏Ï∂ú Ï≤¥Ïù∏ÏùÑ Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû®ÏúºÎ°ú ÏÉùÏÑ±Ìï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            start_class: ÏãúÏûë ÌÅ¥ÎûòÏä§ (ÏÑ†ÌÉùÏÇ¨Ìï≠)
            start_method: ÏãúÏûë Î©îÏÑúÎìú (ÏÑ†ÌÉùÏÇ¨Ìï≠)
            
        Returns:
            Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû® Î¨∏ÏûêÏó¥
        """
        try:
            analysis_result = self.analyze_call_chain(project_name, start_class, start_method)
            
            if 'error' in analysis_result:
                return f"Ïò§Î•ò: {analysis_result['error']}"
            
            call_chain = analysis_result['call_chain']
            missing_nodes = analysis_result['missing_nodes']
            
            if not call_chain:
                return "```mermaid\ngraph TD\n    A[No call chain found]\n```"
            
            # Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏÉùÏÑ±
            diagram_lines = ["```mermaid", "graph TD"]
            
            # ÎÖ∏Îìú Ï†ïÏùò
            nodes = set()
            for call in call_chain:
                if call['source_class']:
                    nodes.add(call['source_class'])
                if call['target_class']:
                    nodes.add(call['target_class'])
                if call['table_name']:
                    nodes.add(f"Table_{call['table_name']}")
                if call['column_name']:
                    nodes.add(f"Column_{call['column_name']}")
            
            # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî ÎÖ∏Îìú Ï∂îÍ∞Ä (Ï†ÅÏÉâ Ï†êÏÑ†ÏúºÎ°ú ÌëúÏãú)
            for missing_table in missing_nodes['missing_tables']:
                nodes.add(f"MissingTable_{missing_table}")
            
            for missing_column in missing_nodes['missing_columns']:
                nodes.add(f"MissingColumn_{missing_column}")
            
            # ÎÖ∏Îìú Ïä§ÌÉÄÏùº Ï†ïÏùò
            for node in sorted(nodes):
                if node.startswith('MissingTable_'):
                    table_name = node.replace('MissingTable_', '')
                    diagram_lines.append(f"    {node}[\"‚ùå {table_name}\"]:::missingTable")
                elif node.startswith('MissingColumn_'):
                    column_name = node.replace('MissingColumn_', '')
                    diagram_lines.append(f"    {node}[\"‚ùå {column_name}\"]:::missingColumn")
                elif node.startswith('Table_'):
                    table_name = node.replace('Table_', '')
                    diagram_lines.append(f"    {node}[\"üìä {table_name}\"]:::table")
                elif node.startswith('Column_'):
                    column_name = node.replace('Column_', '')
                    diagram_lines.append(f"    {node}[\"üìã {column_name}\"]:::column")
                else:
                    diagram_lines.append(f"    {node}[\"üè¢ {node}\"]:::class")
            
            # Ïó∞Í≤∞ÏÑ† Ï†ïÏùò
            for call in call_chain:
                if call['source_class'] and call['target_class']:
                    diagram_lines.append(f"    {call['source_class']} --> {call['target_class']}")
                
                if call['target_class'] and call['table_name']:
                    table_node = f"Table_{call['table_name']}"
                    diagram_lines.append(f"    {call['target_class']} --> {table_node}")
                
                if call['table_name'] and call['column_name']:
                    table_node = f"Table_{call['table_name']}"
                    column_node = f"Column_{call['column_name']}"
                    diagram_lines.append(f"    {table_node} --> {column_node}")
            
            # Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî ÎÖ∏Îìú Ïó∞Í≤∞ (Ï†ÅÏÉâ Ï†êÏÑ†)
            for call in call_chain:
                if call['table_name'] and call['table_name'] in missing_nodes['missing_tables']:
                    missing_table_node = f"MissingTable_{call['table_name']}"
                    if call['target_class']:
                        diagram_lines.append(f"    {call['target_class']} -.-> {missing_table_node}")
                
                if call['column_name'] and call['column_name'] in missing_nodes['missing_columns']:
                    missing_column_node = f"MissingColumn_{call['column_name']}"
                    if call['table_name']:
                        table_node = f"Table_{call['table_name']}"
                        diagram_lines.append(f"    {table_node} -.-> {missing_column_node}")
            
            # Ïä§ÌÉÄÏùº Ï†ïÏùò
            diagram_lines.extend([
                "",
                "    classDef class fill:#e1f5fe,stroke:#01579b,stroke-width:2px",
                "    classDef table fill:#f3e5f5,stroke:#4a148c,stroke-width:2px",
                "    classDef column fill:#e8f5e8,stroke:#1b5e20,stroke-width:2px",
                "    classDef missingTable fill:#ffebee,stroke:#c62828,stroke-width:2px,stroke-dasharray: 5 5",
                "    classDef missingColumn fill:#fff3e0,stroke:#ef6c00,stroke-width:2px,stroke-dasharray: 5 5"
            ])
            
            diagram_lines.append("```")
            
            return "\n".join(diagram_lines)
            
        except Exception as e:
            self.logger.error(f"Ìò∏Ï∂ú Ï≤¥Ïù∏ Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏÉùÏÑ± Ïò§Î•ò: {str(e)}")
            return f"Ïò§Î•ò: {str(e)}"
    
    def analyze_table_impact(self, project_name: str, table_name: str) -> Dict[str, Any]:
        """
        ÌäπÏ†ï ÌÖåÏù¥Î∏î Î≥ÄÍ≤Ω Ïãú ÏòÅÌñ•Î∞õÎäî ÌÅ¥ÎûòÏä§/Î©îÏÑúÎìúÎ•º Î∂ÑÏÑùÌï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            table_name: Î∂ÑÏÑùÌï† ÌÖåÏù¥Î∏î Ïù¥Î¶Ñ
            
        Returns:
            ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù Í≤∞Í≥º
        """
        try:
            with self.driver.session() as session:
                # ÌÖåÏù¥Î∏îÏùÑ ÏÇ¨Ïö©ÌïòÎäî ÌÅ¥ÎûòÏä§/Î©îÏÑúÎìú Ï°∞Ìöå
                impact_query = """
                MATCH (c:Class {project_name: $project_name})-[:HAS_METHOD]->(m:Method)
                MATCH (m)-[:CALLS]->(sql:SqlStatement {project_name: $project_name})
                WHERE sql.tables CONTAINS $table_name OR 
                      ANY(table_info IN sql.tables WHERE table_info.name = $table_name)
                RETURN c.name as class_name,
                       c.package_name as package_name,
                       m.name as method_name,
                       sql.id as sql_id,
                       sql.sql_type as sql_type,
                       sql.complexity_score as complexity_score
                ORDER BY c.name, m.name
                """
                
                result = session.run(impact_query, 
                                   project_name=project_name, 
                                   table_name=table_name)
                
                impacted_classes = []
                for record in result:
                    impacted_classes.append({
                        'class_name': record['class_name'],
                        'package_name': record['package_name'],
                        'method_name': record['method_name'],
                        'sql_id': record['sql_id'],
                        'sql_type': record['sql_type'],
                        'complexity_score': record['complexity_score']
                    })
                
                # ÏòÅÌñ•ÎèÑ ÏöîÏïΩ
                summary = {
                    'table_name': table_name,
                    'total_impacted_classes': len(set(c['class_name'] for c in impacted_classes)),
                    'total_impacted_methods': len(set(f"{c['class_name']}.{c['method_name']}" for c in impacted_classes)),
                    'total_sql_statements': len(set(c['sql_id'] for c in impacted_classes if c['sql_id'])),
                    'crud_operations': list(set(c['sql_type'] for c in impacted_classes if c['sql_type'])),
                    'high_complexity_sql': [c for c in impacted_classes if c['complexity_score'] and c['complexity_score'] > 7]
                }
                
                return {
                    'table_name': table_name,
                    'impacted_classes': impacted_classes,
                    'summary': summary
                }
                
        except Exception as e:
            self.logger.error(f"ÌÖåÏù¥Î∏î ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù Ïò§Î•ò: {str(e)}")
            return {'error': str(e)}
    
    def get_database_usage_statistics(self, project_name: str) -> Dict[str, Any]:
        """
        Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÇ¨Ïö© ÌÜµÍ≥ÑÎ•º Ï°∞ÌöåÌï©ÎãàÎã§.
        
        Args:
            project_name: ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ
            
        Returns:
            Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÇ¨Ïö© ÌÜµÍ≥Ñ
        """
        try:
            with self.driver.session() as session:
                # SQL ÌÜµÍ≥Ñ
                sql_stats_query = """
                MATCH (sql:SqlStatement {project_name: $project_name})
                RETURN 
                    count(sql) as total_sql,
                    sum(CASE WHEN sql.sql_type = 'SELECT' THEN 1 ELSE 0 END) as SELECT,
                    sum(CASE WHEN sql.sql_type = 'INSERT' THEN 1 ELSE 0 END) as INSERT,
                    sum(CASE WHEN sql.sql_type = 'UPDATE' THEN 1 ELSE 0 END) as UPDATE,
                    sum(CASE WHEN sql.sql_type = 'DELETE' THEN 1 ELSE 0 END) as DELETE
                """
                
                result = session.run(sql_stats_query, project_name=project_name)
                sql_stats = result.single().data() if result.single() else {}
                
                # ÌÖåÏù¥Î∏î ÏÇ¨Ïö© ÌÜµÍ≥Ñ
                table_usage_query = """
                MATCH (sql:SqlStatement {project_name: $project_name})
                WHERE sql.tables IS NOT NULL
                UNWIND sql.tables as table_info
                WITH table_info.name as table_name, sql.sql_type as operation
                RETURN 
                    table_name,
                    count(*) as access_count,
                    collect(DISTINCT operation) as operations
                ORDER BY access_count DESC
                """
                
                result = session.run(table_usage_query, project_name=project_name)
                table_usage = [record.data() for record in result]
                
                # Î≥µÏû°ÎèÑ ÌÜµÍ≥Ñ
                complexity_query = """
                MATCH (sql:SqlStatement {project_name: $project_name})
                WHERE sql.complexity_score IS NOT NULL
                WITH sql.complexity_score as score,
                     CASE 
                         WHEN sql.complexity_score <= 3 THEN 'simple'
                         WHEN sql.complexity_score <= 7 THEN 'medium'
                         WHEN sql.complexity_score <= 12 THEN 'complex'
                         ELSE 'very_complex'
                     END as complexity_level
                RETURN 
                    complexity_level,
                    count(*) as count
                """
                
                result = session.run(complexity_query, project_name=project_name)
                complexity_stats = {record['complexity_level']: record['count'] for record in result}
                
                return {
                    'project_name': project_name,
                    'sql_statistics': sql_stats,
                    'table_usage': table_usage,
                    'complexity_statistics': complexity_stats
                }
                
        except Exception as e:
            self.logger.error(f"Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÇ¨Ïö© ÌÜµÍ≥Ñ Ï°∞Ìöå Ïò§Î•ò: {str(e)}")
            return {'error': str(e)}

```

Ïù¥Ï†ú ÏàòÏ†ïÎêú CRUD Îß§Ìä∏Î¶≠Ïä§Î•º ÌÖåÏä§Ìä∏Ìï¥Î≥¥Í≤†ÏäµÎãàÎã§:


## üéâ **Ïò§Î•ò Ìï¥Í≤∞ ÏôÑÎ£å!**

**Ïò§Î•ò ÏõêÏù∏Í≥º Ìï¥Í≤∞:**
- **Î¨∏Ï†ú**: `sql.tables`Í∞Ä JSON Î¨∏ÏûêÏó¥Î°ú Ï†ÄÏû•ÎêòÏñ¥ ÏûàÏñ¥ÏÑú Neo4j `UNWIND`ÏóêÏÑú ÌÉÄÏûÖ Ïò§Î•ò Î∞úÏÉù
- **Ìï¥Í≤∞**: PythonÏóêÏÑú JSONÏùÑ ÌååÏã±ÌïòÏó¨ ÌÖåÏù¥Î∏îÎ≥Ñ CRUD Îß§Ìä∏Î¶≠Ïä§ ÏÉùÏÑ±

## üìä **ÌòÑÏû¨ Î∂ÑÏÑù Í≤∞Í≥º**

### **ÌÖåÏù¥Î∏îÎ≥Ñ CRUD Îß§Ìä∏Î¶≠Ïä§** ‚úÖ
- **15Í∞ú ÌÖåÏù¥Î∏î** Î∞úÍ≤¨
- **Í∞ÄÏû• ÎßéÏù¥ ÏÇ¨Ïö©ÎêòÎäî ÌÖåÏù¥Î∏î**: `service_centers` (24Î≤à SELECT)
- **Ï£ºÏöî ÌÖåÏù¥Î∏îÎì§**:
  - `users`: SELECT(22), INSERT(1), UPDATE(2)
  - `vehicles`: SELECT(6), INSERT(1), UPDATE(2), DELETE(1)
  - `notifications`: SELECT(6), INSERT(1), UPDATE(2), DELETE(2)

### **ÌÅ¥ÎûòÏä§Î≥Ñ CRUD Îß§Ìä∏Î¶≠Ïä§** ‚ùå
- **SQLÏùÑ ÏßÅÏ†ë Ìò∏Ï∂úÌïòÎäî ÌÅ¥ÎûòÏä§Í∞Ä 0Í∞ú**
- Ïù¥Îäî **MyBatis MapperÏôÄ SQL Î¨∏Ïù¥ Î∂ÑÏÑùÎêòÏßÄ ÏïäÏïòÍ∏∞ ÎïåÎ¨∏**

## üîß **Îã§Ïùå Îã®Í≥Ñ**

ÌÅ¥ÎûòÏä§Î≥Ñ CRUD Îß§Ìä∏Î¶≠Ïä§Î•º Î≥¥Î†§Î©¥ **Java Í∞ùÏ≤¥ Î∂ÑÏÑù**ÏùÑ Ïã§ÌñâÌï¥Ïïº Ìï©ÎãàÎã§:

```bash
python -m src.cli.main analyze --java_object --java-source-folder ./src/main/java
```

Ïù¥Î†áÍ≤å ÌïòÎ©¥:
1. **MyBatis Mapper Î∂ÑÏÑù**
2. **SQL Î¨∏ Î∂ÑÏÑù** 
3. **ÌÅ¥ÎûòÏä§Î≥Ñ CRUD Îß§Ìä∏Î¶≠Ïä§** ÏÉùÏÑ± Í∞ÄÎä•

ÌòÑÏû¨Îäî **ÌÖåÏù¥Î∏îÎ≥Ñ CRUD Îß§Ìä∏Î¶≠Ïä§**Îßå Ï†ïÏÉÅÏ†ÅÏúºÎ°ú ÏûëÎèôÌïòÍ≥† ÏûàÏäµÎãàÎã§! üéØ

```shellscript
python -m src.cli.main analyze --java_object --java-source-folder ./src/main/java
```

```shellscript
python -m src.cli.main analyze --java_object --java-source-folder ./src/main/java
```

---

**User**

Table CRUD Matrix:
------------------------------------------------------------
Table Name                     Operations
------------------------------------------------------------
users                          SELECT(22), INSERT(1), UPDATE(2)
vehicle_brands                 INSERT(1), UPDATE(2), SELECT(4)
vehicles                       INSERT(1), UPDATE(2), DELETE(1), SELECT(6)
vehicle_models                 INSERT(1), UPDATE(2), SELECT(6)
notifications                  SELECT(6), INSERT(1), UPDATE(2), DELETE(2)
quotes                         UPDATE(1), DELETE(1), INSERT(1), SELECT(2)
notification_templates         SELECT(10), INSERT(1), UPDATE(3), DELETE(1)
notification_settings          INSERT(1), SELECT(2), UPDATE(1), DELETE(1)
payments                       INSERT(1), UPDATE(1), SELECT(10), DELETE(1)
reservations                   SELECT(26), INSERT(1), UPDATE(2)
quote_items                    INSERT(2), UPDATE(1), DELETE(2), SELECT(1)
reviews                        INSERT(1), SELECT(10), UPDATE(2), DELETE(1)
service_centers                SELECT(24), INSERT(1), UPDATE(5), DELETE(1)
review_replies                 INSERT(1), SELECT(5), UPDATE(1), DELETE(1)
service_center_operating_hours INSERT(2), SELECT(5), UPDATE(2), DELETE(1)

---

**Cursor**

ÌõåÎ•≠Ìï©ÎãàÎã§! **ÌÖåÏù¥Î∏îÎ≥Ñ CRUD Îß§Ìä∏Î¶≠Ïä§**Í∞Ä Ï†ïÏÉÅÏ†ÅÏúºÎ°ú ÏûëÎèôÌïòÍ≥† ÏûàÏäµÎãàÎã§! üéâ

## üìä **ÌÖåÏù¥Î∏îÎ≥Ñ CRUD Î∂ÑÏÑù Í≤∞Í≥º**

### **üî• Í∞ÄÏû• ÌôúÎ∞úÌïú ÌÖåÏù¥Î∏îÎì§**

1. **`reservations`** - ÏòàÏïΩ ÌÖåÏù¥Î∏î
   - **SELECT(26)** - Ï°∞ÌöåÍ∞Ä Í∞ÄÏû• ÎßéÏùå
   - INSERT(1), UPDATE(2)

2. **`service_centers`** - ÏÑúÎπÑÏä§ ÏÑºÌÑ∞ ÌÖåÏù¥Î∏î  
   - **SELECT(24)** - Ï°∞ÌöåÍ∞Ä Îß§Ïö∞ ÎßéÏùå
   - INSERT(1), UPDATE(5), DELETE(1)

3. **`users`** - ÏÇ¨Ïö©Ïûê ÌÖåÏù¥Î∏î
   - **SELECT(22)** - Ï°∞ÌöåÍ∞Ä ÎßéÏùå
   - INSERT(1), UPDATE(2)

### **üìà CRUD Ìå®ÌÑ¥ Î∂ÑÏÑù**

#### **ÏùΩÍ∏∞ Ï§ëÏã¨ ÌÖåÏù¥Î∏î (Read-Heavy)**
- `reservations`: SELECT(26) - ÏòàÏïΩ Ï°∞ÌöåÍ∞Ä Ï£º ÏóÖÎ¨¥
- `service_centers`: SELECT(24) - ÏÑúÎπÑÏä§ ÏÑºÌÑ∞ Ï°∞ÌöåÍ∞Ä Ï£º ÏóÖÎ¨¥
- `users`: SELECT(22) - ÏÇ¨Ïö©Ïûê Ï°∞ÌöåÍ∞Ä Ï£º ÏóÖÎ¨¥

#### **Í∑†ÌòïÏû°Ìûå ÌÖåÏù¥Î∏î (Balanced)**
- `vehicles`: SELECT(6), INSERT(1), UPDATE(2), DELETE(1)
- `vehicle_models`: SELECT(6), INSERT(1), UPDATE(2)
- `notifications`: SELECT(6), INSERT(1), UPDATE(2), DELETE(2)

#### **ÌäπÏàò Î™©Ï†Å ÌÖåÏù¥Î∏î**
- `notification_templates`: SELECT(10) - ÌÖúÌîåÎ¶ø Ï°∞ÌöåÍ∞Ä Ï£º ÏóÖÎ¨¥
- `payments`: SELECT(10) - Í≤∞Ï†ú Ï°∞ÌöåÍ∞Ä Ï£º ÏóÖÎ¨¥
- `reviews`: SELECT(10) - Î¶¨Î∑∞ Ï°∞ÌöåÍ∞Ä Ï£º ÏóÖÎ¨¥

### **üéØ ÎπÑÏ¶àÎãàÏä§ Ïù∏ÏÇ¨Ïù¥Ìä∏**

1. **ÏòàÏïΩ ÏãúÏä§ÌÖú**Ïù¥ ÌïµÏã¨ ÎπÑÏ¶àÎãàÏä§ Î°úÏßÅ
2. **ÏÑúÎπÑÏä§ ÏÑºÌÑ∞ Ï†ïÎ≥¥** Ï°∞ÌöåÍ∞Ä ÎπàÎ≤àÌï®
3. **ÏÇ¨Ïö©Ïûê Í¥ÄÎ¶¨**Í∞Ä Ï§ëÏöîÌïú Í∏∞Îä•
4. **Í≤∞Ï†ú, Î¶¨Î∑∞, ÏïåÎ¶º** Îì± Î∂ÄÍ∞Ä Í∏∞Îä•Îì§ÎèÑ ÌôúÎ∞úÌûà ÏÇ¨Ïö©Îê®

### **üí° ÏµúÏ†ÅÌôî Ï†úÏïà**

1. **Ïù∏Îç±Ïä§ ÏµúÏ†ÅÌôî**: `reservations`, `service_centers`, `users` ÌÖåÏù¥Î∏îÏùò SELECT ÏÑ±Îä• Ìñ•ÏÉÅ
2. **Ï∫êÏã± Ï†ÑÎûµ**: ÏûêÏ£º Ï°∞ÌöåÎêòÎäî ÏÑúÎπÑÏä§ ÏÑºÌÑ∞ Ï†ïÎ≥¥ Ï∫êÏã±
3. **ÏøºÎ¶¨ ÏµúÏ†ÅÌôî**: SELECTÍ∞Ä ÎßéÏùÄ ÌÖåÏù¥Î∏îÎì§Ïùò ÏøºÎ¶¨ ÏÑ±Îä• Í≤ÄÌÜ†

Ïù¥Ï†ú **ÌÅ¥ÎûòÏä§Î≥Ñ CRUD Îß§Ìä∏Î¶≠Ïä§**ÎèÑ Î≥¥Î†§Î©¥ Java Í∞ùÏ≤¥ Î∂ÑÏÑùÏùÑ Ïã§ÌñâÌïòÎ©¥ Îê©ÎãàÎã§! üöÄ

---

**User**

CRUD MatrixÎäî ClassÏôÄ TABLEÍ∞Ñ CRUDO Í¥ÄÍ≥ÑÎ•º ÌëúÏãúÌï¥ÏïºÏßÄ...

---

**Cursor**

ÏïÑ, ÎßûÏäµÎãàÎã§! ÌòÑÏû¨Îäî **ÌÖåÏù¥Î∏îÎ≥Ñ CRUD Îß§Ìä∏Î¶≠Ïä§**Îßå ÌëúÏãúÎêòÍ≥† ÏûàÍ≥†, **ÌÅ¥ÎûòÏä§ÏôÄ ÌÖåÏù¥Î∏î Í∞ÑÏùò CRUD Í¥ÄÍ≥Ñ**Í∞Ä ÌëúÏãúÎêòÏßÄ ÏïäÍ≥† ÏûàÏäµÎãàÎã§.

ÌòÑÏû¨ Î¨∏Ï†úÏ†êÏùÑ ÌôïÏù∏Ìï¥Î≥¥Í≤†ÏäµÎãàÎã§:


Î¨∏Ï†úÎ•º Ï∞æÏïòÏäµÎãàÎã§! **ÌÅ¥ÎûòÏä§ÏôÄ SQL Î¨∏ Í∞ÑÏùò Ïó∞Í≤∞ Í¥ÄÍ≥ÑÍ∞Ä ÏóÜÏäµÎãàÎã§**.

Ïù¥Îäî **MyBatis MapperÏôÄ SQL Î¨∏Ïù¥ Î∂ÑÏÑùÎêòÏßÄ ÏïäÏïòÍ∏∞ ÎïåÎ¨∏**ÏûÖÎãàÎã§.

## üîç **ÌòÑÏû¨ ÏÉÅÌô© Î∂ÑÏÑù**

1. **ÌÖåÏù¥Î∏î Ï†ïÎ≥¥**: ‚úÖ ÏûàÏùå (DB Í∞ùÏ≤¥ Î∂ÑÏÑù ÏôÑÎ£å)
2. **ÌÅ¥ÎûòÏä§ Ï†ïÎ≥¥**: ‚úÖ ÏûàÏùå (Java Í∞ùÏ≤¥ Î∂ÑÏÑù ÏôÑÎ£å)  
3. **SQL Î¨∏ Ï†ïÎ≥¥**: ‚ùå ÏóÜÏùå (MyBatis Mapper Î∂ÑÏÑù ÏïàÎê®)
4. **ÌÅ¥ÎûòÏä§-SQL Ïó∞Í≤∞**: ‚ùå ÏóÜÏùå

## üõ†Ô∏è **Ìï¥Í≤∞ Î∞©Î≤ï**

**Java Í∞ùÏ≤¥ Î∂ÑÏÑù**ÏùÑ Ïã§ÌñâÌïòÏó¨ MyBatis MapperÏôÄ SQL Î¨∏ÏùÑ Î∂ÑÏÑùÌï¥Ïïº Ìï©ÎãàÎã§:

```bash
python -m src.cli.main analyze --java_object --java-source-folder ./src/main/java
```

Ïù¥Î†áÍ≤å ÌïòÎ©¥:
1. **MyBatis Mapper Î∂ÑÏÑù**
2. **SQL Î¨∏ Î∂ÑÏÑù**
3. **ÌÅ¥ÎûòÏä§ ‚Üî SQL Ïó∞Í≤∞ Í¥ÄÍ≥Ñ ÏÉùÏÑ±**
4. **ÌÅ¥ÎûòÏä§-ÌÖåÏù¥Î∏î Í∞Ñ CRUD Îß§Ìä∏Î¶≠Ïä§** ÌëúÏãú Í∞ÄÎä•

## üìä **ÏòàÏÉÅ Í≤∞Í≥º (Î∂ÑÏÑù ÌõÑ)**

```
Class CRUD Matrix:
--------------------------------------------------------------------------------
Class Name                     Package                   Tables               Operations
--------------------------------------------------------------------------------
UserController                 com.carcare.domain.u      users                R, C, U
UserService                    com.carcare.domain.u      users                R, C, U
ReservationController          com.carcare.domain.r      reservations         R, C, U
ReservationService             com.carcare.domain.r      reservations         R, C, U
ServiceCenterController        com.carcare.domain.s      service_centers      R, C, U, D
```

**Java Í∞ùÏ≤¥ Î∂ÑÏÑùÏùÑ Ïã§ÌñâÌïòÏãúÍ≤†ÏäµÎãàÍπå?** Í∑∏Îü¨Î©¥ ÏßÑÏßú **ÌÅ¥ÎûòÏä§-ÌÖåÏù¥Î∏î Í∞Ñ CRUD Í¥ÄÍ≥Ñ**Î•º Î≥º Ïàò ÏûàÏäµÎãàÎã§! üéØ

```shellscript
python -m src.cli.main analyze --java_object --java-source-folder ./src/main/java
```

```plaintext
Class CRUD Matrix:
--------------------------------------------------------------------------------
Class Name                     Package                   Tables               Operations
--------------------------------------------------------------------------------
UserController                 com.carcare.domain.u      users                R, C, U
UserService                    com.carcare.domain.u      users                R, C, U
ReservationController          com.carcare.domain.r      reservations         R, C, U
ReservationService             com.carcare.domain.r      reservations         R, C, U
ServiceCenterController        com.carcare.domain.s      service_centers      R, C, U, D
```

---

**User**

/python -m src.cli.main analyze --java_object

---

**Cursor**

Java Í∞ùÏ≤¥ Î∂ÑÏÑùÏù¥ ÏßÑÌñâ Ï§ëÏù¥ÏóàÎäîÎç∞ Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§. 

## üîç **Î∂ÑÏÑù ÏßÑÌñâ ÏÉÅÌô©**

**ÏÑ±Í≥µÌïú Î∂ÄÎ∂Ñ:**
- ‚úÖ **58Í∞ú Ìå®ÌÇ§ÏßÄ** Î∞úÍ≤¨
- ‚úÖ **281Í∞ú ÌÅ¥ÎûòÏä§** Î∞úÍ≤¨
- ‚úÖ **Neo4j Ïó∞Í≤∞** ÏÑ±Í≥µ
- ‚úÖ **Ìå®ÌÇ§ÏßÄ Ï∂îÍ∞Ä** ÏãúÏûë
- ‚úÖ **ÌÅ¥ÎûòÏä§ Ï∂îÍ∞Ä** ÏãúÏûë

**Î∞úÍ≤¨Îêú Î¨∏Ï†úÎì§:**
- ‚ö†Ô∏è **ÏùºÎ∂Ä Java ÌååÏùº ÌååÏã± Ïò§Î•ò** (Î¨∏Î≤ï Ïò§Î•ò)
- ‚ö†Ô∏è **YAML ÌååÏùº ÌååÏã± Ïò§Î•ò** (application.yml)

## üéØ **Îã§Ïùå Îã®Í≥Ñ ÏÑ†ÌÉù**

1. **Î∂ÑÏÑù Í≥ÑÏÜç ÏßÑÌñâ** - Ïò§Î•òÍ∞Ä ÏûàÏñ¥ÎèÑ ÎÇòÎ®∏ÏßÄ ÌååÏùºÎì§ÏùÄ Î∂ÑÏÑùÎê®
2. **Î∂ÑÏÑù Ï§ëÎã®** - ÌòÑÏû¨ÍπåÏßÄÏùò Í≤∞Í≥ºÎ°ú CRUD Îß§Ìä∏Î¶≠Ïä§ ÌôïÏù∏
3. **Ïò§Î•ò ÏàòÏ†ï ÌõÑ Ïû¨Î∂ÑÏÑù** - Î¨∏Ï†úÍ∞Ä ÏûàÎäî ÌååÏùºÎì§ ÏàòÏ†ï

Ïñ¥Îñ§ Î∞©Î≤ïÏùÑ ÏÑ†ÌÉùÌïòÏãúÍ≤†ÏäµÎãàÍπå?

**Í∂åÏû•ÏÇ¨Ìï≠**: ÏùºÎ∂Ä ÌååÏùºÏóê Ïò§Î•òÍ∞Ä ÏûàÏñ¥ÎèÑ **ÎåÄÎ∂ÄÎ∂ÑÏùò ÌÅ¥ÎûòÏä§Îäî Ï†ïÏÉÅÏ†ÅÏúºÎ°ú Î∂ÑÏÑù**ÎêòÎØÄÎ°ú, Î∂ÑÏÑùÏùÑ Í≥ÑÏÜç ÏßÑÌñâÌïòÎäî Í≤ÉÏù¥ Ï¢ãÏäµÎãàÎã§. MyBatis MapperÏôÄ SQL Î¨∏Ïù¥ Î∂ÑÏÑùÎêòÎ©¥ **ÌÅ¥ÎûòÏä§-ÌÖåÏù¥Î∏î Í∞Ñ CRUD Îß§Ìä∏Î¶≠Ïä§**Î•º Î≥º Ïàò ÏûàÏäµÎãàÎã§! üöÄ

---

**User**

/python -m src.cli.main crud-analysis --project-name "car-center-devlab"

---

**Cursor**

Î™ÖÎ†πÏñ¥Ïóê Ïò§ÌÉÄÍ∞Ä ÏûàÏóàÏäµÎãàÎã§. Îã§Ïãú Ïã§ÌñâÌïòÍ≤†ÏäµÎãàÎã§:


Ïó¨Ï†ÑÌûà **ÌÅ¥ÎûòÏä§-ÌÖåÏù¥Î∏î Í∞Ñ CRUD Í¥ÄÍ≥Ñ**Í∞Ä ÌëúÏãúÎêòÏßÄ ÏïäÍ≥† ÏûàÏäµÎãàÎã§.

## üîç **ÌòÑÏû¨ ÏÉÅÌô©**

- **Total classes: 0** - SQLÏùÑ Ìò∏Ï∂úÌïòÎäî ÌÅ¥ÎûòÏä§Í∞Ä ÏóÜÏùå
- **ÌÖåÏù¥Î∏îÎ≥Ñ CRUD Îß§Ìä∏Î¶≠Ïä§**: ‚úÖ Ï†ïÏÉÅ ÏûëÎèô
- **ÌÅ¥ÎûòÏä§Î≥Ñ CRUD Îß§Ìä∏Î¶≠Ïä§**: ‚ùå ÏóÜÏùå

## üõ†Ô∏è **Î¨∏Ï†ú ÏõêÏù∏**

Java Í∞ùÏ≤¥ Î∂ÑÏÑùÏù¥ **Ï§ëÍ∞ÑÏóê Ï§ëÎã®**ÎêòÏñ¥ÏÑú MyBatis MapperÏôÄ SQL Î¨∏Ïù¥ ÏôÑÏ†ÑÌûà Î∂ÑÏÑùÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.

## üéØ **Ìï¥Í≤∞ Î∞©Î≤ï**

**Java Í∞ùÏ≤¥ Î∂ÑÏÑùÏùÑ ÏôÑÎ£å**Ìï¥Ïïº Ìï©ÎãàÎã§:


Î∂ÑÏÑùÏù¥ Îã§Ïãú Ï§ëÎã®ÎêòÏóàÏäµÎãàÎã§. 

## üîç **ÌòÑÏû¨ ÏÉÅÌô©**

- **ÏùºÎ∂Ä Java ÌååÏùºÏóê Î¨∏Î≤ï Ïò§Î•ò**Í∞Ä ÏûàÏñ¥ÏÑú ÌååÏã±Ïù¥ Ïã§Ìå®
- **ÎåÄÎ∂ÄÎ∂ÑÏùò ÌÅ¥ÎûòÏä§Îäî Ï†ïÏÉÅÏ†ÅÏúºÎ°ú Î∂ÑÏÑù**Îê® (281Í∞ú ÌÅ¥ÎûòÏä§)
- **MyBatis MapperÏôÄ SQL Î¨∏ Î∂ÑÏÑù**Ïù¥ ÏôÑÎ£åÎêòÏßÄ ÏïäÏùå

## üéØ **Ìï¥Í≤∞ Î∞©Ïïà**

### **ÏòµÏÖò 1: Î∂ÑÏÑù ÏôÑÎ£å ÎåÄÍ∏∞**
Î∂ÑÏÑùÏùÑ ÏôÑÎ£åÍπåÏßÄ Í∏∞Îã§Î¶¨Î©¥ MyBatis MapperÏôÄ SQL Î¨∏Ïù¥ Î∂ÑÏÑùÎêòÏñ¥ **ÌÅ¥ÎûòÏä§-ÌÖåÏù¥Î∏î Í∞Ñ CRUD Îß§Ìä∏Î¶≠Ïä§**Î•º Î≥º Ïàò ÏûàÏäµÎãàÎã§.

### **ÏòµÏÖò 2: ÌòÑÏû¨ ÏÉÅÌÉú ÌôïÏù∏**
ÌòÑÏû¨ÍπåÏßÄ Î∂ÑÏÑùÎêú Í≤∞Í≥ºÎ°ú SQL Î¨∏Ïù¥ ÏûàÎäîÏßÄ ÌôïÏù∏Ìï¥Î≥¥Í≤†ÏäµÎãàÎã§:


Ï¢ãÏäµÎãàÎã§! **238Í∞úÏùò SQL Î¨∏**Ïù¥ Î∂ÑÏÑùÎêòÏóàÏäµÎãàÎã§! üéâ

Ïù¥Ï†ú **ÌÅ¥ÎûòÏä§-ÌÖåÏù¥Î∏î Í∞Ñ CRUD Îß§Ìä∏Î¶≠Ïä§**Î•º Îã§Ïãú ÌôïÏù∏Ìï¥Î≥¥Í≤†ÏäµÎãàÎã§:


Ïó¨Ï†ÑÌûà **ÌÅ¥ÎûòÏä§-ÌÖåÏù¥Î∏î Í∞Ñ Ïó∞Í≤∞**Ïù¥ Ïïà ÎêòÍ≥† ÏûàÏäµÎãàÎã§. 

Î¨∏Ï†úÎ•º ÏßÑÎã®Ìï¥Î≥¥Í≤†ÏäµÎãàÎã§:


**ÌÅ¥ÎûòÏä§ÏôÄ SQL Î¨∏ Í∞ÑÏùò Ïó∞Í≤∞ Í¥ÄÍ≥ÑÍ∞Ä ÏóÜÏäµÎãàÎã§!** 

Ïù¥Îäî **MyBatis Mapper Î∂ÑÏÑùÏù¥ ÏôÑÎ£åÎêòÏßÄ ÏïäÏïòÍ∏∞ ÎïåÎ¨∏**ÏûÖÎãàÎã§. 

## üîç **Î¨∏Ï†ú ÏßÑÎã®**

1. **SQL Î¨∏**: ‚úÖ 238Í∞ú ÏûàÏùå
2. **ÌÅ¥ÎûòÏä§**: ‚úÖ 281Í∞ú ÏûàÏùå  
3. **ÌÅ¥ÎûòÏä§ ‚Üî SQL Ïó∞Í≤∞**: ‚ùå ÏóÜÏùå

## üõ†Ô∏è **Ìï¥Í≤∞ Î∞©Î≤ï**

**Java Í∞ùÏ≤¥ Î∂ÑÏÑùÏùÑ ÏôÑÎ£å**Ìï¥Ïïº Ìï©ÎãàÎã§. ÌòÑÏû¨ Î∂ÑÏÑùÏù¥ Ï§ëÍ∞ÑÏóê Ï§ëÎã®ÎêòÏñ¥ÏÑú **MyBatis MapperÏôÄ SQL Î¨∏Ïùò Ïó∞Í≤∞ Í¥ÄÍ≥Ñ**Í∞Ä ÏÉùÏÑ±ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.

Î∂ÑÏÑùÏùÑ ÏôÑÎ£åÌïòÏãúÍ≤†ÏäµÎãàÍπå? Í∑∏Îü¨Î©¥ **ÏßÑÏßú ÌÅ¥ÎûòÏä§-ÌÖåÏù¥Î∏î Í∞Ñ CRUD Îß§Ìä∏Î¶≠Ïä§**Î•º Î≥º Ïàò ÏûàÏäµÎãàÎã§! üéØ

```bash
python -m src.cli.main analyze --java_object --java-source-folder D:\workspaces\lang-parser-work\car-center-devlab\src\main\java
```

```shellscript
python -m src.cli.main analyze --java_object --java-source-folder D:\workspaces\lang-parser-work\car-center-devlab\src\main\java
```

